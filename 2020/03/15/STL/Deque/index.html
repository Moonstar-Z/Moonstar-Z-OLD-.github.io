<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/Moonstar-Z.github.io.git/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/Moonstar-Z.github.io.git/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/Moonstar-Z.github.io.git/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/Moonstar-Z.github.io.git/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/Moonstar-Z.github.io.git/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/Moonstar-Z.github.io.git/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/Moonstar-Z.github.io.git/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="在介绍STL的deque的容器之前，我们先来总结一下vector和list的优缺点。vector在内存中是分配一段连续的内存空间进行存储，其迭代器采用原生指针即可，因此其支持随机访问和存储，支持下标操作符，节省空间。但是其在分配的内存不够的情况下，需要对容器整体进行重新分配、拷贝和释放等操作，而且在vector中间插入或删除元素效率很低。 而list是以节点形式来存放数据，使用的是非连续的内存空间">
<meta property="og:type" content="article">
<meta property="og:title" content="し半世烟尘">
<meta property="og:url" content="https://yoursite.com/2020/03/15/STL/Deque/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="在介绍STL的deque的容器之前，我们先来总结一下vector和list的优缺点。vector在内存中是分配一段连续的内存空间进行存储，其迭代器采用原生指针即可，因此其支持随机访问和存储，支持下标操作符，节省空间。但是其在分配的内存不够的情况下，需要对容器整体进行重新分配、拷贝和释放等操作，而且在vector中间插入或删除元素效率很低。 而list是以节点形式来存放数据，使用的是非连续的内存空间">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://ww2.sinaimg.cn/large/006tNc79gw1fbkfqlslx9j30jk064jrp.jpg">
<meta property="og:image" content="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfql0k0oj30ig0fdq4a.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfqm9euaj30mh0cft9h.jpg">
<meta property="og:updated_time" content="2019-09-11T03:09:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="し半世烟尘">
<meta name="twitter:description" content="在介绍STL的deque的容器之前，我们先来总结一下vector和list的优缺点。vector在内存中是分配一段连续的内存空间进行存储，其迭代器采用原生指针即可，因此其支持随机访问和存储，支持下标操作符，节省空间。但是其在分配的内存不够的情况下，需要对容器整体进行重新分配、拷贝和释放等操作，而且在vector中间插入或删除元素效率很低。 而list是以节点形式来存放数据，使用的是非连续的内存空间">
<meta name="twitter:image" content="https://ww2.sinaimg.cn/large/006tNc79gw1fbkfqlslx9j30jk064jrp.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/Moonstar-Z.github.io.git/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/2020/03/15/STL/Deque/">





  <title> | し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/Moonstar-Z.github.io.git/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/Moonstar-Z.github.io.git/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/Moonstar-Z.github.io.git/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/Moonstar-Z.github.io.git/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/Moonstar-Z.github.io.git/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/Moonstar-Z.github.io.git/2020/03/15/STL/Deque/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Moonstar-Z.github.io.git/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:15+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在介绍STL的deque的容器之前，我们先来总结一下vector和list的优缺点。vector在内存中是分配一段连续的内存空间进行存储，其迭代器采用原生指针即可，因此其支持随机访问和存储，支持下标操作符，节省空间。但是其在分配的内存不够的情况下，需要对容器整体进行重新分配、拷贝和释放等操作，而且在vector中间插入或删除元素效率很低。</p>
<p>而list是以节点形式来存放数据，使用的是非连续的内存空间来存放数据，因此，在其内部插入和删除元素的时间复杂度都是O(1),但是其不支持随机访问和存取，不支持下标，而且比vector占用的内存要多。</p>
<p>综合上述的优缺点，我们貌似需要一个支持随机访问和存取，支持下标访问，而且插入和删除的效率高的容器。于是，STL的deque诞生了，下面就跟着我一起去看看deque的设计和源码实现吧！</p>
<h1 id="Deque概述"><a href="#Deque概述" class="headerlink" title="Deque概述"></a>Deque概述</h1><p>vector是一个单向开口的容器，deque则是一个双向开口的容器，所谓双向开口就是再头尾两端均可以做元素的插入和删除操作。deque容器给我们的直观感觉大概是下面这样的(配图来自STL源码剖析)：</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79gw1fbkfqlslx9j30jk064jrp.jpg" alt="Deque"></p>
<p>deque相比于vector最大的差异就在于支持常熟时间内对首尾两端进行插入和删除操作，而且deque没有容量的概念，其内部采用分段连续内存空间来存储元素，在插入元素的时候随时都可以重新增加一段新的空间并链接起来。</p>
<p>deque提供了Ramdon Access Iterator，同时也支持随机访问和存取，但是它也为此付出了昂贵的代价，其复杂度不能跟vector的原生指针迭代器相提并论。在下面的讲解中会一一为大家介绍STL是怎样”辛苦地”维持一个随机访问迭代器的。</p>
<h1 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h1><p>deque为了维持整体连续的假象，设计一个中控器，其用来记录deque内部每一段连续空间的地址。大体上可以理解为deque中的每一段连续空间分布在内存的不连续空间上，然后用一个所谓的map作为主控，记录每一段内存空间的入口，从而做到整体连续的假象。其布局大概如下(配图来自STL源码剖析)</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfql0k0oj30ig0fdq4a.jpg" alt="STLDequeMap"></p>
<p>看完图解，再来看看源码会很好理解的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向map, map是一个连续的空间, 其每个元素都是一个指向缓冲区的指针</span></span><br><span class="line">  map_pointer <span class="built_in">map</span>;</span><br><span class="line">  size_type map_size;   <span class="comment">// map容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛弃型别定义，我们可以看到map实际上就是一个指向指针的指针(T**)，map所指向的是一个指针，该指针指向型别为T的一块内存空间。理解到这里，大概就清楚了deque的实现原理，不过，这些都不是重点！重点是deque的各种运算符的实现。做好心理准备，咱们继续往下看！！！</p>
<h1 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h1><p>deque提供的是一个随机访问迭代器，由于是分段连续空间，其必须记录当前元素所在段的信息，从而在该段连续空间的边缘进行前进或者后退的时候能知道跳跃到的上一个或下一个缓冲区。deque必须完完全全地掌握和控制这些信息，以达到正确地跳跃！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意deque的迭代器没有重载STL的Iterator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下为支持Iterator_traits而定义的一些类型</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;      </span><br><span class="line">  <span class="keyword">typedef</span> T value_type;                                      </span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;                                       </span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;                                     </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;                        </span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存容器中的结点</span></span><br><span class="line">  T* cur;       <span class="comment">// 指向当前缓冲区中的元素</span></span><br><span class="line">  T* first;     <span class="comment">// 当前缓冲区的起点</span></span><br><span class="line">  T* last;      <span class="comment">// 当前缓冲区的终点</span></span><br><span class="line"></span><br><span class="line">  map_pointer node;   <span class="comment">// 指向管控中心</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">random_access_iterator_tag</span></span></span><br><span class="line"><span class="class"><span class="title">iterator_category</span>(<span class="title">const</span> __<span class="title">deque_iterator</span>&lt;T, Ref, Ptr, BufSiz&gt;&amp;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> random_access_iterator_tag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">value_type</span>(<span class="title">const</span> __<span class="title">deque_iterator</span>&lt;T, Ref, Ptr, BufSiz&gt;&amp;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ptrdiff_t</span>* <span class="title">distance_type</span>(<span class="title">const</span> __<span class="title">deque_iterator</span>&lt;T, Ref, Ptr, BufSiz&gt;&amp;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出，deque的迭代器中有cur,first,last和node四个指针，前三个记录了迭代器与缓冲区的联系，最后一个记录了迭代器于中控器的关系。从下面这张图可以很好的看出其关系：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfqm9euaj30mh0cft9h.jpg" alt="STLDequeIterator"></p>
<p>仅仅定义了迭代器结构还只是开始，迭代器是一个随机访问迭代器，所以其必须提供++，–，下标操作符等运算符。下面就来一一剖析吧！</p>
<h2 id="buffer-size函数"><a href="#buffer-size函数" class="headerlink" title="buffer_size函数"></a>buffer_size函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回deque的buffer_size大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(T)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果n不为0，传回n，表示buffer size由用户自己定义</span></span><br><span class="line"><span class="comment"> * 如果n为0，表示buffer_size采用默认值，</span></span><br><span class="line"><span class="comment"> * 				  那么如果sz(元素大小)小于512，传回512/sz</span></span><br><span class="line"><span class="comment"> * 					如果sz不小于512，传回1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-node函数"><a href="#set-node函数" class="headerlink" title="set_node函数"></a>set_node函数</h2><p>当迭代器处在当前缓冲区的边缘时，一旦前进或者后退，就要考虑超过当前缓冲区的情况，此时需要跳转到下一个缓冲区，这时候set_node就派上用场了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node = new_node;		<span class="comment">// 跳转到相应缓冲区</span></span><br><span class="line">  first = *new_node;	<span class="comment">// 更新跳转后缓冲区first信息</span></span><br><span class="line">  last = first + difference_type(buffer_size());  <span class="comment">// 更新跳转后缓冲区last的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="各种运算子"><a href="#各种运算子" class="headerlink" title="各种运算子"></a>各种运算子</h2><p>以下源码都是deque迭代器重载的运算子，以满足随机访问迭代器的要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断两个迭代器之间的距离，重载了‘-’运算子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +</span><br><span class="line">    (cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前缀自增，注意前缀自增返回自身引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">  ++cur;	<span class="comment">// 先自增当前元素的指针</span></span><br><span class="line">  <span class="keyword">if</span> (cur == last) &#123;	<span class="comment">// 判断是否为当前缓冲区最后一个</span></span><br><span class="line">    set_node(node + <span class="number">1</span>);	<span class="comment">// 如果为当前缓冲区最后一个，则跳转到下一个缓冲区</span></span><br><span class="line">    cur = first;	<span class="comment">// 更新为下一缓冲区的起始点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	后缀自增</span></span><br><span class="line"><span class="comment"> *	返回当前迭代器的一个副本, 并调用前缀自增运算符实现迭代器自身的自增</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line">  ++*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	前缀自减, 处理方式类似于前缀自增</span></span><br><span class="line"><span class="comment"> *	如果当前迭代器指向元素是当前缓冲区的第一个元素</span></span><br><span class="line"><span class="comment"> *	则将迭代器状态调整为前一个缓冲区的最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (cur == first) &#123;</span><br><span class="line">    set_node(node - <span class="number">1</span>);</span><br><span class="line">    cur = last;</span><br><span class="line">  &#125;</span><br><span class="line">  --cur;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理方法同后缀自增</span></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line">  --*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	实现p+=n的功能</span></span><br><span class="line"><span class="comment"> *	迭代器向前移动n个元素，其中n可能为负。实现步骤如下：</span></span><br><span class="line"><span class="comment"> *	1、计算相对于该缓冲区起始位置的偏移量offset</span></span><br><span class="line"><span class="comment"> *	2、如果offset没有超出缓冲区，则直接cur+=n</span></span><br><span class="line"><span class="comment"> *	3、如果offset超过了缓冲区空间</span></span><br><span class="line"><span class="comment"> *			-- 如果offset大于0，计算向前移动多少个缓冲区，offset / difference_type(buffer_size())</span></span><br><span class="line"><span class="comment"> *			-- 如果offset小于0，计算向后移动多少个缓冲区,-difference_type((-offset - 1) / buffer_size()) - 1;</span></span><br><span class="line"><span class="comment"> *	4、调整到移动后的位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)</span><br><span class="line">&#123;</span><br><span class="line">  difference_type offset = n + (cur - first);</span><br><span class="line">  <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))</span><br><span class="line">    cur += n;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    difference_type node_offset =</span><br><span class="line">      offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size())</span><br><span class="line">                 : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;</span><br><span class="line">    set_node(node + node_offset);</span><br><span class="line">    cur = first + (offset - node_offset * difference_type(buffer_size()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现诸如p+n的功能</span></span><br><span class="line"><span class="comment"> * 此函数中直接调用operator +=的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里调用了operator +=()可以自动调整指针状态</span></span><br><span class="line">  <span class="keyword">return</span> tmp += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现p-=n的功能</span></span><br><span class="line"><span class="comment"> * 此处直接利用operator += ，改变一下n的正负即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现p-n的功能</span></span><br><span class="line"><span class="comment"> * 直接调用operator -=的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp -= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下标运算子，支持随机存取的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下述都是一些判断运算的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h1><p>先前在deque的中控器中讲到，deque维护着一个map，用来记录每个缓冲区的位置。除了map外，deque的数据结构中还维护着start和finish两个迭代器，分别指向deque的首尾。此外，它还必须知道map的大小，一旦map所提供的节点不足，就需要配置一块更大的map。</p>
<p>接下来，我们来看看deque的数据结构源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="comment">// 这里省略一堆支持iterator_traits型别定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;  iterator;	<span class="comment">// deque的迭代器</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  iterator start;               <span class="comment">// 表中第一个节点</span></span><br><span class="line">  iterator finish;              <span class="comment">// 表中最后一个节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是前面讲到map指针，用来记录每一个缓冲区的地址</span></span><br><span class="line">  map_pointer <span class="built_in">map</span>;</span><br><span class="line">  size_type map_size;   <span class="comment">// map容量 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//	deque专属空间配置器，每次配置一个元素大小</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">  <span class="comment">//	deque专属空间配置器，每次配置一个指针大小</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配内存, 不进行构造</span></span><br><span class="line">	<span class="function">pointer <span class="title">allocate_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_allocator::allocate(buffer_size()); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放内存, 不进行析构</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate_node</span><span class="params">(pointer n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		data_allocator::deallocate(n, buffer_size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述结构体下，可以很轻松地实现“连续”容器的各种机能函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;	<span class="comment">// 返回第一个节点的迭代器</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;		<span class="comment">// 返回最后一个节点的迭代器</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;	<span class="comment">// const版本</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;		<span class="comment">// const版本</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *	提供随机访问的下标运算子</span></span><br><span class="line"><span class="comment">   *	这里计算实际地址的时候是经过一系列的计算得到的，效率上有缺失</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> start[difference_type(n)]; &#125;</span><br><span class="line">  const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> start[difference_type(n)];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 以下函数分别返回首尾元素的引用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> *tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    const_iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> *tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//	返回deque的大小，这里直接调用迭代器重载的‘-’运算符 </span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish - start;; &#125;</span><br><span class="line">  <span class="comment">//	返回deque最大容量</span></span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// deque为空的时, 只有一个缓冲区</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="deque的构造函数"><a href="#deque的构造函数" class="headerlink" title="deque的构造函数"></a>deque的构造函数</h1><p>deque和vector、list一样，提供了多种构造函数。我们先来看看默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>() : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  create_map_and_nodes(<span class="number">0</span>);	<span class="comment">// 直接调用create_map_and_nodes函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map最少为8个</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_type <span class="title">initial_map_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建内部使用的map，并配置每一个缓冲区</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:create_map_and_nodes(size_type num_elements)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 需要的结点数, 元素个数 / 每个缓冲区能容纳的元素数 + 1</span></span><br><span class="line">  <span class="comment">// 这里如果能整除，会多分配一个</span></span><br><span class="line">  size_type num_nodes = num_elements / buffer_size() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map要维护的结点, 这里最小的值为8，最多为所需节点数+1，前后各留一个以便扩充</span></span><br><span class="line">  map_size = max(initial_map_size(), num_nodes + <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 调用deque专属空间配置器，配置map空间</span></span><br><span class="line">  <span class="built_in">map</span> = map_allocator::allocate(map_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将[nstart, nfinish)区间设置在map的中间,</span></span><br><span class="line">  <span class="comment">// 这样就能保证前后增长而尽可能减少map的重新分配次数</span></span><br><span class="line">  map_pointer nstart = <span class="built_in">map</span> + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">  map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配结点空间</span></span><br><span class="line">  map_pointer cur;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> (cur = nstart; cur &lt;= nfinish; ++cur)</span><br><span class="line">    	<span class="comment">// 为每一个map指针指向的缓冲区的每一个元素分配内存空间 </span></span><br><span class="line">      *cur = allocate_node();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 维护指针状态，为deque的两个迭代器start和finish赋初值</span></span><br><span class="line">  start.set_node(nstart);</span><br><span class="line">  finish.set_node(nfinish);</span><br><span class="line">  start.cur = start.first;</span><br><span class="line">  finish.cur = finish.first + num_elements % buffer_size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了默认构造函数，deque还提供了一系列的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span>&amp; x)</span><br><span class="line">  : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 配置map和元素</span></span><br><span class="line">  create_map_and_nodes(x.size());</span><br><span class="line">  <span class="comment">// 将x的元素拷贝到本deque内</span></span><br><span class="line">  uninitialized_copy(x.begin(), x.end(), start);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个deque，含有n个值为value的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">deque</span>(size_type n, <span class="keyword">const</span> value_type&amp; value)</span><br><span class="line">  : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  fill_initialize(n, value);	<span class="comment">// 调用fill_initialize函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配n个结点, 并以value为元素值初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:fill_initialize(size_type n,</span><br><span class="line">    <span class="keyword">const</span> value_type&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">  create_map_and_nodes(n);	<span class="comment">// 配置map和缓冲区</span></span><br><span class="line">  map_pointer cur;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">  	<span class="comment">// 为每一个缓冲区设定初值</span></span><br><span class="line">    <span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur)</span><br><span class="line">      uninitialized_fill(*cur, *cur + buffer_size(), value);</span><br><span class="line">    <span class="comment">// 尾端可能留有备用空间，不必设初值</span></span><br><span class="line">    uninitialized_fill(finish.first, finish.cur, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (map_pointer n = start.node; n &lt; cur; ++n)</span><br><span class="line">      destroy(*n, *n + buffer_size());</span><br><span class="line">    destroy_map_and_nodes();</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以区间值来构造deque</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">deque</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  :</span> start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  range_initialize(first, last, iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;class ForwardIterator&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:range_initialize(ForwardIterator first,</span><br><span class="line">    ForwardIterator last,</span><br><span class="line">    forward_iterator_tag) &#123;</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line">  distance(first, last, n);	<span class="comment">// 计算有多少个元素</span></span><br><span class="line">  create_map_and_nodes(n);	<span class="comment">// 配置map和缓冲区</span></span><br><span class="line">  uninitialized_copy(first, last, start);	<span class="comment">// 调用全局函数，将[first,last)拷贝到新配置的空间上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，deque还提供了很多种构造函数，基本上都调用上述函数来构造map和缓冲区，这里就不在赘述！</p>
<h1 id="deque的析构函数"><a href="#deque的析构函数" class="headerlink" title="deque的析构函数"></a>deque的析构函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">deque</span>()</span><br><span class="line">&#123;</span><br><span class="line">  destroy(start, finish);     <span class="comment">// 调用全局函数</span></span><br><span class="line">  destroy_map_and_nodes();		<span class="comment">// 释放map和缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:destroy_map_and_nodes()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt;= finish.node; ++cur)</span><br><span class="line">    deallocate_node(*cur);	<span class="comment">// 释放每一个节点</span></span><br><span class="line">  map_allocator::deallocate(<span class="built_in">map</span>, map_size);	<span class="comment">// 释放map空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="deque支持的操作函数"><a href="#deque支持的操作函数" class="headerlink" title="deque支持的操作函数"></a>deque支持的操作函数</h1><h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><p>push_back完成在尾部插入一个元素，根绝上述的deque的结构特点，里面有很多情况需要考虑。</p>
<ul>
<li>如果备用空间足够，就直接push进去</li>
<li>如果备用空间不足，就要考虑配置一个新的缓冲区</li>
</ul>
<p>配置新缓冲区的时候，还需要考虑map空间是否足够</p>
<ul>
<li>如果map空间足够，就直接配置一块新的缓冲区，链接到map中</li>
<li>如果map空间不足，就需要考虑重新配置一块map</li>
</ul>
<p>可见，为了维持整体连续的假象，确确实实，deque的操作函数需要考虑各个方面。下面来看看源代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在deque的尾部压入一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 注意这里采用STL的前闭后开原则</span></span><br><span class="line">  <span class="comment">// 所以last要-1</span></span><br><span class="line">  <span class="comment">// 如果deque里面还有备用空间，则直接压入</span></span><br><span class="line">  <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">    construct(finish.cur, t);</span><br><span class="line">    ++finish.cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 容量已满就要新申请内存了</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    push_back_aux(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅当finish.cur == finish.last - 1才调用</span></span><br><span class="line"><span class="comment"> * 即最后一个缓冲区没有空间才调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:push_back_aux(<span class="keyword">const</span> value_type&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">  value_type t_copy = t;</span><br><span class="line">  <span class="comment">// 判断是否需要调整map空间</span></span><br><span class="line">  reserve_map_at_back();</span><br><span class="line">  *(finish.node + <span class="number">1</span>) = allocate_node();	<span class="comment">// 配置一块新的缓冲区</span></span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    construct(finish.cur, t_copy);	<span class="comment">// 构造新加入的元素</span></span><br><span class="line">    finish.set_node(finish.node + <span class="number">1</span>);	<span class="comment">// 调整finish</span></span><br><span class="line">    finish.cur = finish.first;</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(deallocate_node(*(finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map空间不足，需要调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - <span class="built_in">map</span>))</span><br><span class="line">		<span class="comment">// 此时，需要调整map，更换一个更大的map</span></span><br><span class="line">		reallocate_map(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新配置map, 不会对缓冲区进行操作, map维护的是指向缓冲区的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:reallocate_map(size_type nodes_to_add,</span><br><span class="line">    <span class="keyword">bool</span> add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">  size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line"></span><br><span class="line">  map_pointer new_nstart;</span><br><span class="line">  <span class="comment">// 此处为了防止出现一端已经用完，另一端却还有很多剩余的情况</span></span><br><span class="line">  <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">  	<span class="comment">// 调整新的map中的起始点</span></span><br><span class="line">    new_nstart = <span class="built_in">map</span> + (map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                 + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果前端剩余很多</span></span><br><span class="line">    <span class="keyword">if</span> (new_nstart &lt; start.node)</span><br><span class="line">      copy(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">// 尾端剩余很多</span></span><br><span class="line">      copy_backward(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;	<span class="comment">// map不够用了，就需要配置一块更大的map</span></span><br><span class="line">    size_type new_map_size = map_size + max(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 配置一块大的map</span></span><br><span class="line">    map_pointer new_map = map_allocator::allocate(new_map_size);</span><br><span class="line">    <span class="comment">// 始终要使start和finish处在map空间的中间</span></span><br><span class="line">    new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                 + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 拷贝到新的map空间中去</span></span><br><span class="line">    copy(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">    <span class="comment">// 释放旧的空间</span></span><br><span class="line">    map_allocator::deallocate(<span class="built_in">map</span>, map_size);</span><br><span class="line">    <span class="comment">// 改变map和size参数</span></span><br><span class="line">    <span class="built_in">map</span> = new_map;</span><br><span class="line">    map_size = new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调整新的start和finish</span></span><br><span class="line">  start.set_node(new_nstart);</span><br><span class="line">  finish.set_node(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h2><p>pop_back是将deque的尾部元素弹出，即拿掉该元素并释放空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果尾端不是该缓冲区最开始的那个元素</span></span><br><span class="line">  <span class="keyword">if</span> (finish.cur != finish.first) &#123;</span><br><span class="line">    --finish.cur;</span><br><span class="line">    destroy(finish.cur);  <span class="comment">// 直接拿掉并释放空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pop_back_aux();   <span class="comment">// 需要调整map的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在pop_back中，如果碰到为首元素的情况，调用此函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>: pop_back_aux()</span><br><span class="line">&#123;</span><br><span class="line">  deallocate_node(finish.first);	<span class="comment">// 释放节点</span></span><br><span class="line">  finish.set_node(finish.node - <span class="number">1</span>);	<span class="comment">// 重新设定finish</span></span><br><span class="line">  finish.cur = finish.last - <span class="number">1</span>;</span><br><span class="line">  destroy(finish.cur);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h2><p>此函数用来在deque的头部压入一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 还是一样，不需要调整map的情况，直接压入</span></span><br><span class="line">  <span class="keyword">if</span> (start.cur != start.first) &#123;</span><br><span class="line">    construct(start.cur - <span class="number">1</span>, t);</span><br><span class="line">    --start.cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    push_front_aux(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有再start.cur== start.first的情况下调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:push_front_aux(<span class="keyword">const</span> value_type&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">  value_type t_copy = t;</span><br><span class="line">  reserve_map_at_front();	<span class="comment">// 同push_back()，检查是否需要调整map</span></span><br><span class="line">  *(start.node - <span class="number">1</span>) = allocate_node();	<span class="comment">// 配置一块新的缓冲区</span></span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    start.set_node(start.node - <span class="number">1</span>);	<span class="comment">// 调整start</span></span><br><span class="line">    start.cur = start.last - <span class="number">1</span>;</span><br><span class="line">    construct(start.cur, t_copy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    start.set_node(start.node + <span class="number">1</span>);</span><br><span class="line">    start.cur = start.first;</span><br><span class="line">    deallocate_node(*(start.node - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-front"><a href="#pop-front" class="headerlink" title="pop_front"></a>pop_front</h2><p>此函数实现从头部弹出一个元素，同pop_back()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    destroy(start.cur);</span><br><span class="line">    ++start.cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pop_front_aux();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在start.cur == start.last - 1的时候调用</span></span><br><span class="line"><span class="comment"> * 此时需要调整map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:pop_front_aux()</span><br><span class="line">&#123;</span><br><span class="line">  destroy(start.cur);</span><br><span class="line">  deallocate_node(start.first);</span><br><span class="line">  start.set_node(start.node + <span class="number">1</span>);</span><br><span class="line">  start.cur = start.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>擦除deque中的每一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:clear()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 首先析构除起点和终点的所有元素, 并释放相应空间</span></span><br><span class="line">  <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;</span><br><span class="line">    destroy(*node, *node + buffer_size());</span><br><span class="line">    data_allocator::deallocate(*node, buffer_size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果deque本身不为空, 析构所有对象, 并释放掉结尾的内存</span></span><br><span class="line">  <span class="keyword">if</span> (start.node != finish.node) &#123;</span><br><span class="line">    destroy(start.cur, start.last);  <span class="comment">// 将头缓冲区的元素清除</span></span><br><span class="line">    destroy(finish.first, finish.cur);  <span class="comment">//将尾缓冲区的元素清除</span></span><br><span class="line">    data_allocator::deallocate(finish.first, buffer_size()); <span class="comment">// 头缓冲区保留，释放尾缓冲区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 析构所有元素, 但是不释放空间, 因为deque要满足这个前置条件</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    destroy(start.cur, finish.cur);</span><br><span class="line"></span><br><span class="line">  finish = start; <span class="comment">// 调整finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><p>erase实现了擦除单个指定元素和擦出区间两个版本，源代码分析如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此函数实现擦除单个指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  iterator next = pos;</span><br><span class="line">  ++next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算待擦除点前的元素个数</span></span><br><span class="line">  difference_type index = pos - start;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断待擦除结点前后元素的个数, 哪部分少就移动哪部分</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 前面部分的元素少</span></span><br><span class="line">    copy_backward(start, pos, next);  </span><br><span class="line">    pop_front();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后面部分的元素少</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    copy(next, finish, pos); </span><br><span class="line">    pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> start + index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>擦除[first,last)区间的元素。此函数按下列步骤来擦除区间。</p>
<ul>
<li>需要擦除整个空间，直接调用clear()</li>
<li>需要擦出中间指定区间</li>
</ul>
<p>擦除中间指定区间，需要考虑一下两种情况</p>
<ul>
<li>区间前面的元素少，就移动前面的元素</li>
<li>区间后面的元素少，就移动后面的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123;	<span class="comment">// 需要擦除整个deque</span></span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">return</span> finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    difference_type n = last - first;	<span class="comment">// 清除区间的长度</span></span><br><span class="line">    difference_type elems_before = first - start;  <span class="comment">// 待清除区间前方的元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (elems_before &lt; (size() - n) / <span class="number">2</span>) &#123;	<span class="comment">// 如果前方的元素个数较少</span></span><br><span class="line">      copy_backward(start, first, last);	<span class="comment">// 向后移动前方元素</span></span><br><span class="line">      iterator new_start = start + n;     <span class="comment">// 调整新的起始点</span></span><br><span class="line">      destroy(start, new_start);          <span class="comment">// 全局函数，析构节点元素</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());   <span class="comment">// 释放缓冲区空间</span></span><br><span class="line">      start = new_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">// 后方元素比较少的情况</span></span><br><span class="line">      copy(last, finish, first);	<span class="comment">// 向前移动后方元素</span></span><br><span class="line">      iterator new_finish = finish - n; <span class="comment">// 调整新的finish迭代器</span></span><br><span class="line">      destroy(new_finish, finish);      <span class="comment">// 全局函数，析构节点元素</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());  <span class="comment">// 释放缓冲区空间</span></span><br><span class="line">      finish = new_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + elems_before;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>在指定位置前插入元素，deque的源码中，为insert提供了多个版本，这里列举插入一个元素和n和元素的版本。</p>
<p>在指定位置插入一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果是在deque的最前端插入, 那么直接push_front()即可</span></span><br><span class="line">  <span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">    push_front(x);</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是在deque的末尾插入, 直接调用push_back()</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;</span><br><span class="line">    push_back(x);</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> insert_aux(position, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不在首尾插入元素的时候调用此函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  difference_type index = pos - start;  <span class="comment">// 插入元素前面的元素个数</span></span><br><span class="line">  value_type x_copy = x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>) &#123;  <span class="comment">// 如果前端的元素比较少</span></span><br><span class="line">    push_front(front());  <span class="comment">// 在最前面插入一个与第一个元素一样的数</span></span><br><span class="line">    iterator front1 = start;  <span class="comment">// 记录起始点</span></span><br><span class="line">    ++front1;</span><br><span class="line">    iterator front2 = front1; </span><br><span class="line">    ++front2;</span><br><span class="line">    pos = start + index;</span><br><span class="line">    iterator pos1 = pos;</span><br><span class="line">    ++pos1;</span><br><span class="line">    copy(front2, pos1, front1); <span class="comment">// 拷贝空间，将[front2,pos1)拷贝到front1以后</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;   <span class="comment">// 后端的元素比较少，原理用上</span></span><br><span class="line">    push_back(back());</span><br><span class="line">    iterator back1 = finish;</span><br><span class="line">    --back1;</span><br><span class="line">    iterator back2 = back1;</span><br><span class="line">    --back2;</span><br><span class="line">    pos = start + index;</span><br><span class="line">    copy_backward(pos, back2, back1);</span><br><span class="line">  &#125;</span><br><span class="line">  *pos = x_copy;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在指定位置插入n个元素的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:insert(iterator pos,</span><br><span class="line">                                      size_type n, <span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos.cur == start.cur) &#123;   <span class="comment">// 如果插入点再最前端</span></span><br><span class="line">    iterator new_start = reserve_elements_at_front(n); <span class="comment">// 调整新的start位置</span></span><br><span class="line">    uninitialized_fill(new_start, start, x);	<span class="comment">//直接在前端构造n个元素</span></span><br><span class="line">    start = new_start;  <span class="comment">// 调整新的start</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pos.cur == finish.cur) &#123;</span><br><span class="line">  	<span class="comment">// 与reserve_elements_at_front相同</span></span><br><span class="line">  	<span class="comment">// 考虑篇幅，这里不列出源代码</span></span><br><span class="line">    iterator new_finish = reserve_elements_at_back(n); </span><br><span class="line">    uninitialized_fill(finish, new_finish, x);</span><br><span class="line">    finish = new_finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    insert_aux(pos, n, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入区间前方备用空间能否容纳n个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">iterator <span class="title">reserve_elements_at_front</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  size_type vacancies = start.cur - start.first;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; vacancies)   <span class="comment">// 如果容纳不了，就需要重新配置map</span></span><br><span class="line">    new_elements_at_front(n - vacancies);</span><br><span class="line">  <span class="keyword">return</span> start - difference_type(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在前方备用空间容纳不了待插入的n个元素的情况下调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:new_elements_at_front(size_type new_elements)</span><br><span class="line">&#123;</span><br><span class="line">  size_type new_nodes = (new_elements + buffer_size() - <span class="number">1</span>) / buffer_size();</span><br><span class="line">  reserve_map_at_front(new_nodes);  <span class="comment">// 调整map</span></span><br><span class="line">  size_type i;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= new_nodes; ++i)</span><br><span class="line">      *(start.node - i) = allocate_node(); <span class="comment">// 为每一个map指针配置空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">      deallocate_node(*(start.node - j));</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整map的前端，以在前端能连接更多缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nodes_to_add &gt; start.node - <span class="built_in">map</span>)</span><br><span class="line">    reallocate_map(nodes_to_add, <span class="literal">true</span>);  <span class="comment">// 此函数上面有说明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 好吧，这里才是最重要的insert_aux函数，实现在中间某个位置插入n个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:insert_aux(iterator pos,</span><br><span class="line">    size_type n, <span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> difference_type elems_before = pos - start;  <span class="comment">// 计算该位置前面的元素个数</span></span><br><span class="line">  size_type length = size();</span><br><span class="line">  value_type x_copy = x;</span><br><span class="line">  <span class="keyword">if</span> (elems_before &lt; length / <span class="number">2</span>) &#123;  <span class="comment">// 如果位置前面的元素比较少</span></span><br><span class="line">    iterator new_start = reserve_elements_at_front(n); <span class="comment">// 同上</span></span><br><span class="line">    iterator old_start = start;</span><br><span class="line">    pos = start + elems_before;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_before &gt;= difference_type(n)) &#123; </span><br><span class="line">        iterator start_n = start + difference_type(n);</span><br><span class="line">        uninitialized_copy(start, start_n, new_start);</span><br><span class="line">        start = new_start;</span><br><span class="line">        copy(start_n, pos, old_start);</span><br><span class="line">        fill(pos - difference_type(n), pos, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __uninitialized_copy_fill(start, pos, new_start, start, x_copy);</span><br><span class="line">        start = new_start;</span><br><span class="line">        fill(old_start, pos, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(destroy_nodes_at_front(new_start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;   <span class="comment">// 该位置后面的元素比较少</span></span><br><span class="line">    iterator new_finish = reserve_elements_at_back(n);</span><br><span class="line">    iterator old_finish = finish;</span><br><span class="line">    <span class="keyword">const</span> difference_type elems_after = difference_type(length) - elems_before;</span><br><span class="line">    pos = finish - elems_after;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; difference_type(n)) &#123;</span><br><span class="line">        iterator finish_n = finish - difference_type(n);</span><br><span class="line">        uninitialized_copy(finish_n, finish, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        copy_backward(pos, finish_n, old_finish);</span><br><span class="line">        fill(pos, pos + difference_type(n), x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __uninitialized_fill_copy(finish, pos + difference_type(n),</span><br><span class="line">        x_copy,</span><br><span class="line">        pos, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        fill(pos, old_finish, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(destroy_nodes_at_back(new_finish));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    
       <div>
       
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------　　　　文章看完啦　<i class="fa fa-heart"></i>　感谢您的阅读　　　　-------------</div>
    
</div>
         
      </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Moonstar-Z.github.io.git/2020/03/15/LeeCode/下一个排列/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Moonstar-Z.github.io.git/2020/03/15/STL/find/" rel="prev" title>
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/Moonstar-Z.github.io.git/images/user.jpg" alt="半世烟尘">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/Moonstar-Z.github.io.git/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/Moonstar-Z.github.io.git/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/Moonstar-Z.github.io.git/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/COTVZHAOYUEXING" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1998lovexs@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Deque概述"><span class="nav-number">1.</span> <span class="nav-text">Deque概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#deque的中控器"><span class="nav-number">2.</span> <span class="nav-text">deque的中控器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#deque的迭代器"><span class="nav-number">3.</span> <span class="nav-text">deque的迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#buffer-size函数"><span class="nav-number">3.1.</span> <span class="nav-text">buffer_size函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-node函数"><span class="nav-number">3.2.</span> <span class="nav-text">set_node函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#各种运算子"><span class="nav-number">3.3.</span> <span class="nav-text">各种运算子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#deque的数据结构"><span class="nav-number">4.</span> <span class="nav-text">deque的数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#deque的构造函数"><span class="nav-number">5.</span> <span class="nav-text">deque的构造函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#deque的析构函数"><span class="nav-number">6.</span> <span class="nav-text">deque的析构函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#deque支持的操作函数"><span class="nav-number">7.</span> <span class="nav-text">deque支持的操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#push-back"><span class="nav-number">7.1.</span> <span class="nav-text">push_back</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pop-back"><span class="nav-number">7.2.</span> <span class="nav-text">pop_back</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#push-front"><span class="nav-number">7.3.</span> <span class="nav-text">push_front</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pop-front"><span class="nav-number">7.4.</span> <span class="nav-text">pop_front</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clear"><span class="nav-number">7.5.</span> <span class="nav-text">clear</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#erase"><span class="nav-number">7.6.</span> <span class="nav-text">erase</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#insert"><span class="nav-number">7.7.</span> <span class="nav-text">insert</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io.git/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io.git/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io.git/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io.git/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io.git/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io.git/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/Moonstar-Z.github.io.git/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/Moonstar-Z.github.io.git/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/Moonstar-Z.github.io.git/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/Moonstar-Z.github.io.git/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/Moonstar-Z.github.io.git/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
