<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">

<!-- jquery -->

<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/Moonstar-Z.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Moonstar-Z.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Moonstar-Z.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Moonstar-Z.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Moonstar-Z.github.io/css/main.css">


<link rel="stylesheet" href="/Moonstar-Z.github.io/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/Moonstar-Z.github.io/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1、赋值运算符 题目：为下面的类添加一个赋值运算符  12345678910class CMyString&amp;#123;    public:       CMyString(char*Pdata=nullptr);       CMyString(const CMyString&amp;amp; str);       ~CMyString(void);    private:       char* m">
<meta name="keywords" content="剑指offer">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer题目知识点（二刷）{1-----33题}">
<meta property="og:url" content="https://yoursite.com/2019/09/12/面试/剑指offer/剑指Offer题目解释和对应代码的手写/index.html">
<meta property="og:site_name" content="苍山负雪">
<meta property="og:description" content="1、赋值运算符 题目：为下面的类添加一个赋值运算符  12345678910class CMyString&amp;#123;    public:       CMyString(char*Pdata=nullptr);       CMyString(const CMyString&amp;amp; str);       ~CMyString(void);    private:       char* m">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-03-17T05:33:16.826Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指Offer题目知识点（二刷）{1-----33题}">
<meta name="twitter:description" content="1、赋值运算符 题目：为下面的类添加一个赋值运算符  12345678910class CMyString&amp;#123;    public:       CMyString(char*Pdata=nullptr);       CMyString(const CMyString&amp;amp; str);       ~CMyString(void);    private:       char* m">

<link rel="canonical" href="https://yoursite.com/2019/09/12/面试/剑指offer/剑指Offer题目解释和对应代码的手写/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>
<!-- 打字礼花及震动特效 -->

<div id="append_parent"></div><div id="ajaxwaitid"></div>
<script type="text/javascript" src="/lib/activate-power-mode/activate-power-mode.js"></script>
<script>
	POWERMODE.colorful = true;
	POWERMODE.shake = false;
	document.body.addEventListener('input',POWERMODE);
</script>

<!-- jquery -->

<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <title>剑指Offer题目知识点（二刷）{1-----33题} | 苍山负雪</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/Moonstar-Z.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苍山负雪</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/Moonstar-Z.github.io/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/Moonstar-Z.github.io/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/Moonstar-Z.github.io/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Moonstar-Z.github.io/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/09/12/面试/剑指offer/剑指Offer题目解释和对应代码的手写/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Moonstar-Z.github.io/images/avatar.gif">
      <meta itemprop="name" content="苍山负雪">
      <meta itemprop="description" content="三十功名尘与土，八千里路云和月。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍山负雪">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          剑指Offer题目知识点（二刷）{1-----33题}
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-12T00:00:00+08:00">2019-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-17 13:33:16" itemprop="dateModified" datetime="2020-03-17T13:33:16+08:00">2020-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Moonstar-Z.github.io/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1、赋值运算符"><a href="#1、赋值运算符" class="headerlink" title="1、赋值运算符"></a>1、赋值运算符</h3><blockquote>
<p>题目：为下面的类添加一个赋值运算符</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       CMyString(<span class="keyword">char</span>*Pdata=<span class="literal">nullptr</span>);</span><br><span class="line">       CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">       ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">char</span>* m_pData;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>注意的地方</strong></p>
<p>1 返回值的类型声明是不是该类型的引用，并在最后返回实例的*this，只有返回一个应用才能连续赋值。</p>
<p>2传入的参数的类型是不是 常量的引用 如果是按值传递会增加额外的开销 </p>
<p>3 释放自身已有的内存，否则会出现程序崩溃的情况</p>
<p>4 判断传入的是不是同一个实例 即是自己给自己赋值 这样子会出错</p>
<p><strong>常规解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMyString &amp;CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[]m_pData;</span><br><span class="line">    m_pData=<span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    m_pData=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData)+<span class="number">1</span>];</span><br><span class="line">    strcopy(m_pData,str.m_pData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 但是上面的代码在安全性上面会有一定的问题，在new新内存的时候假如没有足够的内存，m_pData会是一个空指针，程序会出现问题。</p>
<p><strong>考虑安全性的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       CMyString(<span class="keyword">char</span>*Pdata=<span class="literal">nullptr</span>);</span><br><span class="line">       CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">       ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">       CMyString&amp;CMyString::<span class="keyword">operator</span>(<span class="keyword">const</span> CMyString&amp;str);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">char</span>* m_pData;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> CMyString&amp;CMyString::<span class="keyword">operator</span>(<span class="keyword">const</span> CMyString&amp;str)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(*<span class="keyword">this</span>!=&amp;str)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="function">CMyString <span class="title">strTemp</span><span class="params">(str)</span></span>;<span class="comment">//内存不足的情况会出现在这里，但是这里你没有更改原来的实例。</span></span><br><span class="line">         </span><br><span class="line">         <span class="keyword">char</span> *pTemp=strTemp.m_pData;</span><br><span class="line">         strTemp.m_pData=m_pData;</span><br><span class="line">         m_pData=pTemp;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、数组中的重复数字"><a href="#2、数组中的重复数字" class="headerlink" title="2、数组中的重复数字"></a>2、数组中的重复数字</h3><blockquote>
<p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<p>解决的办法：</p>
<p>1 直接将整个数组排序，然后重头到尾扫描数组，此时的时间复杂度为<code>O（nlogn）</code> </p>
<p>2 用哈希表解决这个问题</p>
<p>3 在原来数组重排这个数组，第三种方法，把每个数字放回对应位置的方法。如果出现一个数字无法放回（所在位置已经是对应数字了），那么说明该数字重复。</p>
<p><strong>哈希解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *resu = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">    duplicate(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>), resu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *resu &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *hashTable = <span class="keyword">new</span> <span class="keyword">int</span>[length]();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashTable[numbers[i]]) &#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hashTable[numbers[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交换元素的解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *item1, <span class="keyword">int</span> *item2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *resu = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">    duplicate(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>), resu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *resu &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == i) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numbers[numbers[i]] != numbers[i]) &#123;</span><br><span class="line">            swap(&amp;numbers[numbers[i]], &amp;numbers[i]);<span class="comment">//外部写一个交换的函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            *duplication = numbers[i];<span class="comment">//numbers[numbers[i]] != numbers[i] 这一句检查是否                                         有重复的数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *item1, <span class="keyword">int</span> *item2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *item1;</span><br><span class="line">    *item1 = *item2;</span><br><span class="line">    *item2 = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1扩展的问题"><a href="#2-1扩展的问题" class="headerlink" title="2.1扩展的问题"></a>2.1扩展的问题</h4><blockquote>
<p>不修改数组找出重复的数字</p>
<p>在一个长度为n+1的数组里的所有数字都在1~n范围内。所以数组中至少有一个数是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，输入长度为8的数组{2，3，5，4，3，2，6，7}，那么对应的输出是重复的数字2或者3。</p>
</blockquote>
<p>1.这个题目可以依照题目一的思路来，不过由于不能修改输入数组，所以可以构建一个n+1大小的辅助数组，构建了辅助数组之后可以<strong>使用hash</strong>表也，可以<strong>使用换位置</strong>的思路来做 。<br>2.使用二分的思想来做，二分基数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *numbers, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>, end = length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> lowCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);<span class="comment">//中间的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &lt;= mid &amp;&amp; numbers[i] &gt;= start) &#123;</span><br><span class="line">                lowCnt++;</span><br><span class="line">                         &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">        <span class="keyword">if</span> (lowCnt &gt; (mid - start + <span class="number">1</span>)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">                                     &#125;</span><br><span class="line">        <span class="keyword">else</span>  &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3，二维数组中的查找"><a href="#3，二维数组中的查找" class="headerlink" title="3，二维数组中的查找"></a>3，二维数组中的查找</h3><blockquote>
<p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下的递增的顺序排序，请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。。</p>
</blockquote>
<p>1.目标数为T，从二维数组的最右上角开始查找，如果T比该数字小，说明T比该数字所在列都小，故剔除列，如果  T比该数字大，说明T比该数字所在行都大，故剔除行，直到最后找到为止。<br>2.也可以从最左下角开始，但是不能从另外两个角开始。(为什么？)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows=<span class="built_in">array</span>.size();</span><br><span class="line">    <span class="keyword">int</span> clos=<span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>||clos==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=clos<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i!=rows&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]==target)/ </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]&gt;target)&#123;</span><br><span class="line">        j--;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i++;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不能从另外两个角开始，因为假如第一个数字是1，但是目标是7，此时7可能会在这一行的右边，也可能在这一行的下面，所以我们没有办法确定怎么进行下一步。</p>
<h3 id="4、替换空格"><a href="#4、替换空格" class="headerlink" title="4、替换空格"></a>4、替换空格</h3><blockquote>
<p>题目：请实现一个函数，把字符串中的每个空格替换成“%20”，例如，输入”We are happy.”,则输出”We%20are%20happy.”</p>
</blockquote>
<p>一般像这种需要向后扩充容量重新整理内存的，最好能够考虑到从尾部开始整理的方法<br>1.指针都可以当作数组使用，但是指针本身不检查是否超出数组范围。<br>2.对字符串的处理都应该考虑最后的空字符’\0’。<br>3.应该一个一个的处理字符串中的字符，不要向一蹴而就。<br>4<strong>.扩充字符串可以考虑从尾部开始</strong>。<br>5.应该警惕内存覆盖，如果改变字符串会导致字符串变长，那应该考虑内存的问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span>*str,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//先计算出整个字符串里面空格的数量</span></span><br><span class="line">   <span class="keyword">int</span> numsofspace=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> originallength=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span> * str1=str;<span class="comment">//复制一份原来的字符串</span></span><br><span class="line">    <span class="keyword">while</span>(*str1!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*str1=='')</span><br><span class="line">            numsofspace++;</span><br><span class="line">        str1++;</span><br><span class="line">        originallength++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//替换成%20整个字符串长度的变化</span></span><br><span class="line">    <span class="keyword">int</span> newlength=originallength+<span class="number">2</span>*numsofspace;</span><br><span class="line">    <span class="keyword">if</span>(newlength&gt;length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//下面开始直接替换字符串</span></span><br><span class="line">    <span class="keyword">int</span> indexoriginal=originallength;</span><br><span class="line">    <span class="keyword">int</span> indexnewlength=newlength;</span><br><span class="line">   <span class="comment">//下面是第一个版本用while循环写</span></span><br><span class="line">    <span class="keyword">while</span>(indexoriginal&gt;<span class="number">0</span>&amp;&amp;indexnewlength&gt;indexoriginal）<span class="comment">//这里的条件是 原来的 指针应该大于                                                    0，新的指针应该一直大于等于旧的指针</span></span><br><span class="line">          &#123;</span><br><span class="line">              if(str[indexoriginal]=='')</span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'0'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'2'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'%'</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=str[indexoriginal--];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    <span class="comment">//下面是第二个版本是用for循环写的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=indexoriginal<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              if(str[i]!='')</span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=str[i];</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'0'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'2'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'%'</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、从尾到头打印链表"><a href="#5、从尾到头打印链表" class="headerlink" title="5、从尾到头打印链表"></a>5、从尾到头打印链表</h3><blockquote>
<p>题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">       ListNode(<span class="keyword">int</span> x) :</span><br><span class="line">              val(x), next(<span class="literal">NULL</span>) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.注意传入函数的是指向链表头的指针，在函数中不应该直接使用这个指针，而是应该用一个指针的临时变量来遍历链表。<br>2.方法一：使用栈来实现（用栈更好）。<br>3.方法二：递归在本质上就是一个栈结构，所以也可以用递归来实现。</p>
<p><strong>用栈实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//先定义一个结构体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;printstack(ListNode*head)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">  <span class="built_in">stack</span>&lt;ListNode*&gt;Node;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      Node.push(head);</span><br><span class="line">      <span class="comment">//还有一种写法，直接在栈里面保存的是节点的值</span></span><br><span class="line">      head=head-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">while</span>(Node!=empty())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> nodeval=Node.top();</span><br><span class="line">      Node.pop();</span><br><span class="line">      result.push_back(nodeval);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用递归实现,但是实际上时间比上面的堆栈更加长</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;printstack(ListNode*head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">//下面开始递归的写法</span></span><br><span class="line">    result=printstack(head-&gt;next);</span><br><span class="line">    result.pusn_back(head-val);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、重建二叉树"><a href="#6、重建二叉树" class="headerlink" title="6、重建二叉树"></a>6、重建二叉树</h3><blockquote>
<p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树（假设没有重复数字）。树节点定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.前序遍历的第一个数字总是树的根节点的值。但在中序遍历中，根节点的值在序列的中间，其中左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。要扫描中序遍历序列，才能找到根节点的值。<br>2.又因为前序遍历总是在根节点后先遍历完左子树，才会遍历右子树，所以由后续遍历推断出左子树中节点的数目之后，前序遍历中根节点之后的相同数目的值都是左子树的节点的值。剩下的就是右子树的值。这样就分别找到了左右子树序列。<br>3.<strong>分别确定了根节点和左右子树的前序、中序遍历，我们可以用同样的方法构建左右子树，剩下的可以用递归来完成。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//数学公式的头文件吧</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode*<span class="title">rebulidTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;prologue,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Mediumorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(prologue.size()==<span class="number">0</span>||Mediumorder.size()!=prologue.size())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//应该新建立一个二叉树</span></span><br><span class="line">    TreeNode* newtree=<span class="keyword">new</span> TreeNode(prologue[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(prologue.size()==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> newtree;</span><br><span class="line">    <span class="comment">//检查错误吧这里是</span></span><br><span class="line">    <span class="keyword">auto</span> position=find(Mediumorder.begin(),Mediumorder.end(),prologue[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(position==Mediumorder.end())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSize = position - Mediumorder.begin();</span><br><span class="line">    <span class="keyword">int</span> rightSize = Mediumorder.end() - position - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  newtree-&gt;left=rebulidTree<span class="comment">//向左边递归求解</span></span><br><span class="line">  (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(prologue.begin()+<span class="number">1</span>,prologue.begin()+<span class="number">1</span>+leftSize),</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(Mediumorder.begin(),Mediumorder.begin()+leftSize));</span><br><span class="line">  </span><br><span class="line">  newtree-&gt;right=rebulidTree<span class="comment">//向右边递归求解</span></span><br><span class="line">  (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(prologue.begin()+<span class="number">1</span>+leftSize,prologue.end()),</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(Mediumorder.begin()+leftSize,Mediumorder.end()));、</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">return</span> newtree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是另外的一个解法</span></span><br></pre></td></tr></table></figure>

<h3 id="7、二叉树的下一个节点"><a href="#7、二叉树的下一个节点" class="headerlink" title="7、二叉树的下一个节点"></a>7、二叉树的下一个节点</h3><blockquote>
<p>给定一颗二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了指向左右子树的指针，还有一个指向父节点的指针。树节点定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">next</span>;</span><span class="comment">//还有一个指向父节点的指针</span></span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.如果该节点有右子树，则它的下一个节点就是其右子树的最左子节点。<br>2.如果该节点没有右子树，但是它本身是其父节点的左子节点，那么它的下一个节点就是其父节点。<br>3.如果该节点没有右子树，并且是其父节点的右子节点，那么它的下一个节点就需要向上不断找父节点，直到找到一个节点是其父节点的左子节点，那么该节点的父节点就要我们要找的下一个节点。<br>4.如果上面的方法都没有找到下一个节点，说明该节点不存在下一个节点，返回nullptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeLinkNode*<span class="title">getNextNode</span><span class="params">(TreeLinkNode*pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeLinkNode*nextNode=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//如果存在右子树</span></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       TreeLinkNode* temporary=pNode-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(temporary-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temporary=temporary-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">       nextNode=temporary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不存在右子树的时候</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       TreeLinkNode* temporary=pNode; </span><br><span class="line">     <span class="comment">//这里是如果该节点没有右子树，但是它本身是其父节点的左子节点，那么它的下一个节点就是其父节点</span></span><br><span class="line">        <span class="keyword">if</span>(temporary==temporary-&gt;next-&gt;left)</span><br><span class="line">            nextNode=temporary-&gt;next;</span><br><span class="line">     <span class="comment">//这里是第三种情况，需要一直上溯到一个节点是其父节点的左子节点，那么该节点的父节点就要我们要找的下一个节点。</span></span><br><span class="line">        <span class="keyword">while</span>(temporary-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temporary==temporary-&gt;next-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                nextNode=temporary-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temporary=temporary-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、用两个栈实现队列"><a href="#8、用两个栈实现队列" class="headerlink" title="8、用两个栈实现队列"></a>8、用两个栈实现队列</h3><blockquote>
<p>题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个成员函数，分别完成在队列尾部插入节点和在队列的头部删除节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>固定一个栈用于入队操作，另一个栈用于出队操作：<br>1.入队列操作，不管stack1和stack2是什么状态，直接向stack1入栈即可。<br>2.出队列操作，如果stack2为空，那么把stack1的元素一个一个弹出并压入到stack2中，完成之后，对stack2进行出栈操作，此元素就是最先入队的元素。<br>3.出队列操作，如果stack2不为空，那么直接从stack2出栈，此元素是当前所有元素中最先入队的那个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> solution::push(<span class="keyword">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> solution::pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2!=empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temporary=stack1.top();</span><br><span class="line">        stack1.pop();</span><br><span class="line">        <span class="keyword">return</span> temporary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1!=empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temporary=stack1.top();</span><br><span class="line">            stack2.push(temporary);</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temporary=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> temporary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1两个队列实现一个栈"><a href="#8-1两个队列实现一个栈" class="headerlink" title="8.1两个队列实现一个栈"></a>8.1两个队列实现一个栈</h4><p>两个栈实现一个队列：使用栈1来入队，栈2来出队，角色是固定了的<br><strong>两个队列实现一个栈：使用非空队列来入栈，使用空队列来出栈，角色会转换：</strong><br>1.入栈操作：哪个队列非空，就把元素插入哪个队列的队尾，如果两个队列都为空，那么就随便使用一个队列。<br>2.出栈操作：把非空队列的元素出队并且按顺序一个一个压入另一个队列，直到剩下一个元素，这个元素就是要出栈的元素。输出该元素即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; deueu1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; deueu2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9、斐波那契数列"><a href="#9、斐波那契数列" class="headerlink" title="9、斐波那契数列"></a>9、斐波那契数列</h3><blockquote>
<p>求斐波那契数列的第n项。斐波那契数列的定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">f(n) = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>); n &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>1.使用递归的方法是最简单的，但是效率成问题，有很多重复的计算。其实就是一种自顶向下的思想。 但是可以考虑用尾递归，会减少很多不必要的计算。</p>
<p>2.也可以考虑使用循环做，这样的也可以减少很多不必要的计算。</p>
<p>3.使用自底向上的思想，从n=2开始计算，并且每次保存前面两次计算的结果，以此进行下一次计算，这样就不会有重复的计算。复杂度为O(n)。<br>4.注意一旦n过大，就会超出long long的范围变成一个大数问题。</p>
<p><strong>循环的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre=<span class="number">0</span>,pre1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result=pre+per1;</span><br><span class="line">        pre=pre1;</span><br><span class="line">        pre2=result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归的解法  时间复杂度最高的一种解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>尾递归的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> pre=<span class="number">0</span>,pre1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> FibonacciTailRecursive(n,pre,pre1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> FibonacciTailRecursive(<span class="keyword">int</span> n,<span class="keyword">int</span> ret1,<span class="keyword">int</span> ret2)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> ret1;</span><br><span class="line">     <span class="keyword">return</span> FibonacciTailRecursive(n<span class="number">-1</span>,ret2,ret1+ret2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、旋转数组的最小数字"><a href="#10、旋转数组的最小数字" class="headerlink" title="10、旋转数组的最小数字"></a>10、旋转数组的最小数字</h3><blockquote>
<p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p>
<p>比如{3，4，5，1,2}和{1,2,3,4,5}</p>
</blockquote>
<p>1.旋转之后的数组实际上可以划分为两个排序的子数组，前面子数组的元素都大于或者等于后面子数组的元素，最小的元素恰好是两个子数组的分界线 </p>
<p>2.找中位数 mid mid，如果中位数大于数组首元素 start start，说明该中位数位于前半段数组，如果该中位数小于数组尾元素 end end，说明该中位数位于后半段数组。</p>
<p>3.不管移动 start start还是 end end的位置，都把它移动到 mid mid上面，保证 start start一直在前半段数组， end end一直在后半段数组 </p>
<p>4.end end的最后值就是最小元素的位置，而终结条件是 start start和 end end的距离为1 </p>
<p>5.旋转零个元素也是一个旋转数组，应该考虑到，即 data[start]&lt;data[end] data[start]&lt;data[end]的情况，这个时候最小元素直接就是第一个元素 </p>
<p>6.考虑到首元素等于尾元素等于中间元素的情况，这种情况下无法判断中间元素属于哪个子数组，所以只能采用顺序查找法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNumberOfarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;rotateArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size=rotateArray.size();</span><br><span class="line">    <span class="keyword">if</span>(size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//整个数组本来就已经是排序好成升序的数组</span></span><br><span class="line">    <span class="keyword">if</span>(rotateArray[<span class="number">0</span>]&lt;rotateArray[size<span class="number">-1</span>]||size==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> befor=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> after=size<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(after-befor&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle=(befor+after)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果第一个元素等于最后一个元素 等于中间的一个元素 那就只能强制进行一一检查</span></span><br><span class="line">        <span class="keyword">if</span>(rotateArray[befor]==rotateArray[middle]==rotateArray[after])</span><br><span class="line">            <span class="keyword">return</span> sortArray(rotateArray);</span><br><span class="line">        <span class="comment">//如果中间的元素小于等于最后的那个元素 &#123;45123&#125; 1&lt;3</span></span><br><span class="line">        <span class="keyword">if</span>(rotateArray[middle]&lt;=rotateArray[after])</span><br><span class="line">            after=middle;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            befor=middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateArray[after];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;rotateArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;itreator::it;</span><br><span class="line">    <span class="keyword">int</span> temp=rotateArray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> it=rotateArray.begin()+<span class="number">1</span>;it!=rotateArray.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;*it)</span><br><span class="line">            temp=*it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11、矩阵中的路径"><a href="#11、矩阵中的路径" class="headerlink" title="11、矩阵中的路径"></a>11、矩阵中的路径</h3><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br>例如在下面的3*4矩阵 </p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">t</th>
<th align="center">g</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c</td>
<td align="center">f</td>
<td align="center">c</td>
<td align="center">s</td>
</tr>
<tr>
<td align="center">j</td>
<td align="center">d</td>
<td align="center">e</td>
<td align="center">h</td>
</tr>
</tbody></table>
<p>矩阵中包含一条字符串”bfce”的路径，但是矩阵中不包含”abfb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><strong>可以用回溯法来解决的典型问题。</strong></p>
<p>回溯法可以看成蛮力法的升级版，它从解决问题的每一步的所有可能选项里系统地选择一个可行的解决方案。回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。就这样重复选择，直到到达最终的状态。<br>用回溯法解决的问题的所有选项可以形象的用树状结构表示。在某一步有n个可能的选项，那么该步骤可以看做是树状结构中的一个节点，每个选项看成树中节点连接线，经过这些连接线到达该节点的n个子节点。树的叶子节点对应着终结状态。如果树的叶节点满足题目的约束条件，那么我们就找到了一个可行的解决方案。<br>如果叶节点的状态不满足约束条件，那么只好回溯到它的上一个节点再尝试其他的选项。如果上一个节点的所有可能选项都已经试过了，并且不能到达满足约束条件的终结状态。则再次回溯到上一个节点。</p>
<p><span style="color:red">首先在矩阵中任意选取一个格子作为起点。假设矩阵中某个格子的字符为ch，并且这个格子对应于路径上的第i个字符。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径的第i个位置上。如果路径的第i个字符恰好是ch，那么到相邻的格子上寻找第i+1个字符。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。由于回溯法的递归特性，路径可以被看做一个栈。</span></p>
<p><strong>1.应该有一个布尔值矩阵来记录矩阵的哪些格子已经被使用过了</strong><br><strong>2.使用递归的方式求解。在使用递归的时候应该注意，在退出递归的时候需要根据需求对计数或者标志进行回退或者清除等操作。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;                </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;                 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>*matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">char</span>*str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断初始条件</span></span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="literal">nullptr</span>||rows&lt;=<span class="number">0</span>||clos&lt;=<span class="number">0</span>||str==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">//建立一个数组访问的visit</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;visit(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(clos,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;<span class="comment">//这个长度应该是整个str判断值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=clos;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasPath(matrix,rows,clos,i,j,str,length,visit))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> length,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;visit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[length]==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> isinpath=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=rows&amp;&amp;j&lt;=clos&amp;&amp;i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>&amp;&amp;matrix(i*clos+j)==str[length]&amp;&amp;!visit[i][j])</span><br><span class="line">    &#123;</span><br><span class="line">        length++;</span><br><span class="line">        visit[i][j]=<span class="literal">true</span>;</span><br><span class="line">        isinpath=hasPath(matrix,rows,clos,i<span class="number">-1</span>,j,str,length,visit)||</span><br><span class="line">                 hasPath(matrix,rows,clos,i+<span class="number">1</span>,j,str,length,visit)||</span><br><span class="line">                 hasPath(matrix,rows,clos,i,j<span class="number">-1</span>,str,length,visit)||</span><br><span class="line">                 hasPath(matrix,rows,clos,i,j+<span class="number">1</span>,str,length,visit);</span><br><span class="line">        <span class="comment">//这里就是回溯的哪一步 </span></span><br><span class="line">        <span class="keyword">if</span>(!isinpath)</span><br><span class="line">        &#123;</span><br><span class="line">            length--;</span><br><span class="line">            visit[i][j]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12、机器人的运动范围"><a href="#12、机器人的运动范围" class="headerlink" title="12、机器人的运动范围"></a>12、机器人的运动范围</h3><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p><strong>1.使用递归</strong><br><strong>2.仍然使用布尔值矩阵记录是否进入过</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoveConut</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;threshould,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span>||threshould.size()&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rows=threshould.size();</span><br><span class="line">    <span class="keyword">int</span> clos=threshould[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;visit(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(clos,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">int</span> count=movingconut(threshould,rows,clos,<span class="number">0</span>,<span class="number">0</span>,visit,k);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是整个代码的核心 判断机器人可不可以进入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingcount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;threshould,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">int</span> i,                                 <span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visit,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//检查这个i j 机器人可否进入</span></span><br><span class="line">    <span class="keyword">if</span>(checkinto(threshould,rows,clos,i,j,visit,k))</span><br><span class="line">    &#123;</span><br><span class="line">        count=<span class="number">1</span>+movingcount(threshould,rows,clos,i<span class="number">-1</span>,j,visit,k)||</span><br><span class="line">                movingcount(threshould,rows,clos,i,j<span class="number">-1</span>,visit,k)||</span><br><span class="line">                movingcount(threshould,rows,clos,i+<span class="number">1</span>,j,visit,k)||</span><br><span class="line">                movingcount(threshould,rows,clos,i,j+<span class="number">1</span>,visit,k)||</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkinto</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;threshould,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">int</span> i,                                 <span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visit,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>&amp;&amp;i&lt;=rows&amp;&amp;j&lt;=clos&amp;&amp;getcountofnumber(i,j)&lt;k&amp;&amp;!visit[i][j])</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcountofnumber</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=i%<span class="number">10</span>;</span><br><span class="line">        i/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">while</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=j%<span class="number">10</span>;</span><br><span class="line">        j/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13、剪绳子（动态规划）"><a href="#13、剪绳子（动态规划）" class="headerlink" title="13、剪绳子（动态规划）"></a>13、剪绳子<span style="color:red">（动态规划）</span></h3><p>给一段长度为n的绳子，把绳子剪成m段（m，n都是整数且n&gt;1,m&gt;1，即至少要剪一次），问每段绳子长度的乘积最大是多少？</p>
<p>1.使用动态规划求解：<br>2.确定子问题:例如绳子的长度为8，那么可以剪成1，7两段，那么此时又要求解长度为7的绳子怎么剪最好。依次类推。<br>3.确定转移方程，设方程f(i)f(i)表示长度为ii的绳子剪成mm段之后的最大的乘积。则<br>$$<br>f(i)=max(f(j)×f(i−j)),0&lt;j&lt;i<br>$$<br>4.为了避免重复计算子问题，我们采用自下而上、从小到大的方式来求解，把先求到的子问题的解储存起来，之后要用到的时候直接进行查表。<br>5.注意边界条件：虽然有f(0)=f(1)=0;f(2)=1;f(3)=2;f(0)=f(1)=0;f(2)=1;f(3)=2;但是在表中存下来却不是这个值，而应该是:p(0)=0;p(1)=1;p(2)=2;p(3)=3;p(0)=0;p(1)=1;p(2)=2;p(3)=3;即在起始条件的时候小问题的最优解并不是我们求解大问题时使用的那个值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Maxlength</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">3</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(i/<span class="number">2</span>);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=dp[j]*dp[i-j];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;temp)</span><br><span class="line">                max=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        dp.pusn_back(max);</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14、二进制中1的个数"><a href="#14、二进制中1的个数" class="headerlink" title="14、二进制中1的个数"></a>14、二进制中1的个数</h3><blockquote>
<p>请实现一个函数，输入是一个整数，输出该数二进制表示中1的个数。例如，把9表示成二进制是1001，有2位是1。因此，如果输入9，则该函数输出为2。</p>
</blockquote>
<p>1.不对数据进行移位，而是移位和数据进行与操作的1。因为移位数据可能会因为符号位而造成死循环<br>2.O(1)的解法。使用公式 </p>
<p>​                                                  n=(n-1)&amp;n</p>
<p>n减去1再和自身进行与操作（&amp;）可以消除一个1。例如10表示成二进制是1010，10减1等于9表示成二进制是1001，两者想与得到1000，和1010比起来正好消去了最低位的1。在把消除为0的过程中这种操作的次数即是1个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Numberfone</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; NumberOf1(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15、数值的整数次方"><a href="#15、数值的整数次方" class="headerlink" title="15、数值的整数次方"></a>15、数值的整数次方</h3><p>实现函数double Power(double base,int exponent),求base的exponent次方。不需要考虑大数问题</p>
<p><strong>1.这个题目看起来很简单，但其实考察的是考虑到边界问题和错误输入</strong><br><strong>2.应该分别分析底数和指数大于0、等于0、小于0的情况</strong></p>
<blockquote>
<p>两种最特殊的情况：<br>1.当底数为0而指数为负数的时候，是错误输入。<br>2.当指数为负数的时候，需要求倒数。</p>
</blockquote>
<p><strong>常规解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断底数是否为0 但是这里的底数是一个double类型的输入 所以不能直接用==判断 需要用其他的技巧</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isZero</span><span class="params">(<span class="keyword">double</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-0.0</span>&lt;<span class="number">0.000000001</span>&amp;&amp;n<span class="number">-0.0</span>&gt;<span class="number">0.000000001</span>)<span class="comment">//小数点后面9位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isZero(base)&amp;&amp;exponent&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//指数小于0的情况是什么养子的</span></span><br><span class="line">    <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        base=<span class="number">1.</span>/base;</span><br><span class="line">        exponen=-exponent;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里是直接相乘的情况</span></span><br><span class="line">    <span class="keyword">while</span>(exponent)</span><br><span class="line">    &#123;</span><br><span class="line">        result*=base;</span><br><span class="line">        exponent--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更加高效的解法</strong></p>
<p><strong>更高效率的方法，即乘法的次数为指数的次数的一半即可，exponent/2</strong> </p>
<p><strong>例如求a的n次方，当n为偶数的时候，</strong><br>$$<br>an=an/2×an/2<br>$$<br><strong>当n为奇数的时候，</strong><br>$$<br>an=a(n−1)/2×a(n−1)/2×a<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;              </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isZero</span><span class="params">(<span class="keyword">double</span> base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((base - <span class="number">0.0</span> &lt; <span class="number">0.000000001</span>) &amp;&amp; (<span class="number">0.0</span> - base &lt; <span class="number">0.000000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isZero(base) &amp;&amp; exponent &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        base = <span class="number">1.</span>/base;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> resu = recursivePower(base,exponent);</span><br><span class="line">    <span class="keyword">return</span> resu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">recursivePower</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>)<span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">double</span> temp=recursivePower(base,exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">double</span> result=temp*temp;</span><br><span class="line">    <span class="keyword">if</span>(exponent&amp;<span class="number">0x01</span>)</span><br><span class="line">        result*=base;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16、打印从1到最大的n位数（有问题）"><a href="#16、打印从1到最大的n位数（有问题）" class="headerlink" title="16、打印从1到最大的n位数（有问题）"></a>16、打印从1到最大的n位数（有问题）</h3><p>输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999</p>
<p><strong>解法1</strong><br>例如输入数字3<br>可以当成排列如下数字：<br>000<br>001<br>002<br>…<br>997<br>998<br>999<br>即打印出数字的全排列。<br>所以可以递归求解</p>
<p><strong>常规解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrinttoMax</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span> * number=<span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number,<span class="string">'0'</span>,n);</span><br><span class="line">    number[n]='/0';</span><br><span class="line">    <span class="keyword">while</span>(!increament(number))</span><br><span class="line">    &#123;</span><br><span class="line">        print(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increament</span><span class="params">(<span class="keyword">char</span> *number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isOverflow=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> nTK=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nlenth=<span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nlength<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17、删除链表的节点"><a href="#17、删除链表的节点" class="headerlink" title="17、删除链表的节点"></a>17、删除链表的节点</h3><p>题目1 ：在O（1）时间内删除链表节点，单向链表，只给一个头结点和一个需要被删除的节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode**head,ListNode*pBedelete)</span></span>;</span><br></pre></td></tr></table></figure>

<p>1 如果按照正常的思路来说，需要遍历一次整个链表，那么这个时候时间复杂度会是O（n），达不到题目需要的要求。</p>
<p>2 我们可以吧需要删除节点的下一个节点的值赋值给当前需要删除的节点，然后需要把需要删除的节点指向下一个节点的下一个节点，最后删除下一个节点，效果等同与删除当前节点。</p>
<p>3 但是，如果需要删除的节点位于链表的最后位置，我们还是需要遍历整个链表。</p>
<p>4 如果删除的节点链表唯一的一个节点，那么我们还需要把整个链表置为nullptr.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode**head,ListNode*pBedelete)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//常规进行非空判断</span></span><br><span class="line">    <span class="keyword">if</span>(!head||!pBedelete)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//正常的删除，非为节点</span></span><br><span class="line">    <span class="keyword">if</span>(pBedelete-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode*pnext=pBedelete-&gt;next;</span><br><span class="line">        pBedelete-&gt;m_nValue=pnext-&gt;m_nValue;</span><br><span class="line">        pBedelete-&gt;next=pnext-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pnext;</span><br><span class="line">        pnext=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表只有一个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*head==pBedelete)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pBedelete;</span><br><span class="line">        pBedelete=<span class="literal">nullptr</span>;</span><br><span class="line">        *head=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       ListNode* pNode=*head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next!=pBedelete)</span><br><span class="line">            &#123;</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head-&gt;next=pBedelete-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> pBedelete;</span><br><span class="line">            pBedelete=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-1删除链表中重复的节点"><a href="#17-1删除链表中重复的节点" class="headerlink" title="17.1删除链表中重复的节点"></a>17.1删除链表中重复的节点</h4><p>在一个排序的链表中，如何删除重复的节点。</p>
<p>1.用tmpNode和current指向头结点，用一个flag标志遇到连续的重复值<br>2.current用来遍历整个链表，在遍历时，每当遇到一个新的值的节点，就用tmpNode指向整个节点<br>3.直到遇到下一个新的值前，current遍历链表，若有相同的值，flag置为false<br>4.遇到下一个新的值时，若flag为true，则tmpNode没有重复；若flag为false，则tmpNode重复了<br>5.遍历结束后还要在判断一次</p>
<p>例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br>1.tmpNode和current指向1<br>2.current遍历到2，flag为true，1则加入新的链表中，tmpNode指向2<br>3.current遍历到3，flag为true，2则加入新的链表中，tmpNode指向3<br>4.current遍历到第二个3，遇到重复值，flag置为false<br>5.current遍历到4，flag为false，3这个节点就不管了，flag重新置为true，tmpNode指向4<br>6.current遍历到第二个4，遇到重复值，flag置为false<br>7.current遍历到5，flag为false，4这个节点就不管了，flag重新置为true，tmpNode指向5<br>8.遍历结束，做最后一次判断，flag为true则将5加入新的链表中（若为false则把最后一个节点的next指向null</p>
<p>​      </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;              </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteDulplication</span><span class="params">(ListNode**phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*phead==<span class="literal">nullptr</span>||head==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ListNode* preNode=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pnextNode=*phead;</span><br><span class="line">    <span class="comment">//进入整个链表的循环</span></span><br><span class="line">    <span class="keyword">while</span>(pnextNode!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* Pnext=pnextNode-&gt;next;<span class="comment">//当前节点的下一个节点</span></span><br><span class="line">        <span class="keyword">bool</span> isDulication=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pnext!=<span class="literal">nullptr</span>&amp;&amp;pnext-&gt;m_nValue==pnextNode-&gt;m_nValue)<span class="comment">//接下来两个节点的值相等？</span></span><br><span class="line">        &#123;</span><br><span class="line">            isDulication=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果接下来的链表的节点不是相同的</span></span><br><span class="line">        <span class="keyword">if</span>(!isDulication)</span><br><span class="line">        &#123;</span><br><span class="line">            preNode=pnextNode;</span><br><span class="line">            pnextNode=pnextNode-&gt;next;<span class="comment">//指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果接下来链表节点是相同的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> value=pnextNode-&gt;m_nValue;</span><br><span class="line">            ListNode* Bedelete=pnextNode;</span><br><span class="line">            <span class="keyword">while</span>(!Bedelete=<span class="literal">nullptr</span>&amp;&amp;Bedelete-&gt;m_nValue==value)</span><br><span class="line">            &#123;</span><br><span class="line">                Pnext=Bedelete-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> Bedelete;</span><br><span class="line">                Bedelete=<span class="literal">nullptr</span>;</span><br><span class="line">                Bedelete=Pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(preNode==<span class="literal">nullptr</span>)</span><br><span class="line">                *head=Pnext;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                preNode-&gt;next=Pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            pnextNode=Pnext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18、-正则表达式匹配"><a href="#18、-正则表达式匹配" class="headerlink" title="18、 正则表达式匹配"></a>18、 正则表达式匹配</h3><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符（指紧挨着的字符）可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>1、考虑特殊情况，当str和pattern都是空字符串时，匹配，返回true</p>
<p>​       当str不为空并且<em>pattern</em>为空时，一定不匹配，返回false（str为空，pattern不为空，有可能匹配）</p>
<p>2、考虑每次递归时的第二个字符是否是‘*’</p>
<p>​             当<em>（pattern+1）！=‘*’</em>‘’时，如果当前字符与模式字符相等(包括’.’），那么接着往下判断</p>
<p>​                                                            如果当前字符与模式字符不相等，直接不匹配，返回false</p>
<p>​             当<em>（pattern+1）==‘*’</em>‘’时，  如果当前字符与模式字符相等，那么考虑两种情况</p>
<p>​                                                             情况一：abc和模式ab*bc,当前字符匹配，模式的后面的字符还与其匹配</p>
<p>​                                                             情况二：abbc和模式ab*c，当前匹配，字符串的下一个字符还与其匹配</p>
<p>​                                                             如果当前字符与模式字符，字符串位置不变，模式后移两位，继续判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>*str,<span class="keyword">char</span>*pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(*str!=<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>)!=<span class="string">'*'</span>)<span class="comment">//如果下一个字符不是'*'</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str==*pattern||*str!=<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>,pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>)==<span class="string">'*'</span>)<span class="comment">//如果下一个是'*'</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str==*pattern||*str!=<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">return</span> match(str,pattern+<span class="number">2</span>)||match(str+<span class="number">1</span>, pattern);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> match(str,pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="20、表示数值的字符串"><a href="#20、表示数值的字符串" class="headerlink" title="20、表示数值的字符串"></a>20、表示数值的字符串</h3><h3 id="21、调整数组顺序使得奇数位于偶数前"><a href="#21、调整数组顺序使得奇数位于偶数前" class="headerlink" title="21、调整数组顺序使得奇数位于偶数前"></a>21、调整数组顺序使得奇数位于偶数前</h3><blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<p>  思路：</p>
<p>感觉这道题并没有比较完美的解法，要么时间复杂度高，要么空间复杂度高</p>
<ul>
<li><p>解法1：</p>
<p>遍历数组，将所有奇数前移，将所有偶数保存在队列里，并统计奇数个数</p>
<p>将队列里的偶数再放到数组中</p>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
</li>
<li><p>解法2：</p>
</li>
</ul>
<p>​        用i表示第一个偶数的下标，j表示i后面第一个奇数的下标（i，j初始化都为-1）</p>
<p>​        当找到符合的i,j时，将下标为[i,j)的值向后移一位（这个范围内都是偶数），</p>
<p>​       将原本下标为i的偶数替换为原本下标为j的奇数</p>
<p>​       最坏时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>*<em>使用解法1  *</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deueu&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven</span><span class="params">(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    deueu&lt;<span class="keyword">int</span>&gt;de;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pData[i]&amp;<span class="number">0x01</span>)==<span class="number">1</span>)</span><br><span class="line">            PData[index]=pData[i]</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             de.push_back(pData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index!=length&amp;&amp;!de.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pData[index++]=de.top();</span><br><span class="line">        de.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用解法2  维护两个指针 一前一后</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven</span><span class="params">(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> *begin=pData;</span><br><span class="line">    <span class="keyword">int</span> *end=pData+length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;(*begin&amp;<span class="number">0x1</span>)!=<span class="number">0</span>)</span><br><span class="line">            begin+;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;(*begin&amp;<span class="number">0x1</span>)==<span class="number">0</span>)</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=*end;</span><br><span class="line">            *begin=*end;</span><br><span class="line">            *end=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以扩展写法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reorder</span><span class="params">(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length,<span class="keyword">bool</span>(*fun)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(pData==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> *begin=pData;</span><br><span class="line">    <span class="keyword">int</span> *end=pData+length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;!func(*begin))</span><br><span class="line">            begin+;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;func(*end)</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=*end;</span><br><span class="line">            *begin=*end;</span><br><span class="line">            *end=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line"><span class="keyword">bool</span> isEven(<span class="keyword">int</span> n)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> (n&amp;<span class="number">1</span>)==<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">void</span> ReorderOddEven(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    Reorder(Pdata,length,isEven)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22、链表中的倒数第k个节点"><a href="#22、链表中的倒数第k个节点" class="headerlink" title="22、链表中的倒数第k个节点"></a>22、链表中的倒数第k个节点</h3><p>输入一个链表，输出该链表中倒数第k个节点。<br>为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。<br>例如，一个链表有6个节点，从头结点开始，它们的值以此是1、2、3、4、5、6。<br>这个链表的倒数第3个节点是值为4的节点。</p>
<p>方法1</p>
<p>定义两个节点node1，node2<br>让node1一开始指向第k个节点，node2指向第1个节点<br>此时node1和node2同时前进，[node1, node2]区间一共有k个节点<br>当node1指向最后一个节点时，node2即指向倒数第k个节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode * next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode*<span class="title">FindToNode</span><span class="params">(ListNode*phead,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||k&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* node1=phead;</span><br><span class="line">    ListNode* node2=phead;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node1=node1-&gt;next;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(node1==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node1!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node1=node1-&gt;next;</span><br><span class="line">        node2=node2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23、链表中环的入口节点（难点）"><a href="#23、链表中环的入口节点（难点）" class="headerlink" title="23、链表中环的入口节点（难点）"></a>23、链表中环的入口节点（难点）</h3><p>一个链表中包含环，请找出该链表的环的入口节点。</p>
<p>1.判断整个链表中有没有环的存在？</p>
<p>​    这里可以用一个快指针和一个满指针完成，如果到最后慢指针追上了快指针就表示有环的存在</p>
<p>2.怎么找到环的入口？</p>
<p>   这里还是用一个快指针和一个慢指针完成，假设这个环中有n个节点，让快指针前进n步，然后让慢指针往和快指针一起前进，一直到他们相遇，此时相遇的节点就是环的入口了。</p>
<p>3，怎么确定链表中有多少个环？</p>
<p>  假如在第一步中，快指针和慢指针相遇，那么肯定是在环里面相遇的，然后在让快慢指针一边向前走，一边计数，当指针回到原点，就可以得到环中的节点数了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">MeetNode</span><span class="params">(ListNode*phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode*slow=phead-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(slow==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     ListNode*Fast=slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span>&amp;&amp;Fast!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(slow==Fast)</span><br><span class="line">            <span class="keyword">return</span> Fast;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        Fast=slow-&gt;next;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode*<span class="title">EntryNodeOfLoop</span><span class="params">(ListNode*phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到相遇的节点</span></span><br><span class="line">    ListNode* meetNdoe=MeetNode(phead);</span><br><span class="line">    <span class="keyword">if</span>(meetNdoe==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">   <span class="comment">//找出环的个数</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    ListNode* tempNode=meetNdoe</span><br><span class="line">    <span class="keyword">while</span>(tempNode-&gt;next!=meetNdoe)</span><br><span class="line">    &#123;</span><br><span class="line">        tempNode=tempNode-&gt;next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找出了环的个数后 先移动快指针k步</span></span><br><span class="line">    ListNode*Fast=phead;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Fast=Fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">     ListNode*slow=phead;</span><br><span class="line">    <span class="comment">//快指针和慢指针一起向前移动</span></span><br><span class="line">    <span class="keyword">while</span>(slow!=Fast)</span><br><span class="line">    &#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        Fast=Fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24、反转链表"><a href="#24、反转链表" class="headerlink" title="24、反转链表"></a>24、反转链表</h3><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p>
<p>1.输入的链表头指针为null<br>2.输入的链表只有一个节点<br>3.输入的链表有多个节点（正常情况）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode*<span class="title">ReverseList</span><span class="params">(ListNode*phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(phead-&gt;next==null)</span><br><span class="line">        <span class="keyword">return</span> phead;</span><br><span class="line">    ListNdoe*Preversehead=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNdoe*pNode=phead;</span><br><span class="line">    ListNdoe*preNode=<span class="literal">nullptr</span>;</span><br><span class="line">   <span class="keyword">while</span>(pNode!=<span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       ListNode*Next=pNode-&gt;next;</span><br><span class="line">       <span class="keyword">if</span>(Next==<span class="literal">nullptr</span>)</span><br><span class="line">           Preversehead=pNode;</span><br><span class="line">       pNode-&gt;next=preNode;</span><br><span class="line">       preNode=pNode;</span><br><span class="line">       pNode=Next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用递归实现反转链表</p>
<h3 id="25、合并两个排序的链表"><a href="#25、合并两个排序的链表" class="headerlink" title="25、合并两个排序的链表"></a>25、合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。<br>例如：<br>链表1：1-&gt;3-&gt;5-&gt;7<br>链表2：2-&gt;4-&gt;6-&gt;8<br>合并后：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</p>
<p>很简单 注意边界问题就好了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode*next;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function">ListNode*<span class="title">Merge</span><span class="params">(ListNode* phead1,ListNode*phead2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(phead1==<span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span> phead2;</span><br><span class="line">     <span class="keyword">if</span>(phead2==<span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span> phead1;</span><br><span class="line">     ListNode*MergeHead=<span class="literal">nullptr</span>;</span><br><span class="line">     <span class="keyword">if</span>(phead1-&gt;val&lt;phead2-&gt;val)</span><br><span class="line">     &#123;</span><br><span class="line">         MergeHead=head1;</span><br><span class="line">         MergeHead-&gt;next=Merge(phead1-&gt;next,phead2);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         MergeHead=head2;</span><br><span class="line">         MergeHead-&gt;next=Merge(phead1,phead2-&gt;next);       </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> MergeHead;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>扩展 vector&lt;ListNode*&gt;vec;里面有n个链表，并且已经排好序，请将这里的链表完全排序</p>
<h3 id="26、树的子结构"><a href="#26、树的子结构" class="headerlink" title="26、树的子结构"></a>26、树的子结构</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。<br>（ps：我们约定空树不是任意一个树的子结构）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 直接递归的版本 */</span></span><br><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSubtree</span><span class="params">(BinaryTreeNode*root1,BinaryTreeNode*root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root1=<span class="literal">nullptr</span>&amp;&amp;!root2=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Equal(root1-&gt;val,root2-&gt;val))</span><br><span class="line">        &#123;</span><br><span class="line">            result=DoesSimTree(root1,root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">            result=hasSubtree(root1-&gt;left,root2);</span><br><span class="line">        <span class="keyword">if</span>(!resuklt)</span><br><span class="line">            result=hasSubtree(root1,root2-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Equal</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a-b&gt;<span class="number">0.00000001</span>)&amp;&amp;(a-b&lt;<span class="number">0.00000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DoesSimTree</span><span class="params">(BinaryTreeNode*root1,BinaryTreeNode*root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root1==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!Equal(root1-&gt;val,root2-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> DoesSimTree(root1-&gt;left,root2-&gt;left)&amp;&amp;DoesSimTree(root1-&gt;right,root2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27、二叉树的镜像"><a href="#27、二叉树的镜像" class="headerlink" title="27、二叉树的镜像"></a>27、二叉树的镜像</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>求一棵树的镜像的过程：先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当交换完所有的左右子节点之后，就得到了树的镜像。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BianryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BianryTreeNode* left;</span><br><span class="line">    BianryTreeNode* right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BianryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BianryTreeNode* left;</span><br><span class="line">    BianryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MirrorRecursively</span><span class="params">(BianryTreeNode * proot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;left==<span class="literal">nullptr</span>&amp;&amp;proot-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BianryTreeNode* temp=proot-&gt;left;</span><br><span class="line">    proot-&gt;left=proot-&gt;right;</span><br><span class="line">    proot-&gt;right=temp;</span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MirrorRecursively(proot-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MirrorRecursively(proot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28、对称的二叉树"><a href="#28、对称的二叉树" class="headerlink" title="28、对称的二叉树"></a>28、对称的二叉树</h3><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>从根节点的左右两个子节点出发</p>
<ul>
<li>左子节点采用 根左右 的方式遍历</li>
<li>右子节点采用 左根右 的方式遍历</li>
<li>每遍历一次就进行比较，一旦出现不同的值就表示不是对称的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BianryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BianryTreeNode* left;</span><br><span class="line">    BianryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">issymmetrytree</span><span class="params">(BianryTreeNode* proot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> issymmetrytree(proot,proot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">issymmetrytree</span><span class="params">(BianryTreeNode* proot1,BianryTreeNode* proot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot1==<span class="literal">nullptr</span>&amp;&amp;proot2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(proot1==<span class="literal">nullptr</span>||proot2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(proot1-&gt;val!=proot2-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> issymmetrytree(proot1-&gt;left,proot2-&gt;right)&amp;&amp; issymmetrytree(proot2&gt;left,proot1&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29、顺时针打印矩阵"><a href="#29、顺时针打印矩阵" class="headerlink" title="29、顺时针打印矩阵"></a>29、顺时针打印矩阵</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，<br>例如，如果输入如下矩阵：<br>1 2 3 4<br>5 6 7 8<br>9 10 11 12<br>13 14 15 16<br>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>从外到里 一次打印 但是要注意到边界条件 防止打印的时候越界了 第一次打印的起来是（0.0）第二次打印的起点是（1,1） 选取起点坐标作为分析的依据</p>
<p>得出一个循环的条件<br>$$<br>columns&gt;startX * 2  并且rows&gt;startY * 2<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printarray</span><span class="params">(<span class="keyword">int</span> **number,<span class="keyword">int</span> columns,<span class="keyword">int</span> rows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="literal">nullptr</span>||columns&lt;=<span class="number">0</span>||rows&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(columns&gt;start*<span class="number">2</span>&amp;&amp;rows&gt;start*<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Printarray(number,columns,rows,start);</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printarray</span><span class="params">(<span class="keyword">int</span> **number,<span class="keyword">int</span> columns,<span class="keyword">int</span> rows,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endX=columns<span class="number">-1</span>-start;</span><br><span class="line">    <span class="keyword">int</span> endY=rows<span class="number">-1</span>-start;</span><br><span class="line">    <span class="comment">//从左往右打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=endX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Print(number[start][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从上到下打印一列</span></span><br><span class="line">   <span class="keyword">if</span>(start&lt;endY)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=endY;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           Print(number[i][endY])</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;endX&amp;&amp;start&lt;endX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="30、包含min函数的栈"><a href="#30、包含min函数的栈" class="headerlink" title="30、包含min函数的栈"></a>30、包含min函数的栈</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<p>定义两个栈，一个栈保存数据，另一个保存新数据入栈后的最小数<br>pop时，两个栈都要pop;<br>则minstack()的栈顶即为最小元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sulotion</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;minstack;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;mystack;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mystack.push(value);</span><br><span class="line">        <span class="keyword">if</span>(!minstack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">          minstack.push(<span class="built_in">std</span>::min(minstack.top(),value));  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          minstack.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        minstack.pop();</span><br><span class="line">        mystack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mystack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用两个vector实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        mystack.push_back(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minstack.empty())</span><br><span class="line">            minstack.push_back(value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value&lt;minstack.back())</span><br><span class="line">            minstack.push_back(value);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            minstack.push_back(minstack.back());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mystack.pop_back();</span><br><span class="line">        minstack.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mystack.back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minstack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="31、栈的压入、弹出序列-没看"><a href="#31、栈的压入、弹出序列-没看" class="headerlink" title="31、栈的压入、弹出序列(没看)"></a>31、栈的压入、弹出序列(没看)</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>这道题思路还是挺简单的<br>用一个辅助栈来解决，把压入序列的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。</p>
<p>例：<br>压入序列：1,2,3,4,5<br>弹出序列：4,5,3,2,1<br>将压入序列的元素依次压入辅助栈，直到栈顶为弹出序列的首个元素，即：<br>压入1，1不等于4（弹出序列首个元素）；<br>继续压入2，2不等于4；<br>继续压入3，3不等于4；<br>继续压入4；<br>此时4等于弹出序列的首个元素，将4弹出。<br>此时栈顶3不等于5（弹出序列的第二个元素），继续压入5；<br>此时5等于弹出序列的第二个元素，将5弹出。<br>此时3等于弹出序列的第三个元素，将3弹出。<br>此时2等于弹出序列的第四个元素，将2弹出。<br>此时1等于弹出序列的第五个元素，将1弹出。<br>此时压入序列遍历完毕，弹出序列也遍历完毕，栈为空，所以该弹出序列和该压入序列是匹配的。<br>————————————————</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">const</span> *<span class="keyword">int</span> Ppush,<span class="keyword">const</span> *<span class="keyword">int</span> pPop,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bossible=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(Ppush!=<span class="literal">nullptr</span>&amp;&amp;pPop!=<span class="literal">nullptr</span>&amp;&amp;length&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>*pNextPush=Ppush;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>*pNextPop=pPop;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;data;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="32、从上往下不分行打印二叉树"><a href="#32、从上往下不分行打印二叉树" class="headerlink" title="32、从上往下不分行打印二叉树"></a>32、从上往下不分行打印二叉树</h3><h4 id="1-从上往下打印出二叉树的每个节点，同层节点从左至右打印"><a href="#1-从上往下打印出二叉树的每个节点，同层节点从左至右打印" class="headerlink" title="1.从上往下打印出二叉树的每个节点，同层节点从左至右打印"></a>1.从上往下打印出二叉树的每个节点，同层节点从左至右打印</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printtreeone</span><span class="params">(BinaryTreeNode*ptreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptreeRoot==null)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>:<span class="built_in">deque</span>&lt;BinaryTreeNode*&gt;De;</span><br><span class="line">    De.push_back(BinaryTreeNode*ptreeRoot);</span><br><span class="line">    <span class="keyword">while</span>(De.size())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* Node=De.front();</span><br><span class="line">        De.pop_front();</span><br><span class="line">        print(Node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;left)</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;right)</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-分行从上到下打印二叉树-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行"><a href="#2-分行从上到下打印二叉树-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行" class="headerlink" title="2 分行从上到下打印二叉树 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行"></a>2 分行从上到下打印二叉树 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printtreetwo</span><span class="params">(BinaryTreeNode*ptreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptreeRoot==null)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>:<span class="built_in">deque</span>&lt;BinaryTreeNode*&gt;De;</span><br><span class="line">    <span class="keyword">int</span> TobePrint=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextNode=<span class="number">0</span>;</span><br><span class="line">    De.push_back(BinaryTreeNode*ptreeRoot);</span><br><span class="line">    <span class="keyword">while</span>(De.size())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* Node=De.front();</span><br><span class="line">        De.pop_front();</span><br><span class="line">        print(Node-&gt;val);</span><br><span class="line">        TobePrint--;</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;left);</span><br><span class="line">            nextNode++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;right!=<span class="literal">nullptr</span>);</span><br><span class="line">            nextNode++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(TobePrint==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(‘换行’);</span><br><span class="line">            TobePrint=nextNode;</span><br><span class="line">            nextNode=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、之字形打印二叉树"><a href="#3、之字形打印二叉树" class="headerlink" title="3、之字形打印二叉树"></a>3、之字形打印二叉树</h3><h4 id="3-请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推"><a href="#3-请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推" class="headerlink" title="3 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推"></a>3 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推</h4><p> 两个栈保存，交替打印</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printtreethree</span><span class="params">(BinaryTreeNode*ptreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(ptreeRoot==<span class="literal">nullptr</span>)</span><br><span class="line">       <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">deque</span>&lt;BinaryTreeNode*&gt;De[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> curr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next=<span class="number">1</span>;</span><br><span class="line">    De[curr].push(ptreeRoot);</span><br><span class="line">    <span class="keyword">while</span>(!De[<span class="number">0</span>].empty()||!De[<span class="number">1</span>].empty())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* Node=De[curr].top();</span><br><span class="line">        Print(Ndoe-&gt;val);</span><br><span class="line">        De[curr].pop();</span><br><span class="line">        <span class="keyword">if</span>(curr==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Ndoe-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Ndoe-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">if</span>(Ndoe-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">              <span class="keyword">if</span>(Ndoe-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(De[curr].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            print('换行');</span><br><span class="line">            curr=<span class="number">1</span>-curr;</span><br><span class="line">            next=<span class="number">1</span>-next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33、二叉搜索树的后序遍历序列"><a href="#33、二叉搜索树的后序遍历序列" class="headerlink" title="33、二叉搜索树的后序遍历序列"></a>33、二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历结果。<br>如果是则返回true，否则返回false。<br>假设输入的数组的任意两个数字互不相同。</p>
<p>输入数组{5, 7, 6, 9, 11, 10, 8}，则返回true，<br>因为这个整数序列是下面这个二叉搜索树的后序遍历结果。<br>如果输入的数组是{7, 4, 6, 5}，则由于没有<br>哪棵二叉搜索树的后序遍历结果是这个序列，因此返回false。<br>8<br>/ <br>6 10<br>/ \ / <br>5 7 9 1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isafterlist</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> root=data[length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(data[i]&gt;root);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">int</span> j=i;</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[j]&lt;root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> left=<span class="literal">true</span>;</span><br><span class="line">    left=isafterlist(data,i);</span><br><span class="line">    <span class="keyword">bool</span> right=<span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(i&lt;length<span class="number">-1</span>)</span><br><span class="line">        right=isafterlist(data+i,length-i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (left&amp;&amp;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    .content-wrap {
  opacity: 0.0;
}


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/Moonstar-Z.github.io/tags/剑指offer/" rel="tag"># 剑指offer</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Moonstar-Z.github.io/2019/09/12/C++基础/基础知识总结/" rel="prev" title="C++基础">
      <i class="fa fa-chevron-left"></i> C++基础
    </a></div>
      <div class="post-nav-item">
    <a href="/Moonstar-Z.github.io/2019/09/12/面试/剑指offer/剑指offer题目二刷/" rel="next" title="剑指Offer题目知识点（二刷）{33-----66题}">
      剑指Offer题目知识点（二刷）{33-----66题} <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、赋值运算符"><span class="nav-number">1.</span> <span class="nav-text">1、赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、数组中的重复数字"><span class="nav-number">2.</span> <span class="nav-text">2、数组中的重复数字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1扩展的问题"><span class="nav-number">2.1.</span> <span class="nav-text">2.1扩展的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3，二维数组中的查找"><span class="nav-number">3.</span> <span class="nav-text">3，二维数组中的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、替换空格"><span class="nav-number">4.</span> <span class="nav-text">4、替换空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、从尾到头打印链表"><span class="nav-number">5.</span> <span class="nav-text">5、从尾到头打印链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、重建二叉树"><span class="nav-number">6.</span> <span class="nav-text">6、重建二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、二叉树的下一个节点"><span class="nav-number">7.</span> <span class="nav-text">7、二叉树的下一个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、用两个栈实现队列"><span class="nav-number">8.</span> <span class="nav-text">8、用两个栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1两个队列实现一个栈"><span class="nav-number">8.1.</span> <span class="nav-text">8.1两个队列实现一个栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、斐波那契数列"><span class="nav-number">9.</span> <span class="nav-text">9、斐波那契数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、旋转数组的最小数字"><span class="nav-number">10.</span> <span class="nav-text">10、旋转数组的最小数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、矩阵中的路径"><span class="nav-number">11.</span> <span class="nav-text">11、矩阵中的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、机器人的运动范围"><span class="nav-number">12.</span> <span class="nav-text">12、机器人的运动范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、剪绳子（动态规划）"><span class="nav-number">13.</span> <span class="nav-text">13、剪绳子（动态规划）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14、二进制中1的个数"><span class="nav-number">14.</span> <span class="nav-text">14、二进制中1的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15、数值的整数次方"><span class="nav-number">15.</span> <span class="nav-text">15、数值的整数次方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16、打印从1到最大的n位数（有问题）"><span class="nav-number">16.</span> <span class="nav-text">16、打印从1到最大的n位数（有问题）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17、删除链表的节点"><span class="nav-number">17.</span> <span class="nav-text">17、删除链表的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#17-1删除链表中重复的节点"><span class="nav-number">17.1.</span> <span class="nav-text">17.1删除链表中重复的节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18、-正则表达式匹配"><span class="nav-number">18.</span> <span class="nav-text">18、 正则表达式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">19.</span> <span class="nav-text"> </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20、表示数值的字符串"><span class="nav-number">20.</span> <span class="nav-text">20、表示数值的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21、调整数组顺序使得奇数位于偶数前"><span class="nav-number">21.</span> <span class="nav-text">21、调整数组顺序使得奇数位于偶数前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22、链表中的倒数第k个节点"><span class="nav-number">22.</span> <span class="nav-text">22、链表中的倒数第k个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23、链表中环的入口节点（难点）"><span class="nav-number">23.</span> <span class="nav-text">23、链表中环的入口节点（难点）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24、反转链表"><span class="nav-number">24.</span> <span class="nav-text">24、反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25、合并两个排序的链表"><span class="nav-number">25.</span> <span class="nav-text">25、合并两个排序的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26、树的子结构"><span class="nav-number">26.</span> <span class="nav-text">26、树的子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27、二叉树的镜像"><span class="nav-number">27.</span> <span class="nav-text">27、二叉树的镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28、对称的二叉树"><span class="nav-number">28.</span> <span class="nav-text">28、对称的二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29、顺时针打印矩阵"><span class="nav-number">29.</span> <span class="nav-text">29、顺时针打印矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30、包含min函数的栈"><span class="nav-number">30.</span> <span class="nav-text">30、包含min函数的栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31、栈的压入、弹出序列-没看"><span class="nav-number">31.</span> <span class="nav-text">31、栈的压入、弹出序列(没看)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32、从上往下不分行打印二叉树"><span class="nav-number">32.</span> <span class="nav-text">32、从上往下不分行打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-从上往下打印出二叉树的每个节点，同层节点从左至右打印"><span class="nav-number">32.1.</span> <span class="nav-text">1.从上往下打印出二叉树的每个节点，同层节点从左至右打印</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-分行从上到下打印二叉树-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行"><span class="nav-number">32.2.</span> <span class="nav-text">2 分行从上到下打印二叉树 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、之字形打印二叉树"><span class="nav-number">33.</span> <span class="nav-text">3、之字形打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推"><span class="nav-number">33.1.</span> <span class="nav-text">3 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33、二叉搜索树的后序遍历序列"><span class="nav-number">34.</span> <span class="nav-text">33、二叉搜索树的后序遍历序列</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">苍山负雪</p>
  <div class="site-description" itemprop="description">三十功名尘与土，八千里路云和月。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Moonstar-Z.github.io/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Moonstar-Z.github.io/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/Moonstar-Z.github.io/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/COTVZHAOYUEXING" title="GitHub → https://github.com/COTVZHAOYUEXING" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1998lovexs@gmail.com" title="E-Mail → mailto:1998lovexs@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍山负雪</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Moonstar-Z.github.io/lib/anime.min.js"></script>
  <script src="/Moonstar-Z.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/Moonstar-Z.github.io/lib/velocity/velocity.ui.min.js"></script>
<script src="/Moonstar-Z.github.io/js/utils.js"></script><script src="/Moonstar-Z.github.io/js/motion.js"></script>
<script src="/Moonstar-Z.github.io/js/schemes/muse.js"></script>
<script src="/Moonstar-Z.github.io/js/next-boot.js"></script>



  















  

  

  

</body>
</html>
