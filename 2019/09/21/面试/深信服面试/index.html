<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">

<!-- jquery -->

<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/Moonstar-Z.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Moonstar-Z.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Moonstar-Z.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Moonstar-Z.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Moonstar-Z.github.io/css/main.css">


<link rel="stylesheet" href="/Moonstar-Z.github.io/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/Moonstar-Z.github.io/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1 、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？答案：因为在实际问题中，一组数据往往有很多种不同的数据类型，例如，登记学生的信息，可能需要用到 char型的姓名，int型或 char型的学号，int型的年龄，char型的性别，float型的成绩。又例如，对于记录一本书，需要 char型的书名，char型的作者名，float型的价格。在这些情况下，使用简单的基本数据类型甚">
<meta name="keywords" content="面试">
<meta property="og:type" content="article">
<meta property="og:title" content="面试总结-深信服">
<meta property="og:url" content="https://yoursite.com/2019/09/21/面试/深信服面试/index.html">
<meta property="og:site_name" content="苍山负雪">
<meta property="og:description" content="1 、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？答案：因为在实际问题中，一组数据往往有很多种不同的数据类型，例如，登记学生的信息，可能需要用到 char型的姓名，int型或 char型的学号，int型的年龄，char型的性别，float型的成绩。又例如，对于记录一本书，需要 char型的书名，char型的作者名，float型的价格。在这些情况下，使用简单的基本数据类型甚">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdn.net/201808241009396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NreVNvbmdrcmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180425152114637?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NDk4MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20141120150231808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZV9nYW9oeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20141120144640019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZV9nYW9oeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20141120145439174?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZV9nYW9oeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2310756-67a4ff2b53385008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/455/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2310756-3b1e7fc263f0642a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/446/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2310756-3e2d70fcfe123989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/876/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2310756-a20552080cd50a24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/900/format/webp">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000007977465">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000007977466">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000007977467">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000007977468">
<meta property="og:image" content="https://s4.51cto.com/wyfs02/M02/08/26/wKiom1nc7JDyv9AjAAAskULi-o0043.png">
<meta property="og:image" content="https://s1.51cto.com/wyfs02/M02/08/26/wKiom1nc7M-AgBFmAAEDKBEgcRo105.png">
<meta property="og:image" content="https://img-blog.csdn.net/20160708110724036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f63b5392d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f6398efd6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f63ab4ba7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f63a8839a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f7b5e35f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f7c00aa05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f7d503df1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://yoursite.com/Moonstar-Z.github.io/.com//C:%5CUsers%5CCCTVZYX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568838258773.png">
<meta property="og:image" content="https://yoursite.com/Moonstar-Z.github.io/.com//C:%5CUsers%5CCCTVZYX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568838315710.png">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-49e0d29ba45efa4d359681c647063e5a_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-4f5057199f22b90350bd748e89453b1b_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-0b8e3969800ba34c819104ea153543e6_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-e3e36c9b14933b7b6825afc260170bb3_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-2cd162d5f176bb06233ec3159aa0f448_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-4a0e2948e47c619bc10c4ceb5119db88_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-c804d66ee794fdd113a7cdd003db6f8a_hd.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20180421153546225">
<meta property="og:updated_time" content="2020-03-17T05:38:49.506Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试总结-深信服">
<meta name="twitter:description" content="1 、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？答案：因为在实际问题中，一组数据往往有很多种不同的数据类型，例如，登记学生的信息，可能需要用到 char型的姓名，int型或 char型的学号，int型的年龄，char型的性别，float型的成绩。又例如，对于记录一本书，需要 char型的书名，char型的作者名，float型的价格。在这些情况下，使用简单的基本数据类型甚">
<meta name="twitter:image" content="https://img-blog.csdn.net/201808241009396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NreVNvbmdrcmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">

<link rel="canonical" href="https://yoursite.com/2019/09/21/面试/深信服面试/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>
<!-- 打字礼花及震动特效 -->

<div id="append_parent"></div><div id="ajaxwaitid"></div>
<script type="text/javascript" src="/lib/activate-power-mode/activate-power-mode.js"></script>
<script>
	POWERMODE.colorful = true;
	POWERMODE.shake = false;
	document.body.addEventListener('input',POWERMODE);
</script>

<!-- jquery -->

<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <title>面试总结-深信服 | 苍山负雪</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/Moonstar-Z.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苍山负雪</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/Moonstar-Z.github.io/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/Moonstar-Z.github.io/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/Moonstar-Z.github.io/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Moonstar-Z.github.io/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/09/21/面试/深信服面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Moonstar-Z.github.io/images/avatar.gif">
      <meta itemprop="name" content="苍山负雪">
      <meta itemprop="description" content="三十功名尘与土，八千里路云和月。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍山负雪">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试总结-深信服
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-21 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-21T00:00:00+08:00">2019-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-17 13:38:49" itemprop="dateModified" datetime="2020-03-17T13:38:49+08:00">2020-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Moonstar-Z.github.io/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h6 id="1-、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？"><a href="#1-、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？" class="headerlink" title="1 、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？"></a>1 、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？</h6><p><strong><em>答案：因为在实际问题中，一组数据往往有很多种不同的数据类型，例如，登记学生的信息，可能需要用到 char型的姓名，int型或 char型的学号，int型的年龄，char型的性别，float型的成绩。又例如，对于记录一本书，需要 char型的书名，char型的作者名，float型的价格。在这些情况下，使用简单的基本数据类型甚至是数组都是很困难的。而结构体（类似Pascal中的“记录”），则可以有效的解决这个问题。<br>结构体本质上还是一种数据类型，但它可以包括若干个“成员”，每个成员的类型可以相同也可以不同，也可以是基本数据类型或者又是一个构造类型。</em></strong></p>
<a id="more"></a>

<hr>
<h6 id="2、联合体和结构体的区别，变长结构体的实现。"><a href="#2、联合体和结构体的区别，变长结构体的实现。" class="headerlink" title="2、联合体和结构体的区别，变长结构体的实现。"></a>2、联合体和结构体的区别，变长结构体的实现。</h6><p><strong>联合体</strong>：</p>
<ol>
<li><p>在联合体abc中，整型量i和字符m公用同一内存位置。</p>
</li>
<li><p>当一个联合被说明时，编译程序自动地产生一个变量，其长度为联合中最大的变量长度。、</p>
</li>
<li><p>联合体变量所占内存长度是各最长的成员占的内存长度。</p>
</li>
<li><p>联合体变量中起作用的成员是最后一次存放的成员，在存入新的成员后原有的成员失去了作用！</p>
</li>
</ol>
<p>用途：使几个不同类型的变量共占一段内存<em>(</em>相互覆盖<em>)</em></p>
<p><strong>结构体</strong>是一种构造数据类型</p>
<p>结构体变量所占内存长度是各成员占的内存长度的总和。</p>
<p>用途：把不同类型的数据组合成一个整体<em>——-</em>自定义数据类型</p>
<p><em>1. struct<em>和</em>union*都是由多个不同的数据类型成员组成</em>,* 但在任何同一时刻<em>, union*中只存放了一个被选中的成员</em>,* 而<em>struct</em>的所有成员都存在。在<em>struct</em>中，各成员都占有自己的内存空间，它们是同时存在的。一个<em>struct</em>变量的总长度等于所有成员长度之和。在<em>Union</em>中，所有成员不能同时占用它的内存空间，它们不能同时存在。<em>Union</em>变量的长度等于最长的成员的长度。</p>
<p><em>2.</em> 对于<em>union*的不同成员赋值</em>,* 将会对其它成员重写<em>,</em> 原来成员的值就不存在了<em>,</em> 而对于<em>struct</em>的不同成员赋值是互不影响的。</p>
<p><strong>变长结构体的实现</strong></p>
<p>为什么会有变长结构体?</p>
<p> 项目中用到数据包的处理，但包的大小是不固定的，其长度由包头的2字节决定。比如如下的包头：88 0f 0a ob cd ef 23 00 。长度由头2个字节880f决定，考虑字节序，转为0f88，转为10进制3976个字节的包长度。</p>
<p>​    这个时候存储包的时候，一方面可以考虑设定包的大小固定：如4K=4*1024=4096个字节，因为最大包长不可能超过4k，但该方法的有缺陷，存在一种极端就是包最小仅含包头不含数据域，此时包为8个字节，浪费了4096-8 =4088个字节的存储空间。另一方面考虑有没有一种方法能根据长度进行存储，或者说初始不分配长度，计算出了长度后再分配存储呢。而实际项目中正是通过包头计算出了包的整体大小的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Var_Len_Struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> nsize;</span><br><span class="line">     <span class="keyword">char</span> buffer[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面是为什么要用数组，而不是指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">0</span>];</span><br><span class="line">&#125;Empty;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> *y;</span><br><span class="line">&#125;Ptr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//变长结构体申请内存</span></span><br><span class="line">    Empty *p_array = (Empty *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Empty) + <span class="number">100</span>);  <span class="comment">//可以看到这里直接申请了变长结     构体大小的空间再加100字节,这100字节就相当于是给char b[0]用的了</span></span><br><span class="line">    <span class="comment">//常规方式申请内存,先申请结构体的,再申请指针的</span></span><br><span class="line">    Ptr *p_ptr = (Ptr *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Ptr));</span><br><span class="line">    p_ptr-&gt;y = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//初始化malloc申请的内存</span></span><br><span class="line">    <span class="built_in">memset</span>(p_array, <span class="number">0</span>, <span class="keyword">sizeof</span>(p_array));</span><br><span class="line">    <span class="built_in">memset</span>(p_ptr, <span class="number">0</span>, <span class="keyword">sizeof</span>(p_ptr));</span><br><span class="line">    <span class="built_in">memset</span>(p_ptr-&gt;y, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝字符串并输出</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p_array-&gt;b, <span class="string">"test"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p_ptr-&gt;y, <span class="string">"test"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p_array-&gt;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p_ptr-&gt;y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(p_array != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1.释放变长结构体的空间"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">free</span>(p_array);</span><br><span class="line">        p_array = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(p_ptr-&gt;y != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1.释放指针申请的空间"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">free</span>(p_ptr-&gt;y);</span><br><span class="line">        p_ptr-&gt;y = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(p_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"2.释放结构体的空间"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">free</span>(p_ptr);</span><br><span class="line">            p_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是结构体的最后一个成员<code>char b[0]</code>,是个<strong>空数组</strong>。在我们不知道结构体内的某个成员大小是多少的时候,我们在最后一个成员放置了一个空数组,这样做的好处就是,我们直接用结构体指针申请空间(<code>sizeof(struct) + 给空数组申请的空间</code>),就完成了动态分配</p>
<p>变长结构体的内存是连续的(严谨的说是虚拟内存),而常规方法的不是,所以变长结构体只需释放一次空间,而常规方法需要释放两次。</p>
<p>并且我们使用sizeof查看两个结构体的大小会发现,Empty结构体的大小为4字节,而Ptr的大小为8字节,可以得出char b[0]是不占内存空间的。</p>
<p>最后还有需要注意的一点就是,有些编译器可能不支持char b[0]这样的写法,可以换成char b[1],用法还是一样的,只是这时的结构体大小变成了4 + 1 + 3 = 8字节,最后那个3字节是由于内存对齐填补上的。</p>
<h6 id="3-fprintf函数的使用和返回值（fprintf-、sprintf-、printf-、fwrite-函数的用法与区别）"><a href="#3-fprintf函数的使用和返回值（fprintf-、sprintf-、printf-、fwrite-函数的用法与区别）" class="headerlink" title="3 fprintf函数的使用和返回值（fprintf()、sprintf()、printf()、fwrite()函数的用法与区别）"></a>3 fprintf函数的使用和返回值（fprintf()、sprintf()、printf()、fwrite()函数的用法与区别）</h6><p> <strong>fprintf</strong>()函数主要用于格式化信息输出到指定的文件流中  </p>
<p> fprintf(fp, “%d”, buffer); </p>
<p> fprintf(文件指针,格式字符串,输出表列);</p>
<p>返回值：成功则返回输出的字节数，失败返回eof；</p>
<p><strong>sprintf</strong>是格式化输出到一个字符串，fprintf是格式化输出到一个stream，通常是到文件。</p>
<p><strong>printf</strong> 是和标准输出文件(stdout)关联的,fprintf 则没有这个限制.</p>
<p><strong>fwrite</strong>(&amp;buffer, sizeof(int), 1, fp);是以二进位位方式写入文件<br>fwrite(数据，数据类型大小（字节数），写入数据的最大数量，文件指针);</p>
<p>由于fprintf写入时，对于整数来说，一位占一个字节，比如1，占1个字节；10，占2个字节；100，占3个字节，10000，占5个字节<br>所以文件的大小会随数据的大小而改变，对大数据空间占用很大。<br>而fwrite是按二进制写入，所以写入数据所占空间是根据数据类型来确定，比如int的大小为4个字节（一般32位下），那么整数10所占空间为4个字节，100、10000所占空间也是4个字节。所以二进制写入比格式化写入更省空间。</p>
<h6 id="4-智能指针-share-ptr-的实现"><a href="#4-智能指针-share-ptr-的实现" class="headerlink" title="4 智能指针 share_ptr 的实现"></a>4 智能指针 share_ptr 的实现</h6><p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>成员函数：</p>
<p>use_count 返回引用计数的个数</p>
<p>unique 返回是否是独占所有权( use_count 为 1)</p>
<p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
<p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
<h6 id="6-引用计数的时候怎么保证安全"><a href="#6-引用计数的时候怎么保证安全" class="headerlink" title="6 引用计数的时候怎么保证安全"></a>6 引用计数的时候怎么保证安全</h6><p>这个也是今天想重点介绍的方案，这个方案没有方案一那么直观，但是确实能够解决上面的问题，也比较安全。</p>
<p>综上，其实问题并不出现在Release里面，问题出现在Addref里面，这个addref 做的自增操作，有些随意了。他没有判断当前的状态，是不是应该加一。而是灰常武断的上来就加，这就是问题的根源。</p>
<p>下面直接上硬菜，addref 的算法应该修改如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_ref_lock</span><span class="params">()</span> <span class="comment">// true on success</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>( ;; )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">long</span> tmp = <span class="keyword">static_cast</span>&lt; <span class="keyword">long</span> <span class="keyword">const</span> <span class="keyword">volatile</span>&amp; &gt;(m_ulRef);</span><br><span class="line">         <span class="keyword">if</span>( tmp == <span class="number">0</span> )</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">if</span>( InterlockedCompareExchange( &amp;m_ulRef, tmp + <span class="number">1</span>, tmp ) == tmp )</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细分析一下，</p>
<p>l  首先，会将应用计数放入一个临时变量，然后用InterlockedCompareExchange 方式来比较修改。如果任何其他线程，修改了m_ulRef 这个变量</p>
<p>l  那么肯定InterlockedCompareExchange的返回值不等于 tmp 变量，那么就修改不成功。</p>
<p>l  这个时候重新获取，再次修改，肯定有成功的时候</p>
<p>l  如果上来就是0，那么就不addref了。这个情况下，说明肯定是对象要释放了。</p>
<h6 id="7-防御性编程"><a href="#7-防御性编程" class="headerlink" title="7 防御性编程"></a>7 防御性编程</h6><p>1、保护你的代码远离来自“外部”的无效数据，无论这个“外部”的概念被定位为什么。它可以是来自于外部系统、用户、文件的数据，也可以是模块/组件以外的数据，由你决定。树立“路障”、“安全区”或“信任边界”——在边界之外的一切都是危险的，界限之内的所有都是安全的。关于“路障”代码，需要验证所有的输入数据：检查所有输入参数的类型、长度和值域是否正确。还要加倍检查限制和界限。</p>
<p>2.当我们检查出错误数据后，还需要决定如何处理它。防御性编程不会掩盖错误，也不会隐藏bug。这需要在健壮性（如果问题可以处理那就继续运行）和正确性（不返回不准确的结果）之间做权衡。选择好策略来应对错误数据：返回错误就马上停止，返回中性值就替换数据值……确保策略明确且一贯。</p>
<p>3.不要将代码外部的函数调用或方法调用想得太过美好。请确保你调用外部的API和库之前理解并测试了错误。</p>
<p>4.至少在开发和测试阶段，要使用断言记录假设，并高亮“不可能”的条件。这在大型系统中显得尤为重要，因为随着时间的推移，将会有不同的程序员用高度可靠的代码来维护这些大型系统。</p>
<p>5.添加诊断代码，智能地记录和跟踪以帮助解释在运行时发生的事情，尤其是当你遇到问题的时候。</p>
<p>6.标准化的错误处理。想好如何处理“正常错误”、“预期错误”以及警告，并对此习以为常。</p>
<p>7.只有当你真的需要的时候，才使用异常处理，并确保你得彻底理解该编程语言的异常处理程序。</p>
<h6 id="8-对C-中三大特性的各自的理解https-blog-csdn-net-skySongkran-article-details-82012698"><a href="#8-对C-中三大特性的各自的理解https-blog-csdn-net-skySongkran-article-details-82012698" class="headerlink" title="8 对C++中三大特性的各自的理解https://blog.csdn.net/skySongkran/article/details/82012698"></a>8 对C++中三大特性的各自的理解<a href="https://blog.csdn.net/skySongkran/article/details/82012698" target="_blank" rel="noopener">https://blog.csdn.net/skySongkran/article/details/82012698</a></h6><p><img src="https://img-blog.csdn.net/201808241009396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NreVNvbmdrcmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>封装性是基础，继承性是关键，多态性是补充，并且多态性存在于继承的环境中。</p>
<p> <span style="color:red">封装性</span></p>
<p>​    C++语言中支持数据封装，类是支持数据封装的工具，对象是数据封装的实现。在封装中，还提供一种对数据访问的控制机制，使得一些数据被隐藏在封装体内，因此具有隐藏性。封装体与外界进行信息交换是通过操作接口进行的。这种访问控制机制体现在类的成员可以有公有成员(public)，私有成员(private)，保护成员(protected)。</p>
<p>​    私有成员是在封装体内被隐藏的部分，只有类体内说明的函数(类的成员函数)才可以访问私有成员，而在类体外的函数时不能访问的，公有成员是封装体与外界的一个接口，类体外的函数可以访问公有成员，保护成员是只有该类的成员函数和该类的派生类才可以访问的。</p>
<p>​    类是一种复杂的数据类型它是将不同类型的数据和与这些数据相关的操作封装在一起的集合体。因此，类具有对数据的抽象性，隐藏性和封装性。</p>
<p><span style="color:red"> 继承性</span></p>
<p>​    C++语言允许单继承和多继承。继承是面向对象语言的重要特性。一个类可以根据需要生成它的派生类，派生类还可以再生成派生类。派生类继承基类的成员，另外，还可以定义自己的成员。继承是实现抽象和共享的一种机制。</p>
<p>​    C++语言中的继承机制可以克服传统的面向过程程序设计的缺点，因为传统编程方式不能重复使用程序而造成资源的浪费，而c++语言提供了无限重复利用程序资源的一种新途径。</p>
<p><span style="color:red"> 多态性</span></p>
<p>   多态性是指对不同类的对象发出相同的消息将会有不同的实现。多态性也可以理解为，在一般类中定义的属性或服务被特殊类继承后，可以具有不同的数据类型或不同的实现。可见，多态性与继承性相关联。简单的说，多态性是指发出同样的消息被不同的数据类型的对象接收后导致不同的行为。</p>
<p> C++语言支持多态性表现在：</p>
<p>​       1，C++语言允许函数重载和运算符重载。</p>
<p>​       2，C++语言通过<strong>定义虚函数</strong>来支持动态联编，动态联编是多态性的一个重要的特征。</p>
<p>多态特性的工作依赖虚函数的定义，在需要解决多态问题的重载成员函数前，加上virtual关键字，那么该成员函数就变成了虚函数，从上例代码运行的结果看，系统成功的分辨出了对象的真实类型，成功的调用了各自的重载成员函数。</p>
<p>　　<strong>多态特性让程序员省去了细节的考虑，提高了开发效率，使代码大大的简化，当然虚函数的定义也是有缺陷的，因为多态特性增加了一些数据存储和执行指令的开销，所以能不用多态最好不用</strong>。</p>
<h6 id="9-对数据结构中堆的理解，小顶堆的建立顺序。"><a href="#9-对数据结构中堆的理解，小顶堆的建立顺序。" class="headerlink" title="9 对数据结构中堆的理解，小顶堆的建立顺序。"></a>9 对数据结构中堆的理解，小顶堆的建立顺序。</h6><p>堆（heap）也被称为优先队列（priority queue）。队列中允许的操作是先进先出（FIFO），在队尾插入元素，在队头取出元素。而堆也是一样，在堆底插入元素，在堆顶取出元素，但是堆中元素的排列不是按照到来的先后顺序，而是按照一定的优先顺序排列的。这个优先顺序可以是元素的大小或者其他规则。如图一所示就是一个堆，堆优先顺序就是大的元素排在前面，小的元素排在后面，这样得到的堆称为最大堆。最大堆中堆顶的元素是整个堆中最大的，并且每一个分支也可以看成一个最大堆。同样的，我们可以定义最小堆。</p>
<p>最小堆是一棵完全二叉树，非叶子结点的值不大于左孩子和右孩子的值。本文以图解的方式，说明</p>
<p>最小堆的构建、插入、删除的过程。搞懂最小堆的相应知识后，最大堆与此类似。</p>
<h6 id="10-哈希表的优势，哈希表的使用场景。hash函数的理解；"><a href="#10-哈希表的优势，哈希表的使用场景。hash函数的理解；" class="headerlink" title="10 哈希表的优势，哈希表的使用场景。hash函数的理解；"></a>10 哈希表的优势，哈希表的使用场景。hash函数的理解；</h6><p><strong>优点:(查找速度快)</strong></p>
<p>​       哈希表是种数据结构，它可以提供快速的插入操作和查找操作。第一次接触哈希表时，它的优点多得让人难以置信。不论哈希表中有多少数据，插入和删除（有时包括侧除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。</p>
<p>　　对哈希表的使用者一一人来说，这是一瞬间的事。哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。</p>
<p>​      <strong>使用场景：</strong></p>
<p>​       <strong>而且，也没有一种简便的方法可以以任何一种顺序〔例如从小到大〕遍历表中数据项。如果需要这种能力，就只能选择其他数据结构。</strong></p>
<p><strong>然而如果不需要有序遍历数据，井且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。</strong></p>
<p>若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数（哈希函数），按这个思想建立的表为散列表（哈希表）。</p>
<p>对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为碰撞(英语:Collision)。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理碰撞的方法将一组关键字映射到一个有限的连续的地址集(区间)上，并以关键字在地址集中的”像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。（就是发生冲突，有两个或者多个关键词对应同一个物理地址，就无法分清哪一个对应哪个了。）</p>
<p>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数(Uniform Hash function)，这就是使关键字经过散列函数得到一个”随机的地址”，从而减少碰撞（注意冲突无法避免的）。</p>
<p><strong>什么是哈希函数</strong></p>
<p><strong>哈希函数（散列函数）能够将任意长度的输入值转变成固定长度的值输出，该值称为散列值，输出值通常为字母与数字组合</strong>。</p>
<h6 id="11-给定一百万个IP和端口，如何设计一个hash函数，和哈希表去存储，做什么样子的哈希运算。"><a href="#11-给定一百万个IP和端口，如何设计一个hash函数，和哈希表去存储，做什么样子的哈希运算。" class="headerlink" title="11 给定一百万个IP和端口，如何设计一个hash函数，和哈希表去存储，做什么样子的哈希运算。"></a>11 给定一百万个IP和端口，如何设计一个hash函数，和哈希表去存储，做什么样子的哈希运算。</h6><h6 id="12、解决哈希冲突的办法"><a href="#12、解决哈希冲突的办法" class="headerlink" title="12、解决哈希冲突的办法"></a>12、<strong>解决哈希冲突的办法</strong></h6><p><strong>1、开放定址法</strong></p>
<p>这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p>
<p>Hi=（H（key）+di）% m   i=1，2，…，n</p>
<p>其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：</p>
<p><strong>线性探测再散列</strong></p>
<p>dii=1，2，3，…，m-1</p>
<p>这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>
<p>① 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。<br>② 按上述算法建立起来的哈希表，删除工作非常困难。如果将此元素删除，查找的时会发现空槽，则会认为要找的元素不存在。只能标上已被删除的标记，否则，将会影响以后的查找。<br>③ 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</p>
<p><strong>二次探测再散列</strong></p>
<p>di=12，-12，22，-22，…，k2，-k2    ( k&lt;=m/2 )</p>
<p>这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p>
<p><strong>伪随机探测再散列</strong></p>
<p>di=伪随机数序列。</p>
<p>具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。</p>
<p>例如，已知哈希表长度m=11，哈希函数为：H（key）= key  %  11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。</p>
<p>如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。</p>
<p>如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。</p>
<p>如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。</p>
<p><strong>2、再哈希法</strong></p>
<p>这种方法是同时构造多个不同的哈希函数：</p>
<p>Hi=RH1（key）  i=1，2，…，k</p>
<p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
<p><strong>3、链地址法</strong></p>
<p>​         这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
<p><strong>开放散列（open hashing）/ 拉链法（针对桶链结构）</strong></p>
<p>1）优点： ①对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销） ②由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了 ③删除记录时，比较方便，直接通过指针操作即可</p>
<p>2）缺点： ①存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 ②如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列 ③由于使用指针，记录不容易进行序列化（serialize）操作</p>
<p><strong>封闭散列（closed hashing）/ 开放定址法</strong></p>
<p>1）优点： ①记录更容易进行序列化（serialize）操作 ②如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的</p>
<p>2）缺点： ①存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷 ②使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低 ③由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费 ④删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。</p>
<h6 id="13、未定义的bool值为什么"><a href="#13、未定义的bool值为什么" class="headerlink" title="13、未定义的bool值为什么"></a>13、未定义的bool值为什么</h6><p>不确定 </p>
<p>综上可以看出，在Debug环境下，变量的内存地址空间被编译器默认用0xcc填充了。而在Release环境下，变量的内存地址空间被编译器用随机值填充了。</p>
<p>研究了这么多，其实还是要给出一条建议：在定义变量的同时，给出一个初始值，而不要让编译器默认填充。这样既方便调试，也不会因为Debug或者Release环境的不同而不同。默认填充会有许多的不确定性，不同的编译器也会不同，会引入许多隐含的Bug。</p>
<h6 id="14、Char-c-abc；-strlen（指针）多大4，strlen（c）为3"><a href="#14、Char-c-abc；-strlen（指针）多大4，strlen（c）为3" class="headerlink" title="14、Char* c= abc； strlen（指针）多大4，strlen（c）为3"></a>14、Char* c= abc； strlen（指针）多大4，strlen（c）为3</h6><h6 id="15、套接字编程，一台是小段，一台大端怎么通信"><a href="#15、套接字编程，一台是小段，一台大端怎么通信" class="headerlink" title="15、套接字编程，一台是小段，一台大端怎么通信?"></a>15、套接字编程，一台是小段，一台大端怎么通信?</h6><p>首先理解什么是大端什么是小端</p>
<ul>
<li><strong>大端模式，</strong>是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中</li>
<li><strong>小端模式，</strong>是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180425152114637?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NDk4MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="å¤§å°ç«¯æ¨¡å¼"></p>
<p><strong>大端模式优点：</strong>符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小</p>
<p><strong>小端模式优点：</strong></p>
<ol>
<li>内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（注解：比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）；</li>
<li>CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效</li>
</ol>
<p>由于不同的处理器可以配置成大端或者小端，使得不同主机之间的通信变得复杂。<br>为此，网络协议指定了字节序。TCP/IP协议栈采用<strong>大端字节序</strong>，所以应用程序有时需要再处理器的字节序与网络的字节序之间进行转换。<br>对于TCP/IP应用程序，提供了以下四个通用函数进行转换：</p>
<p><strong>怎么判断本机现在是大端还是小端</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">char</span> * p = (<span class="keyword">char</span>*)&amp;a;  </span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​       如果小端方式中（a占至少两个字节的长度）则a所分配的内存最小地址那个字节中就存着1，其他字节是0；大端的话则1在i的最高地址字节处存放。char是一个字节，所以强制将char型量p指向i则p指向的一定是i的最低地址，那么就可以判断p中的值是不是1来确定是不是小端。</p>
<p><strong>在网络上传输的数据普遍采用的都是大端</strong></p>
<h6 id="16、并发模型有哪些？（留）"><a href="#16、并发模型有哪些？（留）" class="headerlink" title="16、并发模型有哪些？（留）"></a>16、并发模型有哪些？（留）</h6><h6 id="17、程序有哪些段"><a href="#17、程序有哪些段" class="headerlink" title="17、程序有哪些段"></a>17、程序有哪些段</h6><p>站在汇编语言的角度，一个程序分为：<br>数据段 – DS<br>堆栈段 – SS<br>代码段 – CS<br>扩展段 – ES</p>
<p>站在高级语言的角度，根据APUE，一个程序分为如下段：<br>text<br>data (initialized)<br>bss<br>stack<br>heap</p>
<p> 1.一般情况下，一个可执行二进制程序(更确切的说，在Linux操作系统下为一个进程单元，在UC/OSII中被称为任务)在存储(没有调入到内存运行)时拥有3个部分，分别是代码段(text)、数据段(data)和BSS段。这3个部分一起组成了该可执行程序的文件。</p>
<p><strong>★★可执行二进制程序 = 代码段(text)＋数据段(data)+BSS段★★</strong></p>
<p> 2.而当程序被加载到内存单元时，则需要另外两个域：堆域和栈域。图1-1所示为可执行代码存储态和运行态的结构对照图。一个正在运行的C程序占用的内存区域分为代码段、初始化数据段、未初始化数据段(BSS)、堆、栈5个部分。</p>
<p><strong>★★正在运行的C程序 = 代码段+初始化数据段(data)+未初始化数据段(BSS)+堆+栈★★</strong></p>
<p>3.在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显示地申请和释放空间。</p>
<p> 4.动态分配与静态分配，二者最大的区别在于:1. 直到Run-Time的时候，执行动态分配，而在compile-time的时候，就已经决定好了分配多少Text+Data+BSS+Stack。2.通过malloc()动态分配的内存，需要程序员手工调用free()释放内存，否则容易导致内存泄露，而静态分配的内存则在进程执行结束后系统释放(Text, Data), 但Stack段中的数据很短暂，函数退出立即被销毁</p>
<p><img src="https://img-blog.csdn.net/20141120150231808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZV9nYW9oeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><span style="color:green">从可执行文件a.out的角度来讲，如果一个数据未被初始化那就不需要为其分配空间，所以.data和.bss一个重要的区别就是.bss并不占用可执行文件的大小，它只是记载需要多少空间来存储这些未初始化数据，而不分配实际的空间</span></p>
<p><strong>代码段 –text（code segment/text segment）</strong><br>text段在内存中被映射为只读，但.data和.bss是可写的。<br>text段是程序代码段，在AT91库中是表示程序段的大小，它是由编译器在编译连接时自动计算的，当你在链接定位文件中将该符号放置在代码段后，那么该符号表示的值就是代码段大小，编译连接时，该符号所代表的值会自动代入到源程序中。</p>
<p><strong>数据段 – data</strong><br>data包含静态初始化的数据，所以有初值的全局变量和static变量在data区。段的起始位置也是由连接定位文件所确定，大小在编译连接时自动分配，它和你的程序大小没有关系，但和程序使用到的全局变量，常量数量相关。数据段属于静态内存分配。 </p>
<p><strong>bss段–bss</strong><br>bss是英文Block Started by Symbol的简称，通常是指用来存放程序中未初始化的全局变量的一块内存区域，在程序载入时由内核清0。BSS段属于静态内存分配。它的初始值也是由用户自己定义的连接定位文件所确定，用户应该将它定义在可读写的RAM区内，源程序中使用malloc分配的内存就是这一块，它不是根据data大小确定，主要由程序中同时分配内存最大值所确定，不过如果超出了范围，也就是分配失败，可以等空间释放之后再分配。BSS段属于静态内存分配。<br><strong>stack：</strong><br>栈(stack)保存函数的局部变量（但不包括static声明的变量， static 意味着 在数据段中 存放变量），参数以及返回值。是一种“后进先出”（Last In First Out，LIFO）的数据结构，这意味着最后放到栈上的数据，将会是第一个从栈上移走的数据。对于哪些暂时存贮的信息，和不需要长时间保存的信息来说，LIFO这种数据结构非常理想。在调用函数或过程后，系统通常会清除栈上保存的局部变量、函数调用信息及其它的信息。栈另外一个重要的特征是，它的地址空间“向下减少”，即当栈上保存的数据越多，栈的地址就越低。栈（stack）的顶部在可读写的RAM区的最后。</p>
<p><strong>heap:</strong><br>堆(heap)保存函数内部动态分配内存，是另外一种用来保存程序信息的数据结构，更准确的说是保存程序的动态变量。堆是“先进先出”（First In first Out，FIFO）数据结构。它只允许在堆的一端插入数据，在另一端移走数据。堆的地址空间“向上增加”，即当堆上保存的数据越多，堆的地址就越高。<br><img src="https://img-blog.csdn.net/20141120144640019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZV9nYW9oeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>下图是APUE中的一个典型C内存空间分布图：</strong></p>
<p><img src="https://img-blog.csdn.net/20141120145439174?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZV9nYW9oeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>所以可以知道传入的参数,局部变量,都是在栈顶分布,随着子函数的增多而向下增长.函数的调用地址(函数运行代码),全局变量,静态变量都是在分配内存的低部存在,而malloc分配的堆则存在于这些内存之上,并向上生长.</strong></p>
<h6 id="18、MMU内存管理单元"><a href="#18、MMU内存管理单元" class="headerlink" title="18、MMU内存管理单元"></a>18、MMU内存管理单元</h6><p><strong>什么是MMU</strong></p>
<p>MMU(Memory Management Unit)主要用来管理虚拟存储器、物理存储器的控制线路，同时也负责<strong>虚拟地址映射为物理地址</strong>，以及提供硬件机制的内存访问授权、多任务多进程操作系统。（来自百度百科，<strong>对其几个点不熟悉，因此可以只考虑加粗部分</strong>）</p>
<p><strong>发展历史</strong></p>
<p><em>注意：学习一个知识点，很重要的一步是了解其<strong>为什么而存在？它的存在是为了解决什么问题？</strong>然后，在学习的过程中带着这些问题去理解、去思考。</em></p>
<p>在许多年以前，还是使用DOS或一些古老的操作系统时，内存很小，同时，应用程序也很小，将程序存储在内存中基本能够满足需要。随着科技的发展，图形界面及一些其他更复杂的应用出现，内存已经无法存储这些应用程序了，通常的解决办法是将程序分割成很多个<strong>覆盖块</strong>，覆盖块0最先运行，运行结束之后，就调用另一个覆盖块，虽然这些操作由OS来完成，但是，需要程序员对程序进行分割，这非常不高效；因此，人们想出了一个<strong>虚拟存储器（virtual memory）</strong>的方法。虚拟存储器的基本思想是：程序、数据、堆栈的总大小可以超过内存空间的大小，操作系统将当前运行的部分保存在内存中，未使用的部分保存在磁盘中。比如一个16MB的程序和一个内存只有4MB的机器，操作系统通过选择可以决定哪部分4MB的程序内容保存在内存中，并在需要时，在内存与磁盘中交换程序代码，这样16MB的代码就可以运行在4MB的机器中了。<strong>注意：这里面包含了虚拟地址和物理地址的概念</strong></p>
<p><strong>相关概念</strong></p>
<p><strong>地址范围、虚拟地址映射成物理地址</strong>以及<strong>分页机制</strong></p>
<ul>
<li><p><strong>地址范围</strong>： 指处理器能够产生的地址集合，如一个32bit的处理器ARM9，其能产生的地址集合是<strong>0x0000 0000 ~ 0xffff ffff</strong>(4G)，这个地址范围也称为<strong>虚拟地址空间</strong>，其中对应的地址为<strong>虚拟地址</strong>。</p>
</li>
<li><p><strong>虚拟地址与物理地址</strong>： 与虚拟地址空间和虚拟地址相对应的是物理地址空间和物理地址；物理地址空间只是虚拟地址空间的一个<strong>子集</strong>。如一台内存为256MB的32bit X86主机，其虚拟地址空间是0 ~ 0xffffffff(4GB)，物理地址空间范围是0 ~ 0x0fff ffff(256M)</p>
</li>
<li><p>分页机制</p>
<p> 如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为物理地址（<strong>Physical Address</strong>，以下简称<strong>PA</strong>），如下图3-1-1所示；</p>
</li>
</ul>
<p>  <img src="https://upload-images.jianshu.io/upload_images/2310756-67a4ff2b53385008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/455/format/webp" alt="img"></p>
<p>  如果处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将VA映射成PA，，如下图3-1-2。</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/2310756-3b1e7fc263f0642a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/446/format/webp" alt="img"></p>
<ul>
<li>大多数使用MMU的机器都采用<strong>分页机制</strong>。虚拟地址空间以<strong>页</strong>为单位进行划分，而相应的物理地址空间也被划分，其使用的单位称为<strong>页帧</strong>，页帧和页必须保持相同，因为<strong>内存与外部存储器之间的传输是以页为单位进行传输的</strong>。例如，MMU可以通过一个映射项将VA的一页0xb70010000xb7001fff映射到PA的一页0x20000x2fff，如果CPU执行单元要访问虚拟地址0xb7001008，则实际访问到的物理地址是0x2008。</li>
</ul>
<p>虚拟内存的哪个页面映射到物理内存的哪个页帧是通过<strong>页表（Page Table）</strong>来描述的，页表保存在<strong>物理内存中</strong>，<strong>MMU会查找页表来确定一个VA应该映射到什么PA。</strong></p>
<p><strong>功能</strong></p>
<p><strong>执行过程</strong></p>
<p>操作系统和MMU是这样配合的：</p>
<ol>
<li>操作系统在初始化或分配、释放内存时会执行一些指令在物理内存中填写页表，然后用指令设置MMU，告诉MMU页表在物理内存中的什么位置。</li>
<li>设置好之后，CPU每次执行访问内存的指令都会自动引发MMU做查表和地址转换操作，地址转换操作由硬件自动完成，不需要用指令控制MMU去做。</li>
</ol>
<p><span style="color:green"><strong>重要：</strong>我们在程序中使用的变量和函数都有各自的地址，在程序被编译后，这些地址就成了指令中的地址，指令中的地址就成了CPU执行单元发出的内存地址，所以在启用MMU的情况下， 程序中使用的地址均是<strong>虚拟内存地址</strong>，都会引发MMU进行查表和地址转换操作。（注意理解这句话）</span></p>
<p><strong>内存保护机制</strong></p>
<p>处理器一般有<strong>用户模式（User Mode）</strong>和<strong>特权模式（privileged Mode）</strong>之分。操作系统可以在页表中设置每个页表访问权限，有些页表不可以访问，有些页表只能在特权模式下访问，有些页表在用户模式和特权模式下都可以访问，同时，访问权限又分为<strong>可读</strong>、<strong>可写</strong>和<strong>可执行</strong>三种。这样设定之后，当CPU要访问一个VA（Virtual Address）时，<strong>MMU</strong>会检查CPU当前处于用户模式还是特权模式，访问内存的目的是读数据、写数据还是取指令执行，<strong>如果与操作系统设定的权限相符，则允许访问，把VA转换成PA，否则不允许执行，产生异常（Exception）</strong>。</p>
<p><strong>异常与中断</strong>：异常与中断的处理机制类似，不同的是中断由外部设备产生，而 异常由CPU内部产生的；中断产生与CPU当前执行的指令无关，而异常是由于当前执行的指令出现问题导致的</p>
<p>通常操作系统会将<strong>虚拟地址空间</strong>划分为<strong>用户空间</strong>和<strong>内核空间</strong>。例如x86平台的linux系统的虚拟地址空间范围是0x0000 0000 ~ 0xffff ffff，前3G的空间为用户空间，后1G的空间为内核空间。用户程序加载到用户空间，内核程序加载到内核空间，<strong>用户程序不能访问内核中的数据，也不能跳转到内核空间执行</strong>。这样可以保护内核，如果一个进程访问了非法地址，顶多就是这个进程崩溃，而不会影响到内核和系统的稳定性。在系统发生中断或异常时，不仅会跳转到中断或异常服务函数中执行，而且还会从用户模式切换到特权模式，从中断或异常服务程序跳转到内核代码中执行。<strong>总结一下：在正常情况下处理器在用户模式执行用户程序，在中断或异常情况下处理器切换到特权模式执行内核程序，处理完中断或异常之后再返回用户模式继续执行用户程序。</strong></p>
<p><strong>段错误</strong>我们已经遇到过很多次了，它是这样产生的：</p>
<ol>
<li>用户程序要访问的一个VA，经MMU检查无权访问。</li>
<li>MMU产生一个异常，CPU从用户模式切换到特权模式，跳转到内核代码中执行异常服务程序。</li>
<li>内核把这个异常解释为段错误，把引发异常的进程终止掉。</li>
</ol>
<p><strong>S3C2440/S3C2410 中的MMU</strong></p>
<p><strong>S3C2440/S3C2410 MMU概述</strong></p>
<ol>
<li>S3C2440的MMU使用<strong>页表</strong>来实现虚拟地址到物理地址的转换；页表存储在内存中，页表中的每一行对应于虚拟存储空间的一个页，该行包含了该虚拟内存页对应的物理内存页的地址、该页的方位权限和该页的缓冲特性等。这里页表中的每一行称为一个<strong>地址变换条目（entry）也称为“描述符”</strong>。描述符有：段描述符、大页描述符、小页描述符、极小页描述符——他们保存段、大页、小页或极小页的<strong>起始物理地址</strong>；粗页表描述符、细页表描述符——它们保存<strong>二级页表的物理地址</strong>。</li>
<li><strong>页表的存储</strong>：页表存放在内存中，系统通常有<strong>一个寄存器来保存页表的基地址</strong>。在ARM中<strong>系统控制协处理器CP15的寄存器C2用来保存页表的基地址</strong>。</li>
<li><strong>TLB</strong>：因为从虚拟地址到物理地址的变换过程是通过查询页表完成的，而页表又存储在内存中，如果每次程序执行时去读取内存中的数据获取物理地址，代价很大。而程序在执行过程中可能只对页表中的少数几个单元进行访问，根据这一特点，采用一个容量更小（通常为8~16个字）、访问速度和CPU中通用寄存器相当的存储器件来存放当前访问需要的地址变换条目。这个小容量的页表称为TLB（Translation Lookaside buffer）。</li>
<li><strong>S3C2440/S3C2410中的页表</strong><br>在S32440/S3C2410中最多会使用两级页表：以段（Section 1MB）的方式进行转换时只用到一级页表，以页（Page）的方式进行转换时用到二级页表。</li>
<li><strong>CPU访问内存的过程</strong>：<br>a . 当CPU需要访问内存时，先在TLB中查询需要的地址变换条目。如果该条目不存在，CPU从位于内存中的页表中查询，并把相应的结果添加到TLB中。这样，当CPU下一次又需要该地址变换条目时，可以从TLB中直接得到，从而使地址变换的速度大大加快。<br>b. 当内存中的页表内容改变，或者通过修改系统控制协处理器CP15的寄存器C2使用新的页表时，TLB中的内容需要全部清除。系统控制协处理器<strong>CP15的寄存器C8</strong>用来控制清除TLB内容的相关操作。<br>c. MMU可以将某些地址变换条目锁定在TLB中，从而使得获取该地址变换条目的速度保持很快。在CP15中的C10用于控制TLB内容的锁定。<br>d. MMU 可以将整个存储空间分为最多16个域，每个域对应一定的内存区域，该区域具有相同的访问控制属性。<strong>MMU中寄存器C3用于控制与域相关的属性的配置</strong>。<br>e. 当存储访问失效时，MMU提供了相应的机制用于处理这种情况。在<strong>MMU中寄存器C5和寄存器C6用于支持这些机制</strong>。</li>
</ol>
<p><strong>禁止/使能MMU时应注意的问题（重要）</strong></p>
<p>应注意如下几点：</p>
<ul>
<li><span style="color:red">在使能MMU之前，要在内存中<strong>建立页表</strong>，同时，<strong>CP15中的各相关寄存器必须完成初始化</strong>。</span></li>
<li><span style="color:red">如果使用的不是平板存储模式（物理地址和虚拟地址相等），在禁止/使能MMU时，虚拟地址和物理地址的对应关系会发生改变，这时应该<strong>清除cache中的当前地址变换条目</strong>。</span></li>
</ul>
<p><strong>S3C2440/S3C2410中的MMU地址变换</strong></p>
<p>ARM CPU上的地址转换过程涉及3个概念：虚拟地址（VA）、<strong>变换后的虚拟地址（MVA, modified virtrual address）</strong>、物理地址（PA）。</p>
<p>没启动MMU时，CPU核、cache、MMU、外设等所有部件使用的都是物理地址。</p>
<p><strong>启动MMU后，CPU核对外发出虚拟地址VA；VA被转换为MVA供cache、MMU使用，在这里MVA被转换为PA，最后使用PA读写实际设备。</strong></p>
<p>ARM支持的存储块大小有以下几种：</p>
<ul>
<li>段（section）：是大小为1M的存储块。</li>
<li>大页（Large Pages）：是大小为64KB的存储块。</li>
<li>小页（Small Pages）：是大小为4KB的存储块。</li>
<li>极小页（Tiny Pages）：是大小为1KB的存储块。<br>通过配置访问控制机制，还可以将大页分成大小为16KB的子页；将小页分成大小为1KB的子页；极小页不能再细分，只能以1KB大小的整页为单位。</li>
</ul>
<p><strong>MMU中的域</strong></p>
<p>MMU中的域指的是一些段、大页或者小页的集合。ARM支持最多16个域，每个域的访问控制特性由CP15中的寄存器C3中的两位来控制，CP15中的寄存器C3的格式如下所示:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2310756-3e2d70fcfe123989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/876/format/webp" alt="img"></p>
<p>其中每两位控制一个域的访问控制特性，其编码及对应的含义如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2310756-a20552080cd50a24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/900/format/webp" alt="img"></p>
<h6 id="19、函数调用过程"><a href="#19、函数调用过程" class="headerlink" title="19、函数调用过程"></a>19、函数调用过程</h6><p>​       在x86的计算机系统中，内存空间中的栈主要用于保存函数的参数，返回值，返回地址，本地变量等。一切的函数调用都要将不同的数据、地址压入或者弹出栈。因此，为了更好地理解函数的调用，我们需要先来看看栈是怎么工作的。</p>
<p>栈帧，也就是stack frame，其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的。在x86-32bit中，我们用 <code>%ebp</code> 指向栈底，也就是基址指针；用 <code>%esp</code> 指向栈顶，也就是栈指针。下面是一个栈帧的示意图：</p>
<p>​                                              <img src="https://segmentfault.com/img/remote/1460000007977465" alt="å¾ä¸ï¼æ å¸§ç¤ºæå¾"></p>
<p>一般来说，我们将 <code>%ebp</code> 到 <code>%esp</code> 之间区域当做栈帧（也有人认为该从函数参数开始，不过这不影响分析）。并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧。在函数调用过程中，我们将调用函数的函数称为“调用者(caller)”，将被调用的函数称为“被调用者(callee)”。在这个过程中，1）“调用者”需要知道在哪里获取“被调用者”返回的值；2）“被调用者”需要知道传入的参数在哪里，3）返回的地址在哪里。同时，我们需要保证在“被调用者”返回后，<code>%ebp</code>, <code>%esp</code> 等寄存器的值应该和调用前一致。因此，我们需要使用栈来保存这些数据。</p>
<p><strong>函数的调用</strong></p>
<p>我们直接通过实例来看函数是如何调用的。这是一个有参数但没有调用任何函数的简单函数，我们假设它被其他函数调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyFunction</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">5</span>;</span><br><span class="line">    c = <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>;</span><br><span class="line">    MyFunction1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个函数，当调用时，<code>MyFunction()</code> 的汇编代码大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_MyFunction:</span><br><span class="line">    push %ebp            ; //保存%ebp的值</span><br><span class="line">    movl %esp, $ebp      ; //将%esp的值赋给%ebp，使新的%ebp指向栈顶</span><br><span class="line">    movl -12(%esp), %esp ; //分配额外空间给本地变量</span><br><span class="line">    movl $10, -4(%ebp)   ; </span><br><span class="line">    movl $5,  -8(%ebp)   ; </span><br><span class="line">    movl $2,  -12(%ebp)  ;</span><br></pre></td></tr></table></figure>

<p>光看代码可能还是不太明白，我们先来看看此时的栈是什么样的：</p>
<p><img src="https://segmentfault.com/img/remote/1460000007977466" alt="图四：被调用者栈帧的生成"></p>
<p>此时调用者做了两件事情：<strong>第一，将被调用函数的参数按照从右到左的顺序压入栈中。第二，将返回地址压入栈中。</strong>这两件事都是调用者负责的，g。我们再来看看被调用者，它也做了两件事情：第一，将老的（调用者的） <code>%ebp</code> 压入栈，此时 <code>%esp</code> 指向它。第二，将 <code>%esp</code> 的值赋给 <code>%ebp</code>, <code>%ebp</code> 就有了新的值，它也指向存放老 <code>%ebp</code> 的栈空间。这时，它成了是函数 <code>MyFunction()</code> 栈帧的栈底。<strong>这样，我们就保存了“调用者”函数的 `%ebp</strong>`，并且建立了一个新的栈帧。</p>
<p>只要这步弄明白了，下面的操作就好理解了。在 <code>%ebp</code> 更新后，我们先分配一块0x12字节的空间用于存放本地变量，这步一般都是用 <code>sub</code> 或者 <code>mov</code> 指令实现。在这里使用的是 <code>movl</code>。通过使用 <code>mov</code> 配合 <code>-4(%ebp)</code>, <code>-8(%ebp)</code> 和 <code>-12(%ebp)</code> 我们便可以给 <code>a</code>, <code>b</code> 和 <code>c</code> 赋值了。</p>
<p><img src="https://segmentfault.com/img/remote/1460000007977467" alt="图五：本地变量赋值后的栈帧"></p>
<p>上面讲的都是函数的调用过程，我们现在来看看函数是如何返回的。从下面这个例子我们可以看出，和调用函数时正好相反。当函数完成自己的任务后，它会将 <code>%esp</code> 移到 <code>%ebp</code> 处，然后再弹出旧的 <code>%ebp</code> 的值到 <code>%ebp</code>。这样，<code>%ebp</code> 就恢复到了函数调用前的状态了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyFunction</span><span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其汇编大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_MyFunction:</span><br><span class="line">    push %ebp</span><br><span class="line">    movl %esp, %ebp</span><br><span class="line">    movl -12(%esp), %esp</span><br><span class="line">    ...</span><br><span class="line">    mov %ebp, %esp</span><br><span class="line">    pop %ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>我们注意到最后有一个 <code>ret</code> 指令，这个指令相当于 <code>pop + jum</code>。它首先将数据（返回地址）弹出栈并保存到 <code>%esp</code> 中，然后处理器根据这个地址无条件地跳到相应位置获取新的指令。</p>
<p><img src="https://segmentfault.com/img/remote/1460000007977468" alt="图六：被调用者返回后的栈帧"></p>
<p>到这里，C函数的调用过程就基本讲完了。函数的调用其实不难，只要搞懂了如何保存以及还原 <code>%ebp</code> 和 <code>%esp</code>，就能明白函数是如何通过栈帧进行调用和返回的了。</p>
<h6 id="20、时钟中断如何触发进程切换"><a href="#20、时钟中断如何触发进程切换" class="headerlink" title="20、时钟中断如何触发进程切换"></a>20、时钟中断如何触发进程切换</h6><p>一、Linux时钟系统</p>
<p>1.时钟硬件</p>
<p>  绝大多数的PC都有两个时钟源，RTC（实时时钟）和OS（系统时钟）。RTC也叫做CMOS时钟，它是PC主机板上的一块芯片。OS时钟产生于PC主板上的定时/计数芯片，由操作系统控制这个芯片的工作，OS 时钟的基本单位就是该芯片的计数周期。在系统上电启动的时候，会用RTC来初始化OS。OS 时钟只在开机时才有效，而且完全由操作系统控制，所以也被称为软时钟或系统时钟。OS 时钟所用的定时/计数芯片最典型的是 8253/8254 可编程定时/计数芯片。所以当然是以脉冲计数了，输出脉冲的周期叫做一个“时钟滴答”，计算机中的时间是以时钟滴答为单位的，每一次时钟滴答，系统时间就会加 1。操作系统根据当前时钟滴答的数目就可以得到以秒或毫秒等为单位的其他时间格式。</p>
<p><a href="https://s4.51cto.com/wyfs02/M02/08/26/wKiom1nc7JDyv9AjAAAskULi-o0043.png" target="_blank" rel="noopener"><img src="https://s4.51cto.com/wyfs02/M02/08/26/wKiom1nc7JDyv9AjAAAskULi-o0043.png" alt="wKiom1nc7JDyv9AjAAAskULi-o0043.png"></a></p>
<p>2.时钟运行机制</p>
<p><a href="https://s1.51cto.com/wyfs02/M02/08/26/wKiom1nc7M-AgBFmAAEDKBEgcRo105.png" target="_blank" rel="noopener"><img src="https://s1.51cto.com/wyfs02/M02/08/26/wKiom1nc7M-AgBFmAAEDKBEgcRo105.png" alt="wKiom1nc7M-AgBFmAAEDKBEgcRo105.png"></a></p>
<p>二、时钟中断</p>
<p>  Linux的OS时钟的物理产生原因是可编程定时/计数器产生的输出脉冲，这个脉冲送入CPU，就可以引发一个中断请求信号，我们就把它叫做时钟中断。</p>
<p>  每个时钟滴答，时钟中断得到执行。时钟中断执行的频率很高：100次/秒，时钟中断的主要工作是处理和时间有关的所有信息、决定是否执行调度程序。和时间有关的所有信息包括系统时间、进程的时间片、延时、使用 CPU 的时间、各种定时器，进程更新后的时间片为进程调度提供依据，然后在时钟中断返回时决定是否要执行调度程序。</p>
<p>三、Linux的调度程序—Schedule</p>
<p>1.调度原理</p>
<p>  进程运行需要各种各样的系统资源，如内存、文件、打印机和最宝贵的 CPU 等， 所以说，调度的实质就是资源的分配。 </p>
<p>  一个好的调度算法（时间片轮转调度算法、优先权调度算法、多级反馈队列调度、实时调度）应当考虑以下几个方面。<br>（1）公平：保证每个进程得到合理的 CPU 时间。<br>（2）高效：使 CPU 保持忙碌状态，即总是有进程在 CPU 上运行。<br>（3）响应时间：使交互用户的响应时间尽可能短。<br>（4）周转时间：使批处理用户等待输出的时间尽可能短。<br>（5）吞吐量：使单位时间内处理的进程数量尽可能多。</p>
<p>很明显，五个不可能同时满足，所以每种调度算法都是满足其中的一种或多种。</p>
<p>2.Linux进程调度时机</p>
<p>（1）进程状态转换的时刻：进程终止、进程睡眠；<br>（2）当前进程的时间片用完时（current-&gt;counter=0）；<br>（3）设备驱动程序；<br>（4）进程从中断、异常及系统调用返回到用户态时。</p>
<p>3.进程调度的依据</p>
<p>  调度程序运行时，要在所有处于可运行状态的进程之中选择最值得运行的进程投入运行。选择进程的依据是什么呢？在每个进程的 task_struct 结构中有如下 5 项：need_resched、nice、counter、policy 及rt_priority这五项在前面进程概念中介绍过,对于普通进程，选择进程的主要依据为counter 和nice 。对于实时进程，Linux采用了两种调度策略，即FIFO（先来先服务调度）和RR（时间片轮转调度）。因为实时进程具有一定程度的紧迫性，所以衡量一个实时进程是否应该运行，Linux 采用了一个比较固定的标准。实时进程的counter只是用来表示该进程的剩余滴答数，并不作为衡量它是否值得运行的标准，这和普通进程是有区别的。</p>
<p> 与其他操作系统一样，Linux 的时间单位也是“时钟滴答”，只是不同的操作系统对一个时钟滴答的定义不同而已 （Linux 设计者将一个 “时钟滴答” 定义为 10ms）。在这里，我们把 counter 叫做进程的时间片，但实际上它仅仅是时钟滴答的个数。</p>
<h6 id="21、用数组表示二叉树"><a href="#21、用数组表示二叉树" class="headerlink" title="21、用数组表示二叉树"></a>21、用数组表示二叉树</h6><p>传统的二叉树是使用链表的形式,其优点是便于插入和删除,但是查找速度很慢,占用空间也很大.所以现在用数组的形式来构建二叉树,节点存在数组中,而不是由引用相连,节点在数组中的位置对应它在树中的位置,下标为0 的节点为根节点,下标为1是根的左节点,2为根节点的右节点,依次类推,从左到右的顺序存储树的每一层,包括空节点.如下图:</p>
<p><img src="https://img-blog.csdn.net/20160708110724036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>找节点的子节点和父节点可以利用简单的算术计算它们在数组中的索引值</p>
<p>设某个节点索引值为index,则节点的左子节点索引为:</p>
<p><code>2*index+1</code></p>
<p>右子节点索引为:</p>
<p><code>2*index+2</code></p>
<p>父节点索引为:</p>
<p><code>(index-1)/2</code></p>
<p>大多数情况下用数组表示数不是很有效率,除非是完全二叉树.但是普通的二叉树,特别是有很多空节点的.会有很多空洞,浪费存储空间.用数组表示树,删除节点是很费时费力的.</p>
<p>所以用数组表示树适合用于 完全二叉树查找,和插入.下面是我自己写的代码,比较简单:</p>
<p>首先是用数组建立一个二叉树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Binary_tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Binary_tree* left;</span><br><span class="line">    Binary_tree*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_tree</span><span class="params">(Binary_tree*tree,<span class="keyword">int</span> a[],<span class="keyword">int</span> len,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&gt;len)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    tree=<span class="keyword">new</span> Binary_tree;</span><br><span class="line">    tree-&gt;data=a[index];</span><br><span class="line">    tree-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    create_tree(tree-&gt;left, a, len, <span class="number">2</span> * index + <span class="number">1</span>)</span><br><span class="line">    create_tree(tree-&gt;right, a, len, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用数组的形式表示二叉树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAYTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYTREE_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ArrayTree(<span class="keyword">int</span> size,<span class="keyword">int</span> *pRoot);</span><br><span class="line">    ~ArrayTree();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">searchNode</span><span class="params">(<span class="keyword">int</span> nodeIndex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> nodeIndex,<span class="keyword">int</span> direction,<span class="keyword">int</span> *node)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> nodeIndex,<span class="keyword">int</span> *node)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">treeTraverse</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>*m_pTree;</span><br><span class="line">    <span class="keyword">int</span> m_isize;</span><br><span class="line">&#125;</span><br><span class="line">ArrayTree::ArrayTree(<span class="keyword">int</span> size,<span class="keyword">int</span> *pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    m_isize=size;</span><br><span class="line">    m_pTree = <span class="keyword">new</span> <span class="keyword">int</span>[m_iSize];</span><br><span class="line">    r(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; m_iSize;i++)</span><br><span class="line">        m_pTree[i] = <span class="number">0</span>;</span><br><span class="line">    m_pTree[<span class="number">0</span>]=*pRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayTree::~ArrayTree()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_pTree;</span><br><span class="line">    m_pTree = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">searchNode</span><span class="params">(<span class="keyword">int</span> nodeIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nodeIndex&lt;<span class="number">0</span>||nodeIndex&gt;=m_isize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(m_pTree[nodeIndex]==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;m_pTree[nodeIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ArrayTree::addNode(<span class="keyword">int</span> nodeIndex,<span class="keyword">int</span> direction,<span class="keyword">int</span> *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(nodeIndex&lt;<span class="number">0</span>||nodeIndex&gt;=m_isize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>:</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">2</span>*nodeIndex+direction;</span><br><span class="line">    <span class="keyword">if</span>(index&gt;=m_isize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    m_pTree[index]=*node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ArrayTree::delNode(<span class="keyword">int</span> nodeIndex)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nodeIndex &lt; <span class="number">0</span> || nodeIndex &gt;= m_iSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(m_pTree[nodeIndex] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    m_pTree[nodeIndex] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index=nodeIndex*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index1=nodeIndex*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(m_pTree[index]!=<span class="literal">NULL</span>)</span><br><span class="line">        delNode(index);</span><br><span class="line">    <span class="keyword">if</span>(m_pTree[index1]!=<span class="literal">NULL</span>)</span><br><span class="line">        delNode(index1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ArrayTree::treeTraverse()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m_iSize;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m_pTree[i]&lt;&lt;<span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="22、TOPK问题"><a href="#22、TOPK问题" class="headerlink" title="22、TOPK问题"></a>22、TOPK问题</h6><p>面试中，TopK，是问得比较多的几个问题之一，到底有几种方法，这些方案里蕴含的优化思路究竟是怎么样的，今天和大家聊一聊。</p>
<p><em>画外音：</em> <em>除非校招，我在面试过程中从不问TopK这个问题，默认大家都知道。</em></p>
<p><strong>问题描述</strong>：</p>
<p>从<code>arr[1, n]</code>这n个数中，找出最大的k个数，这就是经典的TopK问题。 </p>
<p><strong>栗子</strong>：</p>
<p>从<code>arr[1, 12]={5,3,7,1,8,2,9,4,7,2,6,6}</code> 这<code>n=12个</code>数中，找出最大的<code>k=5</code>个。</p>
<p><strong>一、排序</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f63b5392d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>排序是最容易想到的方法，将n个数排序之后，取出最大的k个，即为所得</p>
<p><strong>伪代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort(arr, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">1</span>, k];</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：<code>O(n*lg(n))</code></p>
<p><strong>分析</strong>：明明只需要TopK，却将全局都排序了，这也是这个方法复杂度非常高的原因。那能不能不全局排序，而只局部排序呢？ 这就引出了第二个优化方法。</p>
<p><strong>二、局部排序</strong></p>
<p>不再全局排序，只对最大的k个排序。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f6398efd6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>冒泡是一个很常见的排序方法，每冒一个泡，找出最大值，冒k个泡，就得到TopK。</p>
<p><strong>伪代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span> to k)&#123;</span><br><span class="line">       bubble_find_max(arr,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">1</span>, k];</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：<code>O(n*k)</code></p>
<p><strong>分析</strong>：冒泡，将全局排序优化为了局部排序，非TopK的元素是不需要排序的，节省了计算资源。不少朋友会想到，需求是TopK，是不是这最大的k个元素也不需要排序呢？ 这就引出了第三个优化方法。</p>
<p><strong>三、堆</strong></p>
<p><strong>思路</strong>：只找到TopK，不排序TopK。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f63ab4ba7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f63a8839a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f7b5e35f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>直到，扫描完所有n-k个元素，最终堆中的k个元素，就是猥琐求的TopK。</p>
<p><strong>伪代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = make_heap(arr[<span class="number">1</span>, k]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=k+<span class="number">1</span> to n)&#123;</span><br><span class="line">        adjust_heap(heep[k],arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> heap[k];</span><br></pre></td></tr></table></figure>



<p><strong>时间复杂度</strong>：<code>O(n*lg(k))</code></p>
<p><em>画外音：n个元素扫一遍，假设运气很差，每次都入堆调整，调整时间复杂度为堆的高度，即lg(k)，故整体时间复杂度是n\</em>lg(k)。 </p>
<p><strong>分析</strong>：堆，将冒泡的TopK排序优化为了TopK不排序，节省了计算资源。堆，是求TopK的经典算法，那还有没有更快的方案呢？</p>
<p><strong>四、随机选择</strong></p>
<p>随机选择算在是《算法导论》中一个经典的算法，其时间复杂度为O(n)，是一个线性复杂度的方法。</p>
<p>这个方法并不是所有同学都知道，为了将算法讲透，先聊一些前序知识，一个所有程序员都应该烂熟于胸的经典算法：快速排序。</p>
<p><em>画外音：</em></p>
<p><em>（1）如果有朋友说，“不知道快速排序，也不妨碍我写业务代码呀”…额…</em></p>
<p><em>（2）除非校招，我在面试过程中从不问快速排序，默认所有工程师都知道；</em></p>
<p><strong>其伪代码是</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, inthigh)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low== high) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> i = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">         quick_sort(arr, low, i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">         quick_sort(arr, i+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心算法思想是，分治法</p>
<p><strong>分治法</strong>（Divide&amp;Conquer），把一个大的问题，转化为若干个子问题 （Divide），每个子问题“<strong>都</strong>”解决，大的问题便随之解决（Conquer）。这里的关键词是<strong>“都”</strong>。从伪代码里可以看到，快速排序递归时，先通过partition把数组分隔为两个部分，两个部分“都”要再次递归。</p>
<p>分治法有一个特例，叫减治法。</p>
<p><strong>减治法</strong>（Reduce&amp;Conquer），把一个大的问题，转化为若干个子问题 （Reduce），这些子问题中“<strong>只</strong>”解决一个，大的问题便随之解决（Conquer）。这里的关键词是<strong>“只”</strong>。</p>
<p><strong>二分查找binary_search</strong>，BS，是一个典型的运用 减治法思想的算法，其伪代码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BS</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, inthigh, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(low&gt; high) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">         mid= (low+high)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[mid]== target) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(arr[mid]&gt; target)</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">return</span> BS (arr, low, mid<span class="number">-1</span>, target);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">return</span> BS (arr, mid+<span class="number">1</span>, high, target);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从伪代码可以看到，二分查找，一个大的问题，可以用一个mid元素，分成左半区，右半区两个子问题。而左右两个子问题，只需要解决其中一个，递归一次，就能够解决二分查找全局的问题。</p>
<p>通过分治法与减治法的描述，可以发现，分治法的复杂度一般来说是大于减治法的：</p>
<p>快速排序：<code>O(n*lg(n))</code></p>
<p>二分查找：<code>O(lg(n))</code></p>
<p>话题收回来，<strong>快速排序</strong>的核心是：</p>
<p><code>i = partition(arr, low, high);</code></p>
<p><strong>这个partition是干嘛的呢？</strong></p>
<p>顾名思义，partition会把整体分为两个部分。</p>
<p>更具体的，会用数组arr中的一个元素（默认是第一个元素t=arr[low]）为划分依据，将数据arr[low, high]划分成左右两个子数组：</p>
<ul>
<li>左半部分，都比t大</li>
<li>右半部分，都比t小</li>
<li>中间位置i是划分元素</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f7c00aa05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>以上述TopK的数组为例，先用第一个元素t=arr[low]为划分依据，扫描一遍数组，把数组分成了两个半区：</p>
<ul>
<li>左半区比t大</li>
<li>右半区比t小</li>
<li>中间是t</li>
</ul>
<p>partition返回的是t最终的位置i。 </p>
<p>很容易知道，partition的时间复杂度是<code>O(n)</code>。</p>
<p><em>画外音：把整个数组扫一遍，比t大的放左边，比t小的放右边，最后t放在中间N[i]。</em></p>
<p><strong>partition和TopK问题有什么关系呢？</strong></p>
<p>TopK是希望求出arr[1,n]中最大的k个数，那如果找到了<strong>第k大</strong> 的数，做一次partition，不就一次性找到最大的k个数了么？</p>
<p><em>画外音：即partition后左半区的k个数。</em></p>
<p>问题变成了arr[1, n]中找到第k大的数。</p>
<p>再回过头来看看<strong>第一次</strong>partition，划分之后：</p>
<p>i = partition(arr, 1, n);</p>
<ul>
<li>如果i大于k，则说明arr[i]左边的元素都大于k，于是只递归arr[1, i-1]里第k大的元素即可；</li>
<li>如果i小于k，则说明说明第k大的元素在arr[i]的右边，于是只递归arr[i+1, n]里第k-i大的元素即可；</li>
</ul>
<p><em>画外音：这一段非常重要，多读几遍。</em></p>
<p>这就是<strong>随机选择</strong>算法randomized_select，RS，其伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RS</span><span class="params">(arr, low, high, k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(low== high) <span class="keyword">return</span> arr[low];</span><br><span class="line"></span><br><span class="line">  i= partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">  temp= i-low; <span class="comment">//数组前半部分元素个数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(temp&gt;=k)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> RS(arr, low, i<span class="number">-1</span>, k); <span class="comment">//求前半部分第k大</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> RS(arr, i+<span class="number">1</span>, high, k-i); <span class="comment">//求后半部分第k-i大</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f7d503df1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>这是一个典型的减治算法，递归内的两个分支，最终只会执行一个，它的时间复杂度是O(n)。</p>
<p>再次强调一下：</p>
<ul>
<li><strong>分治法</strong>，大问题分解为小问题，小问题都要递归各个分支，例如：快速排序</li>
<li><strong>减治法</strong>，大问题分解为小问题，小问题只要递归一个分支，例如：二分查找，随机选择</li>
</ul>
<p>通过随机选择（randomized_select），找到arr[1, n]中第k大的数，再进行一次partition，就能得到TopK的结果。</p>
<p><strong>五、总结</strong></p>
<p>TopK，不难；其思路优化过程，不简单：</p>
<ul>
<li><strong>全局排序</strong>，O(n*lg(n))</li>
<li><strong>局部排序</strong>，只排序TopK个数，O(n*k)</li>
<li><strong>堆</strong>，TopK个数也不排序了，O(n*lg(k))</li>
<li>分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n))</li>
<li>减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n)</li>
<li>TopK的另一个解法：<strong>随机选择</strong>+partition</li>
</ul>
<h6 id="23、UDP-和TCP的区别"><a href="#23、UDP-和TCP的区别" class="headerlink" title="23、UDP 和TCP的区别"></a>23、UDP 和TCP的区别</h6><p>TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。</p>
<p>　　<strong>对于可靠性，TCP通过以下方式进行保证：</strong></p>
<p><strong>数据包校验：</strong></p>
<p>目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p>
<p><strong>对失序数据包重排序：</strong></p>
<p>既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p>
<p><strong>丢弃重复数据：</strong></p>
<p>对于重复数据，能够丢弃重复数据；</p>
<p><strong>应答机制</strong>：</p>
<p>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>
<p><strong>超时重发</strong>：</p>
<p>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>
<p><strong>流量控制</strong>：</p>
<p>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的<strong>滑动窗口协议。</strong></p>
<p><strong>一、UDP与TCP</strong></p>
<p>UDP（User Datagram Protocol用户数据报协议）是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP采用了流量控制、拥塞控制、连续ARQ（Automatic Repeat Request自动重传请求）等技术来保证它的可靠性。</p>
<p>Redis客户端与Redis服务器之间使用TCP协议进行连接，极光推送内部原理也是基于TCP的长连接。</p>
<p><strong>二：UDP应用场景</strong></p>
<p>1、面向数据报方式；2、网络数据大多为短消息；3、拥有大量Client；4、对数据安全性无特殊要求；5、网络负担非常重，但对响应速度要求高。</p>
<p><strong>三：TCP连接与套接字</strong></p>
<p>TCP连接是一种抽象的概念，表示一条可以通信的链路。每条TCP连接有且仅有两个端点，表示通信的双方。且双方在任意时刻都可以作为发送者和接收者。</p>
<p>一条TCP连接的两端就是两个套接字。套接字=IP地址:端口号。因此，TCP连接=（套接字1，套接字2）=（IP1:端口号1，IP2:端口号2）</p>
<p><strong>四：TCP与UDP的基本区别</strong></p>
<p>1、TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付<br>3、<strong>TCP面向字节流，TCP把数据看成一连串无结构的字节流；UDP是面向报文的</strong><br>4、UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等），但网络拥塞时有些报文可能会丢失（所以不可靠）<br>5、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信<br>6<strong>、TCP首部开销20字节；UDP的首部开销小，只有8个字节</strong><br>7、要求比较高的服务一般使用TCP协议，如FTP、Telnet、HTTP、SMTP（Simple Mail Transfer Protocol简单邮件传输协议）、POP3等，而UDP是面向无连接的，使用这个协议的常见服务有DNS（Domain Name System，域名系统）、SNMP(Simple Network Management Protocol，简单网络管理协议)</p>
<p><strong>TCP对应的协议：</strong></p>
<p>（1） FTP：定义了文件传输协议，使用21端口<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口<br>（5） HTTP：是从Web服务器传输超文本到本地浏览器的传送协议</p>
<p><strong>UDP对应的协议：</strong></p>
<p>（1） DNS：用于域名（主机名）解析服务，将域名地址转换为IP地址。DNS用的是53号端口<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势</p>
<p><strong>五：编程区别</strong></p>
<p>通常我们在说到网络编程时默认是指TCP编程，即用前面提到的socket函数创建一个socket用于TCP通讯，函数参数我们通常填为SOCK_STREAM。即socket(PF_INET, SOCK_STREAM, 0)，这表示建立一个socket用于流式网络通讯。<br>SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，也是双向的，即任何一方都可以收发数据，协议本身提供了一些保障机制保证它是可靠的、有序的，即每个包按照发送的顺序到达接收方。<br>而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的，因为通讯双方发送数据后不知道对方是否已经收到数据，是否正常收到数据。任何一方建立一个socket以后就可以用sendto发送数据，也可以用recvfrom接收数据。根本不关心对方是否存在，是否发送了数据。它的特点是通讯速度比较快。大家都知道TCP是要经过三次握手的，而UDP没有。</p>
<p><strong>socket编程：</strong></p>
<p>Socket用在哪呢，主要用在进程间，网络间通信。所谓socket 通常也称作”套接字“，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。一条TCP连接的两端就是两个套接字（套接字=IP地址：端口号）<br>Socket和ServerSocket类库位于java.net包中。ServerSocket用于服务器端，Socket是建立网络连接时使用的。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别。不管是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的。<br>Accept方法用于产生”阻塞”，直到接受到一个连接，并且返回一个客户端的Socket对象实例。”阻塞”是一个术语，它使程序运行暂时”停留”在这个地方，直到一个会话产生，然后程序继续；通常”阻塞”是由循环产生的。<br>getInputStream方法获得网络连接输入，同时返回一个InputStream对象实例。<br>getOutputStream方法连接的另一端将得到输入，同时返回一个OutputStream对象实例。</p>
<p>注意：其中getInputStream和getOutputStream方法均会产生一个IOException，它必须被捕获，因为它们返回的流对象，通常都会被另一个流对象使用。</p>
<p><strong>TCP：</strong></p>
<p>TCP编程的服务器端一般步骤是：</p>
<p>1、创建一个socket，用函数socket()；<br>2、设置socket属性，用函数setsockopt(); * 可选<br>3、绑定IP地址、端口等信息到socket上，用函数bind();<br>4、开启监听，用函数listen()；<br>5、接收客户端上来的连接，用函数accept()；<br>6、收发数据，用函数send()和recv()，或者read()和write();<br>7、关闭网络连接；<br>8、关闭监听；</p>
<p>TCP编程的客户端一般步骤是：</p>
<p>1、创建一个socket，用函数socket()；<br>2、设置socket属性，用函数setsockopt();* 可选<br>3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>4、设置要连接的服务器的IP地址和端口等属性；<br>5、连接服务器，用函数connect()；<br>6、收发数据，用函数send()和recv()，或者read()和write();<br>7、关闭网络连接；</p>
<p><strong>UDP：</strong></p>
<p>UDP编程的服务器端一般步骤是：</p>
<p>　　1、创建一个socket，用函数socket()；</p>
<p>　　2、设置socket属性，用函数setsockopt();* 可选</p>
<p>　　3、绑定IP地址、端口等信息到socket上，用函数bind();</p>
<p>　　4、循环接收数据，用函数recvfrom();</p>
<p>　　5、关闭网络连接；</p>
<p>UDP编程的客户端一般步骤是：</p>
<p>　　1、创建一个socket，用函数socket()；</p>
<p>　　2、设置socket属性，用函数setsockopt();* 可选</p>
<p>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选</p>
<p>　　4、设置对方的IP地址和端口等属性;</p>
<p>　　5、发送数据，用函数sendto();</p>
<p>　　6、关闭网络连接；</p>
<p><span style="color:red">大多数TCP服务器是并发的，大多数UDP服务器是迭代的。</span></p>
<p>如果服务一个客户请求的时间不长，使用迭代服务器没有太大问题，一旦客户请求的时间需要花费很长，不希望整个服务器被单个客户长期占用，而希望同事服务多个客户，就需要选择并发服务器了。</p>
<h6 id="24、面向字节流和面向报文的区别"><a href="#24、面向字节流和面向报文的区别" class="headerlink" title="24、面向字节流和面向报文的区别"></a>24、面向字节流和面向报文的区别</h6><p>面向报文（UDP）和面向字节流（TCP）的区别</p>
<p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。<br>面向字节流的话，<strong>虽然应用程序和TCP的交互是一次一个数据块（</strong>大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p>
<h6 id="25、sizeof数组的值"><a href="#25、sizeof数组的值" class="headerlink" title="25、sizeof数组的值"></a>25、sizeof数组的值</h6><p><img src="/Moonstar-Z.github.io/.com//C:%5CUsers%5CCCTVZYX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568838258773.png" alt="1568838258773"></p>
<h6 id="26、int-、long在32和64位下的长度"><a href="#26、int-、long在32和64位下的长度" class="headerlink" title="26、int 、long在32和64位下的长度"></a>26、int 、long在32和64位下的长度</h6><p><img src="/Moonstar-Z.github.io/.com//C:%5CUsers%5CCCTVZYX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568838315710.png" alt="1568838315710"></p>
<h6 id="27、malloc一次性最大能申请多大内存空间？"><a href="#27、malloc一次性最大能申请多大内存空间？" class="headerlink" title="27、malloc一次性最大能申请多大内存空间？"></a>27、malloc一次性最大能申请多大内存空间？</h6><p>malloc是一个库函数，不同的操作系统上具体实现细节是不同的，以下就以linux条件下进行分析：linux采用的是glibc中堆内存管理ptmalloc实现，虚拟内存的布局规定了malloc申请位置以及大小，malloc一次性能申请小内存（小于128KB），分配的是在堆区（heap），用sbrk()进行对齐生长，而malloc一次性申请大内存（大于128KB时）分配到的是在映射区，而不是在堆区，<strong>采用的mmap()系统调用进行映射。当然虚拟地址只是规定了一种最理想的状态，实际分配还是要考虑到物理内存加交换内存总量的限制，因为每次分配，特别是大内存分配采用mmap（）映射内存需要记录物理内存加交换内存地址，所有物理内存加交换内存限制了malloc实际分配</strong>。比如32位情况下，最新版本的linux的映射区在用户空间区的3G位置，而映射区向下生长，所以理想情况下大概能有2.9GB（除去开始地址128M）,如果你的物理内存加交换区只有2G，malloc一次申请最多1.8G左右，如果你的物理内存加交换区大于4G，那么最多能有2.9G或者2.8G左右。网上能找到测试代码的。</p>
<h6 id="28、全局变量和静态变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"><a href="#28、全局变量和静态变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？" class="headerlink" title="28、全局变量和静态变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？ 　　"></a>28、全局变量和静态变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？ 　　</h6><p>1) 全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>
<p>2) 从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。</p>
<p>3) static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件</p>
<h6 id="29、进程和线程区别，线程共享哪些资源，独占哪些资源"><a href="#29、进程和线程区别，线程共享哪些资源，独占哪些资源" class="headerlink" title="29、进程和线程区别，线程共享哪些资源，独占哪些资源"></a>29、进程和线程区别，线程共享哪些资源，独占哪些资源</h6><h6 id="30、讲讲IO复用，epoll为什么比select效率高"><a href="#30、讲讲IO复用，epoll为什么比select效率高" class="headerlink" title="30、讲讲IO复用，epoll为什么比select效率高"></a>30、讲讲IO复用，epoll为什么比select效率高</h6><p>epoll_data是一个union结构体,它就是epoll版大妈用于保存同学信息的结构体,它可以保存很多类型的信息:fd,指针,等等.有了这个结构体,epoll大妈可以不用吹灰之力就可以定位到同学甲.</p>
<p>别小看了这些效率的提高,在一个大规模并发的服务器中,轮询IO是最耗时间的操作之一.再回到那个例子中,如果每到来一个朋友楼管大妈都要全楼的查询同学,那么处理的效率必然就低下了,过不久楼底就有不少的人了.</p>
<p>对比最早给出的阻塞IO的处理模型, 可以看到采用了多路复用IO之后, 程序可以自由的进行自己除了IO操作之外的工作, 只有到IO状态发生变化的时候由多路复用IO进行通知, 然后再采取相应的操作, 而不用一直阻塞等待IO状态发生变化了.</p>
<p>从上面的分析也可以看出,epoll比select的提高实际上是一个用空间换时间思想的具体应用.</p>
<p>epoll在高并发的情况下，比poll和select的效率要高出很多。比如说淘宝的服务器用的就是epoll。淘宝的访问量就非常大，要如何支持高并发呢？用的就是linux的epoll实现的。要了解epoll，还得从select慢慢看起，而且select也有它的适用情况，比如就使用于局域网下，客户端最多就1000台，那么使用select就比较好，又容易，开销又小</p>
<p>select：主要就是起一个监听的作用。也就是监听多个文件描述符。</p>
<p>在多线程多进程情况时，我们是这样处理连接进来的socket的：</p>
<p><img src="https://pic3.zhimg.com/80/v2-49e0d29ba45efa4d359681c647063e5a_hd.jpg" alt="img"></p>
<p>中间的数组是文件描述符集合，里面都是socket的文件描述符。然后一个线程或进程调用accept进行阻塞监听，然后来了一个连接后，就创建新的进程或者线程去对应该连接，然后就有了新的文件描述符。新的文件描述符就是负责和连接通信的，比如读写什么的，就不是accept新的进程线程了。这种情况下，当客户端没有发数据来服务端，那么对应的线程和进程会一直处于阻塞状态，它要读取该文件描述符，可是却数据，所以一直不返回。而很多情况下，客户端和服务端的数据量传输都是比较少的，所以就有大量的进程或线程处于阻塞状态，这样就会非常耗费系统的资源。</p>
<p>上面就是没有select，poll，epoll的时候的处理方式。</p>
<p>而select是这样的，如下图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4f5057199f22b90350bd748e89453b1b_hd.jpg" alt="img"></p>
<p>select只在一个线程内运行，但它可以监视多个文件描述符，这样就不需要另外的进程和线程资源了。然后我们来叙述一下select的一个比较完整的运行流程：如下图：</p>
<p><img src="https://pic3.zhimg.com/80/v2-0b8e3969800ba34c819104ea153543e6_hd.jpg" alt="img"></p>
<p>我来慢慢解释：socket文件描述符在这里分两种，一种是用于接收外面的socket的，另一种是和外面的socket进行通信的。比如上图中，文件描述符7就是用于接收请求连接的客户端，4，5，6，8都是直接和外面的socket通信的。我们先把4，5，6，7都挂载到select上，也就是说当文件描述符4，5，6，7任一个处于就绪状态的时候，就会反应到select上，什么时候文件描述符处于就绪状态呢？就是当外面发送数据进来，然后文件描述符这里有数据要读，或者文件描述符这边有请求连接的链接，那么select就会去遍历自己对应的文件描述符集合，看看到底是哪个文件描述符有反应了，<strong>select返回的是就绪的文件描述符的个数</strong>，如果是7有反应了，那么就调用accept函数去接收新的连接，然后分配新的文件描述符8给对应的连接，然后再把文件描述符8挂载到这个select上。如果是4，5，6上有反应了，那么就调用read函数，去读取文件描述符上的数据。当select返回后一般还会继续运行select，也就是说放在死循环里，然后继续处于阻塞状态，等待响应。 这里有个瓶颈：就是比如select在处理文件描述符4的时候，文件描述符5又来了数据，那么select就不能处理。这个看视频没有注意到答案？？？</p>
<p>这就是<strong>多路IO转接</strong>了，相信大家应该有理解了吧？如果大家对java的nio框架netty有所熟悉的话，应该就很容易理解了。虽然netty在linux上底层使用的是epoll，但是模型是一样的，有兴趣的可以了解一下：<a href="https://zhuanlan.zhihu.com/c_1040914558763941888" target="_blank" rel="noopener">netty学习</a> 。</p>
<p>这里要注意select的一个缺陷：</p>
<p>1.select能监听的文件描述符个数受限于FD_ SETSIZE,一 般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数。（一个进程能打开的文件描述符的个数就是1024）</p>
<p>2.解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力</p>
<p>然后我们再来看看select函数的声明：</p>
<p>int select(int nfds, fd_ set *readfds, fd_ set *wr itefds,fd_ set *exceptfds, struct timeval *t imeout);</p>
<p>nfds:监控的文件描述符集里最大文件描述符加1,因为此参数会告诉内核检测前多少个文件描述符的状态</p>
<p>（比如刚才那副图中，文件描述符最大是8，所以这个值就是9）</p>
<p>readfds :监控有读数据到达文件描述符集合，传入传出参数</p>
<p>writefds :监控写数据到达文件描述符集合，传入传出参数</p>
<p>exceptfds :监控异常发生到达文件描述符集合,如带外数据到达异常，传入传出参数</p>
<p>（上面三个参数的意思就是：文件描述符有三种方式可以触发select的响应，需要读数据的时候，需要写数据的时候，发送异常的时候，比如说文件描述符4只存在于读数据的集合中，那么select只在4需要读数据的就绪情况下产生反应，其它情况都不产生反应，这样就显得更加灵活）</p>
<p>timeout :定时阻塞监控时间，3种情况</p>
<p>1.NULL，永远等下去</p>
<p>2.设置timeval,等待固定时间</p>
<p>3.设置timeval里时间均为0，检查描述字后立即返回，轮询</p>
<p>（跟java中的wait一个机制，语义理解就好）</p>
<p>所以，这个select就讲到这里了，学习这个能看懂别人的代码就好，或者用于局域网的几台机器即可，不需要要求太高。</p>
<p>（大家可以去看视频看看代码的演示效果，也就是使用select之后就可以一个进程线程对应多个进程线程的连接了）</p>
<p>poll:</p>
<p>就我的大致了解看来，和select没什么大的区别，就是这里没发现说没有最大连接数的限制了。</p>
<p>如下图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-e3e36c9b14933b7b6825afc260170bb3_hd.jpg" alt="img"></p>
<p>第一感觉就是构造形式不同，它传入的是pollfd的结构体数组，一个结构体里，fd是文件描述符号，events是此文件描述符监控的事件，比如前面提到的读数据，写数据，异常。revents是返回的事件，比如此文件符监控读数据和写数据，那么读数据发生时，就会从这里返回。</p>
<p>感觉可能是自己现在的基础比较少，后面有了足够的基础后再来好好看看。</p>
<p>epoll:</p>
<p>epoll是Linux下多路复用IO接口se1ect/poll的增强版本，它能<strong>显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率</strong>，因为它会<strong>复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合</strong>，另一点原因就是获取事件的时候，它<strong>无须遍历整个被侦听的描述符集，只要遍历那些被内核I0事件异步唤醒而加入Ready队列的描述符集合就行</strong>了。</p>
<p>​    epoll:</p>
<p>epoll是Linux下多路复用IO接口se1ect/poll的增强版本，它能<strong>显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率</strong>，因为它会<strong>复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合</strong>，另一点原因就是获取事件的时候，它<strong>无须遍历整个被侦听的描述符集，只要遍历那些被内核I0事件异步唤醒而加入Ready队列的描述符集合就行</strong>了。</p>
<p>解释一下上面这段话：”复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合“ 也就是说，比如select函数响应返回之后，传入的参数，即监听的文件描述符集合需要重新准备，然后再传入。而epoll就不需要再重新准备传入的参数。</p>
<p>“无须遍历整个被侦听的描述符集，只要遍历那些被内核I0事件异步唤醒而加入Ready队列的描述符集合就行” 这句话的意思是：</p>
<p>如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-2cd162d5f176bb06233ec3159aa0f448_hd.jpg" alt="img"></p>
<p>比如左边的就是传入的要监控的文件描述符集合。select和epoll返回了就绪的文件描述符的个数，但是不知道是哪个文件描述符，所以它需要遍历一遍去一一确认。而epoll就是用一个队列存储了这些就绪的文件描述符，直接遍历这个队列即可。这表示了什么？比如说有10万个要监控的文件描述符集合，然后只有三个文件描述符就绪了（或者说三个文件描述符是活跃的），如果是select或epoll,那么他们就需要遍历这10万个文件描述符（应该是满3个了就结束了吧，但是哪个就绪也不确定，如果是最后的那不就凉凉），这就消耗了很大的系统资源。而epoll只需要遍历这个只存储了三个元素的队列即可，这就跟开了挂一样。所以，这就显示出了它能<strong>显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</strong>如果是10万的文件描述符，有8万的活跃文件描述符，那么epoll就显示不出比较大的优越性了。所以，并没有绝对的要使用哪个函数，取决于并发量和数据量。</p>
<p><strong>select的几大缺点：</strong></p>
<p><strong>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大（因为在内核才能监听那些数据，也就是操作文件描述符的读写）</strong></p>
<p><strong>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p>
<p><strong>（3）select支持的文件描述符数量太小了，默认是1024</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-4a0e2948e47c619bc10c4ceb5119db88_hd.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-c804d66ee794fdd113a7cdd003db6f8a_hd.jpg" alt="img"></p>
<p>二 工作模式</p>
<p>　epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<ol>
<li>LT模式</li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ol start="2">
<li>ET模式</li>
</ol>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h6 id="31、浏览器输入一个URL会发生什么"><a href="#31、浏览器输入一个URL会发生什么" class="headerlink" title="31、浏览器输入一个URL会发生什么"></a>31、浏览器输入一个URL会发生什么</h6><p><strong>1、</strong>查询DNS，获取域名对应的IP。</p>
<p>（1）检查本地hosts文件是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。 </p>
<p>（2）如果没有，则查找本地DNS解析器缓存是否有这个网址的映射，如果有，返回映射，解析完成。 </p>
<p>（3）如果没有，则查找填写或分配的首选DNS服务器，称为本地DNS服务器。服务器接收到查询时：</p>
<ul>
<li>如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。 </li>
<li>如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。</li>
</ul>
<p>（4）如果本地DNS服务器也失效：  </p>
<ul>
<li>如果未采用转发模式（迭代），本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如<a href="https://link.zhihu.com/?target=http%3A//baidu.com" target="_blank" rel="noopener">http://baidu.com</a>）的IP给本地DNS服务器，循环往复直至查询到映射，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。</li>
<li>如果采用转发模式（递归），则此DNS服务器就会把请求转发至上一级DNS服务器，如果上一级DNS服务器不能解析，则继续向上请求。最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。</li>
</ul>
<p><strong>2、</strong>客户机发送HTTP请求报文：</p>
<p>（1）应用层：客户端发送HTTP请求报文</p>
<p>（2）传输层：切分长数据，并确保可靠性。</p>
<p>（3）网络层：进行路由</p>
<p>（4）数据链路层：传输数据</p>
<p>（5）物理层：物理传输bit</p>
<p><strong>3、</strong>服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。</p>
<p><strong>4、</strong>客户端解析HTTP响应报文</p>
<p><strong>5、</strong>浏览器开始显示HTML</p>
<p><strong>6、</strong>浏览器重新发送请求获取图片、CSS、JS的数据。</p>
<p><strong>7、</strong>如果有AJAX，浏览器发送AJAX请求，及时更新页面</p>
<p><img src="https://img-blog.csdn.net/20180421153546225" alt="img"></p>
<h6 id="32、类的什么函数不能为虚函数"><a href="#32、类的什么函数不能为虚函数" class="headerlink" title="32、类的什么函数不能为虚函数"></a>32、类的什么函数不能为虚函数</h6><p>1：只有类的成员函数才能说明为虚函数；<br><strong>2：静态成员函数不能是虚函数；</strong><br><strong>3：内联函数不能为虚函数；</strong> </p>
<p><strong>4：构造函数不能是虚函数；</strong><br>5：析构函数可以是虚函数，而且通常声明为虚函数。</p>
<h6 id="33、什么时候需要自己定义拷贝构造函数"><a href="#33、什么时候需要自己定义拷贝构造函数" class="headerlink" title="33、什么时候需要自己定义拷贝构造函数"></a>33、什么时候需要自己定义拷贝构造函数</h6><p>如果你需要定义一个非空的析构函数，那么，通常情况下你也需要定义一个拷贝构造函数。</p>
<h6 id="34、纯虚函数有什么用"><a href="#34、纯虚函数有什么用" class="headerlink" title="34、纯虚函数有什么用"></a>34、纯虚函数有什么用</h6><p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。而针对每种动物的方法又有所不同，此时需要使用多态特性，也就需要在基类中定义虚函数。</p>
<p>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。</p>
<p>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
<p>含有纯虚函数的类称之为抽象类，它不能生成对象（创建实例），只能创建它的派生类的实例。抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。</p>
<p>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<h6 id="35、有哪几种情况只能用intialization-list-而不能用assignment"><a href="#35、有哪几种情况只能用intialization-list-而不能用assignment" class="headerlink" title="35、有哪几种情况只能用intialization list 而不能用assignment?"></a>35、<strong>有哪几种情况只能用intialization list 而不能用assignment?</strong></h6><p>   当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。</p>
<h6 id="36、main-函数执行以前，还会执行什么代码？"><a href="#36、main-函数执行以前，还会执行什么代码？" class="headerlink" title="36、main 函数执行以前，还会执行什么代码？"></a>36、<strong>main 函数执行以前，还会执行什么代码？</strong></h6><p>   全局对象的构造函数会在main 函数之前执行。</p>
<h6 id="37、请说出const与-define-相比，有何优点？"><a href="#37、请说出const与-define-相比，有何优点？" class="headerlink" title="37、请说出const与#define 相比，有何优点？"></a>37、<strong>请说出const与#define 相比，有何优点？</strong></h6><p>const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</p>
<p>1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</p>
<p>2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p>
<h6 id="38、简述数组与指针的区别？"><a href="#38、简述数组与指针的区别？" class="headerlink" title="38、简述数组与指针的区别？"></a>38、<strong>简述数组与指针的区别？</strong></h6><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</p>
<p>(1)修改内容上的差别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”;</span><br><span class="line">a[<span class="number">0</span>] = ‘X’;</span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误，运行时错误</span></span><br></pre></td></tr></table></figure>

<p>(2) 用运算符sizeof 可以计算出数组的容量（字节数）。</p>
<p>sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</p>
<p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br><span class="line">计算数组和指针的内存容量</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="39、int-s-10-int-表示的是什么？"><a href="#39、int-s-10-int-表示的是什么？" class="headerlink" title="39、int (*s[10])(int) 表示的是什么？"></a>39、<strong>int (*s[10])(int) 表示的是什么？</strong></h6><p>int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。</p>
<h6 id="40、栈和文字常量区"><a href="#40、栈和文字常量区" class="headerlink" title="40、栈和文字常量区"></a>40、栈和文字常量区</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">char</span> str2[] = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">const</span> <span class="keyword">char</span> str3[] = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">const</span> <span class="keyword">char</span> str4[] = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">const</span> <span class="keyword">char</span> *str5 = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">const</span> <span class="keyword">char</span> *str6 = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">char</span> *str7 = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">char</span> *str8 = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="built_in">cout</span> &lt;&lt; ( str1 == str2 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0  分别指向各自的栈内存</span></span><br><span class="line">　　<span class="built_in">cout</span> &lt;&lt; ( str3 == str4 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0  分别指向各自的栈内存</span></span><br><span class="line">　　<span class="built_in">cout</span> &lt;&lt; ( str5 == str6 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1指向文字常量区地址相同</span></span><br><span class="line">　　<span class="built_in">cout</span> &lt;&lt; ( str7 == str8 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1指向文字常量区地址相同</span></span><br></pre></td></tr></table></figure>

<h6 id="41、将程序跳转到指定内存地址"><a href="#41、将程序跳转到指定内存地址" class="headerlink" title="41、将程序跳转到指定内存地址"></a>41、<strong>将程序跳转到指定内存地址</strong></h6><p>要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*((<span class="keyword">void</span> (*)( ))<span class="number">0x100000</span> ) ( );</span><br><span class="line">　　首先要将<span class="number">0x100000</span>强制转换成函数指针,即:</span><br><span class="line">　　(<span class="keyword">void</span> (*)())<span class="number">0x100000</span>　　然后再调用它:</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*((<span class="keyword">void</span> (*)())<span class="number">0x100000</span>)();</span><br><span class="line">　　用<span class="keyword">typedef</span>可以看得更直观些:</span><br><span class="line">　　<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*)</span><span class="params">()</span> voidFuncPtr</span>;</span><br><span class="line">　　*((voidFuncPtr)<span class="number">0x100000</span>)();</span><br></pre></td></tr></table></figure>

<h6 id="42、复杂声明"><a href="#42、复杂声明" class="headerlink" title="42、复杂声明"></a>42、<strong>复杂声明</strong></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * ( * (*fp1)(<span class="keyword">int</span>))[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">float</span> (*(* fp2)(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>))(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (* ( * fp3)())[<span class="number">10</span>]();</span><br></pre></td></tr></table></figure>

<p>分别表示什么意思？  </p>
<p>1、<code>void * ( * (*fp1)(int))[10]</code>; <code>fp1</code>是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个<code>void*</code>型指针。</p>
<p>2、<code>float (*(* fp2)(int,int,int))(int)</code>; <code>fp2</code>是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是<code>float</code>型。</p>
<p>3、<code>int (* ( * fp3)())[10]()</code>; <code>fp3</code>是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是<code>int</code>型。</p>
<h6 id="43、头文件中的ifndef-define-endif有什么作用？"><a href="#43、头文件中的ifndef-define-endif有什么作用？" class="headerlink" title="43、头文件中的ifndef/define/endif有什么作用？"></a>43、<strong>头文件中的ifndef/define/endif有什么作用？</strong></h6><p>这是C++预编译头文件保护符，保证即使文件被多次包含，头文件也只定义一次。</p>
<h6 id="44、关于sizeof小结的。"><a href="#44、关于sizeof小结的。" class="headerlink" title="44、关于sizeof小结的。"></a>44、<strong>关于sizeof小结的。</strong></h6><p>答：sizeof计算的是在栈中分配的内存大小。</p>
<p>（1） sizeof不计算static变量占得内存；</p>
<p>（2） 32位系统的指针的大小是4个字节，64位系统的指针是8字节，而不用管指针类型；</p>
<p>（3） char型占1个字节，int占4个字节，short int占2个字节</p>
<p>long int占4个字节，float占4字节，double占8字节，string占4字节</p>
<p>一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节</p>
<p>（4） 数组的长度：</p>
<p>若指定了数组长度，则不看元素个数，总字节数=数组长度*sizeof（元素类型）</p>
<p>若没有指定长度，则按实际元素个数类确定</p>
<p>Ps：若是字符数组，则应考虑末尾的空字符。</p>
<p>（5） 结构体对象的长度</p>
<p>在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。</p>
<p>（6） unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）=4</p>
<p>（7） 自定义类型的sizeof取值等于它的类型原型取sizeof</p>
<p>（8） 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替</p>
<p>（9） sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符</p>
<p>（10） 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸</p>
<h6 id="45、公有继承、受保护继承、私有继承"><a href="#45、公有继承、受保护继承、私有继承" class="headerlink" title="45、公有继承、受保护继承、私有继承"></a>45、<strong>公有继承、受保护继承、私有继承</strong></h6><p>（1）公有继承时，派生类对象可以访问基类中的公有成员，派生类的成员函数可以访问基类中的公有和受保护成员；</p>
<p>（2）私有继承时，基类的成员只能被直接派生类的成员访问，无法再往下继承；</p>
<p>（3）受保护继承时，基类的成员也只被直接派生类的成员访问，无法再往下继承。</p>
<h6 id="46、-main函数执行之前会执行什么？执行之后还能执行代码吗？"><a href="#46、-main函数执行之前会执行什么？执行之后还能执行代码吗？" class="headerlink" title="46、.main函数执行之前会执行什么？执行之后还能执行代码吗？"></a>46、<strong>.main函数执行之前会执行什么？执行之后还能执行代码吗？</strong></h6><p>（1）全局对象的构造函数会在main函数之前执行；</p>
<p>（2）可以，可以用_onexit 注册一个函数，它会在main 之后执行;</p>
<p>如果你需要加入一段在main退出后执行的代码，可以使用atexit()函数，注册一个函数。</p>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function<span class="string">")(void));</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">void fn1( void ), fn2( void ), fn3( void );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">int main( void )</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">atexit(fn1);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">atexit( fn2 );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">printf( "</span>This is executed first.\n<span class="string">" );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">void fn1()</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">printf( "</span> This is\n<span class="string">" );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">void fn2()</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">printf( "</span> executed next.<span class="string">" );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">结果：</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">This is executed first.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">This is executed next.</span></span></span></span><br></pre></td></tr></table></figure>

<h6 id="46、-类使用static成员的优点，如何访问？"><a href="#46、-类使用static成员的优点，如何访问？" class="headerlink" title="46、.类使用static成员的优点，如何访问？"></a>46、<strong>.类使用static成员的优点，如何访问？</strong></h6><p>（1）static 成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突；</p>
<p>（2）可以实施封装。static 成员可以是私有成员，而全局对象不可以；</p>
<p>（3） static 成员是与特定类关联的，可清晰地显示程序员的意图。</p>
<p>static 数据成员必须在类定义体的外部定义(正好一次)，static 关键字只能用于类定义体内部的声明中，定义不能标示为static.<br>不像普通数据成员，static成员不是通过类构造函数进行初始化，也不能在类的声明中初始化，而是应该在定义时进行初始化.保证对象正好定义一次的最好办法，就是将static<br>数据成员的定义放在包含类非内联成员函数定义的文件中。</p>
<p>静态数据成员初始化的格式为：<br>$$<br>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞<br>$$<br>类的静态数据成员有两种访问形式：<br>$$<br>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞<br>$$</p>
<h6 id="47、多态类中的虚函数表是-Compile-Time，还是-Run-Time时建立的"><a href="#47、多态类中的虚函数表是-Compile-Time，还是-Run-Time时建立的" class="headerlink" title="47、多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?"></a>47、<strong>多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?</strong></h6><p>虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组。而对象的隐藏成员–虚拟函数表指针是在运行期–也就是构造函数被调用时进行初始化的，这是实现多态的关键。</p>

    </div>

    
    
    .content-wrap {
  opacity: 0.0;
}


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/Moonstar-Z.github.io/tags/面试/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Moonstar-Z.github.io/2019/09/17/数据库/SQL数据库操作/" rel="prev" title="SQL数据库操作">
      <i class="fa fa-chevron-left"></i> SQL数据库操作
    </a></div>
      <div class="post-nav-item">
    <a href="/Moonstar-Z.github.io/2019/09/21/面试/面试没有回答上来的问题/" rel="next" title="面试没有回答上来的问题">
      面试没有回答上来的问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？"><span class="nav-number">1.</span> <span class="nav-text">1 、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、联合体和结构体的区别，变长结构体的实现。"><span class="nav-number">2.</span> <span class="nav-text">2、联合体和结构体的区别，变长结构体的实现。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-fprintf函数的使用和返回值（fprintf-、sprintf-、printf-、fwrite-函数的用法与区别）"><span class="nav-number">3.</span> <span class="nav-text">3 fprintf函数的使用和返回值（fprintf()、sprintf()、printf()、fwrite()函数的用法与区别）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-智能指针-share-ptr-的实现"><span class="nav-number">4.</span> <span class="nav-text">4 智能指针 share_ptr 的实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-引用计数的时候怎么保证安全"><span class="nav-number">5.</span> <span class="nav-text">6 引用计数的时候怎么保证安全</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-防御性编程"><span class="nav-number">6.</span> <span class="nav-text">7 防御性编程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8-对C-中三大特性的各自的理解https-blog-csdn-net-skySongkran-article-details-82012698"><span class="nav-number">7.</span> <span class="nav-text">8 对C++中三大特性的各自的理解https://blog.csdn.net/skySongkran/article/details/82012698</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#9-对数据结构中堆的理解，小顶堆的建立顺序。"><span class="nav-number">8.</span> <span class="nav-text">9 对数据结构中堆的理解，小顶堆的建立顺序。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-哈希表的优势，哈希表的使用场景。hash函数的理解；"><span class="nav-number">9.</span> <span class="nav-text">10 哈希表的优势，哈希表的使用场景。hash函数的理解；</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#11-给定一百万个IP和端口，如何设计一个hash函数，和哈希表去存储，做什么样子的哈希运算。"><span class="nav-number">10.</span> <span class="nav-text">11 给定一百万个IP和端口，如何设计一个hash函数，和哈希表去存储，做什么样子的哈希运算。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#12、解决哈希冲突的办法"><span class="nav-number">11.</span> <span class="nav-text">12、解决哈希冲突的办法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#13、未定义的bool值为什么"><span class="nav-number">12.</span> <span class="nav-text">13、未定义的bool值为什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#14、Char-c-abc；-strlen（指针）多大4，strlen（c）为3"><span class="nav-number">13.</span> <span class="nav-text">14、Char* c= abc； strlen（指针）多大4，strlen（c）为3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#15、套接字编程，一台是小段，一台大端怎么通信"><span class="nav-number">14.</span> <span class="nav-text">15、套接字编程，一台是小段，一台大端怎么通信?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#16、并发模型有哪些？（留）"><span class="nav-number">15.</span> <span class="nav-text">16、并发模型有哪些？（留）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#17、程序有哪些段"><span class="nav-number">16.</span> <span class="nav-text">17、程序有哪些段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#18、MMU内存管理单元"><span class="nav-number">17.</span> <span class="nav-text">18、MMU内存管理单元</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#19、函数调用过程"><span class="nav-number">18.</span> <span class="nav-text">19、函数调用过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#20、时钟中断如何触发进程切换"><span class="nav-number">19.</span> <span class="nav-text">20、时钟中断如何触发进程切换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#21、用数组表示二叉树"><span class="nav-number">20.</span> <span class="nav-text">21、用数组表示二叉树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#22、TOPK问题"><span class="nav-number">21.</span> <span class="nav-text">22、TOPK问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23、UDP-和TCP的区别"><span class="nav-number">22.</span> <span class="nav-text">23、UDP 和TCP的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#24、面向字节流和面向报文的区别"><span class="nav-number">23.</span> <span class="nav-text">24、面向字节流和面向报文的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#25、sizeof数组的值"><span class="nav-number">24.</span> <span class="nav-text">25、sizeof数组的值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#26、int-、long在32和64位下的长度"><span class="nav-number">25.</span> <span class="nav-text">26、int 、long在32和64位下的长度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#27、malloc一次性最大能申请多大内存空间？"><span class="nav-number">26.</span> <span class="nav-text">27、malloc一次性最大能申请多大内存空间？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#28、全局变量和静态变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"><span class="nav-number">27.</span> <span class="nav-text">28、全局变量和静态变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？ 　　</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#29、进程和线程区别，线程共享哪些资源，独占哪些资源"><span class="nav-number">28.</span> <span class="nav-text">29、进程和线程区别，线程共享哪些资源，独占哪些资源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#30、讲讲IO复用，epoll为什么比select效率高"><span class="nav-number">29.</span> <span class="nav-text">30、讲讲IO复用，epoll为什么比select效率高</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#31、浏览器输入一个URL会发生什么"><span class="nav-number">30.</span> <span class="nav-text">31、浏览器输入一个URL会发生什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#32、类的什么函数不能为虚函数"><span class="nav-number">31.</span> <span class="nav-text">32、类的什么函数不能为虚函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#33、什么时候需要自己定义拷贝构造函数"><span class="nav-number">32.</span> <span class="nav-text">33、什么时候需要自己定义拷贝构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#34、纯虚函数有什么用"><span class="nav-number">33.</span> <span class="nav-text">34、纯虚函数有什么用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#35、有哪几种情况只能用intialization-list-而不能用assignment"><span class="nav-number">34.</span> <span class="nav-text">35、有哪几种情况只能用intialization list 而不能用assignment?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#36、main-函数执行以前，还会执行什么代码？"><span class="nav-number">35.</span> <span class="nav-text">36、main 函数执行以前，还会执行什么代码？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#37、请说出const与-define-相比，有何优点？"><span class="nav-number">36.</span> <span class="nav-text">37、请说出const与#define 相比，有何优点？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#38、简述数组与指针的区别？"><span class="nav-number">37.</span> <span class="nav-text">38、简述数组与指针的区别？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#39、int-s-10-int-表示的是什么？"><span class="nav-number">38.</span> <span class="nav-text">39、int (*s[10])(int) 表示的是什么？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#40、栈和文字常量区"><span class="nav-number">39.</span> <span class="nav-text">40、栈和文字常量区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#41、将程序跳转到指定内存地址"><span class="nav-number">40.</span> <span class="nav-text">41、将程序跳转到指定内存地址</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#42、复杂声明"><span class="nav-number">41.</span> <span class="nav-text">42、复杂声明</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#43、头文件中的ifndef-define-endif有什么作用？"><span class="nav-number">42.</span> <span class="nav-text">43、头文件中的ifndef/define/endif有什么作用？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#44、关于sizeof小结的。"><span class="nav-number">43.</span> <span class="nav-text">44、关于sizeof小结的。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#45、公有继承、受保护继承、私有继承"><span class="nav-number">44.</span> <span class="nav-text">45、公有继承、受保护继承、私有继承</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#46、-main函数执行之前会执行什么？执行之后还能执行代码吗？"><span class="nav-number">45.</span> <span class="nav-text">46、.main函数执行之前会执行什么？执行之后还能执行代码吗？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#46、-类使用static成员的优点，如何访问？"><span class="nav-number">46.</span> <span class="nav-text">46、.类使用static成员的优点，如何访问？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#47、多态类中的虚函数表是-Compile-Time，还是-Run-Time时建立的"><span class="nav-number">47.</span> <span class="nav-text">47、多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">苍山负雪</p>
  <div class="site-description" itemprop="description">三十功名尘与土，八千里路云和月。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Moonstar-Z.github.io/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Moonstar-Z.github.io/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/Moonstar-Z.github.io/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/COTVZHAOYUEXING" title="GitHub → https://github.com/COTVZHAOYUEXING" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1998lovexs@gmail.com" title="E-Mail → mailto:1998lovexs@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍山负雪</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Moonstar-Z.github.io/lib/anime.min.js"></script>
  <script src="/Moonstar-Z.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/Moonstar-Z.github.io/lib/velocity/velocity.ui.min.js"></script>
<script src="/Moonstar-Z.github.io/js/utils.js"></script><script src="/Moonstar-Z.github.io/js/motion.js"></script>
<script src="/Moonstar-Z.github.io/js/schemes/muse.js"></script>
<script src="/Moonstar-Z.github.io/js/next-boot.js"></script>



  















  

  

  

</body>
</html>
