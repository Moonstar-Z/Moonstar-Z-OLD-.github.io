<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">

<!-- jquery -->

<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/Moonstar-Z.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Moonstar-Z.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Moonstar-Z.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Moonstar-Z.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Moonstar-Z.github.io/css/main.css">


<link rel="stylesheet" href="/Moonstar-Z.github.io/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/Moonstar-Z.github.io/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一、OSI7层模型 OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能就是帮助不同类型的主机实现数据传输 。 完成中继功能的节点通常称为中继系统。在OSI七层模型中，处于不同层的中继系统具有不同的名称。    一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。具体">
<meta name="keywords" content="TCP">
<meta property="og:type" content="article">
<meta property="og:title" content="OSI7层协议详解">
<meta property="og:url" content="https://yoursite.com/2019/09/16/网络编程/OSI7层协议详解/index.html">
<meta property="og:site_name" content="苍山负雪">
<meta property="og:description" content="一、OSI7层模型 OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能就是帮助不同类型的主机实现数据传输 。 完成中继功能的节点通常称为中继系统。在OSI七层模型中，处于不同层的中继系统具有不同的名称。    一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。具体">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://hi.csdn.net/attachment/201201/5/0_1325744597WM32.gif">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-343093645638ea0839b71db5eba1f7c0_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-fb8534d86e40986e43449de6c35ebd14_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-991572825990575d273f653a78bcc5e7_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-31bff54e0720487afe37e5f3f282d231_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-741e4cd7f95897d6a61bd219e208f1c1_hd.jpg">
<meta property="og:image" content="https://img-my.csdn.net/uploads/201302/25/1361801670_1367.png">
<meta property="og:image" content="https://img-my.csdn.net/uploads/201302/25/1361802159_1221.png">
<meta property="og:image" content="https://img-my.csdn.net/uploads/201302/25/1361802639_2204.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201223112616-1937529463.jpg">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201231521929-1635094019.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201234441944-1271451860.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201235309225-1640442692.jpg">
<meta property="og:image" content="https://yoursite.com/Moonstar-Z.github.io/.com//C:%5CUsers%5CCCTVZYX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567738933945.png">
<meta property="og:image" content="https://img-blog.csdn.net/20170607205709367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170605110405666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170606084851272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2020-03-17T05:54:47.093Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OSI7层协议详解">
<meta name="twitter:description" content="一、OSI7层模型 OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能就是帮助不同类型的主机实现数据传输 。 完成中继功能的节点通常称为中继系统。在OSI七层模型中，处于不同层的中继系统具有不同的名称。    一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。具体">
<meta name="twitter:image" content="http://hi.csdn.net/attachment/201201/5/0_1325744597WM32.gif">

<link rel="canonical" href="https://yoursite.com/2019/09/16/网络编程/OSI7层协议详解/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>
<!-- 打字礼花及震动特效 -->

<div id="append_parent"></div><div id="ajaxwaitid"></div>
<script type="text/javascript" src="/lib/activate-power-mode/activate-power-mode.js"></script>
<script>
	POWERMODE.colorful = true;
	POWERMODE.shake = false;
	document.body.addEventListener('input',POWERMODE);
</script>

<!-- jquery -->

<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <title>OSI7层协议详解 | 苍山负雪</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/Moonstar-Z.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苍山负雪</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/Moonstar-Z.github.io/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/Moonstar-Z.github.io/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/Moonstar-Z.github.io/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Moonstar-Z.github.io/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/09/16/网络编程/OSI7层协议详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Moonstar-Z.github.io/images/avatar.gif">
      <meta itemprop="name" content="苍山负雪">
      <meta itemprop="description" content="三十功名尘与土，八千里路云和月。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍山负雪">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OSI7层协议详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-16 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-16T00:00:00+08:00">2019-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-17 13:54:47" itemprop="dateModified" datetime="2020-03-17T13:54:47+08:00">2020-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Moonstar-Z.github.io/categories/网络编程/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、OSI7层模型"><a href="#一、OSI7层模型" class="headerlink" title="一、OSI7层模型"></a>一、OSI7层模型</h2><p><img src="http://hi.csdn.net/attachment/201201/5/0_1325744597WM32.gif" alt="img"></p>
<p>OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，<span style="color:red">因此其最主要的功能就是帮助不同类型的主机实现数据传输 。</span></p>
<p>完成中继功能的节点通常称为中继系统。在OSI七层模型中，处于不同层的中继系统具有不同的名称。   </p>
<p>一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。<br>具体说:</p>
<a id="more"></a>

<p>物理层：网卡，网线，集线器，中继器，调制解调器</p>
<p>数据链路层：网桥，交换机</p>
<p>网络层：路由器</p>
<p>网关工作在第四层传输层及其以上</p>
<p>集线器是物理层设备,采用广播的形式来传输信息。</p>
<p>交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文.。</p>
<p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。 </p>
<p><strong>交换机和路由器的区别</strong></p>
<p>交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在则广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部MAC地址表中。<br>使用交换机也可以把网络“分段”，通过对照MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。<br>交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。假使这里使用的是10Mbps的以太网交换机，那么该交换机这时的总流通量就等于2×10Mbps＝20Mbps，而使用10Mbps的共享式HUB时，一个HUB的总流通量也不会超出10Mbps。<br>总之，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。</p>
<p>从过滤网络流量的角度来看，路由器的作用与交换机和网桥非常相似。但是与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。因此，使用路由器转发和过滤数据的速度往往要比只查看数据包物理地址的交换机慢。但是，对于那些结构复杂的网络，使用路由器可以提高网络的整体效率。路由器的另外一个明显优势就是可以自动过滤网络广播。</p>
<p>集线器与路由器在功能上有什么不同? </p>
<p>首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。这样在机器很多或数据量很大时，两者将会有比较明显的。而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，不是完全独立的两种设备。路由器主要克服了交换机不能路由转发数据包的不足。 </p>
<p>总的来说，路由器与交换机的主要区别体现在以下几个方面： </p>
<p>（1）工作层次不同<br>最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 </p>
<p>（2）数据转发所依据的对象不同<br>交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。 </p>
<p>（3）传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域<br>由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 </p>
<p>（4）路由器提供了防火墙的服务<br>路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</p>
<h4 id="1、物理层"><a href="#1、物理层" class="headerlink" title="1、物理层"></a><strong>1、物理层</strong></h4><p>在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。<br>物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-343093645638ea0839b71db5eba1f7c0_hd.jpg" alt="img"></p>
<p>看着高大上，其实是将数据的0、1转换成电信号或者光信号。通过光纤、双绞线甚至是无限电波等介质传输到指定的地址。而传输过程中的集线器、中继器、调制解调器等，也属于物理层的传输介质。物理层是 <code>OSI</code> 七层模型的物理基础，没有它就谈不上数据传输了。</p>
<h4 id="2、数据链路层"><a href="#2、数据链路层" class="headerlink" title="2、数据链路层"></a><strong>2、数据链路层</strong></h4><p>数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。</p>
<p><strong><em>该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</em></strong></p>
<p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。<br>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p>
<p><strong>MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；</strong></p>
<p><strong>LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。</strong></p>
<p>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；<strong>并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</strong></p>
<p><strong><img src="https://pic1.zhimg.com/80/v2-fb8534d86e40986e43449de6c35ebd14_hd.jpg" alt="img"></strong></p>
<p><strong>数据链路层会将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）</strong>。举个例子可能会更好理解，暂且把需要传输的数据看作为不同来源的水，如果直接倒入池子中时，是无法重新分辨出不同来源的水的。但如果将不同来源的灌入瓶子中并打上记号，那就能区分出不同来源的水。这也就是为什么要划分为具有意义的数据帧传送给对端。同时要注意的是，数据链路层只负责将数据运送给物理相连的两端，并不负责直接发送到最终地址。</p>
<p>数据链路层可以看作是快递公司的司机，他们驾驶着汽车，将打包好的货物（数据帧）从一个城市（物理节点）运输到另一个城市</p>
<h4 id="3、网络层"><a href="#3、网络层" class="headerlink" title="3、网络层"></a><strong>3、网络层</strong></h4><p>网络层（Network Layer）是OSI模型的第三层，<strong>它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。</strong>它在下两层的基础上向资源子网提供服务。<strong>其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接</strong>。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。<br>一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 </p>
<p>在实现网络层功能时，需要解决的主要问题如下：<br> <strong>寻址</strong>：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是<strong>逻辑地址（如IP地址）</strong>。<br> <strong>交换</strong>：规定不同的信息交换方式。常见的交换技术有：<strong>线路交换技术和存储转发技术</strong>，后者又包括<strong>报文交换技术和分组交换技术</strong>。<br> <strong>路由算法</strong>：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。<br> <strong>连接服务</strong>：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。</p>
<p><img src="https://pic4.zhimg.com/80/v2-991572825990575d273f653a78bcc5e7_hd.jpg" alt="img"></p>
<p>​        网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。主要由 <code>IP</code>、<code>ICMP</code> 两个协议组成</p>
<p>​        网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是IP地址。IP地址和我们的住址有点相似，我们的住址可以从省到市再到街逐步缩小范围，直至我们住址。IP地址也有这样的能力，通过不断转发到更近的IP地址，最终可以到达目标地址。如何选择这条路，就看网络层了。</p>
<h4 id="4、传输层"><a href="#4、传输层" class="headerlink" title="4、传输层"></a><strong>4、传输层</strong></h4><p>OSI下3层的主要任务是<strong>数据通信</strong>，上3层的任务是<strong>数据处理</strong>。而传输层（Transport Layer）是OSI模型的第4层。因此该层<strong>是通信子网和资源子网的接口和桥梁，起到承上启下的作用</strong>。<br>该层的主要任务是：<strong>向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。</strong><br>传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：<br><strong>传输连接管理</strong>：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提<strong>供“面向连接”和“面向无接连”</strong>的两种服务。<br><strong>处理传输差错</strong>：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。<br><strong>监控服务质量。</strong></p>
<p><strong><img src="https://pic2.zhimg.com/80/v2-31bff54e0720487afe37e5f3f282d231_hd.jpg" alt="img"></strong></p>
<p><strong>传输层起着可靠传输的作用。只在通信双方节点进行处理，而不需在路由器上处理。此层有两个具有代表性的协议： <code>TCP</code> 与 <code>UDP</code>。</strong></p>
<p><code>TCP</code> 协议提供可靠的通信传输，简单说就是确认目标能通信的情况下才会传输数据（因此需要三次握手），传输过程如果丢了数据，也会重发。而 <code>UDP</code> 协议则不然，不会确认目标能否通信，只会根据协议发到对方地址的端口。至于对方收不收到，丢不丢包，一概不管。</p>
<p>传输层有一个重要作用，就是指定通信端口。以请求服务器数据为例，服务器有处理多种协议的能力，如之前应用层所说的<code>HTTP</code>，<code>FTP</code>，<code>TELNET</code> 等，但到底你是用什么协议呢？服务器并不知道。但如果你指定了端口，如 <code>80</code>，服务器就会知道你是想用 <code>HTTP</code> 协议的，自然会转给对应协议的处理程序进行处理。</p>
<p>作比喻的话，可以将传输层看作是快递公司的跟单员。负责任的跟单员（使用 <code>TCP</code> 协议）会保证快递送到客户手上，如果送不到就让公司再发一次。不负责任的跟单员（使用 <code>UDP</code> 协议）层只管将快递送到客户指定的地方，不管快递是否送到客户手上。</p>
<h4 id="5、会话层"><a href="#5、会话层" class="headerlink" title="5、会话层"></a><strong>5、会话层</strong></h4><p>会话层（Session Layer）是OSI模型的第5层，<strong>是用户应用程序和网络之间的接口</strong>，主要任务是：<strong>向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。</strong><br>用户可以按照<strong>半双工、单工和全双工</strong>的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。<strong>域名（DN）</strong>就是一种网络上使用的远程地址例如：<a href="http://www.3721.com就是一个域名。会话层的具体功能如下：" target="_blank" rel="noopener">www.3721.com就是一个域名。会话层的具体功能如下：</a><br><strong>会话管理</strong>：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。<br> <strong>会话流量控制</strong>：提供会话流量控制和交叉会话功能。<br><strong>寻址</strong>：使用远程地址建立会话连接。l<br><strong>出错控制</strong>：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。</p>
<p>会话层作用是负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。常见的协议有 <code>ADSP</code>、<code>RPC</code> 等。</p>
<h4 id="6、表示层"><a href="#6、表示层" class="headerlink" title="6、表示层"></a><strong>6、表示层</strong></h4><p>表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。表示层的具体功能如下：<br><strong>数据格式处理</strong>：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。<br><strong>数据的编码</strong>：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。<br><strong>压缩和解压缩</strong>：为了减少数据的传输量，这一层还负责数据的压缩与恢复。<br><strong>数据的加密和解密</strong>：可以提高网络的安全性。</p>
<p>表示层的作用是将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有 <code>ASCII</code>、<code>SSL/TLS</code> 等。</p>
<p>作用看起来可能比较绕，但其实是挺好理解的。我只会说中文，而日本友人只会说日文，那么我们两个是无法交流的。但如果我们都会说英文，交流时我先在心里想好要说的话是什么，再用英语说出来，日本友人听到英文，在心里转换为日语，他就能弄懂我的意思，此时表示层就是各自在心里转化语言。而浏览器请求回一堆数据，是解析成文本还是图片，就由表示层决定。数据的压缩、加密、打包等功能也都在这层完成。</p>
<p>这一层相当于快递公司的打包员。如果快递（数据）太臃肿，他会在不破坏快递的情况下压扁（压缩）它。如果客户注重安全线，全能的快递公司还能用密码箱（ <code>SSL/TLS</code>）打包快递再快送。当然，打包员会确定，目的地快递站的拆包员，能无损地拆开包裹，将快递交给用户。</p>
<h4 id="7、应用层"><a href="#7、应用层" class="headerlink" title="7、应用层"></a><strong>7、应用层</strong></h4><p>应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，<strong>其功能是直接向用户提供服务</strong>，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。<br>应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。应用层的主要功能如下：<br>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。<br>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</p>
<p><img src="https://pic2.zhimg.com/80/v2-741e4cd7f95897d6a61bd219e208f1c1_hd.jpg" alt="img"></p>
<p>作为前端，应用层肯定是最熟悉的。它的作用是为应用程序提供服务并规定应用程序中通讯相关的细节，也就是为应用提供服务。常见的协议有 <code>HTTP</code>，<code>FTP</code>，<code>TELNET</code>、<code>SMTP</code> 等。</p>
<p>我们日常开发中，接触的协议主要以 <code>HTTP</code> 为主，那么把浏览器看作一个应用，当用户发起请求时，通过 <code>HTTP协议</code>获得数据以供浏览器使用，这就是应用层的用途。而请求时发生错误，对错误进行处理，也是应用层需要负责的</p>
<p> <strong>OSI7层模型的小结</strong><br>由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。<br>在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。<strong>简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。</strong></p>
<h2 id="二-、TCP-IP分层模型"><a href="#二-、TCP-IP分层模型" class="headerlink" title="二 、TCP/IP分层模型"></a><strong>二 、TCP/IP分层模型</strong></h2><p>​        ┌────——────┐┌─┬─┬─-┬─┬─-┬─┬─-┬─┬─-┬─┬─-┐<br>　　│　　　　　　　　││Ｄ│Ｆ│Ｗ│Ｆ│Ｈ│Ｇ│Ｔ│Ｉ│Ｓ│Ｕ│　│<br>　　│　　　　　　　　││Ｎ│Ｉ│Ｈ│Ｔ│Ｔ│Ｏ│Ｅ│Ｒ│Ｍ│Ｓ│其│<br>　　│第四层，应用层　││Ｓ│Ｎ│Ｏ│Ｐ│Ｔ│Ｐ│Ｌ│Ｃ│Ｔ│Ｅ│　│<br>　　│　　　　　　　　││　│Ｇ│Ｉ│　│Ｐ│Ｈ│Ｎ│　│Ｐ│Ｎ│　│<br>　　│　　　　　　　　││　│Ｅ│Ｓ│　│　│Ｅ│Ｅ│　│　│Ｅ│它│<br>　　│　　　　　　　　││　│Ｒ│　│　│　│Ｒ│Ｔ│　│　│Ｔ│　│<br>　　└───────——─┘└─┴─┴─-┴─┴─-┴─┴─-┴─┴─-┴─┴-─┘<br>　　┌───────—–─┐┌─────────——-┬──——–─────────┐<br>　　│第三层，传输层　││　　　ＴＣＰ　　　│　　　　ＵＤＰ　　　　│<br>　　└───────—–─┘└────────——-─┴──────────——–─┘<br>　　┌───────—–─┐┌───—-──┬───—─┬────────——-──┐<br>　　│　　　　　　　　││　　　　　│ＩＣＭＰ│　　　　　　　　　　│<br>　　│第二层，网间层　││　　　　　└──—──┘　　　　　　　　　　│<br>　　│　　　　　　　　││　　　　　　　ＩＰ　　　　　　　　　　　 │<br>　　└────────—–┘└────────────────────————-─-┘<br>　　┌────────—–┐┌─────────——-┬──────——–─────┐<br>　　│第一层，网络接口││ＡＲＰ／ＲＡＲＰ　│　　　　其它　　　　　│<br>　　└────────——┘└─────────——┴─────——–──────┘<br>　　　　　　 TCP/IP四层参考模型</p>
<p>　　包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。<strong>TCP/IP协议簇</strong>是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。</p>
<p>​          TCP/IP协议被组织成四个概念层<strong>，其中有三层对应于ISO参考模型中的相应层</strong>。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。<br>　　TCP/IP分层模型的四个协议层分别完成以下的功能：</p>
<h4 id="第一层-网络接口层"><a href="#第一层-网络接口层" class="headerlink" title="第一层:网络接口层"></a>第一层:网络接口层</h4><p>　　包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。</p>
<p>​       网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，</p>
<p>　　然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。<br>　　实际上TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。</p>
<h4 id="第二层-网间层"><a href="#第二层-网间层" class="headerlink" title="第二层:网间层"></a>第二层:网间层</h4><p>　　对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。</p>
<p>网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。　　<br>　　网络互连层定义了分组格式和协议，即IP协议（Internet Protocol）。　　<br>　　网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。</p>
<h4 id="第三层-传输层"><a href="#第三层-传输层" class="headerlink" title="第三层:传输层"></a>第三层:传输层</h4><p>　　对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。</p>
<p>​        在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。　　<br>　　TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。</p>
<p>　　在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。　　<br>　　UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。</p>
<h4 id="第四层-应用层"><a href="#第四层-应用层" class="headerlink" title="第四层:应用层"></a>第四层:应用层</h4><p>TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。　　<br>　　应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于TCP协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本链接协议（Hyper Text Transfer Protocol，HTTP），也有基于UDP协议的。</p>
<p><img src="https://img-my.csdn.net/uploads/201302/25/1361801670_1367.png" alt="è¿éåå¾çæè¿°"></p>
<h2 id="三、-数据的封装与分用"><a href="#三、-数据的封装与分用" class="headerlink" title="三、 数据的封装与分用"></a>三、 数据的封装与分用</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><img src="https://img-my.csdn.net/uploads/201302/25/1361802159_1221.png" alt="è¿éåå¾çæè¿°"></p>
<p><strong>当应用程序用TCP传送数据时</strong>，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。</p>
<p>TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP segment）；UDP数据与TCP数据基本一致。唯一的不同是UDP传给IP的信息单元称作U D P数据报（UDP datagram），而且UDP的首部长为8字节。IP传给网络接口层的数据单元称作IP数据报(IP datagram)。<strong>通过以太网传输的比特流称作帧(Frame )</strong>。</p>
<h4 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h4><p><img src="https://img-my.csdn.net/uploads/201302/25/1361802639_2204.png" alt="è¿éåå¾çæè¿°"></p>
<p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。<strong>协议是通过目的端口号、源I P地址和源端口号进行解包的。</strong></p>
<h2 id="四、TCP-IP协议简述"><a href="#四、TCP-IP协议简述" class="headerlink" title="四、TCP/IP协议简述"></a>四、TCP/IP协议简述</h2><h4 id="1、什么是TCP-IP"><a href="#1、什么是TCP-IP" class="headerlink" title="1、什么是TCP/IP"></a><strong>1、什么是TCP/IP</strong></h4><p>如果要了解一个人，可以从他归属的集体聊起来。我们的HTTP协议就属于TCP/IP协议家族中的一员，了解HTTP协议再整个网络流程中的地位，也能更加充分的理解HTTP协议。</p>
<p>​      要想了解什么是TCP/IP协议，就要知道为什么有这个协议。中国人和中国人说话，要遵循汉语的的语法结构，使用汉语的发音。当我们和外国人交流时，就要适用外国的语言了，遵循外国的语法机构和发音。其实这就是一种协议，只不过我们称之为语言。计算机再这方面体现的更为直观，两台机器之间该如何通信呢，就需要制定各种各样的协议了。例如：文件传输适用TCP协议。域名系统适用DNS协议。有了些协议的存在，各种数据流按照规则传输，计算机之间得意通信。</p>
<p>​       TCP/IP协议是一个协议集合。大家叫的时候方便说，所以统称为TCP/IP。TCP/IP协议族中有一个重要的概念是分层，TCP/IP协议按照层次分为以下四层。<strong>应用层、传输层、网络层、数据链路层</strong>。为什么要分层？这就如同邓小平1978年的大包干，责任到人。一个层只负责一个层次的问题，如果出问题了，和其他的层次无关，只要维护这个层次也就好了。其实编程语言里也能体现这个分层理论，即封转性、隔离。这里不再延伸细谈。下面我是制作的一个简图。</p>
<p>下面是从网络上找到的TCP/IP通信数据流</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201223112616-1937529463.jpg" alt="img"></p>
<h4 id="2、HTTP-关系密切的协议-IP、TCP-和-DNS"><a href="#2、HTTP-关系密切的协议-IP、TCP-和-DNS" class="headerlink" title="2、HTTP 关系密切的协议 : IP、TCP 和 DNS"></a><strong>2、HTTP 关系密切的协议 : IP、TCP 和 DNS</strong></h4><p>  <strong>IP协议：</strong>IP(Internet protocol),这里的IP不是值得我们通常所说的192.168.1.1.这个IP指的是一种协议，而后面的数字值得是IP地址。IP协议的作用在于把各种数据包准确无误的传递给对方，其中两个重要的条件是IP地址，和MAC地址（Media Access Control Address）。由于IP地址是稀有资源，不可能每个人都拥有一个IP地址，所以我们通常的IP地址是路由器给我们生成的IP地址，路由器里面会记录我们的MAC地址。而MAC地址是全球唯一的，除去人为因素外不可能重复。举一个现实生活中的例子，IP地址就如同是我们居住小区的地址，而MAC地址就是我们住的那栋楼那个房间那个人</p>
<p>==IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址==</p>
<p>你向另外一台电脑发送一条信息，怎么再茫茫人海中瞬间找到对方，以下是图示</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201231521929-1635094019.png" alt="img"></p>
<p><strong>TCP协议：</strong>如果说IP协议是找到对方的详细地址。那么TCP协议就是把安全的把东西带给对方。各有分工，互不冲突。</p>
<p>​         按层次分，TCP属于传输层，提供可靠的字节流服务。什么叫字节流服务呢？这个名字听起来让人不知所以然，下面听下我通俗的解释。所谓的<strong>字节流</strong>，其实就类似于信息切割。比如你是一个卖自行车的，你要去送货。安装好的自行车，太过庞大，又不稳定，容易损伤。不如直接把自行车拆开来，每个零件上都贴上收货人的姓名。最后送到后按照把属于同一个人的自行车再组装起来，这个拆解、运输、拼装的过程其实就是TCP字节流的过程。</p>
<p> <u>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</u></p>
<p> 为了确保信息能够确保准确无误的到达，TCP采用了著名的三次握手策略</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201234441944-1271451860.png" alt="img"></p>
<p><strong>DNS：</strong>DNS(Domain names System) 和HTTP协议一样是处于应用层的服务，提供域名到IP地址之间的解析服务。</p>
<p>互联网之间是通过IP地址通信的，但是IP地址并不符合认得记忆习惯，人喜欢记忆有意义的字词。所以DNS服务就为了解决这个问题而生了。其实很好理解，形如我们电脑中host文件。</p>
<p>192.168.1.11       roverliang.com  </p>
<p>当我们访问roverliang.com 的时候，电脑便不会去外网服务器上查询了，直接去访问192.168.1.111。这是一个简单的域名劫持，足以说明DNS的涵义了。</p>
<p>下面是我们访问一个网页，各种协议在里面起的作用。</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201235309225-1640442692.jpg" alt="img"></p>
<h4 id="3、正常的TCP的三次握手和四次挥手过程"><a href="#3、正常的TCP的三次握手和四次挥手过程" class="headerlink" title="3、正常的TCP的三次握手和四次挥手过程"></a>3、正常的TCP的三次握手和四次挥手过程</h4><p>通过上一篇中网络模型中的IP层的介绍，我们知道网络层，可以实现两个主机之间的通信。但是这并不具体，因为，真正进行通信的实体是在主机中的进程，<strong>是一个主机中的一个进程与另外一个主机中的一个进程在交换数据</strong>。IP协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程<strong>。而端到端的通信才应该是应用进程之间的通信。</strong></p>
<p>UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p>
<p>TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p>
<p><strong>常用的熟知端口号</strong></p>
<p><img src="/Moonstar-Z.github.io/.com//C:%5CUsers%5CCCTVZYX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567738933945.png" alt="1567738933945"></p>
<p><strong>TCP的概述</strong></p>
<p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</p>
<p><strong>TCP报文首部</strong></p>
<p><strong>1 源端口和目的端口</strong>，各占2个字节，分别写入源端口和目的端口；<br><strong>2 序号</strong>，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；<br><strong>3 确认号</strong>，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；<br><strong>4 数据偏移</strong>，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；<br><strong>5 保留</strong>，占6位，保留今后使用，但目前应都位0；<br><strong>6 紧急URG</strong>，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；<br><strong>7 确认ACK</strong>，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；<br><strong>8 推送PSH</strong>，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；<br><strong>9 复位RST</strong>，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；<br><strong>10 同步SYN</strong>，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；<br><strong>11 终止FIN</strong>，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；<br><strong>12 窗口</strong>，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；<br><strong>13 检验和</strong>，占2字节，校验首部和数据这两部分；<br><strong>14 紧急指针</strong>，占2字节，指出本报文段中的紧急数据的字节数；<br><strong>15 选项</strong>，长度可变，定义一些其他的可选的参数。</p>
<h5 id="TCP连接的建立（三次握手）"><a href="#TCP连接的建立（三次握手）" class="headerlink" title="TCP连接的建立（三次握手）"></a><strong>TCP连接的建立（三次握手）</strong></h5><p><img src="https://img-blog.csdn.net/20170607205709367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
<p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p>
<p>1 <strong>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</strong></p>
<p>2 <strong>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong></p>
<p>3 <strong>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</strong></p>
<p>4 <strong>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong></p>
<p>5 <strong>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</strong></p>
<p><img src="https://img-blog.csdn.net/20170605110405666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ä¸æ¬¡æ¡æ"></p>
<h5 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h5><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h5 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h5><p>1  <strong>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong></p>
<p>2  <strong>服务器收到连接释放报文，发出确认报文，<span style="color:red">ACK=1，ack=u+1，并且带上自己的序列号seq=v，</span>此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，<span style="color:red">即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。</span>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</strong></p>
<p>3  <strong>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</strong></p>
<p>4  <strong>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<span style="color:red">FIN=1，ack=u+1，</span>由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的<span style="color:red">序列号为seq=w，</span>此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</strong></p>
<p>5  <strong>客户端收到服务器的连接释放报文后，必须发出确认，<span style="color:red">ACK=1，ack=w+1，而自己的序列号是seq=u+1，</span>此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</strong></p>
<p>6  <strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</strong></p>
<p><img src="https://img-blog.csdn.net/20170606084851272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="åæ¬¡æ¥æ"></p>
<h5 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h5><p> MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h5 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h5><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<h5 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h5><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>

    </div>

    
    
    .content-wrap {
  opacity: 0.0;
}


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/Moonstar-Z.github.io/tags/TCP/" rel="tag"># TCP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Moonstar-Z.github.io/2019/09/15/C++基础知识/引用计数/" rel="prev" title="引用计数">
      <i class="fa fa-chevron-left"></i> 引用计数
    </a></div>
      <div class="post-nav-item">
    <a href="/Moonstar-Z.github.io/2019/09/16/网络编程/计算机网路/" rel="next" title="计算机网络">
      计算机网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、OSI7层模型"><span class="nav-number">1.</span> <span class="nav-text">一、OSI7层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、物理层"><span class="nav-number">1.0.1.</span> <span class="nav-text">1、物理层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、数据链路层"><span class="nav-number">1.0.2.</span> <span class="nav-text">2、数据链路层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、网络层"><span class="nav-number">1.0.3.</span> <span class="nav-text">3、网络层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、传输层"><span class="nav-number">1.0.4.</span> <span class="nav-text">4、传输层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、会话层"><span class="nav-number">1.0.5.</span> <span class="nav-text">5、会话层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、表示层"><span class="nav-number">1.0.6.</span> <span class="nav-text">6、表示层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7、应用层"><span class="nav-number">1.0.7.</span> <span class="nav-text">7、应用层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-、TCP-IP分层模型"><span class="nav-number">2.</span> <span class="nav-text">二 、TCP/IP分层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一层-网络接口层"><span class="nav-number">2.0.1.</span> <span class="nav-text">第一层:网络接口层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二层-网间层"><span class="nav-number">2.0.2.</span> <span class="nav-text">第二层:网间层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三层-传输层"><span class="nav-number">2.0.3.</span> <span class="nav-text">第三层:传输层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第四层-应用层"><span class="nav-number">2.0.4.</span> <span class="nav-text">第四层:应用层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、-数据的封装与分用"><span class="nav-number">3.</span> <span class="nav-text">三、 数据的封装与分用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#封装"><span class="nav-number">3.0.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分用"><span class="nav-number">3.0.2.</span> <span class="nav-text">分用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、TCP-IP协议简述"><span class="nav-number">4.</span> <span class="nav-text">四、TCP/IP协议简述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、什么是TCP-IP"><span class="nav-number">4.0.1.</span> <span class="nav-text">1、什么是TCP/IP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、HTTP-关系密切的协议-IP、TCP-和-DNS"><span class="nav-number">4.0.2.</span> <span class="nav-text">2、HTTP 关系密切的协议 : IP、TCP 和 DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、正常的TCP的三次握手和四次挥手过程"><span class="nav-number">4.0.3.</span> <span class="nav-text">3、正常的TCP的三次握手和四次挥手过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP连接的建立（三次握手）"><span class="nav-number">4.0.3.1.</span> <span class="nav-text">TCP连接的建立（三次握手）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么TCP客户端最后还要发送一次确认呢？"><span class="nav-number">4.0.3.2.</span> <span class="nav-text">为什么TCP客户端最后还要发送一次确认呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP连接的释放（四次挥手）"><span class="nav-number">4.0.3.3.</span> <span class="nav-text">TCP连接的释放（四次挥手）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么客户端最后还要等待2MSL？"><span class="nav-number">4.0.3.4.</span> <span class="nav-text">为什么客户端最后还要等待2MSL？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><span class="nav-number">4.0.3.5.</span> <span class="nav-text">为什么建立连接是三次握手，关闭连接确是四次挥手呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？"><span class="nav-number">4.0.3.6.</span> <span class="nav-text">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">苍山负雪</p>
  <div class="site-description" itemprop="description">三十功名尘与土，八千里路云和月。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Moonstar-Z.github.io/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Moonstar-Z.github.io/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/Moonstar-Z.github.io/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/COTVZHAOYUEXING" title="GitHub → https://github.com/COTVZHAOYUEXING" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1998lovexs@gmail.com" title="E-Mail → mailto:1998lovexs@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍山负雪</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Moonstar-Z.github.io/lib/anime.min.js"></script>
  <script src="/Moonstar-Z.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/Moonstar-Z.github.io/lib/velocity/velocity.ui.min.js"></script>
<script src="/Moonstar-Z.github.io/js/utils.js"></script><script src="/Moonstar-Z.github.io/js/motion.js"></script>
<script src="/Moonstar-Z.github.io/js/schemes/muse.js"></script>
<script src="/Moonstar-Z.github.io/js/next-boot.js"></script>



  















  

  

</body>
</html>
