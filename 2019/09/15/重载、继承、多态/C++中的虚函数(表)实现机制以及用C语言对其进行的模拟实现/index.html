<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">

<!-- jquery -->

<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/Moonstar-Z.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Moonstar-Z.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Moonstar-Z.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Moonstar-Z.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Moonstar-Z.github.io/css/main.css">


<link rel="stylesheet" href="/Moonstar-Z.github.io/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/Moonstar-Z.github.io/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="继承就是一种传承，可以把父类型中的数据传承到子类中，子类除了传承了父类的数据之外，还可以对父类型进行扩展；  公开继承  public 保护继承  protected 私有继承  private 保护成员：在子类和本类中可以访问，其他不行；  1、公开继承：在公开继承下，父类型中的数据是公开的到子类型中权限是公开的；父类型中保护权限的数据到子类中是保护的；父类中私有的数据到子类中会隐藏掉（就是说看">
<meta name="keywords" content="重载、继承、多态">
<meta property="og:type" content="article">
<meta property="og:title" content="重载、继承、多态">
<meta property="og:url" content="https://yoursite.com/2019/09/15/重载、继承、多态/C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现/index.html">
<meta property="og:site_name" content="苍山负雪">
<meta property="og:description" content="继承就是一种传承，可以把父类型中的数据传承到子类中，子类除了传承了父类的数据之外，还可以对父类型进行扩展；  公开继承  public 保护继承  protected 私有继承  private 保护成员：在子类和本类中可以访问，其他不行；  1、公开继承：在公开继承下，父类型中的数据是公开的到子类型中权限是公开的；父类型中保护权限的数据到子类中是保护的；父类中私有的数据到子类中会隐藏掉（就是说看">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://catonmat.net/images/polymorphic-cats.gif">
<meta property="og:image" content="https://yoursite.com/Moonstar-Z.github.io/.com//C:%5CUsers%5CCCTVZYX%5CDesktop%5C1-1.png">
<meta property="og:image" content="https://yoursite.com/Moonstar-Z.github.io/.com//C:%5CUsers%5CCCTVZYX%5CDesktop%5C3-1.png">
<meta property="og:image" content="https://blog.twofei.com/496/3-2.png">
<meta property="og:image" content="https://blog.twofei.com/496/4-1.png">
<meta property="og:image" content="https://blog.twofei.com/496/4-2.png">
<meta property="og:image" content="https://blog.twofei.com/496/4-3.png">
<meta property="og:image" content="https://blog.twofei.com/496/4-4.png">
<meta property="og:image" content="https://blog.twofei.com/496/5-1.png">
<meta property="og:image" content="https://blog.twofei.com/496/5-2.png">
<meta property="og:image" content="https://blog.twofei.com/496/5-3.png">
<meta property="og:image" content="https://blog.twofei.com/496/6-1.png">
<meta property="og:image" content="https://blog.twofei.com/496/6-2.png">
<meta property="og:image" content="https://blog.twofei.com/496/7-1.png">
<meta property="og:image" content="https://blog.twofei.com/496/7-2.png">
<meta property="og:image" content="https://blog.twofei.com/496/7-3.png">
<meta property="og:image" content="https://blog.twofei.com/496/8-1.png">
<meta property="og:image" content="https://blog.twofei.com/496/8-2.png">
<meta property="og:image" content="https://blog.twofei.com/496/8-3.png">
<meta property="og:image" content="https://blog.twofei.com/496/9-1.png">
<meta property="og:image" content="https://blog.twofei.com/496/9-2.png">
<meta property="og:image" content="https://blog.twofei.com/496/9-3.png">
<meta property="og:image" content="https://blog.twofei.com/496/9-4.png">
<meta property="og:image" content="https://blog.twofei.com/496/10-1.png">
<meta property="og:image" content="https://blog.twofei.com/496/10-2.png">
<meta property="og:image" content="https://blog.twofei.com/496/10-3.png">
<meta property="og:image" content="https://blog.twofei.com/496/11-1.png">
<meta property="og:image" content="https://blog.twofei.com/496/11-2.jpg">
<meta property="og:image" content="https://blog.twofei.com/496/c-1.png">
<meta property="og:image" content="https://blog.twofei.com/496/last.png">
<meta property="og:updated_time" content="2020-03-17T05:38:04.264Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="重载、继承、多态">
<meta name="twitter:description" content="继承就是一种传承，可以把父类型中的数据传承到子类中，子类除了传承了父类的数据之外，还可以对父类型进行扩展；  公开继承  public 保护继承  protected 私有继承  private 保护成员：在子类和本类中可以访问，其他不行；  1、公开继承：在公开继承下，父类型中的数据是公开的到子类型中权限是公开的；父类型中保护权限的数据到子类中是保护的；父类中私有的数据到子类中会隐藏掉（就是说看">
<meta name="twitter:image" content="https://catonmat.net/images/polymorphic-cats.gif">

<link rel="canonical" href="https://yoursite.com/2019/09/15/重载、继承、多态/C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>
<!-- 打字礼花及震动特效 -->

<div id="append_parent"></div><div id="ajaxwaitid"></div>
<script type="text/javascript" src="/lib/activate-power-mode/activate-power-mode.js"></script>
<script>
	POWERMODE.colorful = true;
	POWERMODE.shake = false;
	document.body.addEventListener('input',POWERMODE);
</script>

<!-- jquery -->

<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <title>重载、继承、多态 | 苍山负雪</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/Moonstar-Z.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苍山负雪</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/Moonstar-Z.github.io/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/Moonstar-Z.github.io/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/Moonstar-Z.github.io/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Moonstar-Z.github.io/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/09/15/重载、继承、多态/C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Moonstar-Z.github.io/images/avatar.gif">
      <meta itemprop="name" content="苍山负雪">
      <meta itemprop="description" content="三十功名尘与土，八千里路云和月。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍山负雪">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          重载、继承、多态
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-15T00:00:00+08:00">2019-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-17 13:38:04" itemprop="dateModified" datetime="2020-03-17T13:38:04+08:00">2020-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Moonstar-Z.github.io/categories/重载、继承、多态/" itemprop="url" rel="index"><span itemprop="name">重载、继承、多态</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>就是一种传承，可以把父类型中的数据传承到子类中，子类除了传承了父类的数据之外，还可以对父类型进行扩展；</strong></p>
<ol>
<li><strong>公开继承  public</strong></li>
<li><strong>保护继承  protected</strong></li>
<li><strong>私有继承  private</strong></li>
<li><strong>保护成员：在子类和本类中可以访问，其他不行；</strong></li>
</ol>
<p>1、公开继承：在公开继承下，父类型中的数据是公开的到子类型中权限是公开的；父类型中保护权限的数据到子类中是保护的；父类中私有的数据到子类中会隐藏掉（就是说看不见权限，但是实际上式在子类中的）；</p>
<p>2、私有继承：在私有继承下，父类中的公开数据到子类中变成私有的，父类中的保护数据到子类中称为私有的，父类中的私有数据到子类中隐藏；</p>
<p>3、保护继承：保护继承下，父类中的公开数据和保护数据到了子类中都成为保护权限，父类中私有的数据到了子类中就变成了隐藏的；<br>4、注意：不管何种类型的继承关系，父类私有成员到子类中都成为了隐藏掉。</p>
<a id="more"></a>

<h5 id="1-公开继承下的public成员和protected成员的权限变化："><a href="#1-公开继承下的public成员和protected成员的权限变化：" class="headerlink" title="1.公开继承下的public成员和protected成员的权限变化："></a><strong>1.公开继承下的public成员和protected成员的权限变化：</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">geta</span><span class="params">()</span></span>&#123;</span><br><span class="line">		a = <span class="number">300</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*保护类型成员在本类和子类中可以访问*/</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="comment">//int x;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getb</span><span class="params">()</span></span>&#123;</span><br><span class="line">		b = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showa</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt; a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/*关键在于如何设置接口，成功合理的访问到各种类型的数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B pex;</span><br><span class="line">	<span class="comment">/*公开继承public成员依旧是public，所以可以类外访问*/</span></span><br><span class="line">	pex.a = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">/*b是保护类型成员，可以通过设置public接口来访问*/</span></span><br><span class="line">	pex.getb();</span><br><span class="line">	pex.show();</span><br><span class="line">	<span class="comment">/*隐藏成员的问题，怎么访问到隐藏的成员*/</span></span><br><span class="line">	pex.geta();</span><br><span class="line">	pex.showa();</span><br><span class="line">	<span class="comment">//A a = pex;//子类类型赋给了父类类型</span></span><br><span class="line">	<span class="comment">//a.geta();</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a.a &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-私有继承下的成员的权限变化关系，"><a href="#2-私有继承下的成员的权限变化关系，" class="headerlink" title="2.私有继承下的成员的权限变化关系，"></a>2.私有继承下的成员的权限变化关系，</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*私有继承下的权限变化，关键是设置合理的接口访问</span></span><br><span class="line"><span class="comment">父类中的各种类型的数据成员*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showa</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is showa()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showb</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is showb"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is showc"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">geta</span><span class="params">()</span></span>&#123;<span class="comment">//设置合理的接口访问A中的私有数据</span></span><br><span class="line">		showa();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">private</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		showc();</span><br><span class="line">		showb();</span><br><span class="line">		geta();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="comment">//A a = b;对比公开继承，对比一下</span></span><br><span class="line">	b.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。"><a href="#3-突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。" class="headerlink" title="3.突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。"></a>3.突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*友元类*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():x(<span class="number">10</span>),y(<span class="number">123</span>)&#123;&#125;</span><br><span class="line">	<span class="comment">/*B,C声明为A的友元类之后，可以访问到父类的所有类型成员*/</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"---"</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;a.x&lt;&lt; <span class="string">"---"</span> &lt;&lt; a.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.show();</span><br><span class="line">	C c;</span><br><span class="line">	c.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数"><a href="#4-继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数" class="headerlink" title="4.继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数"></a>4.继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数</h5><p><span style="color:red"><strong>构造函数和析构函数是不能被继承的，但是可以被调用。并且子类一定会调用父类的构造函数；</strong></span></p>
<p><strong>子类默认调用父类的无参构造，也可以制定调用构造函数；</strong></p>
<p><strong>析构函数的调用和构造函数的调用顺序相反；</strong></p>
<p><strong>拷贝构造函数和赋值运算符函数也不能被继承：在子类不提供拷贝构造和赋值运算符时，子类默认调用父类的赋值运算符和拷贝构造函数。但子类一旦提供拷贝构造和赋值运算符函数则不再调用父类拷贝构造和赋值运算符函数。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*继承中构造函数和析构函数的调用：构造函数和析构函数不可以</span></span><br><span class="line"><span class="comment">被继承，但是可以被调用，而且子类肯定会调用父类的构造函数</span></span><br><span class="line"><span class="comment">和析构函数。这种机制可以很自然的用于访问父类的私有成员*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//A()&#123;cout &lt;&lt; "A()" &lt;&lt; endl;&#125;</span></span><br><span class="line">	A(<span class="keyword">int</span> x = <span class="number">0</span>):x(x)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"A()构造"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="keyword">int</span> _get()&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*在初始化参数列表中可以指定调用父类的构造函数,指定调用构造函数并且给</span></span><br><span class="line"><span class="comment">	父类中的私有成员赋值*/</span></span><br><span class="line">	<span class="comment">/*注意：子类默认调用父类的无参构造，如果下面的代码没有：A(100),则会调用无参构造，但是父类无参构造</span></span><br><span class="line"><span class="comment">	被注释掉，所以会出错*/</span></span><br><span class="line">	B():A(<span class="number">100</span>)&#123;</span><br><span class="line">		<span class="comment">//x = 200;</span></span><br><span class="line">		<span class="comment">//A(100);</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//访问有参构造的方式,理解这种方式的作用</span></span><br><span class="line">	<span class="comment">/*注意，这种机制下的构造函数所赋的值是赋到了子类中的数据x中，</span></span><br><span class="line"><span class="comment">	而父类中的x仍然为0*/</span></span><br><span class="line">	~B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getbx</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _get();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;<span class="comment">//构建A对象，此时A类构造被调用，并打印出了值</span></span><br><span class="line"> </span><br><span class="line">	B b;<span class="comment">//B类为无参构造，首先调用了A的构造，在调用B的构造</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//打印a对象中的x成员</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;a._get()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a对象中的x为0</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//打印b对象中的x</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.getbx()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//是100</span></span><br><span class="line">	<span class="comment">/*一层一层的退，先调用b的析构，在调用a的析构*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-拷贝构造和赋值运算符的问题"><a href="#5-拷贝构造和赋值运算符的问题" class="headerlink" title="5.拷贝构造和赋值运算符的问题"></a>5.拷贝构造和赋值运算符的问题</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*系统一旦提供构造函数，系统默认的构造函数将被回收</span></span><br><span class="line"><span class="comment">记住，拷贝构造也是构造函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A()&#123;&#125;</span><br><span class="line">	<span class="comment">//A(int x = 0):arr(x)&#123;&#125;</span></span><br><span class="line">	A(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"父类拷贝构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"父类赋值运算符函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*有指针类型的成员时，采用默认机制就麻烦了*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="comment">//int * pi;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B()&#123;&#125;</span><br><span class="line">	B(<span class="keyword">const</span> B&amp; b):A(b)&#123;                      </span><br><span class="line">		<span class="comment">//子类中提供了拷贝构造函数将不再调用父类的拷贝构造</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"子类拷贝构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> B&amp; b)&#123;</span><br><span class="line">		A::<span class="keyword">operator</span>=(b);         <span class="comment">//调用父类的拷贝构造函数的机制</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"子类赋值运算符函数"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B a;</span><br><span class="line">	B b = a;</span><br><span class="line">	B c;</span><br><span class="line">	c = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-名字隐藏"><a href="#6-名字隐藏" class="headerlink" title="6.名字隐藏"></a>6.名字隐藏</h5><p><strong>名字隐藏机制：子类中如果定义了和父类中同名的数据，这些数据包括成员变量和成员函数。则会把父类中的数据隐藏掉。</strong></p>
<p>注意：只要名字相同，计算返回值或者形参列表不同，也会被隐藏。隐藏不代表就没有了，可以通过类名作用域::访问到被隐藏的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"show A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A()&#123;x=<span class="number">20</span>;&#125;</span><br><span class="line">	A(<span class="keyword">int</span> x):x(x)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"show A(int x)"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shouu</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"shouu()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"show B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		A::show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.shouu();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.A::x &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//突破名字隐藏机制</span></span><br><span class="line">	<span class="keyword">int</span> c = b.show();被隐藏，无法访问</span><br><span class="line">	b.A::show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-多继承和函数重写"><a href="#7-多继承和函数重写" class="headerlink" title="7.多继承和函数重写"></a>7.多继承和函数重写</h5><p><strong>多继承是c++特有的语法机制，表现为一个子类有多个直接的父类。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//phone();</span></span><br><span class="line">	phone(<span class="keyword">double</span> price = <span class="number">15</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~phone()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use calling"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MP3(<span class="keyword">double</span> price = <span class="number">20</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~MP3()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use to listening music"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vedio</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vedio(<span class="keyword">double</span> price = <span class="number">0</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~vedio()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">vcd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"watch vedio"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*多继承*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iphone</span>:</span><span class="keyword">public</span> phone,<span class="keyword">public</span> MP3,<span class="keyword">public</span> vedio&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> phone::getprice() + MP3::getprice() + vedio::getprice();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	iphone iphone6;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(iphone) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.MP3::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.phone::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.getprice() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//用名字隐藏机制解决多分数据同名冲突的问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:green">多继承遇到的问题：上面的代码用sizeof就可以看到，子类在多继承的时候会多次复制顶层数据，而我们期望的是price这个成员只需要复制一份就可以了，因为多余的复制是无意义的。首先采用顶层抽象的方式，将三个父类抽象到更高的层面上。</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*抽象到更高层的类中*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">product</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	product(<span class="keyword">double</span> price = <span class="number">0</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt;<span class="string">"product"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span>:</span><span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//phone();</span></span><br><span class="line">	phone(<span class="keyword">double</span> price = <span class="number">15</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~phone()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use calling"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3</span>:</span><span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MP3(<span class="keyword">double</span> price = <span class="number">20</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~MP3()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use to listening music"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vedio</span>:</span><span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vedio(<span class="keyword">double</span> price = <span class="number">0</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~vedio()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">vcd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"watch vedio"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iphone</span>:</span><span class="keyword">public</span> phone,<span class="keyword">public</span> MP3,<span class="keyword">public</span> vedio&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> phone::getprice() + MP3::getprice() + vedio::getprice();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	iphone iphone6;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;同样会产生冲突的问题</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; sizeof(iphone) &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.MP3::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.phone::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;//直接调用产生冲突问题，编译器不知道该调用哪一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，product的构造函数 被调用了三次，因为这种继承是一级一级的来的，构造子类的时候找父类，发现父类还有父类，就去调用爷爷类的构造函数，三次继承，三次调用。</p>
<p>这种继承方式构成了一种菱形或者钻石型的继承，叫做菱形继承或者钻石继承，但钻石继承并没有实际解决数据多次复制的问题，为了解决菱形继承，c++提出了虚继承。虚继承就是在继承的时候加上virtual关键字修饰即可。</p>
<p><span style="color:green">虚继承对于共同的成员父亲类从爷爷类那里继承来的，这里为double price，子类直接越级访问，直接从爷爷类那里继承price。</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*类中也会有对齐和补齐*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*抽象到更高层的类中*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">product</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span>  <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	product(<span class="keyword">double</span> price = <span class="number">0</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"product"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//phone();</span></span><br><span class="line">	phone(<span class="keyword">double</span> price = <span class="number">15</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~phone()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use calling"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MP3(<span class="keyword">double</span> price = <span class="number">20</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~MP3()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use to listening music"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vedio</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vedio(<span class="keyword">double</span> price = <span class="number">0</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~vedio()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">vcd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"watch vedio"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iphone</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> phone,<span class="keyword">virtual</span> <span class="keyword">public</span> MP3,<span class="keyword">virtual</span> <span class="keyword">public</span> vedio&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	iphone(<span class="keyword">int</span> m = <span class="number">0</span>,<span class="keyword">int</span> v = <span class="number">0</span>,<span class="keyword">int</span> p = <span class="number">0</span>):product(m + p + v)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*虚函数之后，product的构造函数只被调用了一次，孙子类直接越级访问</span></span><br><span class="line"><span class="comment">了product类*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">iphone <span class="title">iphone6</span><span class="params">(<span class="number">1000</span>,<span class="number">2041</span>,<span class="number">3201</span>)</span></span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;同样会产生冲突的问题</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; sizeof(iphone) &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.MP3::getprice() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.phone::getprice() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;直接调用产生冲突问题，编译器不知道该调用哪一个</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(iphone) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码中product的构造函数只调用了一次，说明子类直接越级访问了爷爷类的数据。而对于父类特有的子类照常继承，只是没有通过父类去继承爷爷类的数据成员，所以product的构造函数只被调用了一次。</p>
<p>虚函数：在函数前面加上virtual关键字修饰过的就是虚函数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showa</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚函数的主要表现为会占用四个字节的空间，只要成员中出现虚函数，不管有多少个虚函数，都只用四个字节来维护这个虚关系。虚函数会影响对象的大小。维护虚关系使用一个指针来维护的，所以是四个字节。</p>
<p><strong>函数重写：</strong></p>
<p><strong>在父类中出现一个虚函数，如果在子类中提供和父类同名的函数（注意区分名字隐藏），这就加函数重写。</strong></p>
<p><strong>函数重写要求必须有相同函数名，相同的参数列表，相同的返回值。</strong></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li>
<li>多态是以封装和继承为基础的。</li>
<li>C++ 多态分类及实现：<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ul>
<p>当人们谈论C ++中的多态时，他们通常意味着通过基类指针或引用使用派生类，这称为<strong>子类型多态</strong>。但是他们经常忘记C ++中存在各种其他多态性，例如<strong>参数多态性</strong>，<strong>ad-hoc多态性</strong>和<strong>强制多态性</strong>。</p>
<ul>
<li>子类型多态性也称为<strong>运行时多态性</strong>。</li>
<li>参数多态也称为<strong>编译时多态</strong>。</li>
<li>Ad-hoc多态性也称为<strong>重载</strong>。</li>
<li>强制也称为（隐式或显式）<strong>铸造</strong>。</li>
</ul>
<p>在本文中，我将通过C ++语言中的示例来说明所有多态性，并且还可以深入了解它们具有各种其他名称的原因。</p>
<h4 id="1-子类型多态性（运行时多态性）"><a href="#1-子类型多态性（运行时多态性）" class="headerlink" title="1.子类型多态性（运行时多态性）"></a>1.子类型多态性（运行时多态性）</h4><p>子类型多态性是每个人在C ++中说“多态”时都能理解的。它是通过基类指针和引用使用派生类的能力</p>
<p>这是一个例子。假设你有像这些猫科动物的各种猫，</p>
<p><img src="https://catonmat.net/images/polymorphic-cats.gif" alt="å¤æç«"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cats.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> meow（）= <span class="number">0</span>; </span><br><span class="line">&#125;;<span class="comment">//纯虚函数 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>：<span class="title">public</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">void</span> meow（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt;“Meowing like a regular cat！meow！\ n”; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span>：<span class="title">public</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">void</span> meow（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt;“Meowing like a tiger！MREOWWW！\ n”; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ocelot</span>：<span class="title">public</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">void</span> meow（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt;“Meowing like a ocelot！mews！\ n”; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_meowing</span><span class="params">(Felid *cat)</span> </span>&#123;</span><br><span class="line"> cat-&gt;meow();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Cat cat;</span><br><span class="line"> Tiger tiger;</span><br><span class="line"> Ocelot ocelot;</span><br><span class="line"></span><br><span class="line"> do_meowing(&amp;cat);</span><br><span class="line"> do_meowing(&amp;tiger);</span><br><span class="line"> do_meowing(&amp;ocelot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的主要程序传递指针<code>cat</code>，<code>tiger</code>并<code>ocelot</code>以<code>do_meowing</code>一个期望的指针功能<code>Felid</code>。由于它们都是<code>Felid</code>s，程序<code>meow</code>为每个felid 调用正确的函数，输出为：</p>
<p>子类型多态性也称为运行时多态，这是有充分理由的。多态函数调用的解析在运行时通过虚拟表的间接发生。解释这一点的另一种方法是编译器没有在编译时定位要调用的函数的地址，而是在程序运行时，通过解除引用虚拟表中的右指针来调用该函数。在类型理论中，它也被称为包含多态性</p>
<h4 id="2-参数多态性（编译时多态性）"><a href="#2-参数多态性（编译时多态性）" class="headerlink" title="2.参数多态性（编译时多态性）"></a>2.参数多态性（编译时多态性）</h4><p>参数多态提供了为任何类型执行相同代码的方法。在C ++中，参数多态通过模板实现。</p>
<p>最简单的例子之一是泛型<code>max</code>函数，它最多找到两个参数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">max</span>（<span class="title">T</span> <span class="title">a</span>，<span class="title">T</span> <span class="title">b</span>）&#123;</span> </span><br><span class="line"> <span class="keyword">return</span> a&gt; b？a：b; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main（）&#123; </span><br><span class="line"> <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; :: max（<span class="number">9</span>,<span class="number">5</span>）&lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>; <span class="comment">// 9 </span></span><br><span class="line"> <span class="built_in">std</span> :: <span class="built_in">string</span> foo（“foo”），bar（“bar”）; </span><br><span class="line"> <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; :: max（foo，bar）&lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>; <span class="comment">//“foo” </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>max</code>函数是类型的多态<code>T</code>。但请注意，它不适用于指针类型，因为比较指针会比较内存位置而不是内容。为了使它适用于指针，你必须专门化指针类型的模板，这将不再是参数多态，而是ad-hoc多态。</p>
<p>由于参数多态在编译时发生，因此它也称为<strong>编译时多态</strong>。</p>
<h4 id="3-Ad-hoc多态（重载）"><a href="#3-Ad-hoc多态（重载）" class="headerlink" title="3.Ad-hoc多态（重载）"></a>3.Ad-hoc多态（重载）</h4><p>Ad-hoc多态性允许具有相同名称的函数对每种类型采取不同的行为。例如，给定两个<code>int</code>s和<code>+</code>运算符，它将它们加在一起。给定两个，<code>std::string</code>它将它们连接在一起。这称为<strong>重载</strong>。</p>
<p>这是实现功能的具体例子<code>add</code>为<code>int</code> 和<code>string</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">result</span><span class="params">(a)</span></span>;</span><br><span class="line"> result += b;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">5</span>, <span class="number">9</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//14</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="string">"hello "</span>, <span class="string">"world"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您专门化模板，Ad-hoc多态也会出现在C ++中。回到上一个关于<code>max</code>函数的例子，这里是你如何写一个最大值为2 <code>char *</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * max（<span class="keyword">const</span> <span class="keyword">char</span> * a，<span class="keyword">const</span> <span class="keyword">char</span> * b）&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">strcmp</span>（a，b）&gt; <span class="number">0</span>？a：b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-强制多态（铸造）"><a href="#4-强制多态（铸造）" class="headerlink" title="4.强制多态（铸造）"></a>4.强制多态（铸造）</h4><p>当对象或基元被转换为另一种对象类型或基本类型时，就会发生强制。例如，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> b = <span class="number">6</span>; <span class="comment">// int被提升（强制转换）为隐式浮动</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">9.99</span> <span class="comment">// float隐式降级为int</span></span><br></pre></td></tr></table></figure>

<p>当你用C的类型转换的表达式，如明确铸造发生<code>(unsigned int *)</code>或<code>(int)</code>或C ++的<code>static_cast</code>，<code>const_cast</code>，<code>reinterpret_cast</code>，或<code>dynamic_cast</code>。</p>
<p><code>explicit</code>例如，如果类的构造函数不是，则也会发生强制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"> <span class="keyword">int</span> foo; </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> A（<span class="keyword">int</span> foo）：foo（foo）&#123;&#125; </span><br><span class="line"> <span class="keyword">void</span> giggidy（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; foo &lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> moo（A a）&#123; </span><br><span class="line"> a.giggidy（）; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main（）&#123; </span><br><span class="line"> moo（<span class="number">55</span>）; <span class="comment">//打印55 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你创建了A的构造函数<code>explicit</code>，那就不可能了。让构造函数明确以避免意外转换始终是个好主意。</p>
<p>此外，如果类为类型定义转换运算符<code>T</code>，则可以在<code>T</code>期望类型的任何位置使用它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrazyInt</span> &#123;</span> </span><br><span class="line"> <span class="keyword">int</span> v; </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> CrazyInt（<span class="keyword">int</span> i）：v（i）&#123;&#125; </span><br><span class="line"> <span class="keyword">operator</span> <span class="keyword">int</span>（）<span class="keyword">const</span> &#123;<span class="keyword">return</span> v; &#125; <span class="comment">//从CrazyInt转换为int </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="C-中的虚函数-表-实现机制以及用C语言对其进行的模拟实现"><a href="#C-中的虚函数-表-实现机制以及用C语言对其进行的模拟实现" class="headerlink" title="C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现"></a>C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都应该知道C++的精髓是虚函数吧? 虚函数带来的好处就是: 可以定义一个基类的指针, 其指向一个继承类, 当通过基类的指针去调用函数时, 可以在运行时决定该调用基类的函数还是继承类的函数. 虚函数是实现多态(动态绑定)/接口函数的基础. 可以说: 没有虚函数, C++将变得一无是处!</p>
<p>既然是C++的精髓, 那么我们有必要了解一下她的实现方式吗? 有必要! 既然C++是从C语言的基础上发展而来的, 那么我们可以尝试用C语言来模拟实现吗? 有可能! 接下来, 就是我一步一步地来解析C++的虚函数的实现方式, 以及用C语言对其进行的模拟.</p>
<h2 id="C-对象的内存布局"><a href="#C-对象的内存布局" class="headerlink" title="C++对象的内存布局"></a>C++对象的内存布局</h2><p>要想知道C++对象的内存布局, 可以有多种方式, 比如:</p>
<ol>
<li><p>输出成员变量的偏移, 通过offsetof宏来得到</p>
</li>
<li><p>通过调试器查看, 比如常用的VS</p>
</li>
<li><h3 id="只有数据成员的对象"><a href="#只有数据成员的对象" class="headerlink" title="只有数据成员的对象"></a>只有数据成员的对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象大小及偏移:</p>
<table>
<thead>
<tr>
<th align="center">sizeof(Base1)</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">offsetof(Base1, base1_1)</td>
<td>0</td>
</tr>
<tr>
<td align="center">offsetof(Base1, base1_2)</td>
<td>4</td>
</tr>
</tbody></table>
<p>可知对象布局:</p>
<p><img src="/Moonstar-Z.github.io/.com//C:%5CUsers%5CCCTVZYX%5CDesktop%5C1-1.png" alt="1-1"></p>
<p>可以看到, 成员变量是按照定义的顺序来保存的, 最先声明的在最上边, 然后依次保存!<br>类对象的大小就是所有成员变量大小之和.</p>
</li>
<li><h3 id="没有虚函数的对象"><a href="#没有虚函数的对象" class="headerlink" title="没有虚函数的对象"></a>没有虚函数的对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>4</td>
</tr>
</tbody></table>
<p>和前面的结果是一样的? 不需要有什么疑问对吧?<br>因为如果一个函数不是虚函数,那么他就不可能会发生动态绑定,也就不会对对象的布局造成任何影响.<br>当调用一个非虚函数时, 那么调用的一定就是当前指针类型拥有的那个成员函数. 这种调用机制在编译时期就确定下来了.</p>
</li>
<li><h3 id="拥有仅一个虚函数的类对象"><a href="#拥有仅一个虚函数的类对象" class="headerlink" title="拥有仅一个虚函数的类对象"></a>拥有仅一个虚函数的类对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>4</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>8</td>
</tr>
</tbody></table>
<p>咦? 多了4个字节? 且 base1_1 和 base1_2 的偏移都各自向后多了4个字节!<br>说明类对象的最前面被多加了4个字节的”东东”, what’s it?<br>现在, 我们通过VS2013来瞧瞧类Base1的变量b1的内存布局情况:<br>(由于我没有写构造函数, 所以变量的数据没有根据, 但虚函数是编译器为我们构造的, 数据正确!)<br>(Debug模式下, 未初始化的变量值为<code>0xCCCCCCCC</code>, 即:<code>-858983460</code>)</p>
<p><img src="/Moonstar-Z.github.io/.com//C:%5CUsers%5CCCTVZYX%5CDesktop%5C3-1.png" alt="3-1"></p>
<p>看到没? base1_1前面多了一个变量 __vfptr(常说的虚函数表vtable指针), 其类型为void<strong>, 这说明它是一个void*指针(</strong>注意:**不是数组).</p>
<p>再看看[0]元素, 其类型为void*, 其值为 ConsoleApplication2.exe!Base1::base1_fun1(void), 这是什么意思呢? 如果对WinDbg比较熟悉, 那么应该知道这是一种惯用表示手法, 她就是指 Base1::base1_fun1() 函数的地址.</p>
<p>可得, __vfptr的定义伪代码大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>*   __fun[<span class="number">1</span>] = &#123; &amp;Base1::base1_fun1 &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>**  __vfptr = &amp;__fun[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>值得注意的是:</p>
<ol>
<li><p>上面只是一种伪代码方式, 语法不一定能通过</p>
</li>
<li><p>该类的对象大小为12个字节, 大小及偏移信息如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(__vfptr)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(base1_1)</td>
<td>4</td>
</tr>
<tr>
<td>offsetof(base1_2)</td>
<td>8</td>
</tr>
</tbody></table>
</li>
<li><p>大家有没有留意这个__vfptr? 为什么它被定义成一个指向指针数组的指针, 而不是直接定义成一个指针数组呢?</p>
<p>我为什么要提这样一个问题? 因为如果仅是一个指针的情况, 您就无法轻易地修改那个数组里面的内容, 因为她并不属于类对象的一部分.<br>属于类对象的, 仅是一个指向<strong>虚函数表的一个指针__vfptr</strong>而已, 下一节我们将继续讨论这个问题.</p>
</li>
<li><p>注意到<strong>vfptr前面的const修饰. 她修饰的是那个虚函数表, 而不是</strong>vfptr.</p>
</li>
</ol>
<p>现在的对象布局如下:</p>
<p><img src="https://blog.twofei.com/496/3-2.png" alt="img"></p>
<p>虚函数指针__vfptr位于所有的成员变量之前定义.</p>
<p>注意到: 我并未在此说明__vfptr的具体指向, 只是说明了现在类对象的布局情况.<br>接下来看一个稍微复杂一点的情况, 我将清楚地描述虚函数表的构成.</p>
</li>
<li><h3 id="拥有多个虚函数的类对象"><a href="#拥有多个虚函数的类对象" class="headerlink" title="拥有多个虚函数的类对象"></a>拥有多个虚函数的类对象</h3><p>和前面一个例子差不多, 只是再加了一个虚函数. 定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大小以及偏移信息如下:</p>
<p><img src="https://blog.twofei.com/496/4-1.png" alt="img"></p>
<p>有情况!? 多了一个虚函数, 类对象大小却依然是12个字节!</p>
<p>再来看看VS形象的表现:</p>
<p><img src="https://blog.twofei.com/496/4-2.png" alt="img"></p>
<p>呀, __vfptr所指向的函数指针数组中出现了第2个元素, 其值为Base1类的第2个虚函数base1_fun2()的函数地址.</p>
<p>现在, 虚函数指针以及虚函数表的伪定义大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* __fun[] = &#123; &amp;Base1::base1_fun1, &amp;Base1::base1_fun2 &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>** __vfptr = &amp;__fun[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>通过上面两张图表, 我们可以得到如下结论:</p>
<ol>
<li>更加肯定前面我们所描述的: __vfptr只是一个指针, 她指向一个函数指针数组(即: 虚函数表)</li>
<li>增加一个虚函数, 只是简单地向该类对应的虚函数表中增加一项而已, 并不会影响到类对象的大小以及布局情况</li>
</ol>
<p>前面已经提到过: <strong>vfptr只是一个指针, 她指向一个数组, 并且: 这个数组没有包含到类定义内部, 那么她们之间是怎样一个关系呢?<br>不妨, 我们再定义一个类的变量b2, 现在再来看看</strong>vfptr的指向:</p>
<p><img src="https://blog.twofei.com/496/4-3.png" alt="img"></p>
<p>通过Watch 1窗口我们看到:</p>
<ol>
<li>b1和b2是类的两个变量, 理所当然, 她们的地址是不同的(见 &amp;b1 和 &amp;b2)</li>
<li>虽然b1和b2是类的两个变量, 但是: 她们的__vfptr的指向却是同一个虚函数表</li>
</ol>
<p>由此我们可以总结出:</p>
<p>同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void**类型)指向该虚函数表.</p>
<p>是时候该展示一下类对象的内存布局情况了:</p>
<p><img src="https://blog.twofei.com/496/4-4.png" alt="img"></p>
<p>不出意外, 很清晰明了地展示出来了吧? :-) hoho~~</p>
<p>那么问题就来了! 这个虚函数表保存在哪里呢? 其实, 我们无需过分追究她位于哪里, 重点是:</p>
<ol>
<li>她是编译器在<strong>编译时期</strong>为我们创建好的, 只存在一份</li>
<li>定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表</li>
</ol>
</li>
<li><h3 id="单继承且本身不存在虚函数的继承类的内存布局"><a href="#单继承且本身不存在虚函数的继承类的内存布局" class="headerlink" title="单继承且本身不存在虚函数的继承类的内存布局"></a>单继承且本身不存在虚函数的继承类的内存布局</h3><p>前面研究了那么多啦, 终于该到研究继承类了! 先研究单继承!</p>
<p>依然, 简单地定义一个继承类, 如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们再来看看现在的内存布局(定义为Derive1 d1):</p>
<p><img src="https://blog.twofei.com/496/5-1.png" alt="img"></p>
<p>没错! 基类在上边, 继承类的成员在下边依次定义! 展开来看看:</p>
<p><img src="https://blog.twofei.com/496/5-2.png" alt="img"></p>
<p>经展开后来看, 前面部分完全就是Base1的东西: 虚函数表指针+成员变量定义.<br>并且, Base1的虚函数表的[0][1]两项还是其本身就拥有的函数: base1_fun1() 和 base1_fun2().</p>
<p>现在类的布局情况应该是下面这样:</p>
<p><img src="https://blog.twofei.com/496/5-3.png" alt="img"></p>
</li>
<li><h3 id="本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局"><a href="#本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局" class="headerlink" title="本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局"></a>本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局</h3><p>标题<code>本身不存在虚函数</code>的说法有些不严谨, 我的意思是说: 除经过继承而得来的基类虚函数以外, 自身没有再定义其它的虚函数.</p>
<p>Ok, 既然存在基类虚函数覆盖, 那么来看看接下来的代码会产生何种影响:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖基类函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到, Derive1类 重写了Base1类的base1_fun1()函数, 也就是常说的虚函数覆盖. 现在是怎样布局的呢?</p>
<p><img src="https://blog.twofei.com/496/6-1.png" alt="img"></p>
<p>特别注意我高亮的那一行: 原本是Base1::base1_fun1(), 但由于<strong>继承类重写</strong>了基类Base1的此方法, 所以现在变成了Derive1::base1_fun1()!</p>
<p>那么, 无论是通过Derive1的指针还是Base1的指针来调用此方法, 调用的都将是被继承类重写后的那个方法(函数), 多态发生鸟!!!</p>
<p>那么新的布局图:</p>
<p><img src="https://blog.twofei.com/496/6-2.png" alt="img"></p>
</li>
<li><h3 id="定义了基类没有的虚函数的单继承的类对象布局"><a href="#定义了基类没有的虚函数的单继承的类对象布局" class="headerlink" title="定义了基类没有的虚函数的单继承的类对象布局"></a>定义了基类没有的虚函数的单继承的类对象布局</h3><p>说明一下: 由于前面一种情况只会造成覆盖基类虚函数表的指针, 所以接下来我不再同时讨论虚函数覆盖的情况.</p>
<p>继续贴代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和第5类不同的是多了一个自身定义的虚函数. 和第6类不同的是没有基类虚函数的覆盖.</p>
<p><img src="https://blog.twofei.com/496/7-1.png" alt="img"></p>
<p>咦, 有没有发现问题? 表面上看来几乎和第5种情况完全一样? 为嘛呢?<br>现在继承类明明定义了自身的虚函数, 但不见了??<br>那么, 来看看类对象的大小, 以及成员偏移情况吧:</p>
<p><img src="https://blog.twofei.com/496/7-2.png" alt="img"></p>
<p>居然没有变化!!! 前面12个字节是Base1的, 有没有觉得很奇怪?</p>
<p>好吧, 既然表面上没办法了, 我们就只能从汇编入手了, 来看看调用derive1_fun1()时的代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun1();</span><br></pre></td></tr></table></figure>

<p>要注意: 我为什么使用指针的方式调用? 说明一下: 因为如果不使用指针调用, 虚函数调用是不会发生动态绑定的哦! 你若直接 <code>d1.derive1_fun1();</code> , 是不可能会发生动态绑定的, 但如果使用指针: <code>pd1-&gt;derive1_fun1();</code> , 那么 pd1就无从知道她所指向的对象到底是Derive1 还是继承于Derive1的对象, 虽然这里我们并没有对象继承于Derive1, 但是她不得不这样做, 毕竟继承类不管你如何继承, 都不会影响到基类, 对吧?</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun1();</span></span><br><span class="line"><span class="number">00825466</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00825469</span>  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">0082546B  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line"><span class="number">0082546D</span>  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00825470</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">8</span>]  </span><br><span class="line"><span class="number">00825473</span>  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>汇编代码解释:</p>
<p>第2行: 由于pd1是指向d1的指针, 所以执行此句后 eax 就是<strong>d1的地址</strong><br>第3行: 又因为Base1::<strong>vfptr是Base1的第1个成员, 同时也是Derive1的第1个成员, 那么: &amp;</strong>vfptr == &amp;d1, clear? 所以当执行完 <code>mov edx, dword ptr[eax]</code> 后, edx就得到了<strong>vfptr的值, 也就是<strong>虚函数表的地址</strong>.<br>第5行: 由于是</strong>thiscall调用, 所以把this保存到ecx中.<br>第6行: 一定要注意到那个 edx+8, 由于edx是虚函数表的地址, 那么 edx+8将是虚函数表的第3个元素, 也就是__vftable[2]!!!<br>第7行: 调用虚函数.</p>
<p>结果:</p>
<ol>
<li>现在我们应该知道内幕了! 继承类Derive1的虚函数表被加在基类的后面! 事实的确就是这样!</li>
<li>由于Base1只知道自己的两个虚函数索引[0][1], 所以就算在后面加上了[2], Base1根本不知情, 不会对她造成任何影响.</li>
<li>如果<strong>基类没有虚函数</strong>呢? 这个问题我们留到第9小节再来讨论!</li>
</ol>
<p>最新的类对象布局表示:</p>
<p><img src="https://blog.twofei.com/496/7-3.png" alt="img"></p>
</li>
<li><h3 id="多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"><a href="#多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局" class="headerlink" title="多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"></a>多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局</h3><p>真快, 该看看多继承了, 多继承很常见, 特别是接口类中!</p>
<p>依然写点小类玩玩:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类虚函数覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码变得越来越长啦! 为了代码结构清晰, 我尽量简化定义.</p>
<p>初步了解一下对象大小及偏移信息:</p>
<p><img src="https://blog.twofei.com/496/8-1.png" alt="img"></p>
<p>貌似, 若有所思? 不管, 来看看VS再想:</p>
<p><img src="https://blog.twofei.com/496/8-2.png" alt="img"></p>
<p>哇, 不摆了! 一丝不挂啊! :-)</p>
<p>结论:</p>
<ol>
<li>按照基类的声明顺序, 基类的成员依次分布在继承中.</li>
<li>注意被我高亮的那两行, 已经发生了虚函数覆盖!</li>
<li>我们自己定义的虚函数呢? 怎么还是看不见?!</li>
</ol>
<p>好吧, 继承反汇编, 这次的调用代码如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun2();</span><br></pre></td></tr></table></figure>

<p>反汇编代码如下:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun2();</span></span><br><span class="line"><span class="number">00995306</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00995309</span>  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">0099530B  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line"><span class="number">0099530D</span>  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00995310</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">0Ch</span>]  </span><br><span class="line"><span class="number">00995313</span>  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>解释下, 其实差不多:</p>
<p>第2行: 取d1的地址<br>第3行: 取Base1::__vfptr的值!!<br>第6行: 0x0C, 也就是第4个元素(下标为[3])</p>
<p>结论:</p>
<p>Derive1的虚函数表依然是保存到第1个拥有虚函数表的那个基类的后面的.</p>
<p>看看现在的类对象布局图:</p>
<p>（注：图中有点错误，右上角应该是 <code>void* __vftable[4]</code>，多谢 shadow3002 的提醒）</p>
<p>（注：图中有点错误，Derive1是存在虚函数覆盖的。源图丢失，请读者注意不要被误导。<a href="https://blog.twofei.com/496/#comment-577" target="_blank" rel="noopener">多谢 Oyster 的提醒</a>）</p>
<p><img src="https://blog.twofei.com/496/8-3.png" alt="img"></p>
<p>如果第1个基类没有虚函数表呢? 进入第9节!</p>
</li>
<li><h3 id="如果第1个直接基类没有虚函数-表"><a href="#如果第1个直接基类没有虚函数-表" class="headerlink" title="如果第1个直接基类没有虚函数(表)"></a>如果第1个直接基类没有虚函数(表)</h3><p>这次的代码应该比上一个要稍微简单一些, 因为把第1个类的虚函数给去掉鸟!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来看看VS的布局:</p>
<p><img src="https://blog.twofei.com/496/9-1.png" alt="img"></p>
<p>这次相对前面一次的图来说还要简单啦! Base1已经没有虚函数表了! (真实情况并非完全这样, 请继续往下看!)</p>
<p>现在的大小及偏移情况: 注意: <code>sizeof(Base1) == 8;</code></p>
<p><img src="https://blog.twofei.com/496/9-2.png" alt="img"></p>
<p>重点是看虚函数的位置, 进入函数调用(和前一次是一样的):</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun2();</span><br></pre></td></tr></table></figure>

<p>反汇编调用代码:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun2();</span></span><br><span class="line">012E4BA6  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line">012E4BA9  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">012E4BAB  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line">012E4BAD  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line">012E4BB0  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">0Ch</span>]  </span><br><span class="line">012E4BB3  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>这段汇编代码和前面一个完全一样!, 那么问题就来了! Base1 已经没有虚函数表了, 为什么还是把b1的第1个元素当作__vfptr呢?<br>不难猜测: 当前的布局已经发生了变化, 有虚函数表的基类放在对象内存前面!? , 不过事实是否属实? 需要仔细斟酌.</p>
<p>我们可以通过对基类成员变量求偏移来观察:</p>
<p><img src="https://blog.twofei.com/496/9-3.png" alt="img"></p>
<p>可以看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;d1==0x~d4</span><br><span class="line">&amp;d1.Base1::__vfptr==0x~d4</span><br><span class="line">&amp;d1.base2_1==0x~d8</span><br><span class="line">&amp;d1.base2_2==0x~dc</span><br><span class="line">&amp;d1.base1_1==0x~e0</span><br><span class="line">&amp;d1.base1_2==0x~e4</span><br></pre></td></tr></table></figure>

<p>所以不难验证: 我们前面的推断是正确的, 谁有虚函数表, 谁就放在前面!</p>
<p>现在类的布局情况:</p>
<p><img src="https://blog.twofei.com/496/9-4.png" alt="img"></p>
<p>那么, 如果两个基类都没有虚函数表呢?</p>
</li>
<li><h3 id="What-if-两个基类都没有虚函数表"><a href="#What-if-两个基类都没有虚函数表" class="headerlink" title="What if 两个基类都没有虚函数表"></a>What if 两个基类都没有虚函数表</h3><p>代码如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面吃了个亏, 现在先来看看VS的基本布局:</p>
<p><img src="https://blog.twofei.com/496/10-1.png" alt="img"></p>
<p>可以看到, 现在__vfptr已经独立出来了, 不再属于Base1和Base2!</p>
<p>看看求偏移情况:</p>
<p><img src="https://blog.twofei.com/496/10-2.png" alt="img"></p>
<p>Ok, 问题解决! 注意高亮的那两行, <code>&amp;d1==&amp;d1.__vfptr</code>, 说明虚函数始终在最前面!</p>
<p>不用再废话, 相信大家对这种情况已经有底了.</p>
<p>对象布局:</p>
<p><img src="https://blog.twofei.com/496/10-3.png" alt="img"></p>
</li>
<li><h3 id="如果有三个基类-虚函数表分别是有-没有-有"><a href="#如果有三个基类-虚函数表分别是有-没有-有" class="headerlink" title="如果有三个基类: 虚函数表分别是有, 没有, 有!"></a>如果有三个基类: 虚函数表分别是有, 没有, 有!</h3><p>这种情况其实已经无需再讨论了, 作为一个完结篇….</p>
<p>上代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">    <span class="keyword">int</span> base3_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是偏移图：</p>
<p><img src="https://blog.twofei.com/496/11-1.png" alt="img"></p>
<p>以下是对象布局图（多谢 <a href="https://blog.twofei.com/496/#comment-577" target="_blank" rel="noopener">@Oyster</a> 的手绘）：</p>
<p><img src="https://blog.twofei.com/496/11-2.jpg" alt="img"></p>
<p>只需知道: 谁有虚函数表, 谁就往前靠!</p>
</li>
</ol>
<h2 id="C-中父子对象指针间的转换与函数调用"><a href="#C-中父子对象指针间的转换与函数调用" class="headerlink" title="C++中父子对象指针间的转换与函数调用"></a>C++中父子对象指针间的转换与函数调用</h2><p>讲了那么多布局方面的东东, 终于到了尾声, 好累呀!!!</p>
<p>通过前面的讲解内容, 大家至少应该明白了各类情况下类对象的内存布局了. 如果还不会…..呃….. !@#$%^&amp;*</p>
<p>进入正题~</p>
<p>由于继承完全拥有父类的所有, 包括数据成员与虚函数表, 所以:<strong>把一个继承类强制转换为一个基类</strong>是完全可行的.</p>
<p>如果有一个Derive1的指针, 那么:</p>
<ul>
<li>得到Base1的指针: Base1* pb1 = pd1;</li>
<li>得到Base2的指针: Base2* pb2 = pd1;</li>
<li>得到Base3的指针: Base3* pb3 = pd1;</li>
</ul>
<p>非常值得注意的是:</p>
<p>这是在基类与继承类之间的转换, 这种转换会自动计算偏移! 按照前面的布局方式!<br>也就是说: 在这里极有可能: pb1 != pb2 != pb3 ~~, 不要以为她们都等于 pd1!</p>
<p>至于函数调用, 我想, 不用说大家应该知道了:</p>
<ol>
<li>如果不是虚函数, 直接调用指针对应的基本类的那个函数</li>
<li>如果是虚函数, 则查找虚函数表, 并进行后续的调用. 虚函数表在定义一个时, 编译器就为我们创建好了的. 所有的, 同一个类, 共用同一份虚函数表.</li>
</ol>
<h2 id="用C语言完全模拟C-虚函数表的实现与运作方式"><a href="#用C语言完全模拟C-虚函数表的实现与运作方式" class="headerlink" title="用C语言完全模拟C++虚函数表的实现与运作方式"></a>用C语言完全模拟C++虚函数表的实现与运作方式</h2><p>如果对前面两大节的描述仔细了解了的话, 想用C语言来模拟C++的虚函数以及多态, 想必是轻而易举的事情鸟!</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>但是, 话得说在前面, C++的编译器在生成类及对象的时候, 帮助我们完成了很多事件, 比如生成虚函数表!<br>但是, C语言编译器却没有, 因此, 很多事件我们必须手动来完成, 包括但不限于:</p>
<ol>
<li>手动构造父子关系</li>
<li>手动创建虚函数表</li>
<li>手动设置__vfptr并指向虚函数表</li>
<li>手动填充虚函数表</li>
<li>若有虚函数覆盖, 还需手动修改函数指针</li>
<li>若要取得基类指针, 还需手动强制转换</li>
<li>……</li>
</ol>
<p>总之, 要想用C语言来实现, 要写的代码绝对有点复杂.</p>
<h3 id="C-原版调用"><a href="#C-原版调用" class="headerlink" title="C++原版调用"></a>C++原版调用</h3><p>接下来, 我们都将以最后那个, 最繁杂的那个3个基类的实例来讲解, 但作了一些简化与改动:</p>
<ol>
<li>用构造函数初始化成员变量</li>
<li>减少成员变量的个数</li>
<li>减少虚函数的个数</li>
<li>调用函数时产生相关输出</li>
<li>Derive1增加一个基类虚函数覆盖</li>
</ol>
<p>以下是对类的改动, 很少:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base1() : base1_1(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::base1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2() : base2_1(<span class="number">21</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base3() : base3_1(<span class="number">31</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::base3_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derive1() : derive1_1(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::base3_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::derive1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了看到多态的效果, 我们还需要定义一个函数来看效果:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Base1* pb1, Base2* pb2, Base3* pb3, Derive1* pd1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb1-&gt;base1_1 = "</span> &lt;&lt; pb1-&gt;base1_1 &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb1-&gt;base1_fun1(): "</span>;</span><br><span class="line">    pb1-&gt;base1_fun1();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb2-&gt;base2_1 = "</span> &lt;&lt; pb2-&gt;base2_1</span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb3-&gt;base3_1 = "</span> &lt;&lt; pb3-&gt;base3_1 &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt;<span class="string">"    pb3-&gt;base3_fun1(): "</span>;</span><br><span class="line">    pb3-&gt;base3_fun1();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pd1-&gt;derive1_1 = "</span> &lt;&lt; pd1-&gt;derive1_1&lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt;<span class="string">"    pd1-&gt;derive1_fun1(): "</span>;</span><br><span class="line">    pd1-&gt;derive1_fun1();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"    pd1-&gt;base3_fun1(): "</span>;</span><br><span class="line">    pd1-&gt;base3_fun1();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">foo(&amp;d1, &amp;d1, &amp;d1, &amp;d1);</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<p><img src="https://blog.twofei.com/496/c-1.png" alt="img"></p>
<p>可以看到输出结果全部正确(当然了! :-), 哈哈~<br>同时注意到 pb3-&gt;base3_fun1() 的多态效果哦!</p>
<h3 id="用C语言来模拟"><a href="#用C语言来模拟" class="headerlink" title="用C语言来模拟"></a>用C语言来模拟</h3><p>必须要把前面的理解了, 才能看懂下面的代码!</p>
<p>为了有别于已经完成的C++的类, 我们分别在类前面加一个大写的C以示区分(平常大家都是习惯在C++写的类前面加C, 今天恰好反过来, 哈哈).</p>
<h5 id="C语言无法实现的部分"><a href="#C语言无法实现的部分" class="headerlink" title="C语言无法实现的部分"></a>C语言无法实现的部分</h5><p>C/C++是两个语言, 有些语言特性是C++专有的, 我们无法实现! 不过, 这里我是指调用约定, 我们应该把她排除在外.</p>
<p>对于类的成员函数, C++默认使用__thiscall, 也即this指针通过ecx传递, 这在C语言无法实现, 所以我们必须手动声明调用约定为:</p>
<ol>
<li><code>__stdcall</code>, 就像微软的组件对象模型那样</li>
<li><code>__cdecl</code>, 本身就C语言的调用约定, 当然能使用了.</li>
</ol>
<p>上面那种调用约定, 使用哪一种无关紧要, 反正不能使用<code>__thiscall</code>就行了.</p>
<p>因为使用了非__thiscall调用约定, 我们就必须手动传入this指针, 通过成员函数的第1个参数!</p>
<h5 id="从最简单的开始-实现-Base2"><a href="#从最简单的开始-实现-Base2" class="headerlink" title="从最简单的开始: 实现 Base2"></a>从最简单的开始: 实现 Base2</h5><p>由于没有虚函数, 仅有成员变量, 这个当然是最好模拟的咯!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="有了虚函数表的Base1-但没被覆盖"><a href="#有了虚函数表的Base1-但没被覆盖" class="headerlink" title="有了虚函数表的Base1, 但没被覆盖"></a>有了虚函数表的Base1, 但没被覆盖</h5><p>下面是Base1的定义, 要复杂一点了, 多一个__vfptr:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>** __vfptr;</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为有虚函数表, 所以还得单独为虚函数表创建一个结构体的哦!<br>但是, 为了更能清楚起见, 我并未定义前面所说的指针数组, 而是用一个包含一个或多个函数指针的结构体来表示!<br>因为数组能保存的是同一类的函数指针, 不太很友好!<br>但他们的效果是完全一样的, 希望读者能够理解明白!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base1_fun1)(CBase1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> base1_fun1 在这里是一个指针变量!<br><strong>注意:</strong> base1_fun1 有一个CBase1的指针, 因为我们不再使用__thiscall, 我们必须手动传入! Got it?</p>
<p>Base1的成员函数base1_fun1()我们也需要自己定义, 而且是定义成全局的:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">base1_fun1</span><span class="params">(CBase1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有虚函数覆盖的Base3"><a href="#有虚函数覆盖的Base3" class="headerlink" title="有虚函数覆盖的Base3"></a>有虚函数覆盖的Base3</h5><p>虚函数覆盖在这里并不能体现出来, 要在构造对象初始化的时候才会体现, 所以: base3其实和Base1是一样的.</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>** __vfptr;</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base3_fun1)(CBase3* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Base3的成员函数:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">base3_fun1</span><span class="params">(CBase3* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base3_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定义继承类CDerive1"><a href="#定义继承类CDerive1" class="headerlink" title="定义继承类CDerive1"></a>定义继承类CDerive1</h5><p>相对前面几个类来说, 这个类要显得稍微复杂一些了, 因为包含了前面几个类的内容:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CDerive1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CBase1 base1;</span><br><span class="line">    CBase3 base3;</span><br><span class="line">    CBase2 base2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>特别注意: CBase123的顺序不能错!</p>
<p>另外: 由于Derive1本身还有虚函数表, 而且所以项是加到第一个虚函数表(CBase1)的后面的, 所以此时的CBase1::__vfptr不应该单单指向CBase1_VFTable, 而应该指向下面这个包含Derive1类虚函数表的结构体才行:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1_CDerive1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (__stdcall* base1_fun1)(CBase1* that);</span><br><span class="line">    <span class="keyword">void</span>(__stdcall* derive1_fun1)(CDerive1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为CDerive1覆盖了CBase3的base3_fun1()函数, 所以不能直接用Base3的那个表:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3_CDerive1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base3_fun1)(CDerive1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Derive1覆盖Base3::base3_fun1()的函数以及自身定义的derive1_fun1()函数:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">base3_derive1_fun1</span><span class="params">(CDerive1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base3_derive1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">derive1_fun1</span><span class="params">(CDerive1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derive1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造各类的全局虚函数表"><a href="#构造各类的全局虚函数表" class="headerlink" title="构造各类的全局虚函数表"></a>构造各类的全局虚函数表</h5><p>由于没有了编译器的帮忙, 在定义一个类对象时, 所有的初始化工作都只能由我们自己来完成了!</p>
<p>首先构造全局的, 被同一个类共同使用的虚函数表!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CBase1 的虚函数表</span></span><br><span class="line">CBase1_VFTable __vftable_base1;</span><br><span class="line">__vftable_base1.base1_fun1 = base1_fun1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBase3 的虚函数表</span></span><br><span class="line">CBase3_VFTable __vftable_base3;</span><br><span class="line">__vftable_base3.base3_fun1 = base3_fun1;</span><br></pre></td></tr></table></figure>

<p>然后构造CDerive1和CBase1共同使用的虚函数表:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDerive1 和 CBase1 共用的虚函数表</span></span><br><span class="line">CBase1_CDerive1_VFTable __vftable_base1_derive1;</span><br><span class="line">__vftable_base1_derive1.base1_fun1 = base1_fun1;</span><br><span class="line">__vftable_base1_derive1.derive1_fun1 = derive1_fun1;</span><br></pre></td></tr></table></figure>

<p>再构造CDerive1覆盖CBase3后的虚函数表: 注意: 数覆盖会替换原来的函数指针</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBase3_CDerive1_VFTable __vftable_base3_derive1;</span><br><span class="line">__vftable_base3_derive1.base3_fun1 = base3_derive1_fun1;</span><br></pre></td></tr></table></figure>

<h5 id="开始-从CDerive1构造一个完整的Derive1类"><a href="#开始-从CDerive1构造一个完整的Derive1类" class="headerlink" title="开始! 从CDerive1构造一个完整的Derive1类"></a>开始! 从CDerive1构造一个完整的Derive1类</h5><p>先初始化成员变量与__vfptr的指向: 注意不是指错了!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CDerive1 d1;</span><br><span class="line">d1.derive1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">d1.base1.base1_1 = <span class="number">11</span>;</span><br><span class="line">d1.base1.__vfptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;__vftable_base1_derive1);</span><br><span class="line">    </span><br><span class="line">d1.base2.base2_1 = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">d1.base3.base3_1 = <span class="number">31</span>;</span><br><span class="line">d1.base3.__vfptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;__vftable_base3_derive1);</span><br></pre></td></tr></table></figure>

<p>由于目前的CDerive1是我们手动构造的, 不存在真正语法上的继承关系, 如要得到各基类指针, 我们就不能直接来取, 必须手动根据偏移计算:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;d1);</span><br><span class="line">Base1* pb1 = <span class="keyword">reinterpret_cast</span>&lt;Base1*&gt;(p + <span class="number">0</span>);</span><br><span class="line">Base2* pb2 = <span class="keyword">reinterpret_cast</span>&lt;Base2*&gt;(p + <span class="keyword">sizeof</span>(CBase1) + <span class="keyword">sizeof</span>(CBase3));</span><br><span class="line">Base3* pb3 = <span class="keyword">reinterpret_cast</span>&lt;Base3*&gt;(p + <span class="keyword">sizeof</span>(CBase1));</span><br><span class="line">Derive1* pd1 = <span class="keyword">reinterpret_cast</span>&lt;Derive1*&gt;(p);</span><br></pre></td></tr></table></figure>

<p>真正调用:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(pb1, pb2, pb3, pd1);</span><br></pre></td></tr></table></figure>

<p>调用结果:</p>
<p><img src="https://blog.twofei.com/496/last.png" alt="img"></p>

    </div>

    
    
    .content-wrap {
  opacity: 0.0;
}


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/Moonstar-Z.github.io/tags/重载、继承、多态/" rel="tag"># 重载、继承、多态</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Moonstar-Z.github.io/2019/09/15/C++基础/引用计数/" rel="prev" title="引用计数">
      <i class="fa fa-chevron-left"></i> 引用计数
    </a></div>
      <div class="post-nav-item">
    <a href="/Moonstar-Z.github.io/2019/09/15/重载、继承、多态/运算符的重载/" rel="next" title="运算符的重载">
      运算符的重载 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">1.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-公开继承下的public成员和protected成员的权限变化："><span class="nav-number">1.0.0.1.</span> <span class="nav-text">1.公开继承下的public成员和protected成员的权限变化：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-私有继承下的成员的权限变化关系，"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">2.私有继承下的成员的权限变化关系，</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">3.突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">4.继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-拷贝构造和赋值运算符的问题"><span class="nav-number">1.0.0.5.</span> <span class="nav-text">5.拷贝构造和赋值运算符的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-名字隐藏"><span class="nav-number">1.0.0.6.</span> <span class="nav-text">6.名字隐藏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-多继承和函数重写"><span class="nav-number">1.0.0.7.</span> <span class="nav-text">7.多继承和函数重写</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">2.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-子类型多态性（运行时多态性）"><span class="nav-number">2.0.1.</span> <span class="nav-text">1.子类型多态性（运行时多态性）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-参数多态性（编译时多态性）"><span class="nav-number">2.0.2.</span> <span class="nav-text">2.参数多态性（编译时多态性）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Ad-hoc多态（重载）"><span class="nav-number">2.0.3.</span> <span class="nav-text">3.Ad-hoc多态（重载）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-强制多态（铸造）"><span class="nav-number">2.0.4.</span> <span class="nav-text">4.强制多态（铸造）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-中的虚函数-表-实现机制以及用C语言对其进行的模拟实现"><span class="nav-number">3.</span> <span class="nav-text">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">4.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-对象的内存布局"><span class="nav-number">5.</span> <span class="nav-text">C++对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#只有数据成员的对象"><span class="nav-number">5.1.</span> <span class="nav-text">只有数据成员的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#没有虚函数的对象"><span class="nav-number">5.2.</span> <span class="nav-text">没有虚函数的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥有仅一个虚函数的类对象"><span class="nav-number">5.3.</span> <span class="nav-text">拥有仅一个虚函数的类对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥有多个虚函数的类对象"><span class="nav-number">5.4.</span> <span class="nav-text">拥有多个虚函数的类对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单继承且本身不存在虚函数的继承类的内存布局"><span class="nav-number">5.5.</span> <span class="nav-text">单继承且本身不存在虚函数的继承类的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局"><span class="nav-number">5.6.</span> <span class="nav-text">本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义了基类没有的虚函数的单继承的类对象布局"><span class="nav-number">5.7.</span> <span class="nav-text">定义了基类没有的虚函数的单继承的类对象布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"><span class="nav-number">5.8.</span> <span class="nav-text">多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果第1个直接基类没有虚函数-表"><span class="nav-number">5.9.</span> <span class="nav-text">如果第1个直接基类没有虚函数(表)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-if-两个基类都没有虚函数表"><span class="nav-number">5.10.</span> <span class="nav-text">What if 两个基类都没有虚函数表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果有三个基类-虚函数表分别是有-没有-有"><span class="nav-number">5.11.</span> <span class="nav-text">如果有三个基类: 虚函数表分别是有, 没有, 有!</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-中父子对象指针间的转换与函数调用"><span class="nav-number">6.</span> <span class="nav-text">C++中父子对象指针间的转换与函数调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用C语言完全模拟C-虚函数表的实现与运作方式"><span class="nav-number">7.</span> <span class="nav-text">用C语言完全模拟C++虚函数表的实现与运作方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前提"><span class="nav-number">7.1.</span> <span class="nav-text">前提</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-原版调用"><span class="nav-number">7.2.</span> <span class="nav-text">C++原版调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用C语言来模拟"><span class="nav-number">7.3.</span> <span class="nav-text">用C语言来模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#C语言无法实现的部分"><span class="nav-number">7.3.0.1.</span> <span class="nav-text">C语言无法实现的部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从最简单的开始-实现-Base2"><span class="nav-number">7.3.0.2.</span> <span class="nav-text">从最简单的开始: 实现 Base2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有了虚函数表的Base1-但没被覆盖"><span class="nav-number">7.3.0.3.</span> <span class="nav-text">有了虚函数表的Base1, 但没被覆盖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有虚函数覆盖的Base3"><span class="nav-number">7.3.0.4.</span> <span class="nav-text">有虚函数覆盖的Base3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#定义继承类CDerive1"><span class="nav-number">7.3.0.5.</span> <span class="nav-text">定义继承类CDerive1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造各类的全局虚函数表"><span class="nav-number">7.3.0.6.</span> <span class="nav-text">构造各类的全局虚函数表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#开始-从CDerive1构造一个完整的Derive1类"><span class="nav-number">7.3.0.7.</span> <span class="nav-text">开始! 从CDerive1构造一个完整的Derive1类</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">苍山负雪</p>
  <div class="site-description" itemprop="description">三十功名尘与土，八千里路云和月。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Moonstar-Z.github.io/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Moonstar-Z.github.io/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/Moonstar-Z.github.io/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/COTVZHAOYUEXING" title="GitHub → https://github.com/COTVZHAOYUEXING" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1998lovexs@gmail.com" title="E-Mail → mailto:1998lovexs@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍山负雪</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Moonstar-Z.github.io/lib/anime.min.js"></script>
  <script src="/Moonstar-Z.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/Moonstar-Z.github.io/lib/velocity/velocity.ui.min.js"></script>
<script src="/Moonstar-Z.github.io/js/utils.js"></script><script src="/Moonstar-Z.github.io/js/motion.js"></script>
<script src="/Moonstar-Z.github.io/js/schemes/muse.js"></script>
<script src="/Moonstar-Z.github.io/js/next-boot.js"></script>



  















  

  

  

</body>
</html>
