<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/bolgzxy.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/bolgzxy.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/bolgzxy.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/bolgzxy.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/bolgzxy.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/bolgzxy.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:type" content="website">
<meta property="og:title" content="し半世烟尘">
<meta property="og:url" content="https://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="し半世烟尘">
<meta name="twitter:description" content="黄沙百战穿金甲，不破楼兰誓不还。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/bolgzxy.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/page/3/">





  <title>し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/bolgzxy.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/bolgzxy.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/bolgzxy.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/bolgzxy.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/bolgzxy.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/List/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:07:06+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://zcheng.ren/2016/08/24/STLVector/" target="_blank" rel="noopener">上一篇博客</a>中介绍的vector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，很好的支持了随机存取，但由于是连续空间，所以在中间进行插入、删除等操作时都造成了内存块的拷贝和移动，另外在内存空间不足时还需要重新申请一块大内存来进行内存的拷贝。为了克服这些缺陷，STL定义了另一种容器List，它对于数据插入和删除的时间复杂度均为O(1)，而且再内存方面不用频繁的拷贝转移。下面，就一起来看看List的源码实现吧</p>
<h1 id="List概述"><a href="#List概述" class="headerlink" title="List概述"></a>List概述</h1><p>List和Vector都是STL的序列式容器，唯一不同的地方就在于：Vector是一段连续的内存空间，List则是一段不连续的内存空间，相比于Vector来说，List在每次插入和删除的时候，只需要配置或释放一个元素空间，对于任何位置的插入和删除操作，List永远能做到常数时间。但是，List由于不连续的内存空间，导致不支持随机寻址，所以尺有所长寸有所短，在程序中选择使用那种容器还要视元素的构造复杂度和存取行为而定。</p>
<h1 id="List的节点"><a href="#List的节点" class="headerlink" title="List的节点"></a>List的节点</h1><p>List的节点结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer; </span><br><span class="line">  void_pointer next;	<span class="comment">//型别为void*，也可以设为__list_node&lt;T&gt;*</span></span><br><span class="line">  void_pointer prev;</span><br><span class="line">  T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从节点结构可以看出，List就是一个双向链表，其结构如下图所示：</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79gw1fbkfthawhhj30ri07874t.jpg" alt="STLListNode"></p>
<h1 id="List的迭代器"><a href="#List的迭代器" class="headerlink" title="List的迭代器"></a>List的迭代器</h1><p>在Vector中，由于是连续的存储空间，支持随机存取，所以其迭代器可以直接用普通指针代替。但是，在List中行不通。List必须有能力指向List的节点，并有能力进行正确的递增、递减、取值和成员存取等操作。</p>
<p>List是一个双向链表，迭代器必须具备前移、后退的能力，所以List的迭代器是一个Bidirectional Iterator！在Vector中如果进行插入和删除操作后迭代器会失效，List有一个重要的性质就是插入和接合操作都不会造成原有的List迭代器失效。而且，再删除一个节点时，也仅有指向被删除元素的那个迭代器失效，其他迭代器不受任何影响。下面来看看List迭代器的源码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;   <span class="comment">// 支持Iterator_traits</span></span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt;           self;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以下为支持Iterator_traits而定义的一些类型</span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;	<span class="comment">//List的迭代器类型为双向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;                                </span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;    </span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;                                </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;                     </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个是迭代器实际管理的资源指针</span></span><br><span class="line">  link_type node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代器构造函数</span></span><br><span class="line">  __list_iterator(link_type x) : node(x) &#123;&#125;</span><br><span class="line">  __list_iterator() &#123;&#125;</span><br><span class="line">  __list_iterator(<span class="keyword">const</span> iterator&amp; x) : node(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在STL算法中需要迭代器提供支持</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重载operator *, 返回实际维护的数据</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成员调用操作符</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前缀自加</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">  &#123;</span><br><span class="line">    node = (link_type)((*node).next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后缀自加, 需要先产生自身的一个副本, 然会再对自身操作, 最后返回副本</span></span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">  &#123;</span><br><span class="line">    node = (link_type)((*node).prev);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List的迭代器实现了==,!=,++,–,取值和成员调用等操作，由于是存放在不连续的内存空间，所以并不支持vector那样的p+n的操作。</p>
<h1 id="List的数据结构"><a href="#List的数据结构" class="headerlink" title="List的数据结构"></a>List的数据结构</h1><p>List的数据结构个List的节点数据结构是分开定义的，SGI的List不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针，就能完整表现一个链表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个提供STL标准的allocator接口</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表的头结点，并不存放数据</span></span><br><span class="line">  link_type node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//....以下还有一堆List的操作函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ww2.sinaimg.cn/large/006tNc79gw1fbkftit4nmj30jw0g7ab2.jpg" alt="STLList">)</p>
<h1 id="List构造函数"><a href="#List构造函数" class="headerlink" title="List构造函数"></a>List构造函数</h1><p>List提供了一个空构造函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>() &#123; empty_initialize(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于空链表的建立</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">empty_initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node = get_node();</span><br><span class="line">  node-&gt;next = node;  <span class="comment">// 前置节点指向自己</span></span><br><span class="line">  node-&gt;prev = node;  <span class="comment">// 后置节点指向自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，List还提供了带参的构造函数，支持如下初始化操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; myList(<span class="number">5</span>,<span class="number">1</span>); <span class="comment">// 初始化5个1的链表，&#123;1,1,1,1,1&#125;</span></span><br></pre></td></tr></table></figure>

<p>其构造函数源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参构造函数</span></span><br><span class="line"><span class="built_in">list</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建值为value共n个结点的链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  empty_initialize();  <span class="comment">// 先创建一个空链表</span></span><br><span class="line">  insert(begin(), n, value); <span class="comment">// 插入n个值为value的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入n个值为x的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  insert(pos, (size_type)n, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position前插入n个值为x的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:insert(iterator position, size_type n, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n)</span><br><span class="line">    insert(position, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好吧，到这里才是真正的插入操作</span></span><br><span class="line"><span class="comment">// 很简单的双向链表插入操作</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  link_type tmp = create_node(x);</span><br><span class="line">  tmp-&gt;next = position.node;</span><br><span class="line">  tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">  (link_type(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">  position.node-&gt;prev = tmp;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>STL的List提供了很多种构造函数，此处我列举了其中一个，以此为例。</p>
<h1 id="List的其他操作函数"><a href="#List的其他操作函数" class="headerlink" title="List的其他操作函数"></a>List的其他操作函数</h1><h2 id="get-node"><a href="#get-node" class="headerlink" title="get_node"></a>get_node</h2><p>此函数用来配置一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置一个节点并返回</span></span><br><span class="line"><span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> list_node_allocator::allocate(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="put-node"><a href="#put-node" class="headerlink" title="put_node"></a>put_node</h2><p>此函数用来释放一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放指定结点, 不进行析构, 析构交给全局的destroy,</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">	list_node_allocator::deallocate(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="create-node"><a href="#create-node" class="headerlink" title="create_node"></a>create_node</h2><p>此函数用来配置并构造一个节点，并初始化其值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置一个节点，并初始化其值为x</span></span><br><span class="line"><span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  link_type p = get_node();</span><br><span class="line">  construct(&amp;p-&gt;data, x);	<span class="comment">//全局函数</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="destory-node"><a href="#destory-node" class="headerlink" title="destory_node"></a>destory_node</h2><p>此函数用来析构一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 析构结点元素, 并释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	destroy(&amp;p-&gt;data);	<span class="comment">//全局函数</span></span><br><span class="line">	put_node(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>此函数用来在制定位置插入一个节点(上面提到过这个函数，这里重复一下，List的主要插入工作都交给这个函数)，该函数是一个重载函数，其有多种形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好吧，到这里才是真正的插入操作</span></span><br><span class="line"><span class="comment">// 很简单的双向链表插入操作</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  link_type tmp = create_node(x);</span><br><span class="line">  tmp-&gt;next = position.node;</span><br><span class="line">  tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">  (link_type(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">  position.node-&gt;prev = tmp;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其还有如下多种形式的重载函数</span></span><br><span class="line"><span class="comment">// 在[first,last]区间内插入元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt; <span class="title">template</span> &lt;class InputIterator&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:insert(iterator position,</span><br><span class="line">                            InputIterator first, InputIterator last)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    insert(position, *first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在position位置插入元素，元素调用该型别默认构造函数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position)</span> </span>&#123; <span class="keyword">return</span> insert(position, T()); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><p>在尾部插入元素，有了上面的insert函数之后，push_back就比较容易实现了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表最后插入结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; insert(end(), x); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表前端插入结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; insert(begin(), x); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="earse"><a href="#earse" class="headerlink" title="earse"></a>earse</h2><p>移除迭代器所指的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 擦除指定结点</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 双向链表移除节点的操作</span></span><br><span class="line">	link_type next_node = link_type(position.node-&gt;next);</span><br><span class="line">	link_type prev_node = link_type(position.node-&gt;prev);</span><br><span class="line">	prev_node-&gt;next = next_node;</span><br><span class="line">	next_node-&gt;prev = prev_node;</span><br><span class="line">	destroy_node(position.node);</span><br><span class="line">	<span class="keyword">return</span> iterator(next_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述函数还有一个重载版本，移除区间内所有的节点</span></span><br><span class="line"><span class="comment">// 擦除[first, last)间的结点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">list</span>&lt;T, Alloc&gt;:</span>:iterator <span class="built_in">list</span>&lt;T, Alloc&gt;::erase(iterator first, iterator last)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (first != last) erase(first++);</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-front"><a href="#pop-front" class="headerlink" title="pop_front"></a>pop_front</h2><p>移除头节点元素，有了上述的erase函数，就很方便的实现了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除链表第一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; erase(begin()); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h2><p>移除链表中最后一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除链表最后一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	iterator tmp = end();</span><br><span class="line">	erase(--tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>清除链表中的所有节点，也就是一个一个的清除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁所有结点, 将链表置空</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:clear()</span><br><span class="line">&#123;</span><br><span class="line">  link_type cur = (link_type) node-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (cur != node) &#123;	<span class="comment">//遍历每一个节点</span></span><br><span class="line">    link_type tmp = cur;</span><br><span class="line">    cur = (link_type) cur-&gt;next;</span><br><span class="line">    destroy_node(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  node-&gt;next = node;<span class="comment">// 移除后注意要保持链表是一个循环链表</span></span><br><span class="line">  node-&gt;prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>将链表中值为value的节点移除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除特定值的所有结点</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:remove(<span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	iterator first = begin();</span><br><span class="line">	iterator last = end();</span><br><span class="line">	<span class="keyword">while</span> (first != last) &#123;	<span class="comment">//保证链表非空</span></span><br><span class="line">		iterator next = first;</span><br><span class="line">		++next;</span><br><span class="line">		<span class="keyword">if</span> (*first == value) erase(first);	<span class="comment">//擦除该节点</span></span><br><span class="line">		first = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h2><p>将某段连续范围内的元素迁移到指定位置。（非公开接口）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (position != last)</span><br><span class="line">	&#123;</span><br><span class="line">		(*(link_type((*last.node).prev))).next = position.node;</span><br><span class="line">		(*(link_type((*first.node).prev))).next = last.node;</span><br><span class="line">		(*(link_type((*position.node).prev))).next = first.node;</span><br><span class="line">		link_type tmp = link_type((*position.node).prev);</span><br><span class="line">		(*position.node).prev = (*last.node).prev;</span><br><span class="line">		(*last.node).prev = (*first.node).prev;</span><br><span class="line">		(*first.node).prev = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里借用侯捷先生的《STL源码剖析》中的一幅图来说明这个过程。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkftghh04j30eq0exwfs.jpg" alt="STLTransfer"></p>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>List提供的接合函数是Splice，上述transfer是非公开的函数。splice函数有如下几个版本:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表x移动到position之前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x.empty())</span><br><span class="line">		transfer(position, x.begin(), x.end());	<span class="comment">//仅仅调用了transfer函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表中i指向的内容移动到position之前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	iterator j = i;</span><br><span class="line">	++j;</span><br><span class="line">	<span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>;</span><br><span class="line">	transfer(position, i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将[first, last&#125;元素移动到position之前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first != last)</span><br><span class="line">		transfer(position, first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>此函数用来合并两个链表，这里两个链表必须是已拍好序的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设当前容器和x都已序, 保证两容器合并后仍然有序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:merge(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  iterator first1 = begin();</span><br><span class="line">  iterator last1 = end();</span><br><span class="line">  iterator first2 = x.begin();</span><br><span class="line">  iterator last2 = x.end();</span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">      iterator next = first2;</span><br><span class="line">      transfer(first1, first2, ++next);	<span class="comment">//将first2节点迁移到first1之后</span></span><br><span class="line">      first2 = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++first1;</span><br><span class="line">  <span class="keyword">if</span> (first2 != last2) transfer(last1, first2, last2);	<span class="comment">//如果first2还有剩余的，直接接合再链表1尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p>此函数用来反转链表，其具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表倒置</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:reverse()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;</span><br><span class="line">  iterator first = begin();</span><br><span class="line">  ++first;</span><br><span class="line">  <span class="keyword">while</span> (first != end()) &#123;</span><br><span class="line">    iterator old = first;	<span class="comment">// 取出一个节点</span></span><br><span class="line">    ++first;</span><br><span class="line">    transfer(begin(), old, first);	<span class="comment">// 插入到begin()之后</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>此函数对链表进行升序排序，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照升序排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:sort()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">list</span>&lt;T, Alloc&gt; carry;</span><br><span class="line">  <span class="built_in">list</span>&lt;T, Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">int</span> fill = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line">  	<span class="comment">// 从链表中取出一个节点</span></span><br><span class="line">    carry.splice(carry.begin(), *<span class="keyword">this</span>, begin());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把carry中的新元素和counter中的结果逐一进行归并</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; fill &amp;&amp; !counter[i].empty()) &#123;</span><br><span class="line">      counter[i].merge(carry);</span><br><span class="line">      carry.swap(counter[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把归并后的结果存放在counter[i]中</span></span><br><span class="line">    carry.swap(counter[i]);</span><br><span class="line">    <span class="comment">// 已经达到2*fill，fill自增1</span></span><br><span class="line">    <span class="keyword">if</span> (i == fill) ++fill;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将counter中的所有元素进行归并</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; fill; ++i) counter[i].merge(counter[i - <span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// 将counter链表和本链表进行交换</span></span><br><span class="line">  swap(counter[fill - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换本链表和链表x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span> </span>&#123; </span><br><span class="line">	swap(node, x.node); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以举个例子来说明一下这个过程：(以链表5,3,6,4,7,9,1,2,8)</p>
<p>carry每次从数组中取一个数，然后归并到counter数组中，该算法最多只能排序2的64次方个数。</p>
<p>《STL源码剖析》中写到此处是快速排序，其实我觉得应该是归并排序。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/Vector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/Vector/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T11:04:46+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++内置了数组的类型，在使用数组的时候，必须指定数组的长度，一旦配置了就不能改变了，通常我们的做法是：尽量配置一个大的空间，以免不够用，这样做的缺点是比较浪费空间，预估空间不当会引起很多不便。</p>
<p>STL实现了一个Vector容器，该容器就是来改善数组的缺点。vector是一个动态空间，随着元素的加入，它的内部机制会自行扩充以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，再也不必因为害怕空间不足而一开始就配置一个大容量数组了，vector是用多少就分配多少。</p>
<p>要想实现动态分配数组，Vector内部就需要对空间控制做到有效率的掌控，这些机制要如何运作才能高效地实现动态分配呢？本篇博客就从源代码的角度带你领略一下Vector容器内部的构造艺术。</p>
<h1 id="Vector概述"><a href="#Vector概述" class="headerlink" title="Vector概述"></a>Vector概述</h1><p>大家知道，初始化一个数组的时候，需要给数组分配一块内存，数组中的数据都是按序存放的。vector也是如此，再初始化的时候给vector容器分配一块内存，用来存放容器中的数据，一旦分配的内存不足以存放新加入的数据时，就需要扩充空间。STLVector的做法是：重新开辟一段新的空间，将原空间的数据迁移过去，然后新加入的数据存放在新空间之后并释放掉原有空间。</p>
<p>在这个过程中，配置新空间-&gt;数据移动-&gt;释放旧空间会带来一定的时间成本，所以必须尽可能高效的实现，STL的Vector设计中对这一部分做了相当大的优化，使得时间成本尽可能的小。下面就一起去看看这些优秀的设计吧↓。</p>
<h1 id="Vector的数据结构"><a href="#Vector的数据结构" class="headerlink" title="Vector的数据结构"></a>Vector的数据结构</h1><p>我们从最简单的开始，Vector的数据结构相当简单，由于需要判断内存是否够用，所以要用到三个指针，分别指向头，目前使用空间的尾，目前可用空间的尾。其源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;//<span class="title">alloc</span>是<span class="title">STL</span>的空间配置器</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// 这里提供STL标准的allocator接口</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"></span><br><span class="line">  iterator start;               <span class="comment">// 内存空间起始点</span></span><br><span class="line">  iterator finish;              <span class="comment">// 当前使用的内存空间结束点</span></span><br><span class="line">  iterator end_of_storage;      <span class="comment">// 实际分配内存空间的结束点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当初始化一个vector的时候，先分配一段内存，称为目前可用空间，大小为end_of_storage - start + 1，当往vector里面加入数据的时候，finish就往后移，代表目前已使用的空间，这样做的好处是，不用频繁的扩充空间和转移数据，使得时间成本下降。</p>
<p>在上述代码中，我们看到vector采用了STL标准的空间配置其接口，关于空间配置器的知识在<a href="https://zcheng.ren/2016/08/17/STLAllocater/" target="_blank" rel="noopener">带你深入理解STL之空间配置器(思维导图+源码)</a>一文中有讲解，如有疑惑，可以跳转复习一下再来！</p>
<p>vector提供了如下函数来支持获取其数据结构中的相关参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取指向vector首元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指向vector尾元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前对象个数，即已使用空间的大小</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end() - begin()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回重新分配内存前最多能存储的对象个数，即目前可用空间的大小</span></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end_of_storage - begin()); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vector的迭代器"><a href="#Vector的迭代器" class="headerlink" title="Vector的迭代器"></a>Vector的迭代器</h1><p>既然是STL的容器，必须要满足迭代器的相关要求，如对迭代器有疑惑的，参考<a href="https://zcheng.ren/2016/08/23/STLIterator/" target="_blank" rel="noopener">带你深入理解STL之迭代器和Traits技法 </a>。</p>
<p>vector维护的是一段连续的内存空间，所以不论容器中元素的型别为何，普通指针都可以作为vector的迭代器而满足所有必要的条件。vector支持随机存取，所以vector提供的是Random Access Iterator。</p>
<p>下面来看看vector关于迭代器的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// vector内部是连续内存空间，所以迭代器采用原生指针即可</span></span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator;  								</span><br><span class="line"></span><br><span class="line">  <span class="comment">//以下为满足Traits功能定义的内嵌型别</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;                  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;                </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vector的构造函数"><a href="#vector的构造函数" class="headerlink" title="vector的构造函数"></a>vector的构造函数</h1><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>在使用vector的时候，我们通常会有如下定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>

<p>在上述定义中，调用了vector的默认构造函数，其默认不分配内存空间，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector的默认构造函数默认不分配内存空间</span></span><br><span class="line"><span class="built_in">vector</span>() : start(<span class="number">0</span>), finish(<span class="number">0</span>), end_of_storage(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带参构造函数"><a href="#带参构造函数" class="headerlink" title="带参构造函数"></a>带参构造函数</h2><p>通常，vector的初始化可以指定元素个数和初始化类型。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>,<span class="number">1</span>); <span class="comment">// 将vec初始化为10个1</span></span><br></pre></td></tr></table></figure>

<p>vector提供下面的构造函数以支持上述初始化操作：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkg2cxastj30iu0dg0u0.jpg" alt="带参构造函数"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数，允许指定vector的元素个数和初值</span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要对象提供默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; fill_initialize(n, T()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 填充并予以初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  start = allocate_and_fill(n, value);</span><br><span class="line">  finish = start + n;                         <span class="comment">// 设置当前使用内存空间的结束点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里不过多的分配内存</span></span><br><span class="line">  end_of_storage = finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置一块大小为n的内存空间，并予以填充</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 调用STL的空间配置器配置一块大小为n的内存空间</span></span><br><span class="line">  iterator result = data_allocator::allocate(n); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用底层函数uninitialized_fill_n予以填充</span></span><br><span class="line">  uninitialized_fill_n(result, n, x);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面调用了uninitialized_fill_n函数，这个函数是STL的内存基本处理函数，存放在stl_uninitialized.h中，下面来看看它的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果copy construction和operator =等效, 并且destructor is trivial</span></span><br><span class="line"><span class="comment">// 那么就可以使用本函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> fill_n(first, n, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是POD类型使用以下函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ForwardIterator cur = first;</span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur)</span><br><span class="line">    construct(&amp;*cur, x);</span><br><span class="line">  <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用type_traits来判断是否是POD类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> __<span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">T1</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, is_POD());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用Iterator_traits来萃取出其值类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> <span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, value_type(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vector的元素操作函数"><a href="#vector的元素操作函数" class="headerlink" title="vector的元素操作函数"></a>vector的元素操作函数</h1><h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h2><p>push_back()函数将新元素插入于vector的尾部，该函数再完成这一操作的时候，先检查是否还有备用空间，如果有直接再备用空间上构造函数；如果没有就扩充空间，通过重新配置一块大空间，移动数据，释放原空间的操作来完成push_back操作。其源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 向容器尾追加一个元素, 可能导致内存重新分配</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//                          push_back(const T&amp; x)</span></span><br><span class="line"><span class="comment">//                                   |</span></span><br><span class="line"><span class="comment">//                                   |---------------- 容量已满?</span></span><br><span class="line"><span class="comment">//                                   |</span></span><br><span class="line"><span class="comment">//               ----------------------------</span></span><br><span class="line"><span class="comment">//           No  |                          |  Yes</span></span><br><span class="line"><span class="comment">//               |                          |</span></span><br><span class="line"><span class="comment">//               ↓                          ↓</span></span><br><span class="line"><span class="comment">//      construct(finish, x);       insert_aux(end(), x);</span></span><br><span class="line"><span class="comment">//      ++finish;                           |</span></span><br><span class="line"><span class="comment">//                                          |------ 内存不足, 重新分配</span></span><br><span class="line"><span class="comment">//                                          |       大小为原来的2倍</span></span><br><span class="line"><span class="comment">//      new_finish = data_allocator::allocate(len);       &lt;stl_alloc.h&gt;</span></span><br><span class="line"><span class="comment">//      uninitialized_copy(start, position, new_start);   &lt;stl_uninitialized.h&gt;</span></span><br><span class="line"><span class="comment">//      construct(new_finish, x);                         &lt;stl_construct.h&gt;</span></span><br><span class="line"><span class="comment">//      ++new_finish;</span></span><br><span class="line"><span class="comment">//      uninitialized_copy(position, finish, new_finish); &lt;stl_uninitialized.h&gt;</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 内存满足条件则直接追加元素, 否则需要重新分配内存空间</span></span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">    construct(finish, x);</span><br><span class="line">    ++finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    insert_aux(end(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 提供插入操作</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//                 insert_aux(iterator position, const T&amp; x)</span></span><br><span class="line"><span class="comment">//                                   |</span></span><br><span class="line"><span class="comment">//                                   |---------------- 容量是否足够?</span></span><br><span class="line"><span class="comment">//                                   ↓</span></span><br><span class="line"><span class="comment">//              -----------------------------------------</span></span><br><span class="line"><span class="comment">//        Yes   |                                       | No</span></span><br><span class="line"><span class="comment">//              |                                       |</span></span><br><span class="line"><span class="comment">//              ↓                                       |</span></span><br><span class="line"><span class="comment">// 从opsition开始, 整体向后移动一个位置                     |</span></span><br><span class="line"><span class="comment">// construct(finish, *(finish - 1));                    |</span></span><br><span class="line"><span class="comment">// ++finish;                                            |</span></span><br><span class="line"><span class="comment">// T x_copy = x;                                        |</span></span><br><span class="line"><span class="comment">// copy_backward(position, finish - 2, finish - 1);     |</span></span><br><span class="line"><span class="comment">// *position = x_copy;                                  |</span></span><br><span class="line"><span class="comment">//                                                      ↓</span></span><br><span class="line"><span class="comment">//                            data_allocator::allocate(len);</span></span><br><span class="line"><span class="comment">//                            uninitialized_copy(start, position, new_start);</span></span><br><span class="line"><span class="comment">//                            construct(new_finish, x);</span></span><br><span class="line"><span class="comment">//                            ++new_finish;</span></span><br><span class="line"><span class="comment">//                            uninitialized_copy(position, finish, new_finish);</span></span><br><span class="line"><span class="comment">//                            destroy(begin(), end());</span></span><br><span class="line"><span class="comment">//                            deallocate();</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;:</span>:insert_aux(iterator position, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;       <span class="comment">// 还有剩余内存</span></span><br><span class="line">    construct(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">    ++finish;</span><br><span class="line">    T x_copy = x;</span><br><span class="line">    copy_backward(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">    *position = x_copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;        </span><br><span class="line">    <span class="comment">// 内存不足, 需要重新分配</span></span><br><span class="line">    <span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">    <span class="comment">//配置原则：如果原大小为0，就配置1个元素大小</span></span><br><span class="line">    <span class="comment">//        如果原大小不为0，就配置原大小的两倍</span></span><br><span class="line">    <span class="comment">//				前半段用来放置原数据，后半段用来放置新数据</span></span><br><span class="line">    <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">    iterator new_start = data_allocator::allocate(len);</span><br><span class="line">    iterator new_finish = new_start;</span><br><span class="line">    <span class="comment">// 将内存重新配置</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">    	<span class="comment">// 将原vector的内容拷贝到新vector</span></span><br><span class="line">      new_finish = uninitialized_copy(start, position, new_start);</span><br><span class="line">      <span class="comment">// 构造新元素并赋值为x</span></span><br><span class="line">      construct(new_finish, x);</span><br><span class="line">      <span class="comment">// 调整finish的位置</span></span><br><span class="line">      ++new_finish;</span><br><span class="line">      <span class="comment">// 将安插点的原内容也拷贝过来</span></span><br><span class="line">      new_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 分配失败则抛出异常</span></span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      destroy(new_start, new_finish);</span><br><span class="line">      data_allocator::deallocate(new_start, len);</span><br><span class="line">      <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构原容器中的对象</span></span><br><span class="line">    destroy(begin(), end());</span><br><span class="line">    <span class="comment">// 释放原容器分配的内存</span></span><br><span class="line">    deallocate();</span><br><span class="line">    <span class="comment">// 调整内存指针状态</span></span><br><span class="line">    start = new_start;</span><br><span class="line">    finish = new_finish;</span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-back-函数"><a href="#pop-back-函数" class="headerlink" title="pop_back()函数"></a>pop_back()函数</h2><p>pop_back函数弹出当前尾端元素。其源代码比较简单，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//调整finish</span></span><br><span class="line">  --finish;</span><br><span class="line">  <span class="comment">//释放调弹出的元素</span></span><br><span class="line">  destroy(finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a>erase()函数</h2><p>erase函数支持两个版本：</p>
<ul>
<li>清除某个位置上的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position + <span class="number">1</span> != end())</span><br><span class="line">    copy(position + <span class="number">1</span>, finish, position); <span class="comment">//将[position+1,finish]移到[position,finish]</span></span><br><span class="line">  --finish;</span><br><span class="line">  destroy(finish);</span><br><span class="line">  <span class="keyword">return</span> position;<span class="comment">//返回删除点的迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>清除某个区间上的所有函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  iterator i = copy(last, finish, first);<span class="comment">//关于copy函数的源码分析在以后的博文中会提到</span></span><br><span class="line">  <span class="comment">// 析构掉需要析构的元素</span></span><br><span class="line">  destroy(i, finish);</span><br><span class="line">  finish = finish - (last - first);</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里放上两张《STL源码剖析》中的图，便于理解这一过程：</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkg2eirlej30fz0c7dgm.jpg" alt="erase函数"></p>
<p>有上述erase函数，可以衍生出一个函数，用来清除迭代器中所有的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; erase(begin(), end()); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="insert-函数"><a href="#insert-函数" class="headerlink" title="insert()函数"></a>insert()函数</h2><p>insert函数实现的功能是：从position开始，插入n个元素，元素的初值均为x。其源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 在指定位置插入n个元素</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//             insert(iterator position, size_type n, const T&amp; x)</span></span><br><span class="line"><span class="comment">//                                   |</span></span><br><span class="line"><span class="comment">//                                   |---------------- 插入元素个数是否为0?</span></span><br><span class="line"><span class="comment">//                                   ↓</span></span><br><span class="line"><span class="comment">//              -----------------------------------------</span></span><br><span class="line"><span class="comment">//        No    |                                       | Yes</span></span><br><span class="line"><span class="comment">//              |                                       |</span></span><br><span class="line"><span class="comment">//              |                                       ↓</span></span><br><span class="line"><span class="comment">//              |                                    return;</span></span><br><span class="line"><span class="comment">//              |----------- 内存是否足够?</span></span><br><span class="line"><span class="comment">//              |</span></span><br><span class="line"><span class="comment">//      -------------------------------------------------</span></span><br><span class="line"><span class="comment">//  Yes |                                               | No</span></span><br><span class="line"><span class="comment">//      |                                               |</span></span><br><span class="line"><span class="comment">//      |------ (finish - position) &gt; n?                |</span></span><br><span class="line"><span class="comment">//      |       分别调整指针                              |</span></span><br><span class="line"><span class="comment">//      ↓                                               |</span></span><br><span class="line"><span class="comment">//    ----------------------------                      |</span></span><br><span class="line"><span class="comment">// No |                          | Yes                  |</span></span><br><span class="line"><span class="comment">//    |                          |                      |</span></span><br><span class="line"><span class="comment">//    ↓                          ↓                      |</span></span><br><span class="line"><span class="comment">// 插入操作, 调整指针           插入操作, 调整指针           |</span></span><br><span class="line"><span class="comment">//                                                      ↓</span></span><br><span class="line"><span class="comment">//            data_allocator::allocate(len);</span></span><br><span class="line"><span class="comment">//            new_finish = uninitialized_copy(start, position, new_start);</span></span><br><span class="line"><span class="comment">//            new_finish = uninitialized_fill_n(new_finish, n, x);</span></span><br><span class="line"><span class="comment">//            new_finish = uninitialized_copy(position, finish, new_finish);</span></span><br><span class="line"><span class="comment">//            destroy(start, finish);</span></span><br><span class="line"><span class="comment">//            deallocate();</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;:</span>:insert(iterator position, size_type n, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果n为0则不进行任何操作</span></span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size_type(end_of_storage - finish) &gt;= n) &#123;      <span class="comment">// 剩下的内存够分配</span></span><br><span class="line">      T x_copy = x;</span><br><span class="line">      <span class="keyword">const</span> size_type elems_after = finish - position; <span class="comment">// 计算插入点之后的现有元素个数</span></span><br><span class="line">      iterator old_finish = finish;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; n) &#123;  <span class="comment">// 插入点之后的现有元素个数大于新增元素个数，见下图1</span></span><br><span class="line">      	<span class="comment">// 先复制尾部n个元素到尾部</span></span><br><span class="line">        uninitialized_copy(finish - n, finish, finish);</span><br><span class="line">        finish += n; <span class="comment">// 调整新的finish</span></span><br><span class="line">        <span class="comment">// 从后往前复制剩余的旧元素</span></span><br><span class="line">        copy_backward(position, old_finish - n, old_finish);</span><br><span class="line">        <span class="comment">// 从position开始填充新元素</span></span><br><span class="line">        fill(position, position + n, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 插入点之后的现有元素个数小于新增元素个数，见下图2</span></span><br><span class="line">      	<span class="comment">// 先在尾部填充n - elems_after个新增元素</span></span><br><span class="line">        uninitialized_fill_n(finish, n - elems_after, x_copy);</span><br><span class="line">        <span class="comment">// 调整新的finish</span></span><br><span class="line">        finish += n - elems_after;</span><br><span class="line">        <span class="comment">// 复制[position,old_finish]区间的数到新的finish之后</span></span><br><span class="line">        uninitialized_copy(position, old_finish, finish);</span><br><span class="line">        <span class="comment">// 调整finish</span></span><br><span class="line">        finish += elems_after;</span><br><span class="line">        <span class="comment">// 从position开始填充新增元素</span></span><br><span class="line">        fill(position, old_finish, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// 剩下的内存不够分配, 需要重新分配</span></span><br><span class="line">      <span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">      <span class="keyword">const</span> size_type len = old_size + max(old_size, n);</span><br><span class="line">      iterator new_start = data_allocator::allocate(len);</span><br><span class="line">      iterator new_finish = new_start;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">      	<span class="comment">// 将旧的vector中插入点之前的元素复制到新空间，见下图3</span></span><br><span class="line">        new_finish = uninitialized_copy(start, position, new_start);</span><br><span class="line">        <span class="comment">// 将新增元素复制到新空间</span></span><br><span class="line">        new_finish = uninitialized_fill_n(new_finish, n, x);</span><br><span class="line">        <span class="comment">// 将插入点之后的元素复制到新空间</span></span><br><span class="line">        new_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        destroy(new_start, new_finish);</span><br><span class="line">        data_allocator::deallocate(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 清除并释放原有vector</span></span><br><span class="line">      destroy(start, finish);</span><br><span class="line">      deallocate();</span><br><span class="line">      <span class="comment">// 调整新的start和finish</span></span><br><span class="line">      start = new_start;</span><br><span class="line">      finish = new_finish;</span><br><span class="line">      end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述操作可以使插入操作达到最高的效率。配合以下图解更容易理解：</p>
<ul>
<li><p>插入点之后的现有元素个数大于新增元素个数的情况</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkg2dn6tcj30dw0fgabf.jpg" alt="第一种情况"></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/11/STL/STL之迭代器和Traits技法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/11/STL/STL之迭代器和Traits技法/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-11T10:54:47+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在开始讲迭代器之前，先列举几个例子，由浅入深的来理解一下为什么要设计迭代器。</p>
<p>针对下面两个函数，我们来谈谈这种设计的缺陷所在：</p>
<ul>
<li>遍历int数组和单链表listNode时，需要设计两份不一样的sum求和函数，对于STL这样含有大量容器的代码库，针对每一种容器都设计sum的话，过于冗杂</li>
<li>在sum函数中暴露了太多设计细节，如ListNode的节点值类型int，和指向下一个节点的指针next</li>
<li>对于int数组来说，还必须知道数组的大小，以免越界访问</li>
<li>算法的设计过多的依赖容器，容器的改动会造成大量算法函数的随之改动</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于int类的求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) &#123;</span><br><span class="line">		sum += *a++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于listNode类的求和函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	ListNode * next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(ListNode * head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	ListNode *p = head;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		sum += p-&gt;val;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如何设计才能使得算法摆脱特定容器？如何让算法和容器各自独立设计，互不影响又能统一到一起？本篇博客就带你一窥STL的迭代器设计。</p>
<h1 id="迭代器概述"><a href="#迭代器概述" class="headerlink" title="迭代器概述"></a>迭代器概述</h1><p>迭代器是一种抽象的设计概念，在设计模式中是这么定义迭代器模式的，即提供一种方法，使之能够巡访某个聚合物所含的每一个元素，而无需暴露该聚合物的内部表述方式。</p>
<p>不论是泛型思维或STL的实际运用，迭代器都扮演着重要的角色，STL的中心思想就在于：将数据容器和算法分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。</p>
<p>谈到迭代器需要遍历容器就想到指针，的确，迭代器就是一种类似指针的对象，而指针的各种行为中最常见也最重要的就是内容提领(dereference)和成员访问(member access)，因此，迭代器最重要的编程工作就是对operator*和operator-&gt;进行重载工作。</p>
<h1 id="Traits编程技法"><a href="#Traits编程技法" class="headerlink" title="Traits编程技法"></a>Traits编程技法</h1><p>在介绍STL迭代器之前，先来看看Traits编程技法，通过它你能够更好的理解迭代器设计。</p>
<h2 id="template参数推导机制"><a href="#template参数推导机制" class="headerlink" title="template参数推导机制"></a>template参数推导机制</h2><p>我们先回过头去看看sum函数，在sum函数中，我们必须知道容器的元素类型，这关系到函数返回值。既然迭代器设计中不能暴露容器的实现细节，那么我们在算法中是不可能知道容器元素的类型，因此，必须设计出一个机制，能够提取出容器中元素的类型。看看如下示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数中并不知道iter所指的元素型别，而是通过模板T来获取的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>, <span class="title">class</span> <span class="title">T1</span> ,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">sum_impl</span>(<span class="title">I</span> <span class="title">iter</span> ,<span class="title">T1</span> <span class="title">n</span> , <span class="title">T</span> <span class="title">t</span>) &#123;</span></span><br><span class="line">	T sum = <span class="number">0</span>;<span class="comment">//通过模板的特性，可以获取I所指之物的型别,此处为int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里做func应该做的工作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ;i++)&#123;</span><br><span class="line">		sum+=*iter++;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span> , <span class="title">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T1</span> <span class="title">sum</span>(<span class="title">I</span> <span class="title">iter</span> , <span class="title">T1</span> <span class="title">n</span>) &#123;</span><span class="comment">//此处暴露了template参数推导机制的缺陷，在型别用于返回值时便束手无策</span></span><br><span class="line">	<span class="keyword">return</span> sum_impl(iter , n ,*iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> sum1 = sum(a , <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中通过模板的参数推导机制推导出了iter所指之物的型别(int)，于是可以定义T sum变量。</p>
<p>然而，迭代器所指之物的型别并非只是”迭代器所指对象的型别“，最常用的迭代器型别有五种，并非任何情况下任何一种都可利用上述的template参数推导机制来获取，而且对于返回值类型，template参数推导机制也束手无策，因此，Traits技法应运而生，解决了这一难题！</p>
<h2 id="内嵌型别机制"><a href="#内嵌型别机制" class="headerlink" title="内嵌型别机制"></a>内嵌型别机制</h2><p>Traits技法采用内嵌型别来实现获取迭代器型别这一功能需求，具体怎么实现的呢？我们看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义一个简单的iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyIter</span>&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌型别声明</span></span><br><span class="line">	T* ptr;</span><br><span class="line">	MyIter(T* p =<span class="number">0</span>):ptr(p)&#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">I</span>:</span>:value_type <span class="comment">// func返回值型别</span></span><br><span class="line">func(I iter)&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MyIter&lt;<span class="keyword">int</span>&gt; iter(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;func(iter)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，func()函数的返回值型别必须加上关键词typename，因为T是一个template参数，在它被编译器具现化之前，编译器对其一无所知，关键词typename的用意在于告诉编译器这是一个型别，如此才能通过编译。</p>
<p>内嵌型别看起来不错，可以很顺利的提取出迭代器所指型别并克服了template参数推导机制不能用于函数返回值的缺陷。可是，并不是所有的迭代器都是class type，原声指针就不是！如果不是class type，那么就无法声明内嵌型别。但是STL绝对必须接受原生指针作为一个迭代器。因此，必须另行它法！</p>
<h2 id="iterator-traits萃取机"><a href="#iterator-traits萃取机" class="headerlink" title="iterator_traits萃取机"></a>iterator_traits萃取机</h2><p>针对原生指针这类特殊情况，我们很容易想到利用模板偏特化的机制来实现特殊声明，在泛化设计中提供一个特化版本。偏特化的定义是：针对任何template参数更进一步的条件限制所设计出来的一个特化版本。这里，针对上面的MyIter设计出一个适合原生指针的特化版本，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyIter</span> &lt;T*&gt;&#123;</span>   <span class="comment">//T*代表T为原生指针，这便是T为任意型别的一个更进一步的条件限制</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌型别声明</span></span><br><span class="line">	T* ptr;</span><br><span class="line">	MyIter(T* p =<span class="number">0</span>):ptr(p)&#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了上述的介绍，包括template参数推导，内嵌型别，模板偏特化等，下面STL的真正主角要登场了，STL专门设计了一个iterator_traits模板类来”萃取“迭代器的特性。其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于traits出迭代其所指对象的型别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type        value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类如何完成迭代器的型别萃取呢？我们继续往下看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt;:</span>:value_type <span class="comment">// 通过iterator_traits类萃取I的型别</span></span><br><span class="line">func(I iter)&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从表面上来看，这么做只是多了一层间接性，但是带来的好处是极大的！iterator_traits类可以拥有特化版本，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生指针特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T  value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const指针特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &lt;const T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T  value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，原生指针int*虽然不是一种class type，也可以通过traits取其value，到这里traits的思想就基本明了了！下面就来看看STL只能中”萃取机“的源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于traits出迭代其所指对象的型别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 迭代器类型, STL提供五种迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代器所指对象的型别</span></span><br><span class="line">  <span class="comment">// 如果想与STL算法兼容, 那么在类内需要提供value_type定义</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个是用于处理两个迭代器间距离的类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接指向对象的原生指针类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个是对象的引用类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 针对指针提供特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> T*                         pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对指向常对象的指针提供特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T*                   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                   reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于源码中的五种迭代器型别在下一小节中会有详细说明。</p>
<h1 id="迭代器设计"><a href="#迭代器设计" class="headerlink" title="迭代器设计"></a>迭代器设计</h1><h2 id="迭代器型别"><a href="#迭代器型别" class="headerlink" title="迭代器型别"></a>迭代器型别</h2><h3 id="value-type"><a href="#value-type" class="headerlink" title="value_type"></a>value_type</h3><p>所谓value_type，是指迭代器所指对象的型别，在之前的示例中已经介绍得很清楚了，这里就不再赘述。</p>
<h3 id="difference-type"><a href="#difference-type" class="headerlink" title="difference_type"></a>difference_type</h3><p>difference_type用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量。下面以STL里面的计数功能函数count()为例，来介绍一下difference_type的用法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt;:</span>:difference_type   <span class="comment">//返回值类型</span></span><br><span class="line">count(I first , I end , <span class="keyword">const</span> T&amp; value)&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type n = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">for</span>( ; first!=end ; ++first)&#123;</span><br><span class="line">		<span class="keyword">if</span>(*first == value) ++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对原生指针和原生的const指针，iterator_traits的difference_type为ptrdiff_t(long int)，特化版本依然可以采用iterator_traits<em>::difference_type来获取型别。</em></p>
<h3 id="reference-type"><a href="#reference-type" class="headerlink" title="reference_type"></a>reference_type</h3><p>从“迭代器所指之物的内容是否可以改变”的角度可以将迭代器分为两种：</p>
<blockquote>
<p>const迭代器：不允许改变“所指对象之内容”，例如const int* p</p>
<p>mutable迭代器：允许改变“所指对象之内容”，例如int* p</p>
</blockquote>
<p>当我们要对一个mutable迭代器进行提领(reference)操作时，获得的不应该是一个右值(右值不允许赋值操作)，而应该是一个左值，左值才允许赋值操作。</p>
<p>故： + 当p是一个mutable迭代器时，如果其value type是T，那么<em>p的型别应该为T&amp;； + 当p是一个const迭代器时，</em>p的型别为const T&amp;</p>
<h3 id="pointer-type"><a href="#pointer-type" class="headerlink" title="pointer type"></a>pointer type</h3><p>迭代器可以传回一个指针，指向迭代器所指之物。再迭代器源码中，可以找到如下关于指针和引用的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *value; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br></pre></td></tr></table></figure>

<p>在iterator_traits结构体中需要加入其型别，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//针对原生指针的特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T*                         pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//针对原生const指针的特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T*                   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                   reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="iterator-category"><a href="#iterator-category" class="headerlink" title="iterator_category"></a>iterator_category</h3><p>这一型别代表迭代器的类别，一般分为五类：</p>
<p>Input Iterator：只读(read only)</p>
<p>Output Iterator：只写(write only)</p>
<p>Forward Iterator：允许“写入型”算法在此迭代器所形成的区间上进行读写操作</p>
<p>Bidirectional Iterator：可双向移动的迭代器</p>
<p>Random Access Iterator：前四种迭代器都只供应一部分指针的算数能力(前三种支持operator++，第四种支持operator–)，第五种则涵盖所有指针的算数能力，包括p+n,p-n,p[n],p1-p2,p1&lt;p2等在STL中，这五类迭代器的继承关系如下:</p>
<p>下面我们来看看它的源代码实现：// 用于标记迭代器类型<br>struct input_iterator_tag {};<br>struct output_iterator_tag {};<br>struct forward_iterator_tag : public input_iterator_tag {};<br>struct bidirectional_iterator_tag : public forward_iterator_tag {};<br>struct random_access_iterator_tag : public bidirectional_iterator_tag {};</p>
<h3 id="迭代器的保证"><a href="#迭代器的保证" class="headerlink" title="迭代器的保证"></a>迭代器的保证</h3><p>为了符合规范，任何迭代器都应该提供五个内嵌型别，以利于Traits萃取，否则就自别与整个STL架构，可能无法与其他STL组件顺利搭配。STL提供了一份iterator class如下：//为避免挂一漏万，每个新设计的迭代器都必须继承自它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Category</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span> = <span class="title">ptrdiff_t</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Pointer</span> = <span class="title">T</span>*, <span class="title">class</span> <span class="title">Reference</span> = <span class="title">T</span>&amp;&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器源码(完整版)/**</p>
<p>迭代器源码(完整版)/**</p>
<ul>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line">- 用于标记迭代器类型</span><br><span class="line"> */</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 用于traits出迭代其所指对象的型别</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">// 迭代器类型, STL提供五种迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代器所指对象的型别</span></span><br><span class="line">  <span class="comment">// 如果想与STL算法兼容, 那么在类内需要提供value_type定义</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个是用于处理两个迭代器间距离的类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接指向对象的原生指针类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个是对象的引用类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 针对指针提供特化版本</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                         pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                         reference;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对指向常对象的指针提供特化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T*                   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                   reference;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 返回迭代器类别</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:iterator_category</span><br><span class="line">  iterator_category(<span class="keyword">const</span> Iterator&amp;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> category();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 返回表示迭代器距离的类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:difference_type*</span><br><span class="line">  distance_type(<span class="keyword">const</span> Iterator&amp;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 返回迭代器所指对象的类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:value_type*</span><br><span class="line">  value_type(<span class="keyword">const</span> Iterator&amp;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  迭代器相关函数设计distance函数distance函数用来计算两个迭代器之前的距离。针对Input Iterator，Output Iterator，Forward Iterator，Bidirectional Iterator来说，必须逐一累加计算距离针对random_access_iterator来说，支持两个迭代器相减，所以直接相减就能得到距离其具体实现如下:<span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对Input Iterator，Output Iterator，Forward Iterator，Bidirectional Iterator</span></span><br><span class="line"><span class="comment">- 这四种函数，需要逐一累加来计算距离</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">  __distance(InputIterator first, InputIterator last, input_iterator_tag)</span><br><span class="line">  &#123;</span><br><span class="line">    iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">  ++first; ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对random_access_iterator，可直接相减来计算差距</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">iterator_traits</span>&lt;RandomAccessIterator&gt;:</span>:difference_type</span><br><span class="line">  __distance(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">         random_access_iterator_tag)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> last - first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入口函数，先判断迭代器类型iterator_category，然后调用特定函数</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">  distance(InputIterator first, InputIterator last)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> __distance(first, last, category());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Advance函数Advance函数有两个参数，迭代器p和n，函数内部将p前进n次。针对不同类型的迭代器有如下实现：针对input_iterator和forward_iterator,单向，逐一前进针对bidirectional_iterator，双向，可以前进和后退，n&gt;<span class="number">0</span>和n&lt;<span class="number">0</span>针对random_access_iterator，支持p+n，可直接计算其代码实现如下：<span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对input_iterator和forward_iterator版本</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对bidirectional_iterator版本</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">BidirectionalIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">bidirectional_iterator_tag</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">while</span> (n++) --i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对random_access_iterator版本</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">RandomAccessIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    i += n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 入口函数，先判断迭代器的类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __advance(i, n, iterator_category(i));</span><br><span class="line">  &#125;</span><br><span class="line">  附加：type_traits设计iterator_traits负责萃取迭代器的特性；type_traits负责萃取型别的特性。在带你深入理解STL之空间配置器(思维导图+源码)一篇博客中，讲到需要根据对象构造函数和析构函数的trivial和non-trivial特性来采用最有效的措施，例如：如果构造函数是trivial的，那么可以直接采用如<span class="built_in">malloc</span>()和<span class="built_in">memcpy</span>()等函数，来提高效率。例如：如果拷贝一个未知类型的数组，如果其具有trivial拷贝构造函数，那么可以直接利用<span class="built_in">memcpy</span>()来拷贝，反之则要调用该类型的拷贝构造函数。type_traits的源代码实现如下：<span class="comment">/**</span></span><br><span class="line"><span class="comment">- 用来标识真/假对象,利用type_traits响应结果来进行参数推导，</span></span><br><span class="line"><span class="comment">- 而编译器只有面对class object形式的参数才会做参数推导，</span></span><br><span class="line"><span class="comment">- 这两个空白class不会带来额外负担</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">true_type</span>&#123;</span>&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">false_type</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- type_traits结构体设计</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> __<span class="title">type_traits</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="comment">// 不要移除这个成员</span></span><br><span class="line">  <span class="comment">// 它通知能自动特化__type_traits的编译器, 现在这个__type_traits template是特化的</span></span><br><span class="line">  <span class="comment">// 这是为了确保万一编译器使用了__type_traits而与此处无任何关联的模板时</span></span><br><span class="line">  <span class="comment">// 一切也能顺利运作</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下条款应当被遵守, 因为编译器有可能自动生成类型的特化版本</span></span><br><span class="line">  <span class="comment">//   - 你可以重新安排的成员次序</span></span><br><span class="line">  <span class="comment">//   - 你可以移除你想移除的成员</span></span><br><span class="line">  <span class="comment">//   - 一定不可以修改下列成员名称, 却没有修改编译器中的相应名称</span></span><br><span class="line">  <span class="comment">//   - 新加入的成员被当作一般成员, 除非编译器提供特殊支持</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 特化类型:</span></span><br><span class="line">  <span class="comment">//         char, signed char, unsigned char,</span></span><br><span class="line">  <span class="comment">//         short, unsigned short</span></span><br><span class="line">  <span class="comment">//         int, unsigned int</span></span><br><span class="line">  <span class="comment">//         long, unsigned long</span></span><br><span class="line">  <span class="comment">//         float, double, long double</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 以下针对C++内置的基本数据类型提供特化版本, </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 使其具有trivial default constructor,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- copy constructor, assignment operator, destructor并标记其为POD类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;char&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对char的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;signed char&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对unsigned char的特化版本</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;unsigned char&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对short的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;short&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对unsigned short的特化版本</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;unsigned short&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对int的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;int&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对unsigned int的特化版本</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;unsigned int&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对long的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;long&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对unsigned long的特化版本</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;unsigned long&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对float的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;float&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对double的特化版本</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;double&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对long double的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;long double&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对指针提供特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对char *, signed char *, unsigned char *提供特化</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;char*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;signed char*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;unsigned char*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/09/C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/09/C++/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-09T12:02:41+08:00">
                2019-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="➕-C-C"><a href="#➕-C-C" class="headerlink" title="➕ C/C++"></a>➕ C/C++</h1><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针和指针常量；</li>
<li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。(在C++中，只有被声明为const的成员函数才能被一个const类对象调用。)</li>
</ol>
<p><strong><em>注意：</em></strong></p>
<p><strong>1、对于const修饰的成员函数</strong></p>
<p>1）值得注意的是，把一个成员函数声明为const可以保证这个成员函数不修改数据成员，但是，如果据成员是指针，则const成员函数并不能保证不修改指针指向的对象，编译器不会把这种修改检测为错误。</p>
<p>2）const成员函数可以被具有相同参数列表的非const成员函数重载。在这种情况下，类对象的常量性决定调用哪个函数。</p>
<p>3）对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将voidFunc(A a) 改为void Func(const A &amp;a)</p>
<p>​      对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，     又降低了函数的可理解性。例如void Func(int x) 不应该改为voidFunc(const int &amp;x)。</p>
<p>4）const 函数只能调用 const函数，即使某个函数本质上没有修改任何数据，但没有声明为const，也是不能被const函数调用的。</p>
<p><strong>2、常量指针</strong>和<strong>指针常量</strong></p>
<p>1:常量指针</p>
<p><span style="color:red">定义：具有只能够读取内存中数据，却不能够修改内存中数据的属性的指针，称为指向常量的指针，简称常量指针。</span></p>
<p>声明：const int * p; int const * p;</p>
<p>注：可以将一个常量的地址赋值给一个对应类型的常量指针，因为常量指针不能够通过指针修改内粗数据。只能防止通过指针引用修改内存中的数据，并不保护指针所指向的对象。</p>
<hr>
<p>2.指针常量<br><span style="color:red">定义：指针常量是指指针所指向的位置不能改变，即指针本身是一个常量，但是指针所指向的内容可以改变。</span></p>
<p>声明：int * const p=&a;</p>
<p>注：指针常量必须在声明的同时对其初始化，不允许先声明一个指针常量随后再对其赋值，这和声明一般的常量是一样的</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//定义常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//定义常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr1=&amp;a;</span><br><span class="line"><span class="comment">//定义指针常量，必须赋值</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr2=&amp;a;</span><br><span class="line"><span class="comment">//错误，不能把常量的地址赋给指针变量</span></span><br><span class="line"><span class="keyword">int</span> *ptr3=&amp;b;</span><br><span class="line"><span class="comment">//正确，可以把常量的地址赋给常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ptr4=&amp;b;</span><br><span class="line"><span class="comment">//错误，间接引用常量指针不可以修改内存中的数据</span></span><br><span class="line">*ptr1=<span class="number">3</span>;</span><br><span class="line"><span class="comment">//正确，间接引用指针常量可以修改内存中的数据</span></span><br><span class="line">*ptr2=<span class="number">4</span>;</span><br><span class="line"><span class="comment">//正确，常量指针可以指向其他变量</span></span><br><span class="line">ptr1=&amp;b;</span><br><span class="line"><span class="comment">//错误，指针常量不可以指向其他变量</span></span><br><span class="line">ptr2=&amp;b;</span><br><span class="line"><span class="comment">//常量指针常量，即不可以间接引用修改内存数据，也不可以指向别的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr5=&amp;a;</span><br><span class="line"><span class="comment">//错误，不可以间接引用修改内存数据</span></span><br><span class="line">*ptr5=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//错误，不可以修改指向的对象</span></span><br><span class="line">ptr5=&amp;b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>const 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>

<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li>静态成员变量（面向对象）</li>
<li>静态成员函数（面向对象）</li>
<li>静态全局变量（面向过程）</li>
<li>静态局部变量（面向过程）</li>
<li>静态函数（面向过程）</li>
</ul>
<h4 id="1-（面向对象的）静态成员变量"><a href="#1-（面向对象的）静态成员变量" class="headerlink" title="1. （面向对象的）静态成员变量"></a><strong>1. （面向对象的）静态成员变量</strong></h4><p>在类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Myclass(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> Sum;<span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">0</span>;    <span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line">Myclass::Myclass(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;a=a;</span><br><span class="line">	<span class="keyword">this</span>-&gt;b=b;</span><br><span class="line">	<span class="keyword">this</span>-&gt;c=c;</span><br><span class="line">	Sum+=a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Myclass::GetSum()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Sum="</span>&lt;&lt;Sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">	M.GetSum();</span><br><span class="line">	<span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">	N.GetSum();</span><br><span class="line">	M.GetSum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态成员变量有以下特点：</strong></p>
<ol>
<li><p>静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；</p>
</li>
<li><p><span style="color:red">因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；</span></p>
</li>
<li><p>静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。<span style="color:red">静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。</span>在Example 5中，语句int Myclass::Sum=0;是定义并初始化静态成员变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。</p>
</li>
<li><p>static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p>
</li>
<li><p>静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</p>
</li>
<li><p>类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞</p>
</li>
<li><p>类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。</p>
</li>
<li><p>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</p>
</li>
<li><p>如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；</p>
</li>
<li><p>sizeof 运算符不会计算 静态成员变量。</p>
</li>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">&#125;;    <span class="comment">//则sizeof（CMyclass）等于4</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>何时采用静态数据成员？</strong></p>
<p>设置静态成员（变量和函数）这种机制的目的是将某些和类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：</p>
<ol>
<li>不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。</li>
<li>一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。</li>
</ol>
<p>你也许会问，用全局变量不是也可以达到这个效果吗？</p>
<p>同全局变量相比，使用静态数据成员有两个优势：</p>
<ol>
<li><span style="color:red">静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。</span></li>
<li><span style="color:red">可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。</span></li>
</ol>
<h4 id="2-（面向对象的）-静态成员函数"><a href="#2-（面向对象的）-静态成员函数" class="headerlink" title="2.（面向对象的） 静态成员函数"></a><strong>2.（面向对象的） 静态成员函数</strong></h4><p>与静态成员变量类似，我们也可以声明一个静态成员函数。</p>
<p>静态成员函数为类服务而不是为某一个类的具体对象服务。静态成员函数与静态成员变量一样，都是类的内部实现，属于类定义的一部分。普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。</p>
<p>普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体地属于类的某个具体对象的。当函数被调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。</p>
<p>与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">char</span> *name;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> num;  	<span class="comment">//学生人数</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">float</span> total;  <span class="comment">//总分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Student(<span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">float</span>);</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getAverage</span><span class="params">()</span></span>;  <span class="comment">//静态成员函数，用来获得平均成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> Student::total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">   <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">   <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">   num++;</span><br><span class="line">   total += score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Student::say()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是 "</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是 "</span>&lt;&lt;score&lt;&lt;<span class="string">"（当前共"</span>&lt;&lt;num&lt;&lt;<span class="string">"名学生）"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Student::getAverage()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> total / num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   (<span class="keyword">new</span> Student(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">90</span>))-&gt;say();</span><br><span class="line">   (<span class="keyword">new</span> Student(<span class="string">"李磊"</span>, <span class="number">16</span>, <span class="number">80</span>))-&gt;say();</span><br><span class="line">   (<span class="keyword">new</span> Student(<span class="string">"张华"</span>, <span class="number">16</span>, <span class="number">99</span>))-&gt;say();</span><br><span class="line">   (<span class="keyword">new</span> Student(<span class="string">"王康"</span>, <span class="number">14</span>, <span class="number">60</span>))-&gt;say();</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"平均成绩为 "</span>&lt;&lt;Student::getAverage()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">小明的年龄是 <span class="number">15</span>，成绩是 <span class="number">90</span>（当前共<span class="number">1</span>名学生）</span><br><span class="line">李磊的年龄是 <span class="number">16</span>，成绩是 <span class="number">80</span>（当前共<span class="number">2</span>名学生）</span><br><span class="line">张华的年龄是 <span class="number">16</span>，成绩是 <span class="number">99</span>（当前共<span class="number">3</span>名学生）</span><br><span class="line">王康的年龄是 <span class="number">14</span>，成绩是 <span class="number">60</span>（当前共<span class="number">4</span>名学生）</span><br><span class="line">平均成绩为 <span class="number">82.25</span></span><br></pre></td></tr></table></figure>

<p><strong>静态成员函数的特点：</strong></p>
<ol>
<li>出现在类体外的函数定义不能指定关键字static；</li>
<li>静态成员之间可以相互访问，即静态成员函数（仅）可以访问静态成员变量、静态成员函数；</li>
<li>静态成员函数不能访问非静态成员函数和非静态成员变量；</li>
<li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li>
<li>由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；</li>
<li>调用静态成员函数，两种方式：</li>
</ol>
<ul>
<li>通过成员访问操作符(.)和(-&gt;)，也即通过类对象或指向类对象的指针调用静态成员函数。</li>
<li>直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。</li>
</ul>
<p><strong>拷贝构造函数的问题</strong></p>
<p>在使用包含静态成员的类时，有时候会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时对象在消亡时会调用析构函数有可能会对静态变量做操作（例如total_num–），可是这些对象在生成时却没有执行构造函数中的total_num++的操作。<span style="color:red">解决方案是为这个类写一个拷贝构造函数，在该拷贝构造函数中完成total_num++的操作。</span></p>
<h4 id="3-（面向过程的）静态全局变量"><a href="#3-（面向过程的）静态全局变量" class="headerlink" title="3. （面向过程的）静态全局变量"></a><strong>3. （面向过程的）静态全局变量</strong></h4><p>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//Example 1</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt; </span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line">&gt; <span class="keyword">static</span> <span class="keyword">int</span> n; <span class="comment">//定义静态全局变量 </span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; 	n=<span class="number">20</span>;</span><br><span class="line">&gt; 	<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt; 	fn();</span><br><span class="line">&gt; &#125; </span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; 	n++;</span><br><span class="line">&gt; 	<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt; &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>静态全局变量有以下特点：</strong></p>
<ol>
<li>该变量在全局数据区分配内存；</li>
<li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；</li>
<li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； 　</li>
<li>静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。<span style="color:red">自动变量一般会随着函数的退出而释放空间，而全局数据区的数据并不会因为函数的退出而释放空间。</span></li>
</ol>
<p><span style="color:green"><strong>注意</strong></span></p>
<p>如果将上面的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n; <span class="comment">//定义静态全局变量</span></span><br><span class="line"><span class="comment">//改为</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br></pre></td></tr></table></figure>

<p>没有错但是相对于这个样子，上面定义的好处是：</p>
<ol>
<li>静态全局变量不能被其它文件所用；</li>
<li>其它文件中可以定义相同名字的变量，不会发生冲突；</li>
</ol>
<h4 id="4-（面向过程的）静态局部变量"><a href="#4-（面向过程的）静态局部变量" class="headerlink" title="4. （面向过程的）静态局部变量"></a><strong>4. （面向过程的）静态局部变量</strong></h4><p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fn(); <span class="comment">//10</span></span><br><span class="line">	fn(); <span class="comment">//11</span></span><br><span class="line">	fn(); <span class="comment">//12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> n=<span class="number">10</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。</p>
<p>但有时候我们需要在两次调用之间对变量的值进行保存。<span style="color:red">通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，这给程序的维护带来不便。</span></p>
<p>静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p>
<p><strong>静态局部变量有以下特点：</strong></p>
<ol>
<li>静态局部变量在全局数据区分配内存；</li>
<li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li>
<li>静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li>
</ol>
<h4 id="5-（面向过程的）静态函数"><a href="#5-（面向过程的）静态函数" class="headerlink" title="5. （面向过程的）静态函数"></a><strong>5. （面向过程的）静态函数</strong></h4><p>在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;<span class="comment">//声明静态函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span><span class="comment">//定义静态函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义静态函数的好处：（类似于静态全局变量）</p>
<ol>
<li>静态函数不能被其它文件所用；</li>
<li>其它文件中可以定义相同名字的函数，不会发生冲突；</li>
</ol>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h4 id="1-数据、指令和内存"><a href="#1-数据、指令和内存" class="headerlink" title="1.    数据、指令和内存"></a>1.    数据、指令和内存</h4><p>在冯诺依曼体系中，程序的数据和指令，是存放在同一空间中的。在 Linux 中，它们存放在进程的虚拟内存空间中。（相关内容可以关注「程序员的自我修养」系列文章，目前有：<a href="https://liam.page/2016/08/30/review-of-hardware-development/" target="_blank" rel="noopener">一</a>/<a href="https://liam.page/2016/05/01/Introduction-to-Memory-Addressing/" target="_blank" rel="noopener">二</a>/<a href="https://liam.page/2017/01/17/fork-safe/" target="_blank" rel="noopener">三</a>）因此，对于进程来说，数据和指令其实没有本质的差别；其区别仅在于如何理解和使用虚存空间中的内容——如果读取虚存空间某个位置的值来使用，这块内容就是数据，如果执行虚存空间某个位置的代码，这块内容就是指令。决定如何理解和使用虚存空间中的内容的因素，是类型。<span style="color:red">具体到 C 和 C++ 语言来说，对应数据的那部分内存，当中存储的自然就是数据；对应函数的那部分内存，当中存储的就是指令。</span></p>
<p>因此，对于虚存空间中的内容来说，有两个关键要素：</p>
<ul>
<li>它在哪里（内存地址是多少）；</li>
<li>它具有哪些属性、能做哪些事情（它的类型是什么）。</li>
</ul>
<h4 id="2-指针是对内存区域的抽象"><a href="#2-指针是对内存区域的抽象" class="headerlink" title="2.指针是对内存区域的抽象"></a>2.指针是对内存区域的抽象</h4><p>C 和 C++ 中的指针，是一种特殊的复合类型。指针变量中存放着目标对象的内存地址，而与指针相符合的类型，则说明了相应内存区域中的内容具有哪些属性，以及能做什么事情。也就是说，在内存空间某块区域中的内容，原本可以是不可解读的；但是，如果有一个描述这块内存区域的指针存在，我们就能找到它（地址的作用），并且<strong>合理地</strong>使用它（类型的作用）。因此，我们说：<strong>指针是对内存区域的抽象</strong>。</p>
<h4 id="3-定义和使用指针"><a href="#3-定义和使用指针" class="headerlink" title="3.定义和使用指针"></a>3.定义和使用指针</h4><h5 id="3-1指针的定义"><a href="#3-1指针的定义" class="headerlink" title="3.1指针的定义"></a>3.1指针的定义</h5><p>在 C 和 C++ 中定义指针变量是很简单的，和定义普通的变量基本是一样的。所有的区别，仅在于我们需要在变量名称前使用<strong>解引用符号 *</strong> 来标记这是一个指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip1, *ip2;         <span class="comment">// ip1 和 ip2 都是指向 int 类型变量的指针变量</span></span><br><span class="line"><span class="keyword">double</span> d, *dp;          <span class="comment">// d 是 double 类型变量，dp 是指向 double 类型变量的指针变量</span></span><br></pre></td></tr></table></figure>

<p>在上述定义中，我们看到，<code>ip1</code>, <code>ip2</code>, <code>dp</code> 是三个指针——因为在它们之前用 <code>*</code> 号标记处他们是指针；而 <code>d</code> 是一个普通的 <code>double</code> 类型变量。同时，我们注意到，<code>ip1</code> 和 <code>ip2</code> 在定义之时，就确定了他们是指向 <code>int</code> 类型的变量。这意味着，被 <code>ip1</code> 和 <code>ip2</code> 指向的内存，<strong>在使用 ip1 和 ip2 进行访问的时候</strong>，将被当做是 <code>int</code> 类型的对象来对待。同理，<code>dp</code> 指向的内存，<strong>在使用 dp 进行访问的时候</strong>，将被当做是 <code>double</code> 类型的对象来对待。</p>
<p>回顾一下，我们在第一节中提到，内存空间中的内容有两个关键要素：地址和类型。在上述定义过程中，我们通过类型与解引用符号 <code>*</code> 相结合，已经确定了类型。如果要正确使用指针，我们还应该让指针记录一个地址。</p>
<h5 id="3-2获取对象的地址"><a href="#3-2获取对象的地址" class="headerlink" title="3.2获取对象的地址"></a>3.2获取对象的地址</h5><p>上面说到，我们应该在定义指针之后，记录一个地址。在 C 和 C++ 中，我们需要使用<strong>取地址符号 &amp;</strong> 来获取对象的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p  = &amp;val;     <span class="comment">// &amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里</span></span><br></pre></td></tr></table></figure>

<p>（ 绝大多数情况下，）指针的类型和对象的类型需要严格匹配。例如，你不能用一个指向 <code>int</code>类型的指针变量，保存一个 <code>double</code> 类型的对象的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> *pd1 = &amp;dval;    <span class="comment">// 正确：pd1 保存 double 类型变量 dval 的地址</span></span><br><span class="line"><span class="keyword">double</span> *pd2 = pd1;      <span class="comment">// 正确：pd1 是 double 类型的指针，可以赋值初始化同样类型的 pd2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi1 = &amp;dval;       <span class="comment">// 错误：不能用指向 int 类型变量的指针保存 double 类型变量的地址</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = pd1;         <span class="comment">// 错误：pd1 是 double 类型的指针，不能将其赋值给 int 类型的指针</span></span><br></pre></td></tr></table></figure>

<p><span style="color:green">这里是强制转换指针的类型<a href="https://blog.csdn.net/u012273127/article/details/53260978" target="_blank" rel="noopener">https://blog.csdn.net/u012273127/article/details/53260978</a></span></p>
<p>reinterpret_cast</p>
<h5 id="3-3访问指针指向的对象"><a href="#3-3访问指针指向的对象" class="headerlink" title="3.3访问指针指向的对象"></a>3.3访问指针指向的对象</h5><p>在下例中，指针 <code>p</code> 记录了变量 <code>val</code> 的地址。因此，我们可以通过解引用指针 <code>p</code> 来访问变量 <code>val</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p  = &amp;val;         <span class="comment">// &amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 通过指针 p 访问变量 val，输出 val 的值：42</span></span><br><span class="line"></span><br><span class="line">*p = <span class="number">360</span>;               <span class="comment">// 通过指针 p 改变变量 val 的值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 通过指针 p 访问变量 val，输出 val 的值：360</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 输出 val 的值：360</span></span><br></pre></td></tr></table></figure>

<h5 id="3-4空指针和空类型的指针"><a href="#3-4空指针和空类型的指针" class="headerlink" title="3.4空指针和空类型的指针"></a>3.4空指针和空类型的指针</h5><p><span style="color:red">空指针</span>是不指向任何对象的指针，在实际编程中，通常使用空指针作为指针变量有效性的判断标准。</p>
<p>C 语言和老版本 C++ 的空指针字面值是 <code>NULL</code>，它定义在 <code>stdlib</code> 当中；新版本的 C++ 使用 <code>nullptr</code> 作为空指针字面值。C++ 还支持用字面值常量 <code>0</code> 初始化指针变量，被这样初始化的指针变量会是一个空指针</p>
<p><span style="color:red">空类型的指针，</span>指的是形如 <code>void *pv</code> 的指针。这是一类特殊的指针；这里的空类型，不是说没有类型，而是说空类型的指针，可以用于存储任意类型对象的地址。</p>
<h4 id="4-理解指针的定义"><a href="#4-理解指针的定义" class="headerlink" title="4.理解指针的定义"></a>4.理解指针的定义</h4><h5 id="4-1-再探变量声明"><a href="#4-1-再探变量声明" class="headerlink" title="4.1 再探变量声明"></a>4.1 再探变量声明</h5><p> 在 C 和 C++ 中，变量的声明包括一个基本数据类型（或者类类型），以及一组声明符。定义指针使用的解引用符号 <code>*</code> 是类型修饰符，它是声明符的一部分。因此，在下列语句中，<code>int</code>是基本数据类型，<code>*p</code> 是声明符，<code>*</code> 是类型修饰符作为声明符的一部分存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br></pre></td></tr></table></figure>

<p>在同一个变量定义语句中，基本数据类型只能有一个，但是可以有多个形式相同或不同的声明符。这也就是说，同一个语句可以定义出不同类型的变量。</p>
<h5 id="4-2理解稍微复杂的指针定义"><a href="#4-2理解稍微复杂的指针定义" class="headerlink" title="4.2理解稍微复杂的指针定义"></a>4.2理解稍微复杂的指针定义</h5><p>因为指针本身也是变量，所以它当然也是存储在虚存空间里的。因此，我们当然也可以定义一个指向这一指针的指针。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val  = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *p   = &amp;val;</span><br><span class="line"><span class="keyword">int</span> **pp = &amp;p;</span><br></pre></td></tr></table></figure>

<p>我们需要仔细理解一下 <code>pp</code> 的定义。理解这类稍微复杂的定义语句，一个基本的办法就是：从最靠近变量名字的地方开始，一层一层剖析变量的类型。我们来看</p>
<ul>
<li>距离 <code>pp</code> 最近的是一个解引用符 <code>*</code>，这预示着 <code>pp</code> 是一个指针，它指向 <code>int *</code> 类型的变量；</li>
<li>再来看 <code>int *</code>，距离 <code>*pp</code> 最近的，依然是一个解引用符，这意味着 <code>*pp</code> 也是一个指针，它指向 <code>int</code> 类型的变量；</li>
<li>因此 <code>pp</code> 是一个<strong>指向指向 int 类型变量的指针的指针</strong>。</li>
</ul>
<h4 id="5-指针与数组"><a href="#5-指针与数组" class="headerlink" title="5.指针与数组"></a>5.指针与数组</h4><h5 id="5-1数组的名字被当做指针使用"><a href="#5-1数组的名字被当做指针使用" class="headerlink" title="5.1数组的名字被当做指针使用"></a>5.1数组的名字被当做指针使用</h5><p>在 C 和 C++ 中，指针与数组有非常紧密的联系。实际上，使用数组的时候，编译器通常都是在操作指针。这里我们从两个角度说明数组名在很多时候被当做是一个指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;(nums[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (p == nums) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"true!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你执行这一小段代码，那么，不出意外的话，程序会在终端上打印 true!，以及 nums 中的三个数字。这预示着，指针变量 p 保存的内容（也就是 nums[0] 的地址）和 nums 保存的内容是完全一样的；同时，编译器以相同的方式去解释 p 和 nums。显然 p 是一个指向 int 型变量的指针，那么 nums 也就是一个指针了</p>
<h5 id="5-2也不是全部时候"><a href="#5-2也不是全部时候" class="headerlink" title="5.2也不是全部时候"></a>5.2也不是全部时候</h5><p>当然，也不是全部时候，数组名字都被当做是简单的指针。比如，<a href="https://liam.page/2016/11/26/init-vector-from-array/" target="_blank" rel="noopener">前作</a>中的使用方式表明，<span style="color:green">在数组名字被传入 <code>sizeof()</code> 运算符的时候，它会被当做是一个真实的数组来看待。</span></p>
<h5 id="5-3数组指针可以自增"><a href="#5-3数组指针可以自增" class="headerlink" title="5.3数组指针可以自增"></a>5.3数组指针可以自增</h5><p>数组的指针，可以像 C++ 中 <code>std::vector</code> 的迭代器那样进行自增操作。这句话不是太严谨，因为，实际上是先有数组的指针，再有 <code>std::vector</code> 的迭代器；迭代器实际上是仿造数组的指针设计的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);<span class="comment">//计算出数组的长度的办法</span></span><br><span class="line"><span class="keyword">int</span> *iter;</span><br><span class="line"><span class="keyword">int</span> *end = nums + len;     <span class="comment">// end 是尾后指针</span></span><br><span class="line"><span class="keyword">for</span> (iter = nums; iter != end; ++iter) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4数组下标与指针加减"><a href="#5-4数组下标与指针加减" class="headerlink" title="5.4数组下标与指针加减"></a>5.4数组下标与指针加减</h5><p>上面提到，数组指针可以进行加减运算：数组指针与整数的加减，实际是将指针沿着数组进行移动，得到的结果还是一个指针。既然结果是指针，那么就可以解引用，访问数组中的元素。因此有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> *p = nums;</span><br><span class="line"><span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != len; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == *(p + i)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"true!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而事实上，在使用下标访问数组元素的时候，编译器都会转换成类似 <code>*(nums + i)</code> 的形式。也就是说，通过指针运算和解引用来访问数组元素，其实是更加本质的方式。</p>
<h4 id="6-函数与指针"><a href="#6-函数与指针" class="headerlink" title="6.函数与指针"></a>6.函数与指针</h4><h5 id="6-1让函数返回一个数组的指针"><a href="#6-1让函数返回一个数组的指针" class="headerlink" title="6.1让函数返回一个数组的指针"></a>6.1让函数返回一个数组的指针</h5><p>我们知道，函数在返回的过程中，会对返回值进行拷贝。因此，一个无法拷贝的对象，是无法被函数返回的。（也可以参考<a href="https://liam.page/2016/08/14/copy-control-in-Cpp/" target="_blank" rel="noopener">此篇</a>）数组是不能被拷贝的，所以函数无法直接返回数组。为了达到返回数组的目的，我们只能寄希望于让函数返回数组的指针（在 C++ 中还可以返回数组的引用）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];        <span class="comment">// arr 是一个数组，长度是 10，元素类型是 int 型</span></span><br><span class="line"><span class="keyword">int</span> *parr[<span class="number">10</span>];      <span class="comment">// parr 是一个数组，长度是 10，元素类型是 int *，也就是数组中存的是指针</span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">10</span>] = &amp;arr <span class="comment">// p 是一个指针，它指向一个长度是 10 元素类型是 int 型的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *(func(param_list))[<span class="number">10</span>];</span><br><span class="line">                    <span class="comment">// 错误：func 是一个函数，param_list 是它的参数</span></span><br><span class="line">                    <span class="comment">// 它尝试返回一个长度为 10，元素类型为 int * 的数组</span></span><br><span class="line">                    <span class="comment">// 而数组是无法返回的</span></span><br><span class="line"><span class="keyword">int</span> (*func(param_list))[<span class="number">10</span>];</span><br><span class="line">                    <span class="comment">// 正确：func 是一个函数，param_list 是它的参数</span></span><br><span class="line">                    <span class="comment">// 它返回的是一个指针</span></span><br><span class="line">                    <span class="comment">// 这个指针指向了一个长度为 10 元素类型是 int 型的数组</span></span><br><span class="line"><span class="comment">//下面是正常的函数的指针</span></span><br><span class="line">  element_type (*func(param_list))[dimension]</span><br></pre></td></tr></table></figure>

<h5 id="6-2函数的指针"><a href="#6-2函数的指针" class="headerlink" title="6.2函数的指针"></a>6.2函数的指针</h5><p>上文提到，无论是数据（变量）还是指令（函数），都是存放在虚存空间的。因此，既然有变量的指针，那么也一定会有函数的指针。这就是我们这一小节需要讨论的函数指针；这会逐渐引出本文最复杂的话题。</p>
<p>一个函数的类型，取决于它的输入和输出。这也就是说，一个函数的类型，应当包含它的返回值类型和参数列表。比如下面定义的函数，用于比较两个 <code>int</code> 型数据是否相等（这是一个仅用于示例而没有实际用处的函数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isEqual(int, int);</span><br></pre></td></tr></table></figure>

<p>对于一个函数来说，如果你能拿到它的定义，就很容易能取得它的类型：只需要去掉函数名字就可以了。因此，定义一个指向该类型的函数指针，并不困难。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> (*pfunc)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp;isEqual;     <span class="comment">// 定义了一个函数指针，指向 isEqual</span></span><br><span class="line"><span class="keyword">bool</span> (*pfunc)(<span class="keyword">int</span>, <span class="keyword">int</span>) = isEqual;      <span class="comment">// 一个等价定义</span></span><br></pre></td></tr></table></figure>

<p>在这里，<code>pfunc</code> 就是一个函数指针，它指向一个 <code>bool (int, int)</code> 类型的函数。也就是说，这类函数接收两个 <code>int</code> 型的参数，并返回一个 <code>bool</code> 类型的值。</p>
<p>值得一提的是，当函数名字作为值使用时，它会自动地转换成指针（有点像数组名字，不是吗）。因此，在函数指针的初始化或者复制的过程中，取值运算符是可选的。于是，上述两个定义语句是等价的。另一方面，函数指针作为函数调用使用时，它会自动转换成函数名（有点像数组指针，不是吗）。因此，这种情况下，解引用运算符是可选的。请看下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> (*pfunc)(<span class="keyword">int</span>, <span class="keyword">int</span>) = isEqual;<span class="keyword">bool</span> res1 = isEqual(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 通过原函数名调用</span></span><br><span class="line"><span class="keyword">bool</span> res2 = (*pfunc)(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 一个等价调用：通过函数指针，解引用调用</span></span><br><span class="line"><span class="keyword">bool</span> res3 = pfunc(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// 另一个等价调用：函数指针自动转换成函数名</span></span><br></pre></td></tr></table></figure>

<p><span style="color:red">值得一提的是，不同类型的函数的指针之间，不存在任何的类型转换：你不能期待一个接受两个 <code>int</code> 型参数并返回 <code>bool</code> 值的函数的指针，经过类型转换，就能接受三个 <code>int</code> 型的参数。因此，对于重载的同名函数，他们的函数类型是不一样的，因此函数指针也不能是同一个。</span></p>
<h5 id="6-3将函数指针作为参数传入另一个函数"><a href="#6-3将函数指针作为参数传入另一个函数" class="headerlink" title="6.3将函数指针作为参数传入另一个函数"></a>6.3将函数指针作为参数传入另一个函数</h5><p>在传参的过程中（除了 C++ 的传引用），也是伴随着拷贝的过程。因此，一个对象如果不能拷贝，那么它就不能作为参数传入函数。无疑，函数是不能拷贝的，因此你无法将函数作为参数直接传给另一个函数。但是，指针是可以拷贝的，因此，你可以将函数指针作为参数，传给另一个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addIfEqual</span><span class="params">(<span class="keyword">int</span> lhs, <span class="keyword">int</span> rhs, <span class="keyword">bool</span> pfunc(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span>;</span><br><span class="line">                            <span class="comment">// addIfEqual 的第三个参数是一个函数定义</span></span><br><span class="line">                            <span class="comment">// 它会自动地转换成一个函数指针的参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addIfEqual</span><span class="params">(<span class="keyword">int</span> lhs, <span class="keyword">int</span> rhs, <span class="keyword">bool</span> (*pfunc)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span>;</span><br><span class="line">                            <span class="comment">// 一个等价定义：显式地注明第三个参数是函数指针</span></span><br></pre></td></tr></table></figure>

<h5 id="6-4让函数返回一个函数的指针"><a href="#6-4让函数返回一个函数的指针" class="headerlink" title="6.4让函数返回一个函数的指针"></a>6.4让函数返回一个函数的指针</h5><h4 id="7-登峰造极的-void-0"><a href="#7-登峰造极的-void-0" class="headerlink" title="7.登峰造极的 (*(void(*)())0)();"></a>7.登峰造极的 <code>(*(void(*)())0)();</code></h4><p>它表示：<strong>访问内存地址 0，将它作为一个参数列表和返回类型均为空的函数，并执行函数调用</strong>。（这是一个特殊场景下的函数调用，不用纠结为什么会调用 <code>0</code> 位置上的函数）</p>
<p>我们知道 <code>void(*pfunc)();</code> 定义了一个函数指针 <code>pfunc</code>，它指向的函数参数列表为空、返回值类型也为空。因此，<code>(void(*)())</code> 就是一个 C 风格的类型转换符。</p>
<p>因此，<code>(void(*)())0</code> 会将 <code>0</code> 转换成一个函数指针，然后交给 <code>*</code> 解引用，最后传入参数（空的参数列表 <code>()</code>），执行函数调用</p>
<h4 id="8-this-指针"><a href="#8-this-指针" class="headerlink" title="8.this 指针"></a>8.this 指针</h4><ol>
<li><span style="color:red"><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</span></li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用 <code>this</code> 指针：<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
<h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h2><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>inline 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::doA() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>

<h4 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h4><ol>
<li>将 inline 函数体复制到 inline 函数调用点处； </li>
<li>为所用 inline 函数中的局部变量分配内存空间； </li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点</p>
<ol>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h4 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h4><blockquote>
<p><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html" target="_blank" rel="noopener">Are “inline virtual” member functions ever actually “inlined”?</a></p>
</blockquote>
<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
<p>虚函数内联使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">	Base b;</span><br><span class="line">	b.who();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">	Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">	ptr-&gt;who();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">	ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。<span style="color:red">所以使用 volatile 告诉编译器不应对这样的对象进行优化。</span></li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
<h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p>assert() 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure>

<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h2><ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
<h2 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h2><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<p>#pragma pack(n) 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure>

<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bit mode: <span class="number">2</span>;    <span class="comment">// mode 占 2 位</span></span><br></pre></td></tr></table></figure>

<p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ul>
<li>位域在内存中的布局是与机器有关的</li>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ul>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>这里还有几种情况</p>
<h5 id="extren-‘c’"><a href="#extren-‘c’" class="headerlink" title="extren ‘c’"></a>extren ‘c’</h5><ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li>
</ul>
<p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<p>extern “C” 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h2><h4 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure>

<p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p>
<p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p>
<h4 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h4><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p>
<p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p>
<p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure>

<p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student(); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h4><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>最本质的一个区别就是默认的访问控制<ol>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。  </li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ol>
</li>
</ul>
<h2 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h2><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<p>union 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h2><p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p>
<ul>
<li>封装：使用函数指针把属性与方法封装到结构体中</li>
<li>继承：结构体嵌套</li>
<li>多态：父类与子类方法的函数指针不同</li>
</ul>
<blockquote>
<p><a href="https://stackoverflow.com/a/351745" target="_blank" rel="noopener">Can you write object-oriented code in C? [closed]</a></p>
</blockquote>
<h2 id="explicit（显式）关键字-有改进的地方"><a href="#explicit（显式）关键字-有改进的地方" class="headerlink" title="explicit（显式）关键字 /有改进的地方"></a>explicit（显式）关键字 /有改进的地方</h2><p>C++中，一个参数的构造函数(或者除了第一个参数外其余参数都有缺省值的多参构造函数)，承担了两个角色。</p>
<ul>
<li>用于构建单参数的类对象</li>
<li>隐含的类型转换操作符</li>
</ul>
<p>声明为explicit的构造函数不能在隐式转换中使用，只能显示调用，去构造一个类对象。</p>
<p>explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了</p>
<p>但是将拷贝构造函数声明成explicit并不是良好的设计，一般只将有单个参数的constructor声明为explicit，而copy constructor不要声明为explicit.</p>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">按语境转换</a> 除外</li>
</ul>
<p>explicit 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	A(<span class="keyword">int</span>) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">	A a2 = <span class="number">1</span>;		<span class="comment">// OK：复制初始化</span></span><br><span class="line">	A a3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">	A a4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：复制列表初始化</span></span><br><span class="line">	A a5 = (A)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换 </span></span><br><span class="line">	doA(<span class="number">1</span>);			<span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line">	<span class="keyword">if</span> (a1);		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a6（a1）;		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a7 = a1;		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">	B b2 = <span class="number">1</span>;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">	B b3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">	B b4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">	B b5 = (B)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">	doB(<span class="number">1</span>);			<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line">	<span class="keyword">if</span> (b1);		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">	<span class="keyword">bool</span> b7 = b1;		<span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> b8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h2><p>友元的作用是提高了程序的运行效率（即减少了类型检查和安全性检查等都需要时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。</p>
<ul>
<li>能访问私有成员  </li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
<p>下面是友元函数的实例，分别定义一个类A和类B ，各有一个私有整数成员变量通过构造函数初始化；类A有一个成员函数Show(B &amp;b)用来打印A和B的私有成员变量，请分别通过友元函数和友元类来实现此功能。使用友元类 和 友元函数实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">( A&amp; , B&amp; )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> tt;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">( A&amp; , B&amp; )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B( <span class="keyword">int</span> temp = <span class="number">100</span>):tt ( temp )&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">( A&amp; , B&amp; )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> temp = <span class="number">200</span> ):value ( temp )&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">( B &amp;b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; b.tt &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">( A&amp; a, B&amp; b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b .tt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">a.Show( b );</span><br><span class="line"></span><br><span class="line">Show( a, b );</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><h4 id="1-using-声明"><a href="#1-using-声明" class="headerlink" title="1.using 声明"></a>1.using 声明</h4><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::name;</span><br></pre></td></tr></table></figure>

<h4 id="2-构造函数的-using-声明"><a href="#2-构造函数的-using-声明" class="headerlink" title="2.构造函数的 using 声明"></a>2.构造函数的 using 声明</h4><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived(parms) : Base(args) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-using-指示"><a href="#3-using-指示" class="headerlink" title="3.using 指示"></a>3.using 指示</h4><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name name;</span><br></pre></td></tr></table></figure>

<h4 id="4-尽量少使用-using-指示-污染命名空间"><a href="#4-尽量少使用-using-指示-污染命名空间" class="headerlink" title="4.尽量少使用 using 指示 污染命名空间"></a>4.尽量少使用 <code>using 指示</code> 污染命名空间</h4><blockquote>
<p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了指定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
</blockquote>
<p>using 使用</p>
<p>尽量少使用 <code>using 指示</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>应该多使用 <code>using 声明</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-别名指定"><a href="#5-别名指定" class="headerlink" title="5.别名指定"></a>5.别名指定</h4><p>在C++11中，可以用using指定别名，那么和之前的typedef有什么区别呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> FP = <span class="keyword">void</span> (*) (<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>

<h2 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h2><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol>
<li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p>:: 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::count = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::count = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    count = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h2><p>C/C++ 语言可以使用 <strong>#define</strong> 和 <strong>const</strong> 创建符号常量，而使用 <strong>enum</strong> 工具不仅能够创建符号常量，还能定义新的数据类型，但是必须按照一定的规则进行，下面我们一起看下 <strong>enum</strong> 的使用方法。</p>
<h4 id="1-枚举量的声明和定义"><a href="#1-枚举量的声明和定义" class="headerlink" title="1.枚举量的声明和定义"></a>1.枚举量的声明和定义</h4><p><strong>(1)</strong> 首先，请看下面的语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> enumType &#123;Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday&#125;;</span><br></pre></td></tr></table></figure>

<p>这句话有两个作用：</p>
<ul>
<li>第一：声明 enumType 为新的数据类型，称为枚举(enumeration);</li>
<li>第二：声明 Monday、Tuesday 等为符号常量，通常称之为枚举量，其值默认分别为 0-6。（后面会介绍怎样显式的初始化枚举量的值）</li>
</ul>
<p><strong>(2)</strong> 接着利用新的枚举类型 enumType 声明这种类型的变量：enumType Weekday 就像使用基本变量类型int声明变量一样，如 int a; 也可以在定义枚举类型时定义枚举变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> enumType &#123;Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday&#125;Weekday;</span><br></pre></td></tr></table></figure>

<p>然而与基本变量类型不同的地方是，在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量，如：Weekday = Monday; 或者 Weekday = Sunday; 不能将其他值赋给枚举变量，如：Weekday = 10; 这是不允许的，因为 10 不是枚举量。也就是说 Weekday 只能是定义的 Monday-Sunday 这些定义过的枚举量。然而这不是绝对的，第六条会讲到利用强制类型转换将其他类型值赋给枚举变量。</p>
<p><strong>(3)</strong> 上面讲不能将非枚举量赋给枚举变量，那么能不能将枚举量赋给非枚举变量呢？如：<strong>int a=Monday;</strong> 这是允许的，因为枚举量是符号常量，这里的赋值编译器会自动把枚举量转换为int类型。</p>
<p><strong>(4)</strong> 前面讲可以对枚举进行赋值运算，那枚举变量能不能进行算术运算呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weekday++;Weekday = Monday + Tuesday;</span><br></pre></td></tr></table></figure>

<p>这是非法的，因为这些操作可能导致违反类型限制，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Weekday = Sunday;</span><br><span class="line">Weekday++;</span><br></pre></td></tr></table></figure>

<p>Weekday 首先被赋予枚举量中的最后一个值 Sunday(值为6)，再进行递增的话，Weekday 增加到 7，而对于 enumType 类型来说，7 是无效的。</p>
<p><strong>总结：</strong>对于枚举，只定义了赋值运算符，没有为枚举定义算术运算。</p>
<p><strong>(5)</strong>不能对枚举量进行算术运算，那么枚举量能不能参与其他类型变量的运算呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">a = <span class="number">1</span> + Monday;</span><br></pre></td></tr></table></figure>

<p>这是允许的，因为编译器会自动把枚举量转换为 int 类型。</p>
<p><strong>(6)</strong>第二条讲：在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量，言下之意就是可以通过强制转换将其他类型值赋给枚举变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weekday = enumType(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weekday = Wednesday;</span><br></pre></td></tr></table></figure>

<p>但是，如果试图将一个超出枚举取值范围的值通过强制转换赋给枚举变量，会出现什么结果？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weekday = enumType(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>结果将是不确定的，这么做不会出错，但得不到想要的结果。</p>
<h4 id="2-自定义枚举量的值"><a href="#2-自定义枚举量的值" class="headerlink" title="2.自定义枚举量的值"></a>2.自定义枚举量的值</h4><p><strong>(1)</strong> 前面讲通过定义 <strong>enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};</strong> 枚举量 Monday、Tuesday 等的值默认分别为 0-6，我们可以显式的设置枚举量的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum enumType &#123;Monday=1, Tuesday=2, Wednesday=3, Thursday=4, Friday=5, Saturday=6, Sunday=7&#125;;</span><br></pre></td></tr></table></figure>

<p>指定的值必须是整数！</p>
<p><strong>(2)</strong> 也可以只显式的定义一部分枚举量的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum enumType &#123;Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday&#125;;</span><br></pre></td></tr></table></figure>

<p>这样 Monday、Wednesday 均被定义为 1，则 Tuesday=2，Thursday、Friday、Saturday、Sunday 的值默认分别为 2、3、4、5。</p>
<p><strong>总结：</strong>未被初始化的枚举值的值默认将比其前面的枚举值大1。</p>
<p><strong>(3)</strong> 第二条还说明另外一个现象，就是枚举量的值可以相同。</p>
<h4 id="3-枚举的取值范围"><a href="#3-枚举的取值范围" class="headerlink" title="3.枚举的取值范围"></a>3.枚举的取值范围</h4><p>前面讲到可以通过强制转换将其他类型值赋给枚举变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weekday = enumType(2);</span><br></pre></td></tr></table></figure>

<p>这是合法的；</p>
<p>但是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weekday = enumType(20);</span><br></pre></td></tr></table></figure>

<p>是非法的。这里涉及枚举取值范围的概念：枚举的上限是 大于最大枚举量的 最小的 2 的幂，减去 1；</p>
<p>枚举的下限有两种情况：一、枚举量的最小值不小于 0，则枚举下限取 0；二、枚举量的最小值小于 0，则枚举下限是小于最小枚举量的最大的 2 的幂，加上 1。</p>
<p>举例来讲：</p>
<p>假如定义 <strong>enum enumType1 { First=-5，Second=14，Third=10 };</strong> 则枚举的上限是 16-1=15（16大于最大枚举量14，且为2的幂）； 枚举的下限是-8+1=-7（-8小于最小枚举量-5，且为2的幂）；</p>
<h4 id="4-枚举应用"><a href="#4-枚举应用" class="headerlink" title="4.枚举应用"></a>4.枚举应用</h4><p><span style="color:red">个人觉得枚举和 switch 是最好的搭档：</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> enumType&#123;Step0, Step1, Step2&#125;Step=Step0; <span class="comment">// 注意这里在声明枚举的时候直接定义了枚举变量 Step,并初始化为 Step0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (Step)x</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> Step0:&#123;...;<span class="keyword">break</span>;&#125;</span><br><span class="line">  <span class="keyword">case</span> Step1:&#123;...;<span class="keyword">break</span>;&#125;</span><br><span class="line">  <span class="keyword">case</span> Step2:&#123;...;<span class="keyword">break</span>;&#125;</span><br><span class="line">  <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外枚举还有一种少见的用法是 <strong>enum { one ,two ,three};</strong> 就是不指定一个名字,这样我们自然也没法去定义一些枚举类型了。此时就相当于 <strong>static const int one = 0;</strong> 这样定义三个常量一样。然后用的话就是 <strong>int no = one</strong>。</p>
<h2 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h2><h4 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h4><p>强类型枚举（Strongly-typed enums），号称枚举类型，是C++11中的新语法，用以解决传统C++枚举类型存在的缺陷。传统C++中枚举常量被暴漏在外层作用域中，这样若是同一作用域下有两个不同的枚举类型，但含有相同的枚举常量也是不可的，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Side&#123;Right,Left&#125;;</span><br><span class="line"><span class="keyword">enum</span> Thing&#123;Wrong,Right&#125;;</span><br></pre></td></tr></table></figure>

<p>这是不能一起用的。</p>
<p>另外一个缺陷是传统枚举值总是被隐式转换为整形，用户无法自定义类型。C++11中的强类型枚举解决了这些问题。</p>
<h4 id="2-强类型枚举"><a href="#2-强类型枚举" class="headerlink" title="2.强类型枚举"></a>2.强类型枚举</h4><p>强类型枚举使用enum class语法来声明，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumeration</span>&#123;</span></span><br><span class="line">    VAL1,</span><br><span class="line">    VAL2,</span><br><span class="line">    VAL3=<span class="number">100</span>,</span><br><span class="line">    VAL4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，枚举类型时安全的，枚举值也不会被隐式转换为整数，无法和整数数值比较，比如（Enumeration：：VAL4==10会触发编译错误）。</p>
<p>另外枚举类型所使用的类型默认为int类型，也可指定其他类型，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>:</span><span class="keyword">unsigned</span> <span class="keyword">int</span>&#123;VAL1,VAL2&#125;;</span><br></pre></td></tr></table></figure>

<p>正如前面所说，强类型枚举能解决传统枚举不同枚举类下同枚举值名的问题，使用枚举类型的枚举名时，必须指明所属范围，比如：Enum::VAL1，而单独的VAL1则不再具有意义。</p>
<p>还有一点值得说明的是C++11中枚举类型的前置声明也是可行的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum class Enum;</span><br><span class="line">enum class Enum1:unsigned int;</span><br></pre></td></tr></table></figure>

<h4 id="3-项目中的强类型枚举代码片段"><a href="#3-项目中的强类型枚举代码片段" class="headerlink" title="3.项目中的强类型枚举代码片段"></a>3.项目中的强类型枚举代码片段</h4><p>1、图像处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span>&#123;</span>RED,BLUE,YELLOR,BLACK,WHITE&#125;;</span><br></pre></td></tr></table></figure>

<p>2.交通灯</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficLight</span>&#123;</span>RED,YELLOR,GREEN&#125;;</span><br></pre></td></tr></table></figure>

<p>强类型枚举值具有传统枚举的功能——命名枚举值，同时又具有类的特点——具有类域的成员和无法进行默认的类型转换。所以也称之为枚举类——enmu class</p>
<p>枚举类的底层数据必须是有符号或无符号整型，比如 char unsigned int unsigned long，默认为 int。</p>
<p>3.前置声明应用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enmu <span class="class"><span class="keyword">class</span> <span class="title">Clolor</span>:</span><span class="keyword">char</span>;            <span class="comment">//前置声明枚举类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(Color*p)</span></span>;                     <span class="comment">//前置声明的使用</span></span><br><span class="line"><span class="comment">//....................</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span>:</span><span class="keyword">char</span>&#123;RED,GREEN,BLACK,WHITE&#125;;      <span class="comment">//前置声明的定义</span></span><br></pre></td></tr></table></figure>

<h4 id="4-限定作用域的枚举类型"><a href="#4-限定作用域的枚举类型" class="headerlink" title="4.限定作用域的枚举类型"></a>4.限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span> &#123;</span> input, output, append &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-不限定作用域的枚举类型"><a href="#5-不限定作用域的枚举类型" class="headerlink" title="5.不限定作用域的枚举类型"></a>5.不限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( expression )</span><br></pre></td></tr></table></figure>

<p>decltype 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a><a href="https://www.zfl9.com/cpp-refer.html" target="_blank" rel="noopener">引用</a></h2><h4 id="1-引用的概念"><a href="#1-引用的概念" class="headerlink" title="1.引用的概念"></a>1.引用的概念</h4><p>参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝；所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上；</p>
<p>对于像 char、bool、int、float 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速；<br>而数组、结构体、对象是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率；</p>
<p>C/C++禁止在函数调用时直接传递数组的内容，而是强制传递数组指针；而对于结构体和对象没有这种限制，调用函数时既可以传递指针，也可以直接传递内容；为了提高效率，我们一般都是传递指针；</p>
<p>但是在 C++ 中，我们有了一种比指针更加便捷的传递聚合类型数据的方式，那就是<code>引用（Reference）</code>；</p>
<blockquote>
<p>在 C/C++ 中，我们将 char、int、float 等由语言本身支持的类型称为<strong>基本类型</strong>，将<code>数组</code>、<code>结构体</code>、<code>类（对象）</code>等由基本类型组合而成的类型称为<strong>聚合类型</strong>；</p>
</blockquote>
<p><strong>引用（Reference）是 C++ 相对于C语言的又一个扩充；引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据</strong></p>
<p>引用的定义方式：<code>datatype &amp;ref_name = origin_name;</code><br><code>datatype</code>是被引用的数据的类型，<code>ref_name</code>是引用的名称（新名称），<code>origin_name</code>是被引用的数据（原来的名称）；</p>
<p><strong>引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）</strong></p>
<p>由于引用 b 和原始变量 a 都是指向同一地址，所以通过引用也可以修改原始变量中所存储的数据；<br>如果不希望通过引用来修改原来的数据，可以在定义的时候添加<code>const</code>进行限制：<code>const int &amp;b = a;</code>，称为<code>常引用</code>；</p>
<h5 id="1-1引用作为函数参数"><a href="#1-1引用作为函数参数" class="headerlink" title="1.1引用作为函数参数"></a>1.1<strong>引用作为函数参数</strong></h5><p>在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据；如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">x = <span class="number">1</span>; y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"swap1_before: x = %d, y = %d\n"</span>, x, y);</span><br><span class="line">swap1(x, y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"swap1_after: x = %d, y = %d\n\n"</span>, x, y);</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>; y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"swap2_before: x = %d, y = %d\n"</span>, x, y);</span><br><span class="line">swap2(&amp;x, &amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"swap2_after: x = %d, y = %d\n\n"</span>, x, y);</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>; y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"swap3_before: x = %d, y = %d\n"</span>, x, y);</span><br><span class="line">swap3(x, y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"swap3_after: x = %d, y = %d\n"</span>, x, y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:green"><code>swap1(int, int)</code></span>值传递：由于形参a、b的作用范围仅限于函数内部，它们拥有独立的内存，和x、y互不影响；<br><span style="color:green"><code>swap2(int*, int*)</code></span>指针传递：调用函数的时候分别将x、y的地址传递给形参a、b，这样就能在函数内部通过指针间接交换两个数值；<br><span style="color:green"><code>swap3(int&amp;, int&amp;)</code></span>引用传递：调用函数的时候分别将形参a、b绑定到x、y指定的数据，这样就能在函数内部交换两个数值了；</p>
<p>从以上代码的编写中可以发现，按引用传参在使用形式上比指针更加直观；鼓励大量使用引用，一般可以代替指针，当然指针在 C++ 中也是不可或缺，这两者应结合使用；</p>
<h5 id="1-2引用作为函数返回值"><a href="#1-2引用作为函数返回值" class="headerlink" title="1.2引用作为函数返回值"></a>1.2<strong>引用作为函数返回值</strong></h5><p>引用除了可以作为函数形参，还可以作为函数返回值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    n += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = func(a);   <span class="comment">// 传递a的引用给b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d, &amp;a = %p, &amp;b = %p\n"</span>, a, b, &amp;a, &amp;b);</span><br><span class="line">    b++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y = func(x);    <span class="comment">// 用y接收func()的返回值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x = %d, y = %d, &amp;x = %p, &amp;y = %p\n"</span>, x, y, &amp;x, &amp;y);</span><br><span class="line">y++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x = %d, y = %d\n"</span>, x, y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-引用的本质"><a href="#2-引用的本质" class="headerlink" title="2.引用的本质"></a>2.引用的本质</h4><p>​       其实引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d, &amp;a = %p, &amp;b = %p\n"</span>, a, b, &amp;a, &amp;b);</span><br><span class="line"><span class="comment">/* 在编译的某个时候，被转换为如下形式：</span></span><br><span class="line"><span class="comment">int a = 10;</span></span><br><span class="line"><span class="comment">int *b = &amp;a;</span></span><br><span class="line"><span class="comment">printf("a = %d, b = %d, &amp;a = %p, &amp;b = %p\n", a, *b, &amp;a, *&amp;b);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># root @ arch in ~/work on git:master x [9:28:56]</span></span><br><span class="line">$ g++ a.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta"># root @ arch in ~/work on git:master x [9:28:58]</span></span><br><span class="line">$ ./a.out</span><br><span class="line">a = <span class="number">10</span>, b = <span class="number">10</span>, &amp;a = <span class="number">0x7fffdaa16bcc</span>, &amp;b = <span class="number">0x7fffdaa16bcc</span></span><br></pre></td></tr></table></figure>

<p>​         使用<code>&amp;b</code>取地址时，编译器会对代码进行隐式的转换，使得代码输出的是 a 的地址，而不是 b 的地址，这就是为什么获取不到引用变量的地址的原因；也就是说，不是变量 b 不占用内存，而是编译器不让获取它的地址；</p>
<p>引用虽然是基于指针实现的，但它比指针更加易用，从上面的例子也可以看出来，通过指针获取数据时需要加<code>*</code>，书写麻烦，而引用不需要，它和普通变量的使用方式一样；<br>C++ 的发明人 Bjarne Stroustrup 也说过，他在 C++ 中引入引用的直接目的是为了让代码的书写更加漂亮，尤其是在运算符重载中，不借助引用有时候会使得运算符的使用很麻烦；</p>
<p><span style="color:red"><strong>引用和指针的其他区别</strong></span></p>
<p><strong>1) 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据；</strong></p>
<p><strong>2) 可以有 const 指针，但是没有 const 引用；也就是说，引用变量不能定义为下面的形式：</strong><br><strong><code>int a = 10;</code></strong><br><strong><code>int &amp;const b = a;</code></strong><br><strong>因为 b 本来就不能改变指向，加上 const 多此一举；</strong></p>
<p><strong>3) 指针可以有多级，但是引用只能有一级；例如，<code>int **p</code>是合法的，而<code>int &amp;&amp;r</code>是不合法的；</strong><br><strong>如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个&amp;，如下所示：</strong><br><strong><code>int a = 10;</code></strong><br><strong><code>int &amp;r = a;</code></strong><br><strong><code>int &amp;rr = r;</code></strong></p>
<p><strong>4) 指针和引用的自增、自减运算意义不一样；对指针使用<code>++</code>表示指向下一份数据，对引用使用<code>++</code>表示它所指代的数据本身加1；自减（<code>--</code>）也是类似的道理；</strong></p>
<h4 id="3-引用不能绑定到临时数据"><a href="#3-引用不能绑定到临时数据" class="headerlink" title="3.引用不能绑定到临时数据"></a>3.引用不能绑定到临时数据</h4><p>​         我们知道，指针就是数据或代码在内存中的地址，指针变量指向的就是内存中的数据或代码；<br>这里有一个关键词需要强调，就是<strong>内存</strong>，<strong>指针只能指向内存，不能指向寄存器或者硬盘，因为寄存器和硬盘没法寻址</strong></p>
<p>​         其实 C++ 代码中的大部分内容都是放在内存中的，例如<em>定义的变量<em>、</em>创建的对象<em>、</em>字符串常量<em>、</em>函数形参<em>、</em>函数体本身<em>、</em>new<em>或</em>malloc()<em>分配的内存等，这些内容都可以用&amp;来获取地址，进而用指针指向它们；<br>除此之外，还有一些我们平时不太留意的临时数据，例如<span style="color:red"></span></em>表达式的结果<em>、</em>函数的返回值</em>等，它们可能会放在内存中，也可能会放在寄存器中。一旦它们被放到了寄存器中，就没法用&amp;获取它们的地址了，也就没法用指针指向它们了；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;(func());</span><br></pre></td></tr></table></figure>

<p>func() 的返回值 100 也会被放到寄存器中，也没法用&amp;获取它的地址；</p>
<p><strong>什么样的临时数据会放到寄存器中</strong></p>
<p>寄存器离 CPU 近，并且速度比内存快，将临时数据放到寄存器是为了加快程序运行；<br>但是寄存器的数量是非常有限的，容纳不下较大的数据，所以只能将较小的临时数据放在寄存器中；<br>int、double、bool、char 等基本类型的数据往往不超过 8 个字节，用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；<br>而对象、结构体变量是自定义类型的数据，大小不可预测，所以这些类型的临时数据通常会放到内存中；</p>
<p><strong>关于常量表达式</strong></p>
<p>诸如<code>100</code>、<code>200+34</code>、<code>34.5*23</code>、<code>3+7/3</code>等不包含变量的表达式称为<em>常量表达式（Constant expression）</em>；<br>常量表达式由于不包含变量，没有不稳定因素，所以在编译阶段就能求值；编译器不会分配单独的内存来存储常量表达式的值，而是将常量表达式的值和代码合并到一起，放到虚拟地址空间中的代码区；从汇编的角度看，常量表达式的值就是一个立即数，会被“硬编码”到指令中，不能寻址；</p>
<p>总起来说，常量表达式的值虽然在内存中，但是没有办法寻址，所以也不能使用&amp;来获取它的地址，更不能用指针指向它；</p>
<p><strong>引用也不能指代临时数据</strong></p>
<p>引用和指针在本质上是一样的，引用仅仅是对指针进行了简单的封装；<br>引用和指针都不能绑定到无法寻址的临时数据，并且 C++ 对引用的要求更加严格，在某些编译器下甚至连放在内存中的临时数据都不能指代；</p>
<p>下面的代码中，我们将引用绑定到了临时数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_int</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">S <span class="title">func_s</span><span class="params">()</span></span>&#123;</span><br><span class="line">    S a;</span><br><span class="line">    a.a = <span class="number">100</span>;</span><br><span class="line">    a.b = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">S <span class="keyword">operator</span>+(<span class="keyword">const</span> S &amp;A, <span class="keyword">const</span> S &amp;B)&#123;</span><br><span class="line">    S C;</span><br><span class="line">    C.a = A.a + B.a;</span><br><span class="line">    C.b = A.b + B.b;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//下面的代码在GCC和Visual C++下都是错误的</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">100</span>, n = <span class="number">36</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r1 = m + n;</span><br><span class="line">    <span class="keyword">int</span> &amp;r2 = m + <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r3 = <span class="number">12</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r4 = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r5 = func_int();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面的代码在GCC下是错误的，在Visual C++下是正确的</span></span><br><span class="line">    S s1 = &#123;<span class="number">23</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    S s2 = &#123;<span class="number">90</span>, <span class="number">75</span>&#125;;</span><br><span class="line">    S &amp;r6 = func_s();</span><br><span class="line">    S &amp;r7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用作为函数参数</strong><br>当引用作为函数参数时，有时候很容易给它传递临时数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n/<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    isOdd(a);  <span class="comment">//正确</span></span><br><span class="line">    isOdd(a + <span class="number">9</span>);  <span class="comment">//错误</span></span><br><span class="line">    isOdd(<span class="number">27</span>);  <span class="comment">//错误</span></span><br><span class="line">    isOdd(<span class="number">23</span> + <span class="number">55</span>);  <span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-const引用和临时变量"><a href="#4-const引用和临时变量" class="headerlink" title="4.const引用和临时变量"></a>4.const引用和临时变量</h4><p>引用不能绑定到临时数据，这在大多数情况下是正确的，但是当使用 const 关键字对引用加以限定后，引用就可以绑定到临时数据了；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_int</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">S <span class="title">func_s</span><span class="params">()</span></span>&#123;</span><br><span class="line">    S a;</span><br><span class="line">    a.a = <span class="number">100</span>;</span><br><span class="line">    a.b = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">S <span class="keyword">operator</span>+(<span class="keyword">const</span> S &amp;A, <span class="keyword">const</span> S &amp;B)&#123;</span><br><span class="line">    S C;</span><br><span class="line">    C.a = A.a + B.a;</span><br><span class="line">    C.b = A.b + B.b;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">100</span>, n = <span class="number">36</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = m + n;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = m + <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = <span class="number">12</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r4 = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r5 = func_int();</span><br><span class="line"></span><br><span class="line">    S s1 = &#123;<span class="number">23</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    S s2 = &#123;<span class="number">90</span>, <span class="number">75</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> S &amp;r6 = func_s();</span><br><span class="line">    <span class="keyword">const</span> S &amp;r7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在 GCC 和 Visual C++ 下都能够编译通过，这是因为将常引用绑定到临时数据时，编译器采取了一种妥协机制：编译器会为临时数据创建一个新的、无名的临时变量，并将临时数据放入该临时变量中，然后再将引用绑定到该临时变量；注意，临时变量也是变量，所有的变量都会被分配内存；</p>
<p><strong>为什么编译器为常引用创建临时变量是合理的，而为普通引用创建临时变量就不合理呢？</strong></p>
<p>1) 我们知道，将引用绑定到一份数据后，就可以通过引用对这份数据进行操作了，包括读取和写入（修改）；尤其是写入操作，会改变数据的值。而临时数据往往无法寻址，是不能写入的，即使为临时数据创建了一个临时变量，那么修改的也仅仅是临时变量里面的数据，不会影响原来的数据，这样就使得引用所绑定到的数据和原来的数据不能同步更新，最终产生了两份不同的数据，失去了引用的意义；</p>
<p>2) const 引用和普通引用不一样，我们只能通过 const 引用读取数据的值，而不能修改它的值，所以不用考虑同步更新的问题，也不会产生两份不同的数据，为 const 引用创建临时变量反而会使得引用更加灵活和通用；</p>
<p>以上节的 isOdd() 函数为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span></span>&#123;  <span class="comment">//改为常引用</span></span><br><span class="line">    <span class="keyword">if</span>(n/<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">由于在函数体中不会修改 n 的值，所以可以用 <span class="keyword">const</span> 限制 n，这样一来，下面的函数调用就都是正确的了：</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">isOdd(a);  <span class="comment">//正确</span></span><br><span class="line">isOdd(a + <span class="number">9</span>);  <span class="comment">//正确</span></span><br><span class="line">isOdd(<span class="number">27</span>);  <span class="comment">//正确</span></span><br><span class="line">isOdd(<span class="number">23</span> + <span class="number">55</span>);  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h4 id="5-const引用与类型转换"><a href="#5-const引用与类型转换" class="headerlink" title="5.const引用与类型转换"></a>5.const引用与类型转换</h4><p>不同类型的数据占用的内存数量不一样，处理方式也不一样，指针的类型要与它指向的数据的类型严格对应；</p>
<p><strong>类型转换的本质</strong></p>
<p>我们知道，数据是放在内存中的，变量（以及指针、引用）是给这块内存起的名字，有了变量就可以找到并使用这份数据；但问题是，该如何使用呢？</p>
<p>诸如数字、文字、符号、图形、音频、视频等数据都是以二进制形式存储在内存中的，它们并没有本质上的区别，那么，00010000 该理解为数字 16 呢，还是图像中某个像素的颜色呢，还是要发出某个声音呢？如果没有特别指明，我们并不知道；</p>
<p>也就是说，内存中的数据有多种解释方式，使用之前必须要确定；这种「确定数据的解释方式」的工作就是由<strong>数据类型（Data Type）</strong>来完成的；</p>
<p>例如<code>int a;</code>，表明，a 这份数据是整数，不能理解为像素、声音、视频等；</p>
<p>顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义；<br>C/C++ 支持多种数据类型，包括内置类型（例如 int、double、bool 等）和自定义类型（结构体类型和类类型）；</p>
<p><strong>所谓数据类型转换，就是对数据所占用的二进制位做出重新解释</strong>；<br><strong>如果有必要，在重新解释的同时还会修改数据，改变它的二进制位</strong>；</p>
<p>​         <span style="color:red">对于<em>隐式类型转换</em>，编译器可以根据已知的转换规则来决定是否需要修改数据的二进制位；而对于<em>强制类型转换</em>，由于没有对应的转换规则，所以能做的事情仅仅是重新解释数据的二进制位，但无法对数据的二进制位做出修正；这就是隐式类型转换和强制类型转换最根本的区别；</span></p>
<p>比如，<code>int</code>和<code>float</code>类型的指针，是不能随便互相指向对方的数据的，因为整数和浮点数在内存中的存储是大不一样的：</p>
<ul>
<li>对于 int，程序把最高 1 位作为符号位，把剩下的 31 位作为数值位；</li>
<li>对于 float，程序把最高 1 位作为符号位，把最低的 23 位作为尾数位，把中间的 8 位作为指数位；</li>
</ul>
<p>让指针指向「相关的（相近的）但不是严格对应的」类型的数据，表面上看起来是合理的，但是细思极恐，这样会给程序留下很多意想不到的、难以发现的 Bug，所以编译器禁止这样做是非常合理的；<br>当然，如果你想通过强制类型转换达到这个目的，那编译器也会放任不管，给你自由发挥的余地；</p>
<p>引用（Reference）和指针（Pointer）在本质上是一样的，引用仅仅是对指针进行了简单的封装，「类型严格一致」这条规则同样也适用于引用；</p>
<p><strong>const 引用与类型转换</strong></p>
<p>「类型严格一致」是为了防止发生让人匪夷所思的操作，但是这条规则仅仅适用于普通引用，当对引用添加 const 限定后，情况就又发生了变化，编译器允许引用绑定到类型不一致的数据；请看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = n;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> &amp;r2 = n;  <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'@'</span>;</span><br><span class="line"><span class="keyword">char</span> &amp;r3 = c;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r4 = c;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>当引用的类型和数据的类型不一致时，如果它们的类型是相近的，并且遵守「数据类型的自动转换」规则，那么编译器就会创建一个临时变量，并将数据赋值给这个临时变量（这时候会发生自动类型转换），然后再将引用绑定到这个临时的变量，这与「将 const 引用绑定到临时数据时」采用的方案是一样的；</p>
<p>结合上节讲到的知识，总结起来说，给引用添加 const 限定后，不但可以将引用绑定到临时数据，还可以将引用绑定到类型相近的数据，这使得引用更加灵活和通用，它们背后的机制都是<span style="color:red">临时变量；</span></p>
<p><strong>引用类型的函数形参请尽可能的使用 const</strong></p>
<p>当引用作为函数参数时，如果在函数体内部不会修改引用所绑定的数据，那么请尽量为该引用添加 const 限制；</p>
<p>概括起来说，将引用类型的形参添加 const 限制的理由有三个：</p>
<ul>
<li><p>使用 const 可以避免无意中修改数据的编程错误；</p>
</li>
<li><p>使用 const 能让函数接收 const 和非 const 类型的实参，否则将只能接收非 const 类型的实参；</p>
</li>
<li><p>使用 const 引用能够让函数正确生成并使用临时变量</p>
<h5 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h5><ul>
<li>X&amp; &amp;<code>、</code>X&amp; &amp;&amp;<code>、</code>X&amp;&amp; &amp;<code>可折叠成</code>X&amp;`</li>
<li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li>
</ul>
</li>
</ul>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>虽然很多人提出不要在C++中使用宏，但是宏对C/C++的作用却是至关重要的！</p>
<p>对C++语言进行改造，肯定是要用到宏的，不精通宏，怎么好意思说自己精通C++？</p>
<p>看看任何一个高级C++库，全部都遍地是宏！</p>
<h4 id="宏是什么？"><a href="#宏是什么？" class="headerlink" title="宏是什么？"></a>宏是什么？</h4><p>宏就是编译器在预处理阶段进行的 <strong>文本替换</strong> 。 习惯上用大写字母表示&lt;宏名&gt;，目的是为了与变量名区分。常量用大写字母；变量用小写字母。 <code>#define PI 3.1415926</code></p>
<p>如果某一个标识符被定义为宏名后，在取消该宏定义之前，不允许重新对它进行宏定义。 所以应记得及时的尽量取消宏定义： <code>#undef &lt;标识符&gt;</code> 。 <code>#undef</code> 比较多的用途是在使用宏之前先进行 <code>#undef</code> 以保证这个宏不会与先前的定义冲突。</p>
<h4 id="使用宏做函数"><a href="#使用宏做函数" class="headerlink" title="使用宏做函数"></a>使用宏做函数</h4><p>宏可以像函数一样被定义，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MIN(x,y) ((x)&lt;(y)?(x):(y))</span><br></pre></td></tr></table></figure>

<p>但是在实际使用时，只有当写上MIN()，必须加括号，MIN才会被作为宏展开，否则不做任何处理。 编译器(预处理器)对宏只进行简单的文本替换，而 <strong>不会进行语法检查</strong> ，所以更多的检查性工作得你自己来做。</p>
<h4 id="为什么要用宏来做函数？"><a href="#为什么要用宏来做函数？" class="headerlink" title="为什么要用宏来做函数？"></a>为什么要用宏来做函数？</h4><ol>
<li><strong>鸭子原则</strong>：比如MIN宏适用于任何实现了operator&lt;的类型，包括自定义类型（这点与template类似）；</li>
<li><strong>效率最高</strong>：虽然使用inline提示符也将函数或模板定义为内联的，但这只是一种提示而已，到底编译器有没有优化还依赖于编译器的实现，而使用宏函数则是完全由代码本身控制。</li>
</ol>
<h4 id="2个宏编程易犯的错误"><a href="#2个宏编程易犯的错误" class="headerlink" title="2个宏编程易犯的错误"></a>2个宏编程易犯的错误</h4><p>程序员对宏定义的使用要非常小心，特别要注意两个问题：</p>
<blockquote>
<ul>
<li><ul>
<li>谨慎地将宏定义中的 <strong>“参数”</strong> 和 <strong>整个宏</strong> 都用括弧括起来。</li>
</ul>
<p>所以，严格地讲，下述解答:</p>
<p>`#define MIN(A,B) (A) &lt;= (B) ? (A) : (B) </p>
<p>#define MIN(A,B) (A &lt;= B ? A : B )</p>
<p><code>都应判0分； 正确的解答应该是：</code>#define MIN(A, B) ((A) &lt;= (B) ? (A) : (B))`</p>
</li>
<li><ul>
<li><strong>防止宏的副作用</strong> :</li>
</ul>
<p>宏定义 <code>#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B))</code></p>
<p>对 <code>MIN(*p++, b)</code> 的作用结果是： <code>((*p++) &lt;= (b) ? (*p++) : (*p++))</code>这个表达式会产生副作用，指针p会作三次++自增操作。 （因为， <strong>宏的本质是文本替换</strong> ）除此之外，另一个应该判0分的解答是： <code>#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B));</code> 这个解答在宏定义的后面加”;”，显示编写者对宏的概念模糊不清，只能被无情地判0分并被面试官淘汰。</p>
</li>
</ul>
</blockquote>
<h4 id="后面加不加分号："><a href="#后面加不加分号：" class="headerlink" title="后面加不加分号："></a>后面加不加分号：</h4><p>宏定义一般都不在最后加分号，调用的时候才加分号。 这样处理之后就要求使用者将宏视为一条普通语句而不是一个宏，从而需要在后面加上;号。</p>
<h4 id="特殊符号：-、"><a href="#特殊符号：-、" class="headerlink" title="特殊符号：#、"></a>特殊符号：#、</h4><ol>
<li><p># 符号把一个符号直接转换为字符串，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define STRING(x) #x;</span><br><span class="line">const char *str = STRING( test_string );</span><br></pre></td></tr></table></figure>

<p>str的内容就是”test_string”，也就是说 <strong>#会把其后的符号直接加上双引号</strong> , 即STRING( test_string )被扩展为 “test_string” 。</p>
</li>
<li><p>##符号会连接两个符号，从而产生新的符号(词法层次)，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define SIGN( x ) INT_##x</span><br><span class="line">int SIGN( 1 );</span><br></pre></td></tr></table></figure>

<p>宏被展开后将成为：int INT_1;</p>
</li>
</ol>
<p>有资料说可以用#@把一个宏参数变成字符（也就是给参数加上单引号，相对应于#的双引号） <code>#@a = &#39;a&#39;</code> 但是，在gcc上的测试显示不支持#@，测试的结果是”“@，相当于对空添加双引号再加上@的结果。</p>
<h4 id="VA-ARGS-变参宏"><a href="#VA-ARGS-变参宏" class="headerlink" title="VA_ARGS 变参宏"></a><strong>VA_ARGS</strong> 变参宏</h4><p>这个比较酷，它使得你可以定义类似的宏:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define myprintf(templt,...) fprintf(stderr,templt,__VA_ARGS__)</span><br><span class="line">#define myprintf(templt,args...) fprintf(stderr,templt,args)</span><br></pre></td></tr></table></figure>

<p>第一个宏中由于没有对变参起名，我们用默认的宏<strong>VA_ARGS</strong>来替代它。 第二个宏中，我们显式地命名变参为args，那么我们在宏定义中就可以用args来代指变参了。</p>
<p>由于可变参数应该可以为空，所以在只能提供一个参数时，普通的调用方式会引起编译错误。 <code>myprintf(&quot;abc&quot;);</code> 会被替换为 <code>fprintf(stderr, &quot;abc&quot;, );</code> 这是语法错误，解决方法小变通一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define myprintf(templt, ...) fprintf(stderr,templt, ##__VAR_ARGS__)</span><br></pre></td></tr></table></figure>

<p>于是 <code>myprintf(&quot;abc&quot;);</code> 会被替换为 <code>fprintf(stderr, templt, &quot;&quot;);</code> 就没有问题了。 <strong><strong>VA_ARGS</strong>是系统预定义宏，被自动替换为参数列表</strong> 。</p>
<ul>
<li><p><strong>得到<strong>VA_ARGS</strong>具体有多少个参数</strong></p>
<p>得到<strong>VA_ARGS</strong>里具体有多少个参数有时候很有用，这个解决方案在gcc下可以这样做到:</p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PP_NARG(...) PP_NARG_(__VA_ARGS__, PP_RSEQ_N())</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> PP_NARG_(...) PP_ARG_N(__VA_ARGS__) _</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PP_ARG_N( \         _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \                                          _11,_12,_13,_14,_15,_16, N, ...) N</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> PP_RSEQ_N() \         16,15,14,13,12,11,10, \         9,8,7,6,5,4,3,2,1,0</span></span><br></pre></td></tr></table></figure>

<p>  <code>然后</code>cout &lt;&lt; (PP_NARG(1,2,3,4,1,1)) &lt;&lt; endl;</p>
<p>  `就可以得到具体的参数数目6。这里实现的非常漂亮，原理也很直观，就是把<strong>VA_ARGS</strong>与倒序的PP_RSEQ_N组合在一起，这个组合的结果相当于把<strong>VA_ARGS</strong>向后推了x位，这个x就是变参的个数，于是再获取第17位就可以得到这个x了，具体的宏展开如下:</p>
<p>  PP_NARG(1,2,3,4,1,1) =&gt; PP_NARG_(1,2,3,4,1,PP_RSEQ_N()) PP_NARG_(1,2,3,4,1,PP_RSEQ_N()) =&gt; PP_NARG_(1,2,3,4,1,1,16,15,14,…,3,2,1,0) PP_NARG_(1,2,3,4,1,1,16,15,14,…,3,2,1,0) =&gt; PP_ARG_N(1,2,3,4,1,1,16,…,3,2,1,0) PP_ARG_N(1,2,3,4,1,1,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0) =&gt; 6 `</p>
<h4 id="宏不支持递归"><a href="#宏不支持递归" class="headerlink" title="宏不支持递归"></a>宏不支持递归</h4><p>当一个宏自己调用自己时，会发生什么？例如： <code>#define TEST( x ) ( x + TEST( x ) )</code></p>
<p>再调用 <code>TEST( 1 );</code> 会发生什么？</p>
<p>为了防止无限制递归展开，语法规定， <strong>当一个宏遇到自己时，就停止展开</strong> 。也就是说，当对TEST( 1 )进行展开时，展开过程中又发现了一个TEST，那么就将这个TEST当作一般的符号。TEST(1)最终被展开为： <code>1 + TEST( 1)</code> 。</p>
<h4 id="宏从内向外展开"><a href="#宏从内向外展开" class="headerlink" title="宏从内向外展开"></a>宏从内向外展开</h4><p>宏参数的prescan，当一个宏参数被放进宏体时，这个宏参数会首先被全部展开(有例外，见下文)。当展开后的宏参数被放进宏体时，预处理器对新展开的宏体进行第二次扫描，并继续展开。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PARAM( x ) x</span><br><span class="line">#define ADDPARAM( x ) INT_##x</span><br><span class="line">PARAM( ADDPARAM( 1 ) );</span><br></pre></td></tr></table></figure>

<p>因为ADDPARAM( 1 ) 是作为PARAM的宏参数，所以先将ADDPARAM( 1 )展开为INT_1，然后再将INT_1放进PARAM。</p>
<p><strong>当一个宏对它的某个参数进行#或者##时, 这个参数使用点并不被替换为展开后的文本</strong> ，然而解决这个问题的方法很简单，一般就是加多一层 <strong>中间转换宏</strong> 。</p>
<p>例外情况是，如果PARAM宏里对宏参数使用了#或##，那么宏参数不会被展开:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PARAM( x ) #x</span><br><span class="line">#define ADDPARAM( x ) INT_##x</span><br><span class="line">PARAM( ADDPARAM( 1 ) );   // 将被展开为&quot;ADDPARAM( 1 )&quot;。</span><br></pre></td></tr></table></figure>

<p>使用这么一个规则，可以创建一个很有趣的技术：打印出一个宏被展开后的样子，这样可以方便你分析代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_STRING( x ) TO_STRING1( x )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_STRING1( x ) #x</span></span><br></pre></td></tr></table></figure>

<p>TO_STRING首先会将x全部展开(如果x也是一个宏的话)，然后再传给TO_STRING1转换为字符串，现在你可以这样： <code>const char *str = TO_STRING( PARAM( ADDPARAM( 1 ) ) );</code> 去一探PARAM展开后的样子。</p>
<p>这种中间层展开的技巧在宏编程中会经常经常地用到！不过有了Eclipse的”Ctrl + =”进行宏展开的功能，这样打印一个宏就显得落后了。</p>
<p>注意：</p>
<ol>
<li><strong>在#后面的宏形参和在##两旁的宏形参都不会再被展开了！</strong></li>
<li><strong>只展开参数中的宏，而宏体中的宏会当作普通字符串来处理的</strong></li>
</ol>
<h4 id="宏展开时的限制"><a href="#宏展开时的限制" class="headerlink" title="宏展开时的限制"></a>宏展开时的限制</h4><p>警告</p>
<p>有下面的限制的根本原因就是上一条中的2点：</p>
<ul>
<li><strong>在#、##旁边不会展开</strong></li>
<li><strong>只会展开参数中的嵌套宏</strong></li>
</ul>
<p>从以下这个定义匿名变量的宏 <strong>必须拥有三层</strong> 的原因开始讲起:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define ANONYMOUS1(type, line)  type _anonymous##line</span><br><span class="line">#define ANONYMOUS0(type, line)  ANONYMOUS1(type, line)</span><br><span class="line">#define ANONYMOUS(type)  ANONYMOUS0(type, __LINE__)</span><br><span class="line">例：ANONYMOUS(static int);  即: static int _anonymous70;  70表示该行行号；</span><br><span class="line">第一层：ANONYMOUS(static int);  --&gt; ANONYMOUS0(static int, __LINE__)；</span><br><span class="line">第二层：                        --&gt; ANONYMOUS1(static int, 168)；</span><br><span class="line">第三层：                        --&gt; static int  _anonymous168;</span><br></pre></td></tr></table></figure>

<p>原理： <strong>嵌套的宏只有在它处于参数的位置时，且不在##的旁边，才会去解开！</strong> ：</p>
<ol>
<li>在第一层时，<strong>LINE</strong>根本不处于宏参数的位置，所以它不会解开，而是作为一个字符串传递给了第二层；</li>
<li>在第二层时，line参数被替换为<strong>LINE</strong>，而且这个<strong>LINE</strong>处于宏参数中，且不在##的旁白，所以会被解开变成相应的行编号，如168；</li>
<li>在第三层时，才可以真正的生成static int __anonymous168</li>
</ol>
<p>这里 <strong>必须要有三层才能做到，为什么二层做不到呢？</strong> 因为，如果试图在第二层就展开成最后的变量声明式，那么就是试图这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ANONYMOUS(type) ANONYMOUS1(type, __LINE__)</span><br><span class="line">#define ANONYMOUS1(type, line) type _anonymouse##line。</span><br></pre></td></tr></table></figure>

<p>因为第一层不可能展开<strong>LINE</strong>，所以在第二层时的line还仅仅是<strong>LINE</strong>宏，但是不幸的是它在##的后面，因此又得不到展开，所以最后会变成static int _anonymouse__LINE__，当然错了！</p>
<h4 id="常用的预定义宏"><a href="#常用的预定义宏" class="headerlink" title="常用的预定义宏"></a>常用的预定义宏</h4><p>ANSI标准说明了五个预定义的宏名。它们是： <strong><strong>LINE</strong>、<strong>FILE</strong>、<strong>DATE</strong>、<strong>TIME</strong>、<strong>TIMESTAMP</strong>、<strong>STDC</strong>、__cplusplus</strong></p>
<p>gcc中还定义了 <code>__func__</code> 可以标识当前的函数名，debug编译时还定义了 <code>_DEBUG</code> 宏。</p>
<p>如果编译器不标准的,则可能仅支持以上宏名中的几个,或根本不支持，也可能提供其它预定义的宏。</p>
<ul>
<li><strong>LINE</strong> 及 <strong>FILE</strong> 宏指示，#line指令可以改变它的值，简单的讲，编译时，它们包含程序的当前行数和文件名（#line一般很少用）。</li>
<li><strong>DATE</strong> 宏指令含有形式为月/日/年的串,表示源文件被翻译到代码时的日期。</li>
<li><strong>TIME</strong> 宏指令包含程序编译的时间。时间用字符串表示，其形式为： 分：秒</li>
<li><strong>TIMESTAMP</strong> 包含当前源文件的最后修改时间，在自动化编译时肯定常用。</li>
<li><strong>STDC</strong> 宏指令的意义是编译时定义的。一般来讲，如果<strong>STDC</strong>已经定义，编译器将仅接受不包含任何非标准扩展的标准C/C++代码。如果实现是标准的,则宏<strong>STDC</strong>含有十进制常量1。如果它含有任何其它数,则实现是非标准的。</li>
<li>__cplusplus 与标准c++一致的编译器把它定义为一个包含至少6为的数值。与标准c++不一致的编译器将使用具有5位或更少的数值。</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>普通宏定义<ol>
<li>宏名一般用大写</li>
<li>使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。</li>
<li>预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查。</li>
<li>宏定义末尾不加分号；</li>
<li>宏定义写在函数的花括号外边，作用域为其后的程序，通常在文件的最开头。</li>
<li>可以用#undef命令终止宏定义的作用域</li>
<li>宏定义可以嵌套</li>
<li>字符串”“中永远不包含宏</li>
<li>宏定义不分配内存，变量定义分配内存。</li>
</ol>
</li>
<li>带参宏定义<ol>
<li>实参如果是表达式容易出问题</li>
<li>宏名和参数的括号间不能有空格</li>
<li>宏替换只作替换，不做计算，不做表达式求解</li>
<li>函数调用在编译后程序运行时进行，并且分配内存。宏替换在编译前进行，不分配内存</li>
<li>宏的哑实结合不存在类型，也没有类型转换。</li>
<li>函数只有一个返回值，利用宏则可以设法得到多个值</li>
<li>宏展开使源程序变长，函数调用不会</li>
<li>宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）</li>
</ol>
</li>
</ul>
<h4 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h4><h5 id="do-…-while-0-技巧"><a href="#do-…-while-0-技巧" class="headerlink" title="do{…}while(0)技巧"></a>do{…}while(0)技巧</h5><p><strong>这个技巧非常漂亮！</strong></p>
<p><em>使用do-while(0)的宏定义是为了防止if-else( if)的语法错误,这一般是库作者来保证代码的健壮性所使用的技巧。</em> 而且，还 <strong>可以使得宏中使用到的变量都成为 局部变量</strong> ，不造成任何副作用！</p>
<p>这里用一个简单点的宏来演示：</p>
<p> <code>#define SAFE_DELETE(p) do{ delete p; p = NULL} while(0)</code> </p>
<p>假设这里去掉 <code>do...while(0)</code>, 于是这样定义：</p>
<p> <code>#define SAFE_DELETE(p) delete p; p = NULL;</code> 。 </p>
<p>那么以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(NULL != p) SAFE_DELETE(p)</span><br><span class="line">else   ...do sth...</span><br></pre></td></tr></table></figure>

<p>就有两个问题，</p>
<ol>
<li>因为if分支后有两个语句，else分支没有对应的if，编译失败</li>
<li>假设没有else, SAFE_DELETE中的第二个语句无论if测试是否通过，会永远执行。</li>
</ol>
<p>你可能发现，为了避免这两个问题，我不一定要用这个令人费解的do…while, 我直接用{}括起来就可以了 <code>#define SAFE_DELETE(p) { delete p; p = NULL;}</code></p>
<p>的确，这样的话上面的问题是不存在了，但是我想对于C++程序员来讲，在每个语句后面加分号是一种约定俗成的习惯，这样的话，以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(NULL != p) SAFE_DELETE(p);</span><br><span class="line">else   ...do sth...</span><br></pre></td></tr></table></figure>

<p>其else分支就无法通过编译了（原因同上），所以采用do…while(0)是做好的选择了。</p>
<p>也许你会说，我们代码的习惯是在每个判断后面加上{}, 就不会有这种问题了，也就不需要do…while了，如： <code>if(...) {...}else{...}</code></p>
<p>诚然，这是一个好的，应该提倡的编程习惯，但一般这样的宏都是作为library的一部分出现的，而 <strong>对于一个library的作者，他所要做的就是让其库具有通用性，强壮性，因此他不能有任何对库的使用者的假设，如其编码规范，技术水平等</strong> 。</p>
<p>总结的说，这种do{…}while(0)技巧有以下优点：</p>
<ol>
<li>在宏定义中可以使用局部变量；</li>
<li>在宏定义中可以包含多个语句，但可以当作一条语句使用。如上述if结构中的代码，如果没有do-while把多条语句组织成一个代码块，则程序的运行结果就不正确，甚至不能编译。</li>
</ol>
<h4 id="使用宏完成注册操作"><a href="#使用宏完成注册操作" class="headerlink" title="使用宏完成注册操作"></a>使用宏完成注册操作</h4><p>经常需要对对新建的或派生的类进行注册操作，比如MAPREDUCE_REG、TEST(gtest)等。</p>
<p>这类操作需要通知库代码来调用自己的类执行某些操作，而且这种注册操作一般是在非函数区域中声明，即函数外进行声明。如何做到在函数区域外声明时还能保证执行某段代码？</p>
<p>这就需要利用 <strong>C++标准保证全局变量一定会在main开始之前准备好，因此可以利用全局变量的构造函数来执行代码</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define REG(classname)                                          \</span><br><span class="line">struct __TempClassName_##classname &#123;                            \</span><br><span class="line">    __TempClassName_##classname()&#123;                              \</span><br><span class="line">        RegisterManager::RegisterMap.insert(new classname());   \</span><br><span class="line">    &#125;                                                           \</span><br><span class="line">&#125;;                                                              \</span><br><span class="line">__TempClassName_##classname classname##_reg_obj</span><br></pre></td></tr></table></figure>

<p>使用的时候就是这样： <code>REG(MyClass);</code> 就会在RegisterManager的RegisterMap里插入一个MyClass对象的指针，这样就完成了注册操作。</p>
<p>gtest中的TEST宏做的更漂亮，它使用了静态成员变量来替代那个全局变量完成了注册操作，并把用户的代码扩展为虚函数的代码</p>
<table>
<thead>
<tr>
<th><code>1 2 3 4 5 6 7 8 9</code></th>
<th><code>#define TEST(type)                                             \ class _TempClass##type : public TestBase {                     \ public:                                                        \     virtual void Fun();                                        \ private:                                                       \     static RegHelper reg_obj_;                                 \ };                                                             \ RegHelper _TempClass##type::reg_obj_(new type());              \ virtual void _TempClass##type::Fun()</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第8行：这里完成注册操作</p>
<p>第9行：非常酷，用户的代码就变成了虚函数Fun的代码</p>
<p>使用方式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEST(abc) &#123;</span><br><span class="line">    //at here, customer’s code will be virtual function code as TestBase::Fun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h4><ul>
<li><p>宏常量：但是如果仅仅是定义常量，那么应该果断的使用const而不是使用宏。</p>
</li>
<li><p>头文件的重复包含：这个用途几乎不用说了，头文件都需要用宏包含起来以免重复包含。</p>
</li>
<li><p>条件编译：生成一个程序的不同版本、或者对debug和release使用不同的代码时非常常见:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if defined(OS_HPUX) &amp;&amp; (defined(HPUX_11_11) || defined(HPUX_11_23)</span><br><span class="line">// for HP-UX 11.11 and 11.23</span><br><span class="line">#elif defined(OS_HPUX) &amp;&amp; defined(HPUX_11_31</span><br><span class="line">// for HP-UX 11.31</span><br><span class="line">#elif defined(OS_AIX)</span><br><span class="line">// for AIX</span><br><span class="line">#else</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用_DEBUG进行一个调试工作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">printf(&quot;Debug information\n&quot;);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏函数：避免函数调用，提高程序效率。宏函数基本上可以被模板和内联函数所取代，但是还是有一些简单的函数会使用宏，而且宏函数可以确保一定是内联的。</p>
</li>
<li><p>引用编译期数据：这种情况只能使用宏来解决了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SHOW_CODE_LOCATION() cout&lt;&lt;__FILE__&lt;&lt;&apos;:&apos;&lt;&lt;__LINE__&lt;&lt;&apos;\n&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然，最NB的功能肯定是自动生成代码了！</p>
</li>
<li><p>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</p>
</li>
</ul>
<h2 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h2><p>好处</p>
<ul>
<li>更高效：少了一次调用默认构造函数的过程。</li>
<li>有些场合必须要用初始化列表：<ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ol>
</li>
</ul>
<h2 id="initializer-list-列表初始化"><a href="#initializer-list-列表初始化" class="headerlink" title="initializer_list 列表初始化"></a>initializer_list 列表初始化</h2><p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</p>
<p>initializer_list 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.size() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.end(), l.begin(), l.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> T*, <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; c_arr() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.size()&#125;;  <span class="comment">// 在 return 语句中复制列表初始化</span></span><br><span class="line">                                   <span class="comment">// 这不使用 std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The vector size is now "</span> &lt;&lt; s.c_arr().second &lt;&lt; <span class="string">" ints:\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Range-for over brace-init-list: \n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// auto 的规则令此带范围 for 工作</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// auto 的特殊规则</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The list bound to auto has size() = "</span> &lt;&lt; al.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span></span><br><span class="line">                             <span class="comment">// 它无类型，故 T 无法推导</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p>
<p><img src="https://raw.githubusercontent.com/huihut/interview/master/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png" alt="é¢åå¯¹è±¡ç¹å¾"></p>
<p>面向对象三大特征 —— 封装、继承、多态</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p>
<ul>
<li><code>public</code> 成员：可以被任意实体访问</li>
<li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li>
<li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li>
</ul>
<p><span style="color:red"><strong>明明可以用函数解决的问题</strong>，<strong>为什么要封装起来</strong>？</span></p>
<p>上面那种是 functions, 下面这种叫做 functors. ( 我姑且翻译成函子 )</p>
<p>两者最本质的区别在于，上面仅仅是一个<strong>过程</strong>；而下面，却可以包含<strong>状态</strong>。后者，可以轻松实现闭包。</p>
<p>在 C++11 里面，后者直接演化为 lambda 了。</p>
<hr>
<p>我就用你提到的 <code>sort</code> 来举一个小例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j);&#125;</span><br><span class="line">&#125; myobject;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector&#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort (myvector.begin(), myvector.end(), myfunction);</span><br><span class="line"><span class="built_in">std</span>::sort (myvector.begin(), myvector.end(), myobject);</span><br></pre></td></tr></table></figure>

<p>简化了你的例子，我们来关注本质区别。看起来，好像等效对不？</p>
<p>那么现在需求变了，排序的时候，我只希望排<strong>值大于 40</strong> 的元素，请问咋整，你说，只好把这个 <code>40</code> 写到函数里了。那如果我说这个 <code>40</code> 是来自用户输入呢？也可能是 <code>50</code> 或是 <code>60</code>，请问怎么办？</p>
<p>此时，function 好像有点没有用武之地了。但我们的 functor 却依然可以大显身手。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    myclass(<span class="keyword">int</span> i) : flag(i) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> ((flag &lt; i || flag &lt; j) &amp;&amp; i &lt; j);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector&#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line"><span class="function">myclass <span class="title">myobject</span><span class="params">(<span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::sort (myvector.begin(), myvector.end(), myobject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 32 12 26 33 45 53 71 80</span></span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>基类（父类）——&gt; 派生类（子类）</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li>
<li>多态是以封装和继承为基础的。</li>
<li>C++ 多态分类及实现：<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ul>
<blockquote>
<p><a href="https://catonmat.net/cpp-polymorphism" target="_blank" rel="noopener">The Four Polymorphisms in C++</a></p>
</blockquote>
<h4 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h4><p>函数重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="动态多态（运行期期-晚绑定）"><a href="#动态多态（运行期期-晚绑定）" class="headerlink" title="动态多态（运行期期/晚绑定）"></a>动态多态（运行期期/晚绑定）</h4><ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数，解释见：<a href="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97" target="_blank" rel="noopener">虚函数（virtual）可以是内联函数（inline）吗？</a></li>
</ul>
<p>动态多态使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>                     // 形状类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> Rect(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;calcArea();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<p>虚析构函数使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();    </span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h3><h5 id="1C-中的虚函数、纯虚函数区别和联系"><a href="#1C-中的虚函数、纯虚函数区别和联系" class="headerlink" title="1C++中的虚函数、纯虚函数区别和联系"></a>1C++中的虚函数、纯虚函数区别和联系</h5><p><strong>虚函数和纯虚函数有以下所示方面的区别。</strong><br>（1）类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。<br>（2）虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现，这就像Java的接口一样。通常把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为很难预料到父类里面的这个函数不在子类里面不去修改它的实现。<br>（3）虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。<br>（4）带纯虚函数的类叫<span style="color:red">虚基类</span>，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，<span style="color:red">在C#中用abstract定义抽象类，而在C++中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。</span></p>
<h5 id="2-纯虚函数"><a href="#2-纯虚函数" class="headerlink" title="2 纯虚函数"></a><strong>2 纯虚函数</strong></h5><p>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p>
<p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p>
<p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p>
<p>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
<p>顺便说一句，为一个纯虚函数提供定义也是可能的。也就是说，你可以为纯虚函数提供实现，C++编译器也不会阻拦（DEV_CPP中G++(gcc 3.4.2)编译器并不支持为纯虚函数定义缺省行为；在VC6.0支持为纯虚函数定义缺省的实现，派生类的虚函数override基类的纯虚函数），但调用它的唯一方式是通过类名完整地指明是哪个调用（如：pb-&gt;Base:: pureVirtual()）。</p>
<p><strong>有时，声明一个除纯虚函数外什么也不包含的类很有用。这样的类叫协议类（Protocol class），它为派生类仅提供函数接口，完全没有实现。</strong></p>
<h5 id="3-虚函数（在此指的是非纯虚函数）"><a href="#3-虚函数（在此指的是非纯虚函数）" class="headerlink" title="3 虚函数（在此指的是非纯虚函数）"></a><strong>3 虚函数（在此指的是非纯虚函数）</strong></h5><p>虚函数的情况和纯虚函数有点不一样。照例，派生类继承了函数的接口，但简单虚函数一般还提供了实现，派生类可以选择改写（override）它们或不改写它们。</p>
<p>声明虚函数的目的在于，<strong><em>使派生类继承函数的接口和缺省实现</em></strong>。</p>
<p>虚函数的意义，每个类必须提供一个可以被调用的虚函数，但每个类可以按它们认为合适的任何方式处理。如果某个类不想做什么特别的事，可以借助于基类中提供的缺省处理函数。也就是说，虚函数的声明是在告诉子类的设计者，”你必须支持虚函数，但如果你不想写自己的版本，可以借助基类中的缺省版本。”</p>
<p>实际上，为虚函数同时提供函数声明和缺省实现是很危险的。(当你增加一个派生类继承基类时,必须小心使用虚函数,满足派生类特有的需求，否则就是调用基类的虚函数，可能引起错误)</p>
<h5 id="4-非虚函数"><a href="#4-非虚函数" class="headerlink" title="4 非虚函数"></a>4 非虚函数</h5><p>最后，来谈谈类的非虚函数，当一个成员函数为非虚函数时，它在派生类中的行为就不应该不同。实际上，非虚成员函数表明了一种特殊性上的不变性，因为它表示的是不会改变的行为――不管一个派生类有多特殊。</p>
<p>声明非虚函数的目的在于，使派生类继承函数的接口和强制性实现。（所有的派生类都应该完成的使用该函数完成某一个功能）</p>
<p>建议</p>
<p>结合前面的学过的，再次强调一下，如果你没有为类设计虚函数（纯虚函数），该类一般来说应该不具有继承特性（除非确实的存在IS-A关系，即便存在，派生类也没有了特殊性，这种情况一般是设计中抽象的不合理）。当然除了Protocol class也不应该把类的成员函数全部设计成虚函数（纯虚函数），这也说明了类设计的不合理（不能正确的抽象出基类、派生类之间不变的部分）。</p>
<p>c++中没有接口的概念，与之对应的是纯虚类，即只含有纯虚函数的类，c++抽象类的概念是含有纯虚函数成员的类。这是因为c++提供多继承，而像 java、c#这些只提供单继承（避免多继承的复杂性和低效性）的语言为了模拟多继承功能就提供了接口概念，接口可以继承多个。</p>
<p>abstract class是抽象类，至少包含一个纯虚函数的类就叫做抽象类。</p>
<p>但是如果一个类，所有的成员都是纯虚函数，那么它和一般的抽象类在用法上是有区别的。至少Microsoft给的COM接口定义全部都是仅由纯虚函数构成的类。因此把这样的类定义叫做纯虚类也不算错。</p>
<p>纯虚函数和虚函数的区别在于前者不包含定义，而后者包含函数体。</p>
<p>那么纯虚类就是不包含任何实现（包括成员函数定义和成员变量定义。前者代表算法，后者代表结构）。不包含任何算法和结构的类叫做纯虚类，应该没有问题。</p>
<p>在Java里面的确没有纯虚类的概念，因为Java里没有纯虚函数这个概念。Java管虚函数叫做abstract function，管抽象类叫做abstract class，直接说来，Java根本没有virtual这个关键字，都用abstract代替，因此Java里面根本就没有Pure这个概念。有那就是 interface。在interface里面定义的函数都不能有函数体，这个在Java里面叫做接口。那么C++里面与interface等同的概念就 是纯虚类了，C++用纯虚类来模拟interface这个抽象概念，因此这里说的“纯虚类”与Java的abstract class不同，与C++的一般抽象类也不同。“纯虚类”与C++一般抽象类的区别就好比Java里面interface 和 abstract class的区别。</p>
<h3 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h3><p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</p>
<p>⑴抽象类的定义：</p>
<p>称带有纯虚函数的类为抽象类。</p>
<p>⑵抽象类的作用：</p>
<p>抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所 以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
<p>(3)使用抽象类时注意：</p>
<p>• 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<p>• 抽象类是不能定义对象的。</p>
<p>abstract不是c++的关键词，是微软自己的发明，用来提供.net支持 。VC++并不规范，笔者用devcpp做程序设计，无abstract关键字<br>至于抽象类确实一个类中有纯虚函数就是抽象类 。CSDN中关于C++中abstract关键字的介绍应该是微软扩展出来的，编译器不支持abstract关键字。</p>
<blockquote>
<p><a href="https://blog.csdn.net/u012260238/article/details/53610462" target="_blank" rel="noopener">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p>
</blockquote>
<h3 id="虚函数指针、虚函数表"><a href="#虚函数指针、虚函数表" class="headerlink" title="虚函数指针、虚函数表"></a>虚函数指针、虚函数表</h3><ul>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li>
</ul>
<blockquote>
<p><a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p>
</blockquote>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<h3 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h3><ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：<ul>
<li>虚继承<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul>
</li>
<li>虚函数<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h3><ul>
<li>模板类中可以使用虚函数</li>
<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li>
</ul>
<h3 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h3><ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
<h2 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a>内存分配和管理</h2><h4 id="1-malloc、calloc、realloc、alloca"><a href="#1-malloc、calloc、realloc、alloca" class="headerlink" title="1 malloc、calloc、realloc、alloca"></a>1 malloc、calloc、realloc、alloca</h4><ol>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ol>
<h4 id="2-malloc、free"><a href="#2-malloc、free" class="headerlink" title="2 malloc、free"></a>2 malloc、free</h4><p>用于分配、释放内存</p>
<p>malloc、free 使用</p>
<p>申请内存，确认是否申请成功</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">assert(str != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>释放内存后指针置空</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-new、delete"><a href="#3-new、delete" class="headerlink" title="3 new、delete"></a>3 new、delete</h4><ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ol>
<p>new、delete 使用</p>
<p>申请内存，确认是否申请成功</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* t = <span class="keyword">new</span> T();     <span class="comment">// 先内存分配 ，再构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> t;           <span class="comment">// 先析构函数，再内存释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定位-new"><a href="#定位-new" class="headerlink" title="定位 new"></a>定位 new</h4><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br><span class="line"><span class="keyword">new</span> (place_address) type (initializers)</span><br><span class="line"><span class="keyword">new</span> (place_address) type [size]</span><br><span class="line"><span class="keyword">new</span> (place_address) type [size] &#123; braced initializer <span class="built_in">list</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>place_address</code> 是个指针</li>
<li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li>
</ul>
<h4 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h4><blockquote>
<p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this" target="_blank" rel="noopener">Is it legal (and moral) for a member function to say delete this?</a></p>
</blockquote>
<p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
<h2 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h2><blockquote>
<p><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618" target="_blank" rel="noopener">如何定义一个只能在堆上（栈上）生成对象的类?</a></p>
</blockquote>
<h4 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h4><p>方法：将析构函数设置为私有</p>
<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<h4 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h4><p>方法：将 new 和 delete 重载为私有</p>
<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h4 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h4><p>头文件：<code>#include &lt;memory&gt;</code></p>
<h4 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ps (<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str))；</span><br></pre></td></tr></table></figure>

<h4 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h4><ol>
<li>shared_ptr</li>
<li>unique_ptr</li>
<li>weak_ptr</li>
<li>auto_ptr（被 C++11 弃用）</li>
</ol>
<ul>
<li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li>
<li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li>
</ul>
<h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p>
<ul>
<li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li>
</ul>
<h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h5><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p>
<ul>
<li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li>
</ul>
<h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p>
<ul>
<li>unique_ptr 用于取代 auto_ptr</li>
</ul>
<h5 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h5><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p>
<h5 id="auto-ptr-与-unique-ptr-比较"><a href="#auto-ptr-与-unique-ptr-比较" class="headerlink" title="auto_ptr 与 unique_ptr 比较"></a>auto_ptr 与 unique_ptr 比较</h5><ul>
<li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li>
<li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li>
</ul>
<h3 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h3><blockquote>
<p><a href="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx" target="_blank" rel="noopener">MSDN . 强制转换运算符</a></p>
</blockquote>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><ul>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li>
</ul>
<blockquote>
<p>向上转换是一种隐式转换。</p>
</blockquote>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul>
<li>用于多态类型的转换</li>
<li>执行行运行时类型检查</li>
<li>只适用于指针或引用</li>
<li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li>
</ul>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><ul>
<li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li>
</ul>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><ul>
<li>用于位的简单重新解释</li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li>
<li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li>
<li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 </li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ul>
<h4 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h4><ul>
<li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li>
</ul>
<p>bad_cast 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Circle&amp; ref_circle = <span class="keyword">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> (bad_cast b) &#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught: "</span> &lt;&lt; b.what();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><ul>
<li>typeid 运算符允许在运行时确定对象的类型</li>
<li>type_id 返回一个 type_info 对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li>
<li>只能获取对象的实际类型</li>
</ul>
<h4 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h4><ul>
<li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li>
<li>头文件：<code>typeinfo</code></li>
</ul>
<p>typeid、type_info 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span>                       // 能飞的</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>= <span class="number">0</span>;     <span class="comment">// 起飞</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>= <span class="number">0</span>;        <span class="comment">// 降落</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> :</span> <span class="keyword">public</span> Flyable         <span class="comment">// 鸟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foraging</span><span class="params">()</span> </span>&#123;...&#125;           <span class="comment">// 觅食</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> :</span> <span class="keyword">public</span> Flyable        <span class="comment">// 飞机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">carry</span><span class="params">()</span> </span>&#123;...&#125;              <span class="comment">// 运输</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> take <span class="title">off</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info &amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">doSomething</span><span class="params">(Flyable *obj)</span>                 <span class="comment">// 做些事情</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;takeoff();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(*obj).name() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 输出传入对象类型（"class Bird" or "class Plane"）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(*obj) == <span class="keyword">typeid</span>(Bird))            <span class="comment">// 判断对象类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bird *bird = <span class="keyword">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="comment">// 对象转化</span></span><br><span class="line">        bird-&gt;foraging();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj-&gt;land();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p># </p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/08/各种排序的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/08/各种排序的方法/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-08T15:42:22+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="各种排序方法总结"><a href="#各种排序方法总结" class="headerlink" title="各种排序方法总结"></a>各种排序方法总结</h2><h2 id="1、冒泡排序（bubble-Sort）"><a href="#1、冒泡排序（bubble-Sort）" class="headerlink" title="1、冒泡排序（bubble Sort）"></a>1、冒泡排序（bubble Sort）</h2><p>冒泡排序是最简单粗暴的排序方法之一。它的原理很简单，每次从左到右两两比较，把大的交换到后面，每次可以确保将前M个元素的最大值移动到最右边。</p>
<p><strong>步骤</strong></p>
<ol>
<li>从左开始比较相邻的两个元素x和y，如果 x &gt; y 就交换两者</li>
<li>执行比较和交换，直到到达数组的最后一个元素</li>
<li>重复执行1和2，直到执行n次，也就是n个最大元素都排到了最后</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123; <span class="comment">// times</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size() - i - <span class="number">1</span>; j++) &#123; <span class="comment">// position</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换的哪里可以写一个函数进行交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=nums[j];</span><br><span class="line">    nums[j]=nums[j+<span class="number">1</span>];</span><br><span class="line">    nums[j+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当然这里的一不也可以不借助临时变量</span></span><br><span class="line">nums[j]+=nums[j+<span class="number">1</span>];</span><br><span class="line">nums[j+<span class="number">1</span>]=nums[j]-nums[j+<span class="number">1</span>];</span><br><span class="line">nums[j]=nums[j]-nums[j+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//swap函数写成模板的形式是</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span>((<span class="title">vector</span>&lt;T&gt; &amp;<span class="title">nums</span>,<span class="title">T</span> *<span class="title">a</span>,<span class="title">T</span> *<span class="title">b</span>)//&lt;typename T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>由于我们要重复执行n次冒泡，每次冒泡要执行n次比较（实际是1到n的等差数列，也就是<code>(a1 + an) * n / 2</code>），也就是 <code>O(n^2)</code>。 空间复杂度是<code>O(n)</code>。</p>
<p>冒泡排序是稳定的排序算法，元素较少时效率比较高。</p>
<h2 id="2、插入排序（Insertion-Sort）"><a href="#2、插入排序（Insertion-Sort）" class="headerlink" title="2、插入排序（Insertion Sort）"></a>2、插入排序（Insertion Sort）</h2><p>插入排序的原理是从左到右，把选出的一个数和前面的数进行比较，找到最适合它的位置放入，使前面部分有序。</p>
<p> <strong>步骤</strong></p>
<ol>
<li>从左开始，选出当前位置的数x，和它之前的数y比较，如果x &lt; y则交换两者</li>
<li>对x之前的数都执行1步骤，直到前面的数字都有序</li>
<li>选择有序部分后一个数字，插入到前面有序部分，直到没有数字可选择</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size(),i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i,j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j]+=nums[j<span class="number">-1</span>];</span><br><span class="line">                nums[j<span class="number">-1</span>]=nums[j]-nums[j<span class="number">-1</span>];</span><br><span class="line">                nums[j]-=nums[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>因为要选择n次，而且插入时最坏要比较n次，所以时间复杂度同样是<code>O(n^2)</code>。空间复杂度是<code>O(n)</code>。</p>
<p>插入排序是一种稳定的排序方法，排序元素比较少的时候很好，大量元素便会效率低下。</p>
<h2 id="3、选择排序（Selection-Sort）"><a href="#3、选择排序（Selection-Sort）" class="headerlink" title="3、选择排序（Selection Sort）"></a>3、选择排序（Selection Sort）</h2><p>选择排序的原理是，每次都从乱序数组中找到最大（最小）值，放到当前乱序数组头部，最终使数组有序。</p>
<p><strong>步骤</strong></p>
<ol>
<li>从左开始，选择后面元素中最小值，和最左元素交换</li>
<li>从当前已交换位置往后执行，直到最后一个元素</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selection_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;nums.size(),j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[min]&gt;nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">            min=j;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[min];</span><br><span class="line">        muns[min]=nums[i];</span><br><span class="line">        nums[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是<code>O(n^2)</code>。空间复杂度是<code>O(n)</code>。</p>
<p><span style="color:red">冒泡法和选择排序</span>很像，两者区别在于：冒泡排序是每一次都可能要交换，而选择排序是在比较时记下最小数的位置最后来交换，所以他们的交换过程是不一样的，但查找的过程是一样的。因此选择排序的效率比冒泡法只高不低。</p>
<h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><p>希尔排序从名字上看不出来特点，因为它是以发明者命名的。它的另一个名字是“递减增量排序算法“。这个算法可以看作是插入排序的优化版，因为插入排序需要一位一位比较，然后放置到正确位置。为了提升比较的跨度，希尔排序将数组按照一定步长分成几个子数组进行排序，通过逐渐减短步长来完成最终排序</p>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png" alt="img"></p>
<p><strong>步骤</strong></p>
<ol>
<li>计算当前步长，按步长划分子数组</li>
<li>子数组内插入排序</li>
<li>步长除以2后继续12两步，直到步长最后变成1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap=nums.size()&gt;&gt;<span class="number">1</span>;gap&gt;<span class="number">0</span>;gap&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">            <span class="keyword">int</span> j=i-gap;</span><br><span class="line">            <span class="keyword">for</span>(; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp;j-=gap)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j+gap]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j+gap]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h2><p>归并排序是采用分治法（Divide and Conquer）的一个典型例子。这个排序的特点是把一个数组打散成小数组，然后再把小数组拼凑再排序，直到最终数组有序。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png" alt="img"></p>
<p>　     可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。<strong>分</strong>阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p>
<p>​       再来看看<strong>治</strong>阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。    </p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194508761-468169540.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194621308-588010220.png" alt="img"></p>
<p><strong>步骤</strong></p>
<ol>
<li>把当前数组分化成n个单位为1的子数组，然后两两比较合并成单位为2的n/2个子数组</li>
<li>继续进行这个过程，按照2的倍数进行子数组的比较合并，直到最终数组有序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> end=nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp(nums.size);</span><br><span class="line">    Merge_Sort(nums,begin,end,temp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> middle=(begin+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(middle!=begin)</span><br><span class="line">    &#123;</span><br><span class="line">        Merge_Sort(nums,begin,middle,temp);<span class="comment">//左边</span></span><br><span class="line">        Merge_Sort(nums,middle,end,temp)<span class="comment">//右边</span></span><br><span class="line">        Merge_array(nums.begin,middle,end.temp);  <span class="comment">//排序合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_array</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> middle,<span class="keyword">int</span> end,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=begin; <span class="comment">//左边数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> b=middle;<span class="comment">//右边数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> c=begin; <span class="comment">//临时数组的指针</span></span><br><span class="line">    <span class="keyword">while</span>(a!=middle&amp;&amp;b!=end)<span class="comment">//左右两个数据进行比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[a]&lt;nums[b])</span><br><span class="line">            temp[c++]=nums[a];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[c++]=nums[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;middle)<span class="comment">//一边的数组已近没有了，全部放进到temp数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[c++]=nums[a++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;end)<span class="comment">//一边的数组已近没有了，全部放进到temp数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[c++]=nums[b++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>在<code>merge_array</code>过程中，实际的操作是当前两个子数组的长度，即2m。又因为打散数组是二分的，最终循环执行数是<code>logn</code>。所以这个算法最终时间复杂度是<code>O(nlogn)</code>，空间复杂度是<code>O(n)</code>。</p>
<h2 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h2><p>快速排序也是利用分治法实现的一个排序算法。快速排序和归并排序不同，它不是一半一半的分子数组，而是选择一个基准数，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断对左右两部分也执行相同步骤，直到整个数组有序。</p>
<p><strong>步骤</strong></p>
<ol>
<li>用一个基准数将数组分成两个子数组</li>
<li>将大于基准数的移到右边，小于的移到左边</li>
<li>递归的对子数组重复执行1，2，直到整个数组有序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//占用辅助空间的解法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> end=nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp(nums.size);</span><br><span class="line">    Quick_Sort(nums,begin,end,temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> middle,<span class="keyword">int</span> end,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> middle=(begin+end)/<span class="number">2</span>;<span class="comment">//选取中间的一个点</span></span><br><span class="line">    <span class="keyword">if</span>(midlle!=begin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=begin,b=end<span class="number">-1</span>;<span class="comment">//辅助空间的两个指针 一前一后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i=middle)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[midlle])<span class="comment">//和这个值做一个比较 </span></span><br><span class="line">                temp[a++]=nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[b--]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        temp[a]=nums[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=temp[i];<span class="comment">//放回nums数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        Quick_Sort(nums,begin,a,temp);</span><br><span class="line">        Quick_Sort(nums,a+<span class="number">1</span>,end,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不占用辅助空间的解法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> end=nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">    Quick_Sort(nums,begin,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里进行比较的数字还可以是随机的、</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int index=RandomInRange(begin,end); </span></span><br><span class="line">    <span class="keyword">if</span>(begin&lt;end<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=begin;</span><br><span class="line">        <span class="keyword">int</span> b=end<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a&lt;b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[b]&gt;=nums[begin]&amp;&amp;a&lt;b)</span><br><span class="line">                b--;</span><br><span class="line">            <span class="keyword">while</span>(nums[a]&lt;=nums[begin]&amp;&amp;a&lt;b)</span><br><span class="line">                a++;</span><br><span class="line">            swap(nums[a],nums[b]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[begin],nums[b]);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另外一张快排的写法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Patition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> length,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>||begin&lt;<span class="number">0</span>||end&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index=RandomInRange(begin,end); </span><br><span class="line">    swap(nums[index],nums[end]);</span><br><span class="line">    <span class="keyword">int</span> small=begin<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=samll;i&lt;end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;nums[end])</span><br><span class="line">        &#123;   </span><br><span class="line">            ++small;</span><br><span class="line">            <span class="keyword">if</span>(small!=i)</span><br><span class="line">                swap(nums[i],nums[small]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++small;</span><br><span class="line">    swap(nums[small],nums[end]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> length,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin==end)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index=Patition(nums,length,begin,end);</span><br><span class="line">    <span class="keyword">if</span>(index&gt;begin)</span><br><span class="line">        index=Patition(nums,length,begin,index<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        index=Patition(nums,length,index+<span class="number">1</span>,end); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h2><p>堆排序经常用于求一个数组中最大k个元素时。因为堆实际上是一个完全二叉树，所以用它可以用一维数组来表示。因为最大堆的第一位总为当前堆中最大值，所以每次将最大值移除后，调整堆即可获得下一个最大值，通过一遍一遍执行这个过程就可以得到前k大元素，或者使堆有序。</p>
<p>在了解算法之前，首先了解在一维数组中节点的下标：</p>
<ul>
<li>i节点的父节点 parent(i) = floor((i-1)/2)</li>
<li>i节点的左子节点 left(i) = 2i + 1</li>
<li>i节点的右子节点 right(i) = 2i</li>
</ul>
<p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p>
<p><strong>堆</strong></p>
<p>　　<strong>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182750011-675658660.png" alt="img"></p>
<p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182857323-2092264199.png" alt="img"></p>
<p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p>
<p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p>
<p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p>
<p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p>
<p><strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p>
<p>　　a.假设给定无序序列结构如下</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192038651-934327647.png" alt="img"></p>
<p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192209433-270379236.png" alt="img"></p>
<p>4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192854636-1823585260.png" alt="img"></p>
<p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217193347886-1142194411.png" alt="img"></p>
<p>此时，我们就将一个无需序列构造成了一个大顶堆。</p>
<p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p>
<p>a.将堆顶元素9和末尾元素4进行交换</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217194207620-1455153342.png" alt="img"></p>
<p>b.重新调整结构，使其继续满足堆定义</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218153110495-1280388728.png" alt="img"></p>
<p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152348229-935654830.png" alt="img"></p>
<p>再简单总结下堆排序的基本思路：</p>
<p>　　<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p>
<p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p>
<p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p>
<p>步骤</p>
<ol>
<li>构造最大堆（Build Max Heap）：首先将当前元素放入最大堆下一个位置，然后将此元素依次和它的父节点比较，如果大于父节点就和父节点交换，直到比较到根节点。重复执行到最后一个元素。</li>
<li>最大堆调整（Max Heapify）：调整最大堆即将根节点移除后重新整理堆。整理方法为将根节点和最后一个节点交换，然后把堆看做n-1长度，将当前根节点逐步移动到其应该在的位置。</li>
<li>堆排序（HeapSort）：重复执行2，直到所有根节点都已移除。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();<span class="comment">//整个的大小是 n </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//先是确定最下面的那个非叶节点，然后依次过构造一个最大堆 </span></span><br><span class="line">    &#123; </span><br><span class="line">        max_heapify(nums, i, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)<span class="comment">// heap sort</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        num[i] = nums[<span class="number">0</span>];</span><br><span class="line">        num[<span class="number">0</span>] = temp;</span><br><span class="line">        max_heapify(nums, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curr = beg;</span><br><span class="line">    <span class="keyword">int</span> child = curr * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//子节点</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; end &amp;&amp; nums[child] &lt; nums[child + <span class="number">1</span>])<span class="comment">//先把左节点和右节点比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[curr] &lt; nums[child]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//交换子节点和父节点的值</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[curr];</span><br><span class="line">            nums[curr] = nums[child];</span><br><span class="line">            num[child] = temp;</span><br><span class="line">            <span class="comment">//这里是一直往下 后面的操作可能会改变之前排列好的序列</span></span><br><span class="line">            curr = child;</span><br><span class="line">            child = <span class="number">2</span> * curr + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Max_headpify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current=begin;</span><br><span class="line">    <span class="keyword">int</span> child=current*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(child+<span class="number">1</span>&lt;end&amp;&amp;nums[child]&lt;nums[child+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[current]&lt;nums[child])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[current],current[child]);</span><br><span class="line">            current=child;</span><br><span class="line">            child=current*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;in&gt;Max_Sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result(nums.size());</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)<span class="comment">//先构造一个最大堆</span></span><br><span class="line">    &#123;</span><br><span class="line">       Max_headpify(nums,i,nums.size()<span class="number">-1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        num[i] = nums[<span class="number">0</span>];</span><br><span class="line">        num[<span class="number">0</span>] = temp;</span><br><span class="line">        result.push_back(num[i]);</span><br><span class="line">        max_heapify(nums, <span class="number">0</span>, i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>堆执行一次调整需要<code>O(logn)</code>的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度是<code>O(nlogn)</code>。空间复杂度是<code>O(n)</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/07/剑指offer题目二刷/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/07/剑指offer题目二刷/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T16:24:04+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>剑指Offer题目知识点（二刷）{33—–66题}</p>
<h3 id="34、二叉树中和为某一值的路径"><a href="#34、二叉树中和为某一值的路径" class="headerlink" title="34、二叉树中和为某一值的路径"></a>34、二叉树中和为某一值的路径</h3><p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>使用前序遍历，然后用栈保存路径，并统计当前路径的sum。<br>当某个节点已经不在路径内，这个节点要出栈，并从sum中减去对应的值。<br>ps:因为打印路径的时候需要遍历这个栈，所以这个栈结构最好能遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>               val;</span><br><span class="line">    BinaryTreeNode*  left;</span><br><span class="line">    BinaryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(BinaryTreeNode*root,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line">    <span class="keyword">int</span> currentSum=<span class="number">0</span>;</span><br><span class="line">    FindPath(root,sum,path,currentSum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(BinaryTreeNode*root,<span class="keyword">int</span> sum,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path,<span class="keyword">int</span> currentsum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentSum+=root-&gt;val;</span><br><span class="line">    path.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">bool</span> isleaf=(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">if</span>(currentSum==sum&amp;&amp;isleaf)</span><br><span class="line">    &#123;</span><br><span class="line">        print(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FindPath(root-&gt;left,sum,path,currentSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FindPath(root-&gt;right,sum,path,currentSum);</span><br><span class="line">    &#125;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="35、复杂链表的复制"><a href="#35、复杂链表的复制" class="headerlink" title="35、复杂链表的复制"></a>35、复杂链表的复制</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，<br>一个指向下一个节点，另一个特殊指针指向任意一个节点或者null），<br>返回结果为复制后复杂链表的head。<br>（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  val;</span><br><span class="line">    ComplexListNode* next;</span><br><span class="line">    ComplexListNode* Sibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.第一步：根据原始链表的每个节点N创建对应的N’。把N’链接在N的后面。<br>2.第二步：设置复制出来的节点的random<br>3.第三步：把这个长链表拆分成两个链表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  val;</span><br><span class="line">    ComplexListNode* next;</span><br><span class="line">    ComplexListNode* Sibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClonNode</span><span class="params">(ComplexListNode*head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComplexListNode*node=head;</span><br><span class="line">    <span class="keyword">while</span>(node-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ComplexListNode*pClond=<span class="keyword">new</span> ComplexListNode();</span><br><span class="line">        pClond-&gt;val=node-val;</span><br><span class="line">        pClond-&gt;next=ndoe-&gt;next;</span><br><span class="line">        </span><br><span class="line">        pClond-&gt;Sibling=<span class="literal">nullptr</span>;</span><br><span class="line">        ndoe-&gt;next=pClond;</span><br><span class="line">        ndoe=pClond-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectSibling</span><span class="params">(ComplexListNode*head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connectSibling* Node=head;</span><br><span class="line">    <span class="keyword">while</span>(Node!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        connectSibling* pClond= Node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Node-&gt;Sibling!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pClond-&gt;Sibling=Node-&gt;Sibling-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node=pClond-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReconnectNode</span><span class="params">(ComplexListNode*head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComplexListNode*Node=head;</span><br><span class="line">    ComplexListNode*pClondhead=<span class="literal">nullptr</span>;</span><br><span class="line">    ComplexListNode*pClondNode=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//先设置好头结点</span></span><br><span class="line">    <span class="keyword">if</span>(Node!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pClondhead=pClondNode=Node-&gt;next;</span><br><span class="line">        Node-&gt;next=pClondNode-&gt;next;</span><br><span class="line">        Node=Node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Ndoe!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pClondNode-&gt;next=Node-&gt;next;</span><br><span class="line">        pClondNode=Ndoe-&gt;next;</span><br><span class="line">        Node-&gt;next=pClondNode-&gt;next;</span><br><span class="line">        Node=pClondNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pClondhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="36、二叉树与双向链表（-）"><a href="#36、二叉树与双向链表（-）" class="headerlink" title="36、二叉树与双向链表（*****）"></a>36、二叉树与双向链表（<strong>*****</strong>）</h3><p>使用中序遍历二叉搜索树，得到的便是整个排序的序列。<br>我们用一个节点指针 lastNodeInList 来指向已排序的链表的最后一个节点。<br>在中序遍历的时候，每遍历到一个节点，就将该节点与 lastNodeInList 双向连接，并将 lastNodeInList 置为新遍历到的这个节点。</p>
<p>一直递归到最左边的节点，然后往外回，采用的是中序遍历，这样子的节点遍历顺序刚好是排序好的了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  val;</span><br><span class="line">    BinaryTreeNode* left;</span><br><span class="line">    BinaryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">convertNode</span><span class="params">(BinaryTreeNode*proot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTreeNode*PlistInNode=<span class="literal">nullptr</span>;</span><br><span class="line">    converyNode(proot,PlistInNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">converyNode</span><span class="params">(BinaryTreeNode*pNode,BinaryTreeNode**PlistInNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BinaryTreeNode*pcurrentNode=proot;</span><br><span class="line">    <span class="keyword">if</span>(pcurrentNode-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        converyNode(pcurrentNode-&gt;left,PlistInNode);</span><br><span class="line">    &#125;</span><br><span class="line">    pcurrentNode-&gt;left=PlistInNode;</span><br><span class="line">    <span class="keyword">if</span>(PlistInNode!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (*PlistInNode)-&gt;right=pcurrentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    *PlistInNode=pcurrentNode;</span><br><span class="line">    <span class="keyword">if</span>(pcurrentNode-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        converyNode(pcurrentNode-&gt;right,PlistInNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="37、序列化二叉树"><a href="#37、序列化二叉树" class="headerlink" title="37、序列化二叉树"></a>37、序列化二叉树</h3><p> 请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>这里是二叉树的序列化的代码 及时直接前序遍历二叉树 然后如果是nullptr 则是输出的￥</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  val;</span><br><span class="line">    BinaryTreeNode* left;</span><br><span class="line">    BinaryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(BinaryTreeNode*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cont&lt;&lt;<span class="string">"$"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Serialize(root-&gt;left);</span><br><span class="line">    Serialize(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是反序列化的代码  ReadStream 这个函数主要的功能是看从字节流里面读出来的是数字还是符号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deserialize</span><span class="params">(BinaryTreeNode**root,istream&amp;stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">if</span>(ReadStream(stream,&amp;number))</span><br><span class="line">    &#123;</span><br><span class="line">        *proot=<span class="keyword">new</span> BinarytreeNode();</span><br><span class="line">        (*proot)-&gt;val=number;</span><br><span class="line">        (*proot)-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">        (*proot)-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        Deserialize(&amp;((*proot)-&gt;left),stream);</span><br><span class="line">        Deserialize(&amp;((*proot)-&gt;right),stream);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="38、字符串的排列"><a href="#38、字符串的排列" class="headerlink" title="38、字符串的排列"></a>38、字符串的排列</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>ps：输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母</p>
<p>将字符串操作分为三步进行：<br>将字符串分为两部分，第一部分是第一个字符；另外一部分是后面的字符串；每次循环将第一个字符与后面的每个字符进行交换；<br>对后一部分字符串，视为当前字符串，进行前面同样的操作；<br>子字符串操作完成后，需要恢复第一个位置的原本字符。<br>例子：如“abcd”，a和b交换后，成为“bacd”;当后面的3个字符的子字符串操作完成后，需要对‘a’和‘c’进行交换，但是当前是“bacd”；所以需要再交换回来成为“abcd”，再进行交换及后面子字符串的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Permutation(str,str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">char</span>*begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin==<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">"%s/n"</span>,str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假如这里是abcd 先是 a 和 b 进行交换，得到bacd 然后是后面的 acd 进行排序 然后</span></span><br><span class="line">         <span class="comment">//又是 ad 进行排序 最后是 a  在依次往外压出 最后还原成abcd </span></span><br><span class="line">        <span class="comment">//在进行第二轮大的排序  abcd----&gt;cbad; </span></span><br><span class="line">        <span class="comment">//                   abcd----&gt;dcbd;</span></span><br><span class="line">        <span class="comment">//这样子就可以把整个排列的情况列举出来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>* ph=begin;ph!=<span class="string">'\0'</span>;ph++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(ph,begin);</span><br><span class="line">            Permutation(str,begin+<span class="number">1</span>);</span><br><span class="line">            swap(ph,begin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *temp=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39、数组中出现次数超过一半的数字"><a href="#39、数组中出现次数超过一半的数字" class="headerlink" title="39、数组中出现次数超过一半的数字"></a>39、数组中出现次数超过一半的数字</h3><blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，说明它出现的次数比其他所有数字出现的次数和还要多。</p>
<p>那么要找的数字肯定是最后一次把数组设置为1时对应的数字，即val可能就是我们要的值<br>之所以说是可能，是因为还要验证val出现的次数是否真正超过了数组长度的一半</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MorethanHalfNumber</span><span class="params">(<span class="keyword">int</span> *number,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result=number[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> time=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(time==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result=number[i];</span><br><span class="line">            time=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result==number[i])</span><br><span class="line">        &#123;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            time--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!checknumberMoreThanHalf(number,length,result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种比较笨比的办法 这里首先会改变数组里数字的排序情况 然后时间复杂度也不是很好</p>
<p>基快排的思想去找到中间的那个数字，然后看这个数字是不是超过一半</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanNumber</span><span class="params">(<span class="keyword">int</span> *numbers,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> middle=length&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end=length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> index=Partition(numbers,start,end);</span><br><span class="line">    <span class="keyword">while</span>(index!=middle)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(index&gt;middle)</span><br><span class="line">       &#123;</span><br><span class="line">           end=index<span class="number">-1</span>;</span><br><span class="line">           Patition(numbers,start,end);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            start=index+<span class="number">1</span>;</span><br><span class="line">            Patation(numbers,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result=numbers[middle];</span><br><span class="line">    <span class="keyword">if</span>(!checknumberMoreThanHalf(number,length,result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="40、最小的K个数"><a href="#40、最小的K个数" class="headerlink" title="40、最小的K个数"></a>40、最小的K个数</h3><p>输入n个整数，找出其中最小的K个数。<br>例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。<br>ps：题目只要求最小的k个数，没有要求这k个数要排序</p>
<p>解法1：</p>
<ul>
<li>使用partition算法</li>
<li>时间复杂度为O(n)</li>
<li>空间复杂度为O(1)</li>
<li>数组会乱序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetlastNumbers</span><span class="params">(<span class="keyword">int</span> *put,<span class="keyword">int</span> length,<span class="keyword">int</span>*output,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(put==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>||k&gt;length||k&lt;=<span class="number">0</span>)\</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end=length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> index=Patition(put,start,end);</span><br><span class="line">    <span class="keyword">while</span>(index!=k<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;k<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end=index<span class="number">-1</span>;</span><br><span class="line">            Patition(put,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            start=index+<span class="number">1</span>;</span><br><span class="line">            Patition(put,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        output[i]=put[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用优先队列来做，用最大堆实现整个过程</p>
<p>==代码==</p>
<p>还可以基于红黑树做，用到STL的map 或者是 multiset</p>
<p>==代码==</p>
<h3 id="41、数据流中的中位数"><a href="#41、数据流中的中位数" class="headerlink" title="41、数据流中的中位数"></a>41、数据流中的中位数</h3><p>如何得到一个数据流中的中位数？如果从数据流中读取奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序后中间两个数的平均数</p>
<p>1.本来使用一个AVL树来实现是最佳的，但是各种语言的函数库都还没有现成的AVL树的实现，所以选择使用两个堆来完成。使用一个最大堆实现中位数左边的数据容器，使用一个最小堆实现中位数右边的数据容器。往堆中插入一个数据的时间是O(logn)，而取得最大最小数据的时间是O(1)。</p>
<blockquote>
<p>1.必须保证数据平均分配到两个堆中间，即两个堆中的数据数目之差不能超过1。为了实现数据的平均分配，可以在数据的总数目是偶数是把新数据插入到最小堆中，否则插入到最大堆中。<br>2.还必须保证最小堆中的所有数据都要大于最大堆中的数据。比如在偶数个数据时，如果要插入的数据小于最大堆的一些数据，需要把数据先插入最大堆，然后把最大堆的最大数据弹出，再插入到最小堆中。奇数个数的数据插入时也相同。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于vector的最大堆个最小堆实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//插入前 先判断现在左右整个堆奇偶性</span></span><br><span class="line">        <span class="keyword">if</span>(((min.size()+max.size())&amp;<span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max.size()&gt;&amp;&amp;num&lt;max[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                max.push_back(num);</span><br><span class="line">                push_head(max.begin(),max.end(),less&lt;T&gt;());</span><br><span class="line">                num=max[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//这里没有看懂为什么要维护两次</span></span><br><span class="line">                push_head(max.begin(),max.end(),less&lt;T&gt;());</span><br><span class="line">                max.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            min.push_back(num);</span><br><span class="line">            push_head(min.begin(),min.end(),greater&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(min.size()&gt;<span class="number">0</span>&amp;&amp;num&gt;min[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                min.push_back(num);</span><br><span class="line">                push_head(min.begin(),min.end(),greater&lt;T&gt;());</span><br><span class="line">                num=min[<span class="number">0</span>];</span><br><span class="line">                push_head(min.begin(),min.end(),greater&lt;T&gt;());</span><br><span class="line">                min.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            max.push_back(num);</span><br><span class="line">            push_head(max.begin(),max.end(),less&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetMiddleNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=min.size()+max.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> mother fucker;</span><br><span class="line">        T result;</span><br><span class="line">        <span class="keyword">if</span>(size&amp;<span class="number">1</span>==<span class="number">1</span>)</span><br><span class="line">            result=min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result=(max[<span class="number">0</span>]+min[<span class="number">0</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt;min;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt;max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42、连续子数组的最大和"><a href="#42、连续子数组的最大和" class="headerlink" title="42、连续子数组的最大和"></a>42、连续子数组的最大和</h3><p>输入一个整型数组，数组里面有正数也有负数。数组中的一个或连续多个整数组成自一个子数组，求所有子数组的和的最大值。要求时间复杂度为O(n)</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/06/LeeCode/下一个排列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/06/LeeCode/下一个排列/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-06T16:19:29+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a><strong>下一个排列</strong></h4><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<ol>
<li>判断按照字典序有木有下一个，如果完全降序就没有下一个</li>
<li>如何判断有木有下一个呢？只要存在a[i-1] &lt; a[i]的升序结构，就有，而且我们应该从右往左找，一旦找到，因为这样才是真正下一个</li>
<li>当发现a[i-1] &lt; a[i]的结构时，从在[i, ∞]中找到最接近a[i-1]并且又大于a[i-1]的数字，由于降序，从右往左遍历即可得到k</li>
<li>然后交换a[i-1]与a[k]，然后对[i, ∞]排序即可，排序只需要首尾不停交换即可，因为已经是降序 上面说的很抽象，还是需要拿一些例子思考才行，比如[0,5,4,3,2,1]，下一个是[1,0,2,3,4,5]</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;nums[j]&lt;=nums[j<span class="number">-1</span>])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="comment">//在这里去判断排列的情况 看看是不是一直降序</span></span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()/<span class="number">2</span>;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i],nums[nums.size()<span class="number">-1</span>-i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1 2 4</span></span><br><span class="line">        <span class="keyword">int</span> r=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r]&gt;nums[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[r], nums[j<span class="number">-1</span>]);</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">int</span> cnt = (nums.size() - j)/<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            swap(nums[j+i], nums[nums.size() - <span class="number">1</span> - i]);</span><br><span class="line">            ++i; --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/06/STL/空间配置器的标准接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/06/STL/空间配置器的标准接口/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-06T16:02:10+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="空间配置器概述"><a href="#空间配置器概述" class="headerlink" title="空间配置器概述"></a>空间配置器概述</h1><p>以前在项目中运用STL一般都不会涉及到空间配置器，可是，在STL的实现中，空间配置器是重中之重，因为整个STL的操作对象都存放在容器之内，而容器一定需要配置空间以置放资料。所以，在阅读STL源码时，最先需要掌握的就是空间配置器，没了它，容器，算法怎么存在？</p>
<p>C++ STL的空间配置器将内存的配置、释放和对象的构造和析构分开，内存配置操作由alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造操作由::construct()负责，对象的析构操作由::destroy()负责。首先放一张思维导图来概述一下STL的整个空间配置器概览。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfode4zyj30qs0agq3y.jpg" alt="空间配置器"></p>
<h1 id="对象的构造和析构"><a href="#对象的构造和析构" class="headerlink" title="对象的构造和析构"></a>对象的构造和析构</h1><p>个人觉得看源码只需要图和代码注释即可，所以本篇博客图片较多！对着图来看代码效率会高很多！</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfo9n8psj30ql08z3zm.jpg" alt="构造和析构"></p>
<p>下面是源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new.h&gt;        // 需要placement new的原型</span></span></span><br><span class="line"><span class="comment">// -----------------构造函数---------------------------------//</span></span><br><span class="line"><span class="comment">// 使用placement new在已经分配的内存上构造对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(<span class="title">T1</span>* <span class="title">p</span>, <span class="title">const</span> <span class="title">T2</span>&amp; <span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">new</span> (p) T1(value);<span class="comment">//将value设定到指针p所指的空间上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------析构函数---------------------------------//</span></span><br><span class="line"><span class="comment">// -----------第一个版本：接受一个指针--------------------------//</span></span><br><span class="line"><span class="comment">// 调用成员的析构函数, 需要类型具有non-trivial destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span>* <span class="title">pointer</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    pointer-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------第二个版本：接受两个迭代器------------------------//</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __destroy(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先是两个特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">char</span>*)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">wchar_t</span>*, <span class="keyword">wchar_t</span>*)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构一组对象, 用于具有non-trivial destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span></span></span><br><span class="line"><span class="class">__<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first &lt; last; ++first)</span><br><span class="line">    destroy(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有类型non-trivial destructor, 则使用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span>, <span class="title">ForwardIterator</span>, __<span class="title">true_type</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用traits技术, 判断类型是否就有non-trivial destructor, 然后调用不同的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">T</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">  __destroy_aux(first, last, trivial_destructor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内存的配置和释放"><a href="#内存的配置和释放" class="headerlink" title="内存的配置和释放"></a>内存的配置和释放</h1><p>在内存配置方面，STL分为两级配置器，当请求的内存大于128b的时候调用第一级配置器，当请求的内存小于等于128b的时候调用第二级配置器。先来看看下面这张表，大概就能知道第一级和第二级配置器主要干了些什么，其他的一些细节如内存池是怎么工作的，下面会给出具体解释。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfoeivm3j30q3078t9m.jpg" alt="内存配置"></p>
<h2 id="第一级配置器"><a href="#第一级配置器" class="headerlink" title="第一级配置器"></a>第一级配置器</h2><p>首先我们来看第一级配置器的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//调用malloc函数不成功后调用</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用realloc函数不成功后调用 </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类似于C++的set_new_handle错误处理函数一样，如果不设置，在内存不足时，返回THROW_BAD_ALLOC</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG  </span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;  </span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:  </span><br><span class="line">	<span class="comment">//直接调用malloc来分配内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">	 <span class="keyword">void</span> *result = <span class="built_in">malloc</span>(n);  </span><br><span class="line">	 <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_malloc(n);  <span class="comment">//如果分配失败，则调用oom_malloc()</span></span><br><span class="line">	 <span class="keyword">return</span> result;  </span><br><span class="line">	&#125;  </span><br><span class="line"> 	<span class="comment">//第一级配置器直接调用free来释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* n */</span>)</span>  </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="built_in">free</span>(p); </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//直接调用reallloc来分配内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> new_sz)</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">	 <span class="keyword">void</span> * result = <span class="built_in">realloc</span>(p, new_sz);  </span><br><span class="line">	 <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_realloc(p, new_sz);  <span class="comment">//如果realloc分配不成功，调用oom_realloc()</span></span><br><span class="line">	 <span class="keyword">return</span> result;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常处理函数，即内存分配失败后的处理</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="keyword">void</span> (*f)()))</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">	 <span class="keyword">void</span> (* old)() = __malloc_alloc_oom_handler;  </span><br><span class="line">	 __malloc_alloc_oom_handler = f;  </span><br><span class="line">	 <span class="keyword">return</span>(old);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上述源码中可以看到，STL的第一级配置器仅仅是调用了malloc，free等函数，然后增加了内存分配错误下的异常处理函数，下面我们就通过源码来看看在内存分配失败后，STL是怎么处理的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是针对内存分配失败后的处理</span></span><br><span class="line"><span class="comment">//首先，将__malloc_alloc_oom_handler的默认值设为0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_malloc(<span class="keyword">size_t</span> n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">void</span> (* my_malloc_handler)();  </span><br><span class="line">	<span class="keyword">void</span> *result;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  <span class="comment">// 不断地尝试释放、再配置、再释放、再配置</span></span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;  </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;  <span class="comment">//这里是当没有设置处理函数的时候，直接抛出异常</span></span><br><span class="line">		(*my_malloc_handler)();   <span class="comment">// 调用处理例程，尝试释放内存</span></span><br><span class="line">		result = <span class="built_in">malloc</span>(n);  	  <span class="comment">// 再重新分配内存</span></span><br><span class="line">		<span class="keyword">if</span> (result) <span class="keyword">return</span>(result);  <span class="comment">// 如果分配成功则返回指针</span></span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">void</span> (* my_malloc_handler)();  </span><br><span class="line">	<span class="keyword">void</span> *result;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  <span class="comment">//不断地尝试释放、再配置、再释放、再配置</span></span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;  </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; <span class="comment">//这里是当没有设置处理函数的时候，直接抛出异常 </span></span><br><span class="line">		(*my_malloc_handler)();  <span class="comment">// 调用处理例程，尝试释放内存</span></span><br><span class="line">		result = <span class="built_in">realloc</span>(p, n);  <span class="comment">// 再重新分配内存</span></span><br><span class="line">		<span class="keyword">if</span> (result) <span class="keyword">return</span>(result);  <span class="comment">// 如果分配成功则返回指针</span></span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二级配置器"><a href="#第二级配置器" class="headerlink" title="第二级配置器"></a>第二级配置器</h2><p>当申请内存小于128b的时候，会调用第二级配置器。第二级配置器有一个内存池和一个对应的自由链表，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> obj  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">union</span> obj * free_list_link;  </span><br><span class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里有一个技巧，如果使用union的第一个成员，则指向另一个相同的union obj；而如果使用第二个成员，则指向实际的内存区域，这样一来，既实现了链表结点只用一个指针的大小空间，却能同时做索引和指向内存区域。</p>
<blockquote>
<p>这里的这个技巧我觉得有必要解释一下，首先client_data是一个常量指针，指向client_data[0]，然后client_data[0]和free_list_link共用同一段内存，我们在使用这个union的时候，先让client_data指向实际的内存区域，然后将free_list_link(也就是client_data[0])赋值为下一个结点的地址，注意这里我只是修改了client_data[0]，client_data并没有修改，而是始终指向实际内存。</p>
</blockquote>
<p>我们先来看看第二级配置器的部分源码，然后再去分析其中每个函数的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;   <span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;  <span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;   <span class="comment">//free-lists个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一参数用于多线程，这里不做讨论。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 此函数将bytes的边界上调至8的倍数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));  </span><br><span class="line">	&#125;  </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">	<span class="comment">// 此union结构体上面已经解释过了</span></span><br><span class="line">	<span class="keyword">union</span> obj  </span><br><span class="line">	&#123;  </span><br><span class="line">	<span class="keyword">union</span> obj * free_list_link;  </span><br><span class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">	&#125;;  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="comment">//16个free-lists</span></span><br><span class="line">	<span class="keyword">static</span> obj * __VOLATILE free_list[__NFREELISTS];</span><br><span class="line">	<span class="comment">// 根据待待分配的空间大小, 在free_list中选择合适的大小  </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span>  size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个大小为n的对象，并可能加入大小为n的其它区块到free-lists</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;  </span><br><span class="line">	<span class="comment">// 配置一大块空间，可容纳nobjs个大小为“size”的区块</span></span><br><span class="line">	<span class="comment">// 如果配置nobjs个区块有所不便，nobjs可能会降低，所以需要用引用传递</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span></span>;  </span><br><span class="line">	<span class="comment">// 内存池  </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *start_free;      <span class="comment">// 内存池起始点，只在chunk_alloc()中变化 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *end_free;        <span class="comment">// 内存池结束点，只在chunk_alloc()中变化 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;      <span class="comment">// 已经在堆上分配的空间大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;<span class="comment">// 空间配置函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span></span>; <span class="comment">// 空间释放函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> old_sz , <span class="keyword">size_t</span> new_sz)</span></span>; <span class="comment">//空间重新配置函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些静态成员变量的初始化</span></span><br><span class="line"><span class="comment">// 内存池起始位置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 内存池结束位置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 已经在堆上分配的空间大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 内存池容量索引数组  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj * __VOLATILE  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt; ::free_list[__NFREELISTS ] = </span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>

<p>看完上面这一堆源码，你可能早就头晕眼花，一脸懵逼了，没事，我再来用一张思维导图来帮你理一理思绪：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfocm8q6j30ri0dl40t.jpg" alt="二级配置器1"></p>
<p>接下来又是枯燥的源码时间！相信有上面这张图，看源码的思路就比较清晰了。</p>
<h3 id="空间配置函数allocate"><a href="#空间配置函数allocate" class="headerlink" title="空间配置函数allocate()"></a>空间配置函数allocate()</h3><p>借用《STL源码剖析》里面的一张图，来说明空间配置函数的调用过程：(看图放松，放松完继续看源码！别偷懒)</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfobir1sj30mz0fw402.jpg" alt="空间配置函数"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	obj * <span class="keyword">volatile</span> * my_free_list;  </span><br><span class="line">	obj * result;  </span><br><span class="line">	<span class="comment">// 大于128就调用第一级配置器</span></span><br><span class="line">	<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;  </span><br><span class="line">	 <span class="keyword">return</span>(malloc_alloc::allocate(n));  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">// 寻找16个free_lists中适当的一个</span></span><br><span class="line">	my_free_list = free_list + FREELIST_INDEX(n);  </span><br><span class="line">	result = *my_free_list;  </span><br><span class="line">	<span class="keyword">if</span> (result == <span class="number">0</span>) &#123;  </span><br><span class="line">		<span class="comment">// 如果没有可用的free list，准备重新填充free_list</span></span><br><span class="line">		<span class="keyword">void</span> *r = refill(ROUND_UP(n));  </span><br><span class="line">		<span class="keyword">return</span> r;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调整free list</span></span><br><span class="line">	*my_free_list = result -&gt; free_list_link;  </span><br><span class="line">	<span class="keyword">return</span> (result);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="重新填充函数refill"><a href="#重新填充函数refill" class="headerlink" title="重新填充函数refill()"></a>重新填充函数refill()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">int</span> nobjs = <span class="number">20</span>;  <span class="comment">//	默认获取20个</span></span><br><span class="line">	<span class="keyword">char</span> * chunk = chunk_alloc(n, nobjs);  <span class="comment">//找内存池要空间</span></span><br><span class="line">	obj * <span class="keyword">volatile</span> * my_free_list;  </span><br><span class="line">	obj * result;  </span><br><span class="line">	obj * current_obj, * next_obj;  </span><br><span class="line">	<span class="keyword">int</span> i;  </span><br><span class="line">	<span class="comment">// 如果内存池仅仅只够分配一个对象的空间, 直接返回即可  </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);  </span><br><span class="line">	<span class="comment">// 内存池能分配更多的空间，调整free_list纳入新节点</span></span><br><span class="line">	my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在chunk的空间中建立free_list  </span></span><br><span class="line">	result = (obj *)chunk;</span><br><span class="line">	*my_free_list = next_obj = (obj *)(chunk + n); <span class="comment">//导引free_list指向新配置的空间(取自内存池)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; ; i++) &#123;	<span class="comment">//从1开始，因为第0个返回给客端</span></span><br><span class="line">		current_obj = next_obj;  </span><br><span class="line">		next_obj = (obj *)((<span class="keyword">char</span> *)next_obj + n);  </span><br><span class="line">		<span class="keyword">if</span>(nobjs - <span class="number">1</span> == i) &#123;  </span><br><span class="line">			current_obj -&gt; free_list_link = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			current_obj -&gt; free_list_link = next_obj;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span>(result);<span class="comment">//返回头指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存池函数chunk-alloc"><a href="#内存池函数chunk-alloc" class="headerlink" title="内存池函数chunk_alloc()"></a>内存池函数chunk_alloc()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span>*  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">char</span> * result;  </span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = size * nobjs;  </span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;  <span class="comment">// 计算内存池剩余容量  </span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//内存池中的剩余空间满足需求 </span></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(result);<span class="comment">//返回起始地址</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果内存池中剩余的容量不够分配, 但是能至少分配一个节点时,  </span></span><br><span class="line">    <span class="comment">// 返回所能分配的最多的节点, 返回start_free指向的内存块  </span></span><br><span class="line">    <span class="comment">// 并且重新设置内存池起始点  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bytes_left &gt;= size) &#123;</span><br><span class="line">        nobjs = bytes_left/size;  </span><br><span class="line">        total_bytes = size * nobjs;  </span><br><span class="line">        result = start_free;  </span><br><span class="line">        start_free += total_bytes;  </span><br><span class="line">        <span class="keyword">return</span>(result);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 内存池剩余内存连一个节点也不够分配  </span></span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);  </span><br><span class="line">        <span class="comment">// 将剩余的内存分配给指定的free_list[FREELIST_INDEX(bytes_left)]  </span></span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        	<span class="comment">//内存池内还有一些零头，先分给适当的free_list</span></span><br><span class="line">        	<span class="comment">//寻找适当的free_list</span></span><br><span class="line">            obj * __VOLATILE * my_free_list =  </span><br><span class="line">                   	free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line">            <span class="comment">// 调整free_list，将内存池中的残余空间编入 </span></span><br><span class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;  </span><br><span class="line">            *my_free_list = (obj *)start_free;  </span><br><span class="line">        &#125;  </span><br><span class="line">        start_free = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);  </span><br><span class="line">        <span class="comment">// 分配失败, 搜索原来已经分配的内存块, 看是否有大于等于当前请求的内存块  </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;<span class="comment">// heap里面空间不足，malloc失败</span></span><br><span class="line">            <span class="keyword">int</span> i;  </span><br><span class="line">            obj * __VOLATILE * my_free_list, *p;  </span><br><span class="line">            <span class="comment">// 试着检查检查free_list中的可用空间，即尚有未用的空间，且区块够大  </span></span><br><span class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;  </span><br><span class="line">                my_free_list = free_list + FREELIST_INDEX(i);  </span><br><span class="line">                p = *my_free_list;  </span><br><span class="line">                <span class="comment">// 找到了一个, 将其加入内存池中  </span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;  </span><br><span class="line">                    *my_free_list = p -&gt; free_list_link;  </span><br><span class="line">                    start_free = (<span class="keyword">char</span> *)p;  </span><br><span class="line">                    end_free = start_free + i;  </span><br><span class="line">                    <span class="comment">// 内存池更新完毕, 重新分配需要的内存  </span></span><br><span class="line">                    <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </span><br><span class="line">                    <span class="comment">//任何剩余零头将被编入适当的free_list以留备用 </span></span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 再次失败, 直接调用一级配置器分配, 期待异常处理函数能提供帮助  </span></span><br><span class="line">        <span class="comment">// 不过在我看来, 内存分配失败进行其它尝试已经没什么意义了,  </span></span><br><span class="line">        <span class="comment">// 最好直接log, 然后让程序崩溃  </span></span><br><span class="line">        end_free = <span class="number">0</span>;</span><br><span class="line">        	<span class="comment">//调用第一级配置器，看看out-of-memory机制能不能起点作用</span></span><br><span class="line">            start_free = (<span class="keyword">char</span> *)malloc_alloc::allocate(bytes_to_get);  </span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;  </span><br><span class="line">        end_free = start_free + bytes_to_get;  </span><br><span class="line">        <span class="comment">// 内存池更新完毕, 重新分配需要的内存  </span></span><br><span class="line">        <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存释放函数deallocate"><a href="#内存释放函数deallocate" class="headerlink" title="内存释放函数deallocate()"></a>内存释放函数deallocate()</h3><p>内存释放函数会将释放的空间交还给free_list以留备用。其过程如下图所示：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfoariykj30mp0gitai.jpg" alt="空间释放函数"></p>
<p>其实就是一个简单的单链表插入的过程。其源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	obj *q = (obj *)p;  </span><br><span class="line">	obj * <span class="keyword">volatile</span> * my_free_list;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 大于128的直接交由第一级配置器释放  </span></span><br><span class="line">	<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;  </span><br><span class="line">		malloc_alloc::deallocate(p, n);  </span><br><span class="line">		<span class="keyword">return</span>;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 寻找适当的free_list  </span></span><br><span class="line">	my_free_list = free_list + FREELIST_INDEX(n);  </span><br><span class="line">	<span class="comment">// 调整free_list，回收区块</span></span><br><span class="line">	q -&gt; free_list_link = *my_free_list;  </span><br><span class="line">	*my_free_list = q;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="配置器的使用"><a href="#配置器的使用" class="headerlink" title="配置器的使用"></a>配置器的使用</h1><p>通过以上的图和源代码，基本上将STL的两层配置器讲完了，接下来就来熟悉一下怎么使用配置器。</p>
<p>STL将上述配置器封装在类simple_alloc中，提供了四个用于内存操作的借口函数，分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::allocate(n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span>	</span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> (T*) Alloc::allocate(<span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span> </span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::deallocate(p, n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">                </span>&#123; Alloc::deallocate(p, <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就示范在vector中是怎么使用它的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;  //<span class="title">alloc</span>被默认为第二级配置器</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 专属的空间配置器，每次只分配一个元素的大小</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在释放内存的时候直接调用借口函数即可</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(...)&#123;</span><br><span class="line">			data_allocator::deallocate(start , end_of_storage - start);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/06/链表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/06/链表/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-06T16:00:09+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2></li>
<li><p>双向链表属于链表的一种，也叫双链表双向即是说它的链接方向是双向的，它由若干个节点组成，每个节点都包含下一个节点和上一个节点的指针，所以从双向链表的任意节点开始，都能很方便访问他的前驱结点和后继节点。（此时可以前项访问前面一个节点和后面的节点）</p>
</li>
<li></li>
<li><p>特点</p>
</li>
<li><ul>
<li>创建双链表时无需指定链表的长度。(和单链表一样)</li>
<li>比起单链表，双链表需要多一个指针用于指向前驱节点，所以需要存储空间比单链表多一点。(多一个节点存储数据)</li>
<li>双链表的插入和删除需要同时维护       next 和 prev 两个指针。</li>
<li>双链表中的元素访问需要通过顺序访问，即要通过遍历的方式来寻找元素。</li>
</ul>
</li>
<li></li>
<li><p><img src="file:///C:/Users/CCTVZYX/AppData/Local/Temp/msohtmlclip1/01/clip_image001.jpg" alt="âååé¾è¡¨c++ å¾âçå¾çæç´¢ç»æ"></p>
</li>
<li><p><strong>（1）定义双向链表的基本结构</strong></p>
</li>
<li><p>typedef struct  _DOUBLE_LINK_NODE<br>   {</p>
<pre><code>int data;  //存放的数据</code></pre></li>
<li><p>​    struct _DOUBLE_LINK_NODE* prev;//指向前一个节点</p>
</li>
<li><p>​     struct _DOUBLE_LINK_NODE* next;//指向后一个节点</p>
</li>
<li><p>}DOUBLE_LINK_NODE;</p>
</li>
<li><p>（2）创建双向链表节点</p>
</li>
<li><p>DOUBLE_LINK_NODE*  create_double_link_node(int value) //传入一个值</p>
</li>
<li><p>{</p>
<pre><code>DOUBLE_LINK_NODE* pDLinkNode =  NULL;
pDLinkNode = (DOUBLE_LINK_NODE*)malloc(sizeof(DOUBLE_LINK_NODE));//配值空间</code></pre></li>
<li><p>​    assert(NULL != pDLinkNode);</p>
</li>
<li><p>​       memset(pDLinkNode, 0,  sizeof(DOUBLE_LINK_NODE)); //初始化函数</p>
</li>
<li></li>
<li><p>void *memset(void *s, int ch, size_t n);</p>
</li>
<li><p>函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t  ）用 ch 替换并返回 s 。</p>
</li>
<li></li>
<li><p>​    pDLinkNode-&gt;data =  value;<br>​       return pDLinkNode;<br>   }</p>
</li>
<li><p><strong>（**</strong>3<strong>**）删除双向链表</strong></p>
</li>
<li><p>void  delete_all_double_link_node(DOUBLE_LINK_NODE** pDLinkNode)<br>   {</p>
<pre><code>DOUBLE_LINK_NODE* pNode;
if(NULL == *pDLinkNode)
    return ;</code></pre></li>
<li></li>
<li><p>pNode = *pDLinkNode;</p>
<pre><code>*pDLinkNode = pNode-&gt;next;//下一个节点</code></pre></li>
<li><p>​    free(pNode);</p>
</li>
<li><p>下面是递归调用delete_all_double_link_node（）;一直到把所有节点释放完毕</p>
</li>
<li><p>​     delete_all_double_link_node(pDLinkNode);<br>   }</p>
</li>
<li><p><strong>（**</strong>4<strong>**）在双向链表中查找数据</strong></p>
</li>
<li><p>DOUBLE_LINK_NODE*  find_data_in_double_link(const DOUBLE_LINK_NODE* pDLinkNode, int data)<br>   {</p>
<pre><code>DOUBLE_LINK_NODE* pNode =  NULL;
if(NULL == pDLinkNode)
    return NULL;</code></pre></li>
<li><p>pNode =  (DOUBLE_LINK_NODE*)pDLinkNode;</p>
</li>
<li><p>简单的循环查找数据</p>
</li>
<li><p>​    while(NULL != pNode){<br>​           if(data ==  pNode-&gt;data)<br>​               return pNode;<br>​           pNode = pNode -&gt;next;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>return  NULL;<br>   }</p>
</li>
<li><p><strong>（**</strong>5<strong>**）双向链表中插入数据（相当的不严谨，你是插在前面呢？还是插在后面？）</strong></p>
</li>
<li><p>STATUS  insert_data_into_double_link(DOUBLE_LINK_NODE** ppDLinkNode, int data)<br>   {</p>
<pre><code>DOUBLE_LINK_NODE* pNode;
DOUBLE_LINK_NODE* pIndex;</code></pre></li>
<li><p>if(NULL == ppDLinkNode)</p>
<pre><code>return FALSE;</code></pre></li>
<li><p>整个双向链表中没有数据，插入的是第一个数据</p>
</li>
<li><p>if(NULL == *ppDLinkNode){</p>
<pre><code>    pNode =  create_double_link_node(data);
    assert(NULL != pNode);
    *ppDLinkNode = pNode;
    (*ppDLinkNode)-&gt;prev =  (*ppDLinkNode)-&gt;next = NULL;
    return TRUE;
}</code></pre></li>
<li></li>
<li><p>if(NULL !=  find_data_in_double_link(*ppDLinkNode, data))</p>
<pre><code>return FALSE;</code></pre></li>
<li></li>
<li><p>pNode = create_double_link_node(data);</p>
<pre><code>assert(NULL != pNode);</code></pre></li>
<li><p>pIndex = *ppDLinkNode;</p>
<pre><code>while(NULL !=  pIndex-&gt;next)
pIndex =  pIndex-&gt;next;</code></pre></li>
<li><p>​        pNode-&gt;prev = pIndex;<br>​       pNode-&gt;next =  pIndex-&gt;next;<br>​       pIndex-&gt;next = pNode;<br>​       return TRUE;<br>   }</p>
</li>
<li><p>（<strong>5**</strong>）双向链表中插入数据（自己手写严谨代码明确要求插入在之前好是之后，不是直接乱码七八遭的插入，我<strong><strong>c</strong></strong>你大爷的<strong><strong>C</strong></strong>）**</p>
</li>
<li><p>void  DoubleList::insertNode_before_i(DOUBLE_LINK_NODE*head,int cahdata,int i)</p>
</li>
<li><p>{</p>
</li>
<li><p>if(DOUBLE_LINK_NODE==null)</p>
</li>
<li><p>​    return null; </p>
</li>
<li><p>//因为要插入一个节点，所以需要分配一个节点的空间，这里应该也可以直接使用creat</p>
</li>
<li><p>DOUBLE_LINK_NODE<em>one,</em>two;</p>
</li>
<li><p>one=(DOUBLE_LINK_NODE*)malloc(sizeof(DOUBLE_LINK_NODE));</p>
</li>
<li><p>one-&gt;data=chadata;</p>
</li>
<li><p>//插入的时候考虑到插入的位置，没有节点,，要在头节点插入</p>
</li>
<li><p>if(i==0)</p>
</li>
<li><p>​    {</p>
</li>
<li><p>​      one-&gt;next=head-&gt;next;</p>
</li>
<li><p>​    if(head-&gt;next!=null)</p>
</li>
<li><p>​     head-&gt;next-prev=one;   </p>
</li>
<li><p>else {</p>
</li>
<li><p>​           one-&gt;prev=head;</p>
</li>
<li><p>​           head-&gt;next=one;</p>
</li>
<li><p>​         }   </p>
</li>
<li><p>​     }</p>
</li>
<li><p>//如果此时要插入的并不是第一个，那么需要找到待插入的前一个节点</p>
</li>
<li><p>else{</p>
</li>
<li><p>​       int k=0;</p>
</li>
<li><p>​       two=head-&gt;next;</p>
</li>
<li><p>​      while(k&lt;i-1&amp;&amp;two!=null)</p>
</li>
<li><p>​            {</p>
</li>
<li><p>​               two=two-&gt;next;</p>
</li>
<li><p>​                k++</p>
</li>
<li><p>​               }</p>
</li>
<li><p>​         if(two==null)</p>
</li>
<li><p>​          return false;</p>
</li>
<li><p>​        else{   </p>
</li>
<li><p>​                 if(two-&gt;next!=null){</p>
</li>
<li><p>​                 two-&gt;next-&gt;prve=one;</p>
</li>
<li><p>​                 one-&gt;next=two-&gt;next;</p>
</li>
<li><p>​                 two-&gt;next=one;</p>
</li>
<li><p>​                 one-&gt;prve=two;</p>
</li>
<li><p>​                                          }</p>
</li>
<li><p>​                 else{</p>
</li>
<li><p>​                         two-&gt;next=one;</p>
</li>
<li><p>​                        one-&gt;prve=two;</p>
</li>
<li><p>​                       }</p>
</li>
<li><p>​                }</p>
</li>
<li><p>​             }</p>
</li>
<li></li>
<li><p>}</p>
</li>
<li></li>
<li><p><strong>（**</strong>6<strong><strong>.1</strong></strong>）双向链表中删除数据<strong><strong>(</strong></strong>直接删除的指明的数据<strong>**)</strong></p>
</li>
<li><p>STATUS  delete_data_from_double_link(DOUBLE_LINK_NODE** ppDLinkNode, int data)<br>   {</p>
</li>
<li><p>DOUBLE_LINK_NODE*one; </p>
</li>
<li><p>if(ppDLinkNode==null||*ppDLinkNode==null)</p>
</li>
<li><p>return false;</p>
</li>
<li><p>one=find_dat_in_double_Link(*ppDLinkNode,data);</p>
</li>
<li><p>if(one==null)</p>
</li>
<li><p>{</p>
</li>
<li><p>return false;</p>
</li>
<li><p>cout&lt;&lt;”链表中节点中没有对应的数据”&lt;&lt;endl;</p>
</li>
<li><p>}</p>
</li>
<li></li>
<li><p>if(one==*ppDLinkNode)</p>
</li>
<li><p>​    {</p>
</li>
<li><p>​     if((*ppDLinkNode)-&gt;next==null)</p>
</li>
<li><p>​     *ppDLinkNode=null;</p>
</li>
<li><p>cout&lt;&lt;”我成功的删除的第一个节点，此时链表中没有数据了”</p>
</li>
<li><p>​     else{</p>
</li>
<li><p>​          <em>ppDLinkNode=</em>ppDlinkNode-&gt;nxet;</p>
</li>
<li><p>​            (*ppDlinkNode)-&gt;prve=null;</p>
</li>
<li><p>​       cout&lt;&lt;”成功删除第一个头结点，此时还有数据”;</p>
</li>
<li><p>​       }</p>
</li>
<li><p>​     }</p>
</li>
<li><p>else{</p>
</li>
<li><p>​     if(one-next=null)</p>
</li>
<li><p>​       {</p>
</li>
<li><p>​       one-&gt;prve-&gt;next=null;</p>
</li>
<li><p>​      cout&lt;&lt;”成功删除尾部节点”;</p>
</li>
<li><p>​        }</p>
</li>
<li><p>​      else{</p>
</li>
<li><p>​              one-&gt;prev-&gt;next=one-&gt;next;</p>
</li>
<li><p>​              one-&gt;next-&gt;prve=one-&gt;prev</p>
</li>
<li><p>​            cout&lt;&lt;”成功删除中间节点”;</p>
</li>
<li><p>​            }</p>
</li>
<li><p>​        }</p>
</li>
<li><p>free(one);</p>
</li>
<li><p>​    return ture;</p>
</li>
<li><p>}</p>
</li>
<li><p><strong>（**</strong>6<strong><strong>.2</strong></strong>）双向链表中删除数据<strong><strong>(</strong></strong>直接删除指定节点位置的数据<strong>**)</strong></p>
</li>
<li><p>STATUS  delete_data_from_double_link(DOUBLE_LINK_NODE** ppDLinkNode, int i)</p>
</li>
<li><p>{</p>
</li>
<li><p>DOUBLE_LINK_NODE<em>one,</em>two;</p>
</li>
<li><p>​     if(*ppDLInkNode==null&amp;&amp;ppDLinkNode==null)</p>
</li>
<li><p>​     return false;</p>
</li>
<li><p>​    if(*ppDLinkNode-&gt;next==null)</p>
</li>
<li><p>​    {</p>
</li>
<li><p>​     cout&lt;&lt;”It’s null List!!”;</p>
</li>
<li><p>​    return </p>
</li>
<li><p>​      } </p>
</li>
<li></li>
<li><p>if(i==0)</p>
</li>
<li><p>​     {</p>
</li>
<li><p>​      if((*ppDlinkNode)-&gt;next==null)</p>
</li>
<li><p>​    </p>
</li>
<li><p>​       cout&lt;&lt;”delete the List!and  the List don’t exist any node;”</p>
</li>
<li><p>​     else{</p>
</li>
<li><p>​          one=*ppDLinkNode-&gt;next;</p>
</li>
<li><p>​         *ppDLinkNode=one;</p>
</li>
<li><p>​          one-&gt;prev=Null;</p>
</li>
<li><p>​           cout&lt;&lt;”free the first  node!” </p>
</li>
<li><p>​       }</p>
</li>
<li><p>​        free(*ppDLinkNode); </p>
</li>
<li><p>​     }</p>
</li>
<li><p>else{</p>
</li>
<li><p>int k=0;</p>
</li>
<li><p>two=*ppDlLinkNode-&gt;next;</p>
</li>
<li><p>while(k&lt;i&amp;&amp;two-&gt;next!=null) </p>
</li>
<li><p>​    {</p>
</li>
<li><p>​    two=two-&gt;next;</p>
</li>
<li><p>​    k++;     </p>
</li>
<li><p>​    }</p>
</li>
<li><p>​    if(two-&gt;next-next==null)         </p>
</li>
<li><p>​         two-&gt;next=null;</p>
</li>
<li><p>​         cout&lt;&lt;”free the last  node,and the previous is link to null”;    </p>
</li>
<li><p>​     else{</p>
</li>
<li><p>​       one=two-&gt;next;</p>
</li>
<li><p>​        two-&gt;next=one-&gt;next;</p>
</li>
<li><p>​         one-&gt;next-prev=two;</p>
</li>
<li><p>​          cout&lt;&lt;”free  the node ,normally!”;  </p>
</li>
<li><p>​          }</p>
</li>
<li><p>​      free(two); </p>
</li>
<li><p>​      retuen true;    </p>
</li>
<li><p>​     }</p>
</li>
<li><p>}</p>
</li>
<li><p><strong>（**</strong>7<strong>**）统计双向链表中数据的个数</strong></p>
</li>
<li><p>int  count_number_in_double_link(const DOUBLE_LINK_NODE* pDLinkNode)<br>   {</p>
<pre><code>if(pDLinkNode==null){</code></pre></li>
<li><p>​    cout&lt;&lt;”no List”;</p>
</li>
<li><p>}   </p>
</li>
<li><p>int count = 0;</p>
<pre><code>DOUBLE_LINK_NODE* pNode =  (DOUBLE_LINK_NODE*)pDLinkNode;</code></pre></li>
<li><p>while(NULL  != pNode){</p>
<pre><code>    count ++;
    pNode = pNode-&gt;next;
}
return count;</code></pre><p>   }</p>
</li>
<li><p><strong>（**</strong>8<strong>**）打印双向链表中数据</strong></p>
</li>
<li><p>void  dispaly_ldouble_ink_node(DOUBLE_LINK_NODE* pDLinkNode){</p>
</li>
<li><p>if(pDLinkNode==null)</p>
</li>
<li><p>​    cout&lt;&lt;”no List”;</p>
</li>
<li><p>​    DOUBLE_LINK_NODE* one=pDLinkNode;</p>
</li>
<li><p>​    while(one!=null)</p>
</li>
<li><p>​         {</p>
</li>
<li><p>​    cout&lt;<one->data&lt;&lt;endl;</one-></p>
</li>
<li><p>​     one=one-&gt;next;</p>
</li>
<li><p>​        }</p>
</li>
<li><p>}</p>
<p>   【+|</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/06/指针/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/06/指针/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-06T15:58:44+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C指针"><a href="#C指针" class="headerlink" title="C指针"></a>C指针</h2><h4 id="1、内存、实时内存和虚拟内存"><a href="#1、内存、实时内存和虚拟内存" class="headerlink" title="1、内存、实时内存和虚拟内存"></a>1、内存、实时内存和虚拟内存</h4><h5 id="1-1内存与类型"><a href="#1-1内存与类型" class="headerlink" title="1.1内存与类型"></a>1.1内存与类型</h5><p><strong>类型</strong></p>
<p>寄存器、cache、RAM、辅存</p>
<h5 id="1-2数据与指令"><a href="#1-2数据与指令" class="headerlink" title="1.2数据与指令"></a>1.2数据与指令</h5><p>数据如何传到内存中呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move eax, A</span><br></pre></td></tr></table></figure>

<p> 上面的将A送到exa寄存器里面，CUP把变量A的地址发送到地址总线，查看该数据是否存在L1 cache中，没有则不被命中，如果存在，则被命中。</p>
<p>未被命中时会在下一级内存里面查找 L2 cache。</p>
<h5 id="1-3编译过程"><a href="#1-3编译过程" class="headerlink" title="1.3编译过程"></a>1.3编译过程</h5><p><strong>*<span style="color::red">源代码–预处理–编译–汇编–目标文件–链接–可执行文件</span>*</strong></p>
<h5 id="1-4内存模型"><a href="#1-4内存模型" class="headerlink" title="1.4内存模型"></a>1.4内存模型</h5><p>实地址内存模型</p>
<p>扁平内存模型</p>
<p>分段内存模型</p>
<h5 id="1-5使用分段的内存排列"><a href="#1-5使用分段的内存排列" class="headerlink" title="1.5使用分段的内存排列"></a>1.5使用分段的内存排列</h5><p>分段  源代码被编译后分成5个主要的部分</p>
<p><strong><em>代码–数据–BSS–栈–堆</em></strong></p>
<p>————</p>
<p><strong>代码段</strong></p>
<p><strong>数据段</strong></p>
<p>全局变量和非0值初始变量。静态非配的变量和非0值初始变量。</p>
<p><strong>BSS段</strong></p>
<p>包括所有未初始化的全局变量，以及用static关键字声明且未被初始化的静态局部变量。</p>
<p><strong>栈段</strong></p>
<p>存储局部变量、函数参数、和返回的地址</p>
<p><strong>堆段</strong></p>
<p>创建进程的时候堆区由操作系统分配给每个进程，动态内存从堆中获取。从堆中分配的内存只能通过指针访问。</p>
<h4 id="2、指针基础"><a href="#2、指针基础" class="headerlink" title="2、指针基础"></a>2、指针基础</h4><h5 id="2-1变量的地址"><a href="#2-1变量的地址" class="headerlink" title="2.1变量的地址"></a>2.1变量的地址</h5><p>存放一个变量需要用到地址</p>
<h5 id="2-2地址操作符"><a href="#2-2地址操作符" class="headerlink" title="2.2地址操作符"></a>2.2地址操作符</h5><p>即是取地址操作符</p>
<h5 id="2-3指针的声明"><a href="#2-3指针的声明" class="headerlink" title="2.3指针的声明"></a>2.3指针的声明</h5><p>$$<br>int * intput,char* chatptr<br>$$</p>
<p>$$<br>数据类型* 变量名<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inner_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> in_a;</span><br><span class="line">    <span class="keyword">int</span> in_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ndoe</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    <span class="keyword">int</span> *b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inner_node</span>* <span class="title">in_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-4指针赋值"><a href="#2-4指针赋值" class="headerlink" title="2.4指针赋值"></a>2.4指针赋值</h5><p>两种方法给指针赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 利用取地址符号&amp; 分配变量的地址</span></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr=&amp;x;</span><br><span class="line"><span class="comment">//2 让指针变量指向来自堆的动态分配内存</span></span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*conut);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：操作指针的时候一定注意是在一个有效的内存地址上面，不然会引起分段错误，最后程序崩溃。</p>
<h5 id="2-5指针变量的大小"><a href="#2-5指针变量的大小" class="headerlink" title="2.5指针变量的大小"></a>2.5指针变量的大小</h5><p>32位平台上面，指针的大小为（int  *,char *,float *和void *）4个字节。聚合数据类型的指针变量大小（数组和结构体）也是4字节。</p>
<h5 id="2-6指针解引用"><a href="#2-6指针解引用" class="headerlink" title="2.6指针解引用"></a>2.6指针解引用</h5><p>$$<br>对指针进行取值的操作means指针的解引用(*)<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> X=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr=&amp;x;</span><br></pre></td></tr></table></figure>

<p>对于上面的赋值操作应该有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*ptr==*(&amp;x)==x==<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h5 id="2-7指针的基本用法"><a href="#2-7指针的基本用法" class="headerlink" title="2.7指针的基本用法"></a>2.7指针的基本用法</h5><p>$$<br>指针的优势<br>$$</p>
<p><strong>传值</strong></p>
<p><strong>引用传递</strong></p>
<p>传递值的时候需要赋值一份临时变量</p>
<p>按引用传递则是把整形变量的地址返回给调用者。</p>
<h5 id="2-8指针和常量"><a href="#2-8指针和常量" class="headerlink" title="2.8指针和常量"></a>2.8指针和常量</h5><p><em><em>常量指针变量    *</em><br>$$<br>&lt;指针类型</em>&gt;const&lt;变量名&gt;<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> ptr,<span class="keyword">char</span>*<span class="keyword">const</span> ptr1;</span><br></pre></td></tr></table></figure>

<p>1、常量指针变量声明时必须初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr=&amp;nums;</span><br></pre></td></tr></table></figure>

<p>2、一旦完成初始化，常量指针就不能再指向其他任何内存地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr=&amp;nums;</span><br><span class="line"><span class="keyword">int</span> nums1=<span class="number">20</span>;</span><br><span class="line">ptr=&amp;nums1;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">addr</th>
<th align="center">values</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x123456</td>
<td align="center">nums=10</td>
</tr>
<tr>
<td align="center">0x654321</td>
<td align="center">nums1=20</td>
</tr>
<tr>
<td align="center">0x111112</td>
<td align="center">==<strong>const ptr=0x654321</strong>==</td>
</tr>
</tbody></table>
<p><strong>常量指针</strong></p>
<p>常量指针是指某个指针变量的值不能修改<br>$$<br>const&lt;指针类型*&gt;&lt;变量名&gt;<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * ptr.<span class="keyword">const</span> ;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * ptr;</span><br><span class="line">ptr=&amp;nums;</span><br><span class="line"><span class="comment">//解引用后在给他赋值 因为是const 所以不予许这样做</span></span><br><span class="line">*ptr=<span class="number">20</span>;</span><br><span class="line"><span class="comment">//但是给原来的值从新赋值却是可以的</span></span><br><span class="line">nums=<span class="number">20</span></span><br></pre></td></tr></table></figure>

<h5 id="2-9多级指针"><a href="#2-9多级指针" class="headerlink" title="2.9多级指针"></a>2.9多级指针</h5><p>指针本身也有一个地址，我把这个指针的地址再放到另外一个指针里面去，就是二级指针。但是存储的时候需要一个不同类型的变量去存储。<br>$$<br>&lt;数据类型&gt;**&lt;变量名&gt;<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>；</span><br><span class="line"><span class="keyword">int</span> *ptr=&amp;s;</span><br><span class="line"><span class="keyword">int</span> **ptr1=&amp;ptr;</span><br></pre></td></tr></table></figure>

<h5 id="2-10理解神秘的指针表达式"><a href="#2-10理解神秘的指针表达式" class="headerlink" title="2.10理解神秘的指针表达式"></a>2.10理解神秘的指针表达式</h5><p><strong>一级指针</strong></p>
<p>地址：ptr==&amp;a</p>
<p>求值：*ptr==a</p>
<p><strong>二级指针</strong></p>
<p>地址：*ptr1==ptr= = * (&amp;ptr)= =&amp;a= =0x01010;</p>
<p>求值：**ptr1== *(ptr) = = *( *(&amp;ptr))= =a==10;</p>
<h4 id="3、指针和一维数组"><a href="#3、指针和一维数组" class="headerlink" title="3、指针和一维数组"></a>3、指针和一维数组</h4><h5 id="3-1数组内存排列"><a href="#3-1数组内存排列" class="headerlink" title="3.1数组内存排列"></a>3.1数组内存排列</h5><p>&amp;a[1]-&amp; a[0]=4</p>
<p><strong>字节序</strong></p>
<p> 大端和小端</p>
<p>大端是高字节存储在第一个位置，依次类推。</p>
<p>小端是低字节存储在第一个位置，依次类推。</p>
<h5 id="3-2指针运算"><a href="#3-2指针运算" class="headerlink" title="3.2指针运算"></a>3.2指针运算</h5><p>$$<br>++<br>$$</p>
<h2 id><a href="#" class="headerlink" title="$$"></a>$$</h2><p>$$</p>
<p>$$<br>+<br>$$</p>
<p>$$<br>-<br>$$</p>
<p> 内存中数据的排列是连续的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> * ptr;</span><br><span class="line">ptr=arr;</span><br></pre></td></tr></table></figure>

<p><strong>指针的加法</strong><br>$$<br>ptr=ptr+1<br>$$<br>表示的是下一个数组的元素的内存</p>
<p>在编译器中进行的操作是<br>$$<br>&lt;指针变量&gt;=&lt;指针变量&gt;+&lt;增加值&gt;*&lt;指针变量数据类型大小&gt;<br>$$</p>
<h5 id="3-3数组探究"><a href="#3-3数组探究" class="headerlink" title="3.3数组探究"></a>3.3数组探究</h5><p>数组变量名是等同于指定数组的第0个位置的地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr_var=&amp;arr_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们可以这样子定义</span></span><br><span class="line">arr_var+offset=&amp;arr_var[offset];</span><br><span class="line">和</span><br><span class="line">*arr_var+offset=arr_var[offset];</span><br></pre></td></tr></table></figure>

<p><strong>动态数组的使用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr=(<span class="keyword">int</span>*)mallco(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        ptr[<span class="number">0</span>]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptr=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(ptr,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*count);</span><br><span class="line">        ptr[count]=data;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">while</span>(c!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"insert choice\n"</span>);</span><br><span class="line">        sacnf(<span class="string">"%d"</span>,&amp;c)</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"insrt data"</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line">                insert(data);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span>:<span class="number">2</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"show data"</span>)</span><br><span class="line">                show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指针数组</strong></p>
<p>声明格式<br>$$<br>&lt;数据类型*&gt;&lt;变量名&gt;[数组元素数目]<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *arr_ptr[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>这个数组里面存放的全部都是地址，但是可以通过解引用的方式进行取值操作。</p>
<p><strong>数组指针</strong><br>$$<br>&lt;数据类型&gt;（*&lt;变量名&gt;）[数组元素数目]<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*arr_val)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h4 id="4、指针和字符串"><a href="#4、指针和字符串" class="headerlink" title="4、指针和字符串"></a>4、指针和字符串</h4><h5 id="4-1内存中的字符串排列"><a href="#4-1内存中的字符串排列" class="headerlink" title="4.1内存中的字符串排列"></a>4.1内存中的字符串排列</h5><p>用指针访问字符串的元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str=<span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr=str;</span><br><span class="line">    <span class="keyword">while</span>(*ptr!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%c"</span>,*ptr);</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2动态分配内存"><a href="#4-2动态分配内存" class="headerlink" title="4.2动态分配内存"></a>4.2动态分配内存</h5><p>下面的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *m=foo();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>*str=<span class="string">"STRING"</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码始终可以打印出STRING,char *str是局部变量，但是可以在整个范围内被访问。<br>$$<br>内存是从RO扇区分配的，在整个程序的运行期都是有效的<br>$$</p>
<h5 id="4-4字符串数组"><a href="#4-4字符串数组" class="headerlink" title="4.4字符串数组"></a>4.4字符串数组</h5><p>三种声明的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str_arr[<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* str_arr[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>** str_arr</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/bolgzxy.github.io/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/bolgzxy.github.io/">1</a><a class="page-number" href="/bolgzxy.github.io/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/bolgzxy.github.io/page/4/">4</a><a class="extend next" rel="next" href="/bolgzxy.github.io/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/bolgzxy.github.io/images/user.jpg" alt="半世烟尘">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/bolgzxy.github.io/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/bolgzxy.github.io/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/bolgzxy.github.io/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/COTVZHAOYUEXING" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1998lovexs@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/bolgzxy.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
