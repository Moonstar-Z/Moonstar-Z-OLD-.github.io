<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/bolgzxy.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/bolgzxy.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/bolgzxy.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/bolgzxy.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/bolgzxy.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/bolgzxy.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:type" content="website">
<meta property="og:title" content="し半世烟尘">
<meta property="og:url" content="https://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="し半世烟尘">
<meta name="twitter:description" content="黄沙百战穿金甲，不破楼兰誓不还。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/bolgzxy.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/page/3/">





  <title>し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/bolgzxy.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/bolgzxy.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/bolgzxy.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/bolgzxy.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/bolgzxy.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/remove/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/remove/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的remove删除算法，源码中介绍了函数remove、remove_copy、remove_if、remove_copy_if、unique、unique_copy。并对这些函数的源码进行详细的剖析，并适当给出使用例子，具体详见下面源码剖析。</p>
<h3 id="remove移除算法源码剖析"><a href="#remove移除算法源码剖析" class="headerlink" title="remove移除算法源码剖析"></a>remove移除算法源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove, remove_if, remove_copy, remove_copy_if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除[first,last)区间内所有与value值相等的元素，并不是真正的从容器中删除这些元素(原容器的内容不会改变)</span></span><br><span class="line"><span class="comment">//而是将结果复制到一个以result为起始位置的容器中。新容器可以与原容器重叠</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">remove_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">OutputIter</span> __<span class="title">result</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type, _Tp);</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)<span class="comment">//遍历容器</span></span><br><span class="line">    <span class="keyword">if</span> (!(*__first == __value)) &#123;<span class="comment">//如果不相等</span></span><br><span class="line">      *__result = *__first;<span class="comment">//赋值给新容器</span></span><br><span class="line">      ++__result;<span class="comment">//新容器前进一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除[first,last)区间内被仿函数pred判断为true的元素,并不是真正的从容器中删除这些元素(原容器的内容不会改变)</span></span><br><span class="line"><span class="comment">//而是将结果复制到一个以result为起始位置的容器中。新容器可以与原容器重叠</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">remove_copy_if</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">OutputIter</span> __<span class="title">result</span>, _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">             <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)<span class="comment">//遍历容器</span></span><br><span class="line">    <span class="keyword">if</span> (!__pred(*__first)) &#123;<span class="comment">//若pred判断为false</span></span><br><span class="line">      *__result = *__first;<span class="comment">//赋值给新容器</span></span><br><span class="line">      ++__result;<span class="comment">//新容器前进一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除[first,last)区间内所有与value值相等的元素,该操作不会改变容器大小，只是容器中元素值改变</span></span><br><span class="line"><span class="comment">//即移除之后，重新整理容器的内容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">remove</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type, _Tp);</span><br><span class="line">  __STL_CONVERTIBLE(_Tp, <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __first = find(__first, __last, __value);<span class="comment">//利用顺序查找找出第一个与value相等的元素</span></span><br><span class="line">  _ForwardIter __i = __first;</span><br><span class="line">  <span class="comment">//下面调用remove_copy</span></span><br><span class="line">  <span class="keyword">return</span> __first == __last ? __first </span><br><span class="line">                           : remove_copy(++__i, __last, __first, __value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除[first,last)区间内所有被pred判断为true的元素,该操作不会改变容器大小，只是容器中元素值改变</span></span><br><span class="line"><span class="comment">//即移除之后，重新整理容器的内容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">remove_if</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">               <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __first = find_if(__first, __last, __pred);<span class="comment">//利用顺序查找找出第一个与value相等的元素</span></span><br><span class="line">  _ForwardIter __i = __first;</span><br><span class="line">  <span class="comment">//下面调用remove_copy_if</span></span><br><span class="line">  <span class="keyword">return</span> __first == __last ? __first </span><br><span class="line">                           : remove_copy_if(++__i, __last, __first, __pred);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面四个移除函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::remove</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool IsOdd (int i) &#123; return ((i%2)==1); &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;10,20,31,30,20,11,10,20&#125;;      // 10 20 31 30 20 11 10 20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector (8);</span></span><br><span class="line"><span class="comment">	  std::remove_copy (myints,myints+8,myvector.begin(),20); // 10 31 30 11 10 0 0 0</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "myvector contains:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  // bounds of range:</span></span><br><span class="line"><span class="comment">	  int* pbegin = myints;                          // ^</span></span><br><span class="line"><span class="comment">	  int* pend = myints+sizeof(myints)/sizeof(int); // ^                       ^</span></span><br><span class="line"><span class="comment">	  pend = std::remove (pbegin, pend, 20);         // 10 31 30 11 10 ?  ?  ?</span></span><br><span class="line"><span class="comment">													 // ^              ^</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "range contains:";</span></span><br><span class="line"><span class="comment">	  for (int* p=pbegin; p!=pend; ++p)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *p;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector2 (7);</span></span><br><span class="line"><span class="comment">	  std::remove_copy_if (myints,myints+7,myvector2.begin(),IsOdd);</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "myvector2 contains:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=myvector2.begin(); it!=myvector2.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  pend = std::remove_if (pbegin, pend, IsOdd);   // 10 30 10 ? ? ? ? ?</span></span><br><span class="line"><span class="comment">													 // ^       ^</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "the range contains:";</span></span><br><span class="line"><span class="comment">	  for (int* p=pbegin; p!=pend; ++p)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *p;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	myvector contains: 10 31 30 11 10 0 0 0</span></span><br><span class="line"><span class="comment">	range contains: 10 31 30 11 10</span></span><br><span class="line"><span class="comment">	myvector2 contains: 10 30 10 10 0 0 0</span></span><br><span class="line"><span class="comment">	the range contains: 10 30 10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unique and unique_copy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">OutputIter</span> __<span class="title">result</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  _Tp __value = *__first;</span><br><span class="line">  *__result = __value;</span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)</span><br><span class="line">    <span class="keyword">if</span> (!(__value == *__first)) &#123;</span><br><span class="line">      __value = *__first;</span><br><span class="line">      *++__result = __value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若result类型为output_iterator_tag，则调用该函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                 _<span class="title">OutputIter</span> __<span class="title">result</span>, </span></span><br><span class="line"><span class="class">                                 <span class="title">output_iterator_tag</span>) &#123;</span></span><br><span class="line">		<span class="comment">//判断first的value_type类型，根据不同类型调用不同函数</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若result类型为forward_iterator_tag，则调用该函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">ForwardIter</span> __<span class="title">result</span>, <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  *__result = *__first;<span class="comment">//记录第一个元素</span></span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)<span class="comment">//遍历区间</span></span><br><span class="line">	  <span class="comment">//若不存在相邻重复元素，则继续记录到目标区result</span></span><br><span class="line">    <span class="keyword">if</span> (!(*__result == *__first))</span><br><span class="line">      *++__result = *__first;<span class="comment">//记录元素到目标区</span></span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////unique_copy将区间[first,last)内元素复制到以result开头的区间上，但是如果存在相邻重复元素时，只复制其中第一个元素</span></span><br><span class="line"><span class="comment">//和unique一样，这里也有两个版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)	</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class OutputIterator&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator unique_copy (InputIterator first, InputIterator last,</span></span><br><span class="line"><span class="comment">                              OutputIterator result);</span></span><br><span class="line"><span class="comment">predicate (2)	</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator unique_copy (InputIterator first, InputIterator last,</span></span><br><span class="line"><span class="comment">                              OutputIterator result, BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> <span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">OutputIter</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __result;</span><br><span class="line">  <span class="comment">//根据result迭代器的类型，调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result,</span><br><span class="line">                       __ITERATOR_CATEGORY(__result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">OutputIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  _Tp __value = *__first;</span><br><span class="line">  *__result = __value;</span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)</span><br><span class="line">    <span class="keyword">if</span> (!__binary_pred(__value, *__first)) &#123;</span><br><span class="line">      __value = *__first;</span><br><span class="line">      *++__result = __value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                 _<span class="title">OutputIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                                 _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>,</span></span><br><span class="line"><span class="class">                                 <span class="title">output_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result, __binary_pred,</span><br><span class="line">                       __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">ForwardIter</span> __<span class="title">result</span>, </span></span><br><span class="line"><span class="class">                           _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type);</span><br><span class="line">  *__result = *__first;</span><br><span class="line">  <span class="keyword">while</span> (++__first != __last)</span><br><span class="line">    <span class="keyword">if</span> (!__binary_pred(*__result, *__first)) *++__result = *__first;</span><br><span class="line">  <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">OutputIter</span> <span class="title">unique_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">OutputIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __result;</span><br><span class="line">  <span class="comment">//根据result迭代器的类型，调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(__first, __last, __result, __binary_pred,</span><br><span class="line">                       __ITERATOR_CATEGORY(__result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除区间[first,last)相邻连续重复的元素</span></span><br><span class="line"><span class="comment">//unique有两个版本</span></span><br><span class="line"><span class="comment">//功能：Removes all but the first element from every consecutive group of equivalent elements in the range [first,last).</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一采用operator==	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator unique (ForwardIterator first, ForwardIterator last);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二采用pred操作	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator unique (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                          BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">unique</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  __first = adjacent_find(__first, __last);<span class="comment">//找出第一个相邻元素的起始位置</span></span><br><span class="line">  <span class="keyword">return</span> unique_copy(__first, __last, __first);<span class="comment">//调用unique_copy完成操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">unique</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>, </span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __first = adjacent_find(__first, __last, __binary_pred);<span class="comment">//找出第一个相邻元素的起始位置</span></span><br><span class="line">  <span class="keyword">return</span> unique_copy(__first, __last, __first, __binary_pred);<span class="comment">//调用unique_copy完成操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/RB-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/RB-tree/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>红黑树是平衡二叉搜索树的一种，其通过特定的操作来保持二叉查找树的平衡。首先，我们来复习一下二叉查找树的知识，建议如果对二叉查找树不理解的先去搜一下相关博客来了解一下。</p>
<p>二叉搜索树是指一个空树或者具有以下性质的二叉树：</p>
<ul>
<li>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点</li>
</ul>
<p>我们知道，一颗由n个节点随机构造的二叉搜索树的高度为logn，但是，由于输入值往往不够随机，导致二叉搜索树可能失去平衡，造成搜索效率低下的情况。从而，引出了平衡二叉搜索树的概念。对于“平衡”这个约束不同的结构有不同的规定，如AVL树要求任何节点的两个子树的高度最大差别为1，可谓是高度平衡啊；而红黑树仅仅确保没有一条路径会比其他路径长出两倍，因而达到接近平衡的目的。红黑数不仅是一个平衡二叉搜索树，而且还定义了相当多的约束来确保插入和删除等操作后能达到平衡。</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfyj3b8rj30k607xdg6.jpg" alt="balancedTree"></p>
<p>那么，红黑树究竟是怎么定义，来使得能够达到平衡的目的呢？我们接着看下去。</p>
<h1 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h1><p>红黑树既然属于二叉搜索树的一种，当然需要满足上述二叉搜索树的性质，除此之外，红黑树还为每一个节点增加了一个存储位来表示节点的颜色属性，它可以为red或者black，通过对任何一条从根到叶子节点的路径上每个点进行着色方式的限制，来确保没有一条路径会比其他路径长出两倍，因而达到接近平衡的目的。</p>
<p>那么，红黑树是如何进行着色的呢？下面引出了红黑树的五条性质：</p>
<ul>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
<p>正是这五条性质，使得红黑树的高度能保持在logn，从而达到平衡的目的，进而使得其在查找、插入和删除的时间复杂度最坏为O(logn)，下面就是一棵典型的红黑树。</p>
<p><img src="http://obd5s81mp.bkt.clouddn.com/STLRbtree.png" alt="红黑树"></p>
<blockquote>
<p>注: 因本人能力有限可能无法将红黑树讲得很清楚全面，而且STL红黑树的实现也较为复杂，建议先到下面推荐的几篇博客里去补补知识</p>
<ul>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="noopener">教你初步了解红黑树</a></li>
<li><a href="http://blog.csdn.net/eson_15/article/details/51144079" target="_blank" rel="noopener">【数据结构和算法05】 红-黑树（看完包懂~）</a></li>
<li><a href="http://blog.csdn.net/v_JULY_v/article/details/6124989" target="_blank" rel="noopener">一步一图一代码，一定要让你真正彻底明白红黑树</a></li>
</ul>
</blockquote>
<h1 id="红黑树的节点结构"><a href="#红黑树的节点结构" class="headerlink" title="红黑树的节点结构"></a>红黑树的节点结构</h1><p>红黑树的节点在二叉树的节点结构上增加了颜色属性，而且，为了更好的进行插入和删除操作，进而增加了指向父节点的指针。为了更好的弹性，STL红黑树的节点采用双层设计，将不依赖模板的参数提取出来，作为base结构，然后用带模板的节点结构取继承它。下面是红黑树节点结构的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="keyword">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;  <span class="comment">// 紅色為 0</span></span><br><span class="line"><span class="keyword">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色為 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">  color_type color;	<span class="comment">// 节点颜色</span></span><br><span class="line">  base_ptr parent;	<span class="comment">// 指向父节点</span></span><br><span class="line">  base_ptr left;		<span class="comment">// 指向左子节点</span></span><br><span class="line">  base_ptr right;		<span class="comment">// 指向右子节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一直往左走，就能找到红黑树的最小值节点</span></span><br><span class="line">  <span class="comment">// 二叉搜索树的性质</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 一直往右走，就能找到红黑树的最大值节点</span></span><br><span class="line">  <span class="comment">// 二叉搜索树的性质</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的节点定义，采用双层节点结构</span></span><br><span class="line"><span class="comment">// 基类中不包含模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">rb_tree_node</span> :</span> <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	Value value_field;    <span class="comment">// 節點實值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="红黑树的迭代器"><a href="#红黑树的迭代器" class="headerlink" title="红黑树的迭代器"></a>红黑树的迭代器</h1><p>为了将RBtree实现为一个泛型容器，迭代器的设计很关键。我们要考虑它的型别，以及前进(increment)、后退(devrement)、提领(dereference)和成员访问(member access)等操作。</p>
<p>迭代器和节点一样，采用双层设计，STL红黑树的节点<strong>rb_tree_node继承于</strong>rb_tree_node_base；STL的迭代器结构<strong>rb_tree_iterator继承于</strong>rb_tree_base_iterator，我们可以用一张图来解释这样的设计目的。</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfyhi8o9j30me0cdabl.jpg" alt="STLRbTreeNodeAndIterator"></p>
<p>将这些分开设计，可以保证对节点和迭代器的操作更具有弹性。下面来看迭代器的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_base_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  base_ptr node;	<span class="comment">// 用来连接红黑树的节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找该节点的后继节点上</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>) &#123;	<span class="comment">// 如果存在右子节点</span></span><br><span class="line">      node = node-&gt;right;		<span class="comment">// 直接跳到右子节点上</span></span><br><span class="line">      <span class="keyword">while</span> (node-&gt;left != <span class="number">0</span>) <span class="comment">// 然后一直往左子树走，直到左子树为空</span></span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                    <span class="comment">// 没有右子节点</span></span><br><span class="line">      base_ptr y = node-&gt;parent;    <span class="comment">// 找出父节点</span></span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;right) &#123;    <span class="comment">// 如果该节点一直为它的父节点的右子节点</span></span><br><span class="line">        node = y;                		<span class="comment">// 就一直往上找，直到不为右子节点为止</span></span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;right != y)      <span class="comment">// 若此时该节点不为它的父节点的右子节点</span></span><br><span class="line">        node = y;                <span class="comment">// 此时的父节点即为要找的后继节点</span></span><br><span class="line">                                 <span class="comment">// 否则此时的node即为要找的后继节点，此为特殊情况，如下</span></span><br><span class="line">                                 <span class="comment">// 我们要寻找根节点的下一个节点，而根节点没有右子节点</span></span><br><span class="line">                                 <span class="comment">// 此种情况需要配合rbtree的header节点的特殊设计，后面会讲到</span></span><br><span class="line">    &#125;                        </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找该节点你的前置节点</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;color == __rb_tree_red &amp;&amp; <span class="comment">// 如果此节点是红节点</span></span><br><span class="line">        node-&gt;parent-&gt;parent == node)		<span class="comment">// 且父节点的父节点等于自己</span></span><br><span class="line">      node = node-&gt;right;								<span class="comment">// 则其右子节点即为其前置节点</span></span><br><span class="line">    <span class="comment">// 以上情况发生在node为header时，即node为end()时</span></span><br><span class="line">    <span class="comment">// 注意：header的右子节点为mostright，指向整棵树的max节点，后面会有解释</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>) &#123;					<span class="comment">// 如果存在左子节点</span></span><br><span class="line">      base_ptr y = node-&gt;left;					<span class="comment">// 跳到左子节点上</span></span><br><span class="line">      <span class="keyword">while</span> (y-&gt;right != <span class="number">0</span>)							<span class="comment">// 然后一直往右找，知道右子树为空</span></span><br><span class="line">        y = y-&gt;right;			</span><br><span class="line">      node = y;													<span class="comment">// 则找到前置节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;															<span class="comment">// 如果该节点不存在左子节点</span></span><br><span class="line">      base_ptr y = node-&gt;parent;				<span class="comment">// 跳到它的父节点上</span></span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;left) &#123;					<span class="comment">// 如果它等于它的父子节点的左子节点</span></span><br><span class="line">        node = y;												<span class="comment">// 则一直往上查找</span></span><br><span class="line">        y = y-&gt;parent;									</span><br><span class="line">      &#125;																	<span class="comment">// 直到它不为父节点的左子节点未知</span></span><br><span class="line">      node = y;													<span class="comment">// 此时他的父节点即为要找的前置节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">rb_tree_iterator</span> :</span> <span class="keyword">public</span> __rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 配合迭代器萃取机制的一些声明</span></span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt;     iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, <span class="keyword">const</span> Value&amp;, <span class="keyword">const</span> Value*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Ref, Ptr&gt;   self;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  <span class="comment">// 迭代器的构造函数</span></span><br><span class="line">  __rb_tree_iterator() &#123;&#125;</span><br><span class="line">  __rb_tree_iterator(link_type x) &#123; node = x; &#125;</span><br><span class="line">  __rb_tree_iterator(<span class="keyword">const</span> iterator&amp; it) &#123; node = it.node; &#125;</span><br><span class="line">  <span class="comment">// 提领和成员访问函数，重载了*和-&gt;操作符</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> link_type(node)-&gt;value_field; &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">  <span class="comment">// 前置++和后置++</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123; increment(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    increment();		<span class="comment">// 直接调用increment函数</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前置--和后置--</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123; decrement(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    decrement();		<span class="comment">// 直接调用decrement函数</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述源代码中，一直提到STL RBTree特殊节点header的设计，这个会在RBTree结构中讲到，下面跟着我一起继续往下看吧。</p>
<h1 id="红黑树的数据结构"><a href="#红黑树的数据结构" class="headerlink" title="红黑树的数据结构"></a>红黑树的数据结构</h1><p>有了上面的节点和迭代器设计，就能很好的定义出一颗RBTree了。废话不多说，一步一步来剖析源代码吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;		</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator; <span class="comment">// 专属配置器</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 一些类型声明</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// RB-tree的数据结构</span></span><br><span class="line">  size_type node_count; <span class="comment">// 记录树的节点个数</span></span><br><span class="line">  link_type header;  		<span class="comment">// header节点设计</span></span><br><span class="line">  Compare key_compare;	<span class="comment">// 节点间的键值大小比较准则</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下三个函数用来取得header的成员</span></span><br><span class="line">  <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;parent; &#125;</span><br><span class="line">  <span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;left; &#125;</span><br><span class="line">  <span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;right; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下六个函数用来取得节点的成员</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;value_field; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> KeyOfValue()(value(x)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(x-&gt;color); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下六个函数用来取得节点的成员，由于双层设计，导致这里需要两个定义</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> ((link_type)x)-&gt;value_field; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> KeyOfValue()(value(link_type(x)));&#125; </span><br><span class="line">  <span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(link_type(x)-&gt;color); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求取极大值和极小值，这里直接调用节点结构的函数极可</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (link_type)  __rb_tree_node_base::minimum(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (link_type) __rb_tree_node_base::maximum(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// RBTree的迭代器定义</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, const_reference, const_pointer&gt; </span><br><span class="line">          const_iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;	<span class="comment">// 由于红黑树自带排序功能，所以必须传入一个比较器函数</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> leftmost(); &#125;        <span class="comment">// RBTree的起始节点为左边最小值节点</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> leftmost(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;							<span class="comment">// RBTree的终止节点为右边最大值节点</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;	<span class="comment">// 判断红黑树是否为空	</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;		<span class="comment">// 获取红黑树的节点个数</span></span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>); &#125;	<span class="comment">// 获取红黑树的最大节点个数，</span></span><br><span class="line">																												<span class="comment">// 没有容量的概念，故为sizetype最大值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看到，在RBTree的数据结构中，定义了RBTree节点和迭代器，然后添加了header节点，以及node_count参数，其他都是一下简单的函数声明和类型声明。除此之外，并没有过多的增加东西。这里理解起来还是比较简单，至于header有什么作用，请继续往下看。</p>
<h1 id="红黑树的构造与内存管理"><a href="#红黑树的构造与内存管理" class="headerlink" title="红黑树的构造与内存管理"></a>红黑树的构造与内存管理</h1><h2 id="红黑树的构造函数"><a href="#红黑树的构造函数" class="headerlink" title="红黑树的构造函数"></a>红黑树的构造函数</h2><p>红黑树的空构造函数将创建一个空树，此”空树“非彼二叉树的空树也。空构造函数首先配置一个节点空间，使header指向该节点空间，然后将header的leftmost和rightmost指向自己，父节点指向0。非空的STL RBTree中，header和root之间互为父节点，然后header的leftmost始终指向该树的最小值节点，rightmost始终指向该树的最大值节点，其示例图如下（左图为空树，右图为非空树）：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfynyzckj30ha0acdgd.jpg" alt="STLRBTreeInit"></p>
<p>下面来看看它的构造函数代码吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">	<span class="comment">// 这部分代码是从红黑树的结构定义中提取出来的</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator; <span class="comment">// 专属配置器</span></span><br><span class="line"></span><br><span class="line">  <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rb_tree_node_allocator::allocate(); &#125; <span class="comment">// 配置空间</span></span><br><span class="line"></span><br><span class="line">  <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">    link_type tmp = get_node();            <span class="comment">// 配置空間</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      construct(&amp;tmp-&gt;value_field, x);    <span class="comment">// 构造内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(put_node(tmp));</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化函数，用来初始化一棵RBTree</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = get_node();    <span class="comment">// 产生一个节点空间，令header指向它</span></span><br><span class="line">    color(header) = __rb_tree_red; <span class="comment">// 令header为红色，用来区分header和root</span></span><br><span class="line">    root() = <span class="number">0</span>;</span><br><span class="line">    leftmost() = header;    <span class="comment">// 令header的左子节点为其自己</span></span><br><span class="line">    rightmost() = header;    <span class="comment">// 令header的右子节点为其自己</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 真正的默认构造函数</span></span><br><span class="line">  rb_tree(<span class="keyword">const</span> Compare&amp; comp = Compare())</span><br><span class="line">  : node_count(<span class="number">0</span>), key_compare(comp) &#123; init(); &#125;	<span class="comment">// 直接调用初始化函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 带参构造函数，以另一棵RBTree为初值来初始化</span></span><br><span class="line">  rb_tree(<span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x) </span><br><span class="line">    : node_count(<span class="number">0</span>), key_compare(x.key_compare)</span><br><span class="line">  &#123; </span><br><span class="line">    header = get_node();    <span class="comment">// 產生一個節點空間，令 header 指向它</span></span><br><span class="line">    color(header) = __rb_tree_red;    <span class="comment">// 令 header 為紅色</span></span><br><span class="line">    <span class="keyword">if</span> (x.root() == <span class="number">0</span>) &#123;    <span class="comment">//  如果 x 是個空白樹</span></span><br><span class="line">      root() = <span class="number">0</span>;</span><br><span class="line">      leftmost() = header;     <span class="comment">// 令 header 的左子節點為自己。</span></span><br><span class="line">      rightmost() = header; <span class="comment">// 令 header 的右子節點為自己。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">//  x 不是一個空白樹</span></span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        root() = __copy(x.root(), header);        <span class="comment">//调用copy函数</span></span><br><span class="line">      &#125;</span><br><span class="line">      __STL_UNWIND(put_node(header));</span><br><span class="line">      leftmost() = minimum(root());    <span class="comment">// 令 header 的左子節點為最小節點</span></span><br><span class="line">      rightmost() = maximum(root());    <span class="comment">// 令 header 的右子節點為最大節點</span></span><br><span class="line">    &#125;</span><br><span class="line">    node_count = x.node_count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// copy函数定义如下</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">typename</span> <span class="title">rb_tree</span>&lt;K, V, KeyOfValue, Compare, Alloc&gt;:</span>:link_type </span><br><span class="line">	rb_tree&lt;K, V, KeyOfValue, Compare, Alloc&gt;::__copy(link_type x, link_type p) &#123;</span><br><span class="line">	  link_type top = clone_node(x); <span class="comment">// 克隆root节点</span></span><br><span class="line">	  top-&gt;parent = p;	<span class="comment">// 将root节点父节点指向p</span></span><br><span class="line">	 	<span class="comment">// 以下为非递归的二叉树复制过程</span></span><br><span class="line">	  __STL_TRY &#123;</span><br><span class="line">	    <span class="keyword">if</span> (x-&gt;right)</span><br><span class="line">	      top-&gt;right = __copy(right(x), top); <span class="comment">// 一直copy右子节点</span></span><br><span class="line">	    p = top;	</span><br><span class="line">	    x = left(x);	<span class="comment">// 取左节点</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;	<span class="comment">// 左子节点不为空</span></span><br><span class="line">	      link_type y = clone_node(x);	<span class="comment">// 克隆左子节点</span></span><br><span class="line">	      p-&gt;left = y;	<span class="comment">// p的左子节点设为y</span></span><br><span class="line">	      y-&gt;parent = p;	<span class="comment">// y的父节点设为p</span></span><br><span class="line">	      <span class="keyword">if</span> (x-&gt;right)		<span class="comment">// 如果左子节点还有右子节点，继续复制</span></span><br><span class="line">	        y-&gt;right = __copy(right(x), y);</span><br><span class="line">	      p = y;	<span class="comment">// 直到没有左子节点</span></span><br><span class="line">	      x = left(x);</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	  __STL_UNWIND(__erase(top));</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">return</span> top;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// clone一个节点函数</span></span><br><span class="line">  <span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span> </span>&#123;    <span class="comment">// 複製一個節點（的值和色）</span></span><br><span class="line">	  link_type tmp = create_node(x-&gt;value_field);</span><br><span class="line">	  tmp-&gt;color = x-&gt;color;</span><br><span class="line">	  tmp-&gt;left = <span class="number">0</span>;</span><br><span class="line">	  tmp-&gt;right = <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="红黑树的析构函数"><a href="#红黑树的析构函数" class="headerlink" title="红黑树的析构函数"></a>红黑树的析构函数</h2><p>析构函数负责清除和释放红黑树上的每一个节点，并且初始化该红黑树为空树，即恢复header为初始状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">	<span class="comment">// 这部分代码是从红黑树的结构定义中提取出来的</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; rb_tree_node_allocator::deallocate(p); &#125;</span><br><span class="line">	<span class="comment">// 析构一个节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">    destroy(&amp;p-&gt;value_field);        <span class="comment">// 析构内容</span></span><br><span class="line">    put_node(p);                    <span class="comment">// 释放空间 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~rb_tree() &#123;</span><br><span class="line">    clear();</span><br><span class="line">    put_node(header);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清除整棵树并初始化header节点</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">      __erase(root());</span><br><span class="line">      <span class="comment">// 初始化Header节点</span></span><br><span class="line">      leftmost() = header;</span><br><span class="line">      root() = <span class="number">0</span>;</span><br><span class="line">      rightmost() = header;</span><br><span class="line">      node_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清除RBTree的每个节点</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">void</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:__erase(link_type x) &#123;</span><br><span class="line">	  <span class="comment">// 直接清，不用调平衡</span></span><br><span class="line">	  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">	    __erase(right(x));</span><br><span class="line">	    link_type y = left(x);</span><br><span class="line">	    destroy_node(x);</span><br><span class="line">	    x = y;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h1><p>红黑树在插入节点的时候，会破坏其平衡，这时候需要旋转和变色来使红黑树重新达到平衡。这才是红黑树的精髓所在啊！所以这部分很长，大家耐心看，最好拿纸笔画一下。</p>
<h2 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h2><p>我们先来看看平衡二叉树的旋转问题。平衡二叉树中，插入一个节点后，有可能会破坏二叉树的平衡，这时候可以通过左旋和右旋函数来使其重新恢复平衡。</p>
<p>通常破坏平衡二叉树平衡的插入情况有如下四种：</p>
<ul>
<li>插入点位于X节点的左子节点的左子树，左左</li>
<li>插入点位于X节点的右子节点的右子树，右右</li>
<li>插入点位于X节点的左子节点的右子树，左右</li>
<li>插入点位于X节点的右子节点的左子树，右左</li>
</ul>
<p>其中，情况1和2彼此对称，称为外侧插入，可以采用单旋转操作来调整；情况3和4彼此对称，称为内侧插入，需要采用双旋转操作来调整。</p>
<h3 id="外侧插入"><a href="#外侧插入" class="headerlink" title="外侧插入"></a>外侧插入</h3><p>对于外侧插入，我们通常采用一次旋转就能解决问题，请看下面两种外侧插入的示意图，其中左图对应上述情况1，右图对应上述情况2。</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfykuu26j30l009baan.jpg" alt="AVLTreeOutSideInsert"></p>
<p>对于左图的情况，采用一次右旋操作，可以使二叉树重新恢复平衡，操作示意图如下所示：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfyjxqufj30li09n0t9.jpg" alt="AVLTreeRightRotate"></p>
<p>对于右图的情况，采用一次左旋操作，可以使二叉树重新恢复平衡，操作示意图如下所示：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfyr8ogqj30kt09474r.jpg" alt="AVLTreeLeftRotate"></p>
<h3 id="内侧插入"><a href="#内侧插入" class="headerlink" title="内侧插入"></a>内侧插入</h3><p>对于内侧插入，通常比较复杂，需要采用两次旋转操作来调整平衡。请看下面的内侧插入的示意图，其中左图对于上述情况3，右图对应上述情况4。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfylqfcnj30su08qwfc.jpg" alt="AVLTreeInsideInsert"></p>
<p>对于左图的情况，需要先进行依次左旋操作，再进行一次右旋操作即可调整平衡，操作示意图如下：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfylqfcnj30su08qwfc.jpg" alt="AVLTreeTwoRatate"></p>
<p>对于右图的情况，需要先进行依次右旋操作，再进行一次左旋操作即可调整平衡，操作示意图如下：</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfyql0n5j30sr093756.jpg" alt="AVLTreeTwoRatate2"></p>
<h2 id="红黑树的插入-1"><a href="#红黑树的插入-1" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h2><p>有了上面的单旋转和双旋转知识，应该就很好理解红黑数的平衡调整过程。红黑树在插入节点的时候，不仅需要考虑插入导致的不平衡，还要考虑颜色属性是否满足其性质要求。为了更清楚的表达整个过程，我们先来定义一下几个标示量，使用X来表示一个新插入的节点，使用P来表示新插入节点的父节点，使用U来表示P节点的兄弟节点，使用G来表示P节点的父亲节点，使用N代表NIL节点。于是，可以将插入情况分为一下几类：</p>
<h3 id="树为空"><a href="#树为空" class="headerlink" title="树为空"></a>树为空</h3><p>新插入的节点为红色，因为此时树为空，那么插入该节点后只需要把节点颜色调整为黑色即可。</p>
<h3 id="父节点为黑"><a href="#父节点为黑" class="headerlink" title="父节点为黑"></a>父节点为黑</h3><p>如果插入的节点的父节点为黑色，那么插入一个红节点将不会影响树的平衡，直接插入即可。这里就体现了黑红树的优势，O(1)时间内就能判断是否破坏了平衡，如果这里是AVL树的话就需要进行一次O(logn)判断是否平衡。</p>
<h3 id="父节点为红色"><a href="#父节点为红色" class="headerlink" title="父节点为红色"></a>父节点为红色</h3><p>当父节点为红色的时候，就不满足条件4，即父节点为红色的时候，子节点必须为黑色，而新加入的节点为红色。这个时候需要考虑如下两种情况</p>
<h4 id="1）叔父节点为红色"><a href="#1）叔父节点为红色" class="headerlink" title="1）叔父节点为红色"></a>1）叔父节点为红色</h4><p>这种情况下，需要将父节点和叔父节点变为黑色，将祖父节点变为红色即可，不过如果祖父节点为红色的话，还是违反了红黑树的性质，此时必须执行一个继续向上迭代的程序来对红黑树的颜色进行调整，最后需要将根节点设置为黑色，如下图所示：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfys6slgj30ob07kwfa.jpg" alt="RBTreeInsert1"></p>
<h4 id="2）叔父节点为黑色-Nil节点为黑"><a href="#2）叔父节点为黑色-Nil节点为黑" class="headerlink" title="2）叔父节点为黑色(Nil节点为黑)"></a>2）叔父节点为黑色(Nil节点为黑)</h4><p>这时候，需要对其进行旋转操作，和上面AVL树的旋转一样，分为4种情况，下面一一举例来说明这四种情况：</p>
<ul>
<li>左左，外侧插入</li>
</ul>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfyphkp5j30iz07a74u.jpg" alt="RBTreeInsert2"></p>
<ul>
<li>左右，内侧插入</li>
</ul>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfyi70nej30q306uaax.jpg" alt="RBTreeInsert3"></p>
<ul>
<li>右左，内侧插入</li>
</ul>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfymw4rxj30ps07iq3t.jpg" alt="RBTreeInsert4"></p>
<ul>
<li>右右，外侧插入</li>
</ul>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfysv1zbj30gh06zdgd.jpg" alt="RBTreeInsert5"></p>
<h2 id="红黑树的插入源代码分析"><a href="#红黑树的插入源代码分析" class="headerlink" title="红黑树的插入源代码分析"></a>红黑树的插入源代码分析</h2><p>红黑树的插入主要靠以下三个函数来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__rb_tree_rotate_left(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line"><span class="comment">// 右旋函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__rb_tree_rotate_right(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line"><span class="comment">// 插入后调节平衡函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line"><span class="comment">// 插入的核心函数</span></span><br><span class="line">iterator __insert(base_ptr x, base_ptr y, <span class="keyword">const</span> value_type&amp; v);</span><br></pre></td></tr></table></figure>

<p>上述三个函数就代表了上一小节示例图中的左旋，右旋和变色的源代码接口。</p>
<p>另外，STL还提供了两个个接口函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许出现相同的值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"><span class="comment">// 不允许出现相同的值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert_unique</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面就针对这五个函数一一来分析一下他们的源代码(以insert_unique为例)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此插入函数不允许重复</span></span><br><span class="line"><span class="comment">// 返回的是一个pair，第一个元素为红黑树的迭代器，指向新增节点</span></span><br><span class="line"><span class="comment">// 第二个元素表示插入操作是否成功的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span> , <span class="title">class</span> <span class="title">Value</span> , <span class="title">class</span> <span class="title">KeyOfValue</span> , <span class="title">class</span> <span class="title">Compare</span> , <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;typename rb_tree&lt;Key , Value , KeyOfValue , Compare , Alloc&gt;::iterator , bool&gt;  </span></span><br><span class="line"><span class="class"><span class="title">rb_tree</span>&lt;Key , Value , KeyOfValue , Compare , Alloc&gt;:</span>:insert_unique(<span class="keyword">const</span> Value &amp;v)  </span><br><span class="line">&#123;  </span><br><span class="line">    rb_tree_node* y = header;    <span class="comment">// 根节点root的父节点  </span></span><br><span class="line">    rb_tree_node* x = root();    <span class="comment">// 从根节点开始  </span></span><br><span class="line">    <span class="keyword">bool</span> comp = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        y = x;  </span><br><span class="line">        comp = key_compare(KeyOfValue()(v) , key(x));    <span class="comment">// v键值小于目前节点之键值？  </span></span><br><span class="line">        x = comp ? left(x) : right(x);   <span class="comment">// 遇“大”则往左，遇“小于或等于”则往右  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 离开while循环之后，y所指即插入点之父节点（此时的它必为叶节点）  </span></span><br><span class="line">    iterator j = iterator(y);     <span class="comment">// 令迭代器j指向插入点之父节点y  </span></span><br><span class="line">    <span class="keyword">if</span>(comp)     <span class="comment">// 如果离开while循环时comp为真（表示遇“大”，将插入于左侧）  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(j == begin())    <span class="comment">// 如果插入点之父节点为最左节点  </span></span><br><span class="line">            <span class="keyword">return</span> pair&lt;iterator , <span class="keyword">bool</span>&gt;(_insert(x , y , z) , <span class="literal">true</span>);<span class="comment">// 调用_insert函数</span></span><br><span class="line">        <span class="keyword">else</span>     <span class="comment">// 否则（插入点之父节点不为最左节点）  </span></span><br><span class="line">            --j;   <span class="comment">// 调整j，回头准备测试  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(key_compare(key(j.node) , KeyOfValue()(v) ))  </span><br><span class="line">        <span class="comment">// 新键值不与既有节点之键值重复，于是以下执行安插操作  </span></span><br><span class="line">        <span class="keyword">return</span> pair&lt;iterator , <span class="keyword">bool</span>&gt;(_insert(x , y , z) , <span class="literal">true</span>);  </span><br><span class="line">    <span class="comment">// 以上，x为新值插入点，y为插入点之父节点，v为新值  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 进行至此，表示新值一定与树中键值重复，那么就不应该插入新值  </span></span><br><span class="line">    <span class="keyword">return</span> pair&lt;iterator , <span class="keyword">bool</span>&gt;(j , <span class="literal">false</span>);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正地插入执行程序 _insert()  </span></span><br><span class="line"><span class="comment">// 返回新插入节点的迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span> , <span class="title">class</span> <span class="title">Value</span> , <span class="title">class</span> <span class="title">KeyOfValue</span> , <span class="title">class</span> <span class="title">Compare</span> , <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">typename</span>&lt;Key , Value , KeyOfValue , Compare , Alloc&gt;:</span>:_insert(base_ptr x_ , base_ptr y_ , <span class="keyword">const</span> Value &amp;v)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 参数x_ 为新值插入点，参数y_为插入点之父节点，参数v为新值  </span></span><br><span class="line">    link_type x = (link_type) x_;  </span><br><span class="line">    link_type y = (link_type) y_;  </span><br><span class="line">    link_type z;  </span><br><span class="line">    <span class="comment">// key_compare 是键值大小比较准则。应该会是个function object  </span></span><br><span class="line">    <span class="keyword">if</span>(y == header || x != <span class="number">0</span> || key_compare(KeyOfValue()(v) , key(y) ))  </span><br><span class="line">    &#123;  </span><br><span class="line">        z = create_node(v);    <span class="comment">// 产生一个新节点  </span></span><br><span class="line">        left(y) = z;           <span class="comment">// 这使得当y即为header时，leftmost() = z  </span></span><br><span class="line">        <span class="keyword">if</span>(y == header)  </span><br><span class="line">        &#123;  </span><br><span class="line">            root() = z;  </span><br><span class="line">            rightmost() = z;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y == leftmost())     <span class="comment">// 如果y为最左节点  </span></span><br><span class="line">            leftmost() = z;          <span class="comment">// 维护leftmost()，使它永远指向最左节点  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        z = create_node(v);        <span class="comment">// 产生一个新节点  </span></span><br><span class="line">        right(y) = z;              <span class="comment">// 令新节点成为插入点之父节点y的右子节点  </span></span><br><span class="line">        <span class="keyword">if</span>(y == rightmost())  </span><br><span class="line">            rightmost() = z;       <span class="comment">// 维护rightmost()，使它永远指向最右节点  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    parent(z) = y;      <span class="comment">// 设定新节点的父节点  </span></span><br><span class="line">    left(z) = <span class="number">0</span>;        <span class="comment">// 设定新节点的左子节点  </span></span><br><span class="line">    right(z) = <span class="number">0</span>;       <span class="comment">// 设定新节点的右子节点  </span></span><br><span class="line">    <span class="comment">// 新节点的颜色将在_rb_tree_rebalance()设定（并调整）  </span></span><br><span class="line">    _rb_tree_rebalance(z , header-&gt;parent);      <span class="comment">// 参数一为新增节点，参数二为根节点root  </span></span><br><span class="line">    ++node_count;       <span class="comment">// 节点数累加  </span></span><br><span class="line">    <span class="keyword">return</span> iterator(z);  <span class="comment">// 返回一个迭代器，指向新增节点  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数  </span></span><br><span class="line"><span class="comment">// 重新令树形平衡（改变颜色及旋转树形）  </span></span><br><span class="line"><span class="comment">// 参数一为新增节点，参数二为根节点root  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _rb_tree_rebalance(_rb_tree_node_base* x , _rb_tree_node_base*&amp; root)  </span><br><span class="line">&#123;  </span><br><span class="line">    x-&gt;color = _rb_tree_red;    <span class="comment">//新节点必为红  </span></span><br><span class="line">    <span class="keyword">while</span>(x != root &amp;&amp; x-&gt;parent-&gt;color == _rb_tree_red)    <span class="comment">// 父节点为红  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left)      <span class="comment">// 父节点为祖父节点之左子节点  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            _rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;right;    <span class="comment">// 令y为伯父节点  </span></span><br><span class="line">            <span class="keyword">if</span>(y &amp;&amp; y-&gt;color == _rb_tree_red)    <span class="comment">// 伯父节点存在，且为红  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;           <span class="comment">// 更改父节点为黑色  </span></span><br><span class="line">                y-&gt;color = _rb_tree_black;                   <span class="comment">// 更改伯父节点为黑色  </span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;     <span class="comment">// 更改祖父节点为红色  </span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 无伯父节点，或伯父节点为黑色  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(x == x-&gt;parent-&gt;right)   <span class="comment">// 如果新节点为父节点之右子节点  </span></span><br><span class="line">                &#123;  </span><br><span class="line">                    x = x-&gt;parent;  </span><br><span class="line">                    _rb_tree_rotate_left(x , root);    <span class="comment">// 第一个参数为左旋点  </span></span><br><span class="line">                &#125;  </span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;     <span class="comment">// 改变颜色  </span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;  </span><br><span class="line">                _rb_tree_rotate_right(x-&gt;parent-&gt;parent , root);    <span class="comment">// 第一个参数为右旋点  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>          <span class="comment">// 父节点为祖父节点之右子节点  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            _rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left;    <span class="comment">// 令y为伯父节点  </span></span><br><span class="line">            <span class="keyword">if</span>(y &amp;&amp; y-&gt;color == _rb_tree_red)    <span class="comment">// 有伯父节点，且为红  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;           <span class="comment">// 更改父节点为黑色  </span></span><br><span class="line">                y-&gt;color = _rb_tree_black;                   <span class="comment">// 更改伯父节点为黑色  </span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;     <span class="comment">// 更改祖父节点为红色  </span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;          <span class="comment">// 准备继续往上层检查  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 无伯父节点，或伯父节点为黑色  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)        <span class="comment">// 如果新节点为父节点之左子节点  </span></span><br><span class="line">                &#123;  </span><br><span class="line">                    x = x-&gt;parent;  </span><br><span class="line">                    _rb_tree_rotate_right(x , root);    <span class="comment">// 第一个参数为右旋点  </span></span><br><span class="line">                &#125;  </span><br><span class="line">                x-&gt;parent-&gt;color = _rb_tree_black;     <span class="comment">// 改变颜色  </span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = _rb_tree_red;  </span><br><span class="line">                _rb_tree_rotate_left(x-&gt;parent-&gt;parent , root);    <span class="comment">// 第一个参数为左旋点  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="comment">//while  </span></span><br><span class="line">    root-&gt;color = _rb_tree_black;    <span class="comment">// 根节点永远为黑色  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 左旋函数  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _rb_tree_rotate_left(_rb_tree_node_base* x , _rb_tree_node_base*&amp; root)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// x 为旋转点  </span></span><br><span class="line">    _rb_tree_node_base* y = x-&gt;right;          <span class="comment">// 令y为旋转点的右子节点  </span></span><br><span class="line">    x-&gt;right = y-&gt;left;  </span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left != <span class="number">0</span>)  </span><br><span class="line">        y-&gt;left-&gt;parent = x;           <span class="comment">// 别忘了回马枪设定父节点  </span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 令y完全顶替x的地位（必须将x对其父节点的关系完全接收过来）  </span></span><br><span class="line">    <span class="keyword">if</span>(x == root)    <span class="comment">// x为根节点  </span></span><br><span class="line">        root = y;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)         <span class="comment">// x为其父节点的左子节点  </span></span><br><span class="line">        x-&gt;parent-&gt;left = y;  </span><br><span class="line">    <span class="keyword">else</span>                                  <span class="comment">// x为其父节点的右子节点  </span></span><br><span class="line">        x-&gt;parent-&gt;right = y;  </span><br><span class="line">    y-&gt;left = x;  </span><br><span class="line">    x-&gt;parent = y;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 右旋函数  </span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _rb_tree_rotate_right(_rb_tree_node_base* x , _rb_tree_node_base*&amp; root)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// x 为旋转点  </span></span><br><span class="line">    _rb_tree_node_base* y = x-&gt;left;          <span class="comment">// 令y为旋转点的左子节点  </span></span><br><span class="line">    x-&gt;left = y-&gt;right;  </span><br><span class="line">    <span class="keyword">if</span>(y-&gt;right != <span class="number">0</span>)  </span><br><span class="line">        y-&gt;right-&gt;parent = x;           <span class="comment">// 别忘了回马枪设定父节点  </span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 令y完全顶替x的地位（必须将x对其父节点的关系完全接收过来）  </span></span><br><span class="line">    <span class="keyword">if</span>(x == root)  </span><br><span class="line">        root = y;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;right)         <span class="comment">// x为其父节点的右子节点  </span></span><br><span class="line">        x-&gt;parent-&gt;right = y;  </span><br><span class="line">    <span class="keyword">else</span>                                  <span class="comment">// x为其父节点的左子节点  </span></span><br><span class="line">        x-&gt;parent-&gt;left = y;  </span><br><span class="line">    y-&gt;right = x;  </span><br><span class="line">    x-&gt;parent = y;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h1><p>红黑树在删除节点后，需要调整以使得红黑树保持平衡，由于删除后调节平衡实在太复杂，本文就不做分析，只提供其接口函数。</p>
<p>如果对其感兴趣的话，可以参考一下这篇博文：<a href="https://www.cnblogs.com/deliver/p/5392768.html" target="_blank" rel="noopener">(图解）红黑树的插入和删除</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点后调节平衡</span></span><br><span class="line"><span class="keyword">inline</span> __rb_tree_node_base*</span><br><span class="line">__rb_tree_rebalance_for_erase(__rb_tree_node_base* z,</span><br><span class="line">                              __rb_tree_node_base*&amp; root,</span><br><span class="line">                              __rb_tree_node_base*&amp; leftmost,</span><br><span class="line">                              __rb_tree_node_base*&amp; rightmost);</span><br></pre></td></tr></table></figure>

<p>STL为红黑树提供了以下删除操作的节点函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>;</span><br><span class="line"><span class="comment">// 删除迭代器区间位置内的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line"><span class="comment">// 清除所有的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面来看看它们的源码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span></span></span><br><span class="line"><span class="class"><span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:erase(iterator position) &#123;</span><br><span class="line">  <span class="comment">// 删除节点后需要使其重新恢复平衡</span></span><br><span class="line">  link_type y = (link_type) __rb_tree_rebalance_for_erase(position.node,</span><br><span class="line">                                                          header-&gt;parent,</span><br><span class="line">                                                          header-&gt;left,</span><br><span class="line">                                                          header-&gt;right);</span><br><span class="line">  <span class="comment">// 清除掉被删除的节点，释放内存</span></span><br><span class="line">  destroy_node(y);</span><br><span class="line">  --node_count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清除掉区间内的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:erase(iterator first, </span><br><span class="line">                                                            iterator last) &#123;</span><br><span class="line">  <span class="keyword">if</span> (first == begin() &amp;&amp; last == end())</span><br><span class="line">    clear();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) erase(first++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清除所有的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里不需要调用上面的__rb_tree_rebalance_for_erase</span></span><br><span class="line">    <span class="comment">// 而是直接调用不需要调节平衡的删除节点函数，见下面</span></span><br><span class="line">    __erase(root()); </span><br><span class="line">    leftmost() = header;</span><br><span class="line">    root() = <span class="number">0</span>;</span><br><span class="line">    rightmost() = header;</span><br><span class="line">    node_count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 删除红黑树的节点，删除过程中不需要调节平衡</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:__erase(link_type x) &#123;</span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">    __erase(right(x));</span><br><span class="line">    link_type y = left(x);</span><br><span class="line">    destroy_node(x);</span><br><span class="line">    x = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="红黑树的元素搜寻"><a href="#红黑树的元素搜寻" class="headerlink" title="红黑树的元素搜寻"></a>红黑树的元素搜寻</h1><p>find函数用于查找是否存在键值为k的节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找RBTree中是否存在键值为k的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:iterator </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::find(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  link_type y = header;        <span class="comment">// Last node which is not less than k. </span></span><br><span class="line">  link_type x = root();        <span class="comment">// Current node. </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) </span><br><span class="line">    <span class="comment">// key_compare是节点键值大小比较函数</span></span><br><span class="line">    <span class="keyword">if</span> (!key_compare(key(x), k)) </span><br><span class="line">      <span class="comment">// 如果节点x的键值大于k，则继续往左子树查找</span></span><br><span class="line">      y = x, x = left(x);    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 如果节点x的键值小于k，则继续往右子树查找</span></span><br><span class="line">      x = right(x);</span><br><span class="line">  iterator j = iterator(y); </span><br><span class="line">  <span class="comment">// y的键值不小于k，返回的时候需要判断与k是相等还是小于  </span></span><br><span class="line">  <span class="keyword">return</span> (j == end() || key_compare(k, key(j.node))) ? end() : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，STL的红黑树还针对multiset和multimap提供了几个搜寻函数，分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算键值为x的节点的个数</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 提供了查询与某个键值相等的节点迭代器范围</span></span></span><br><span class="line">pair&lt;iterator,iterator&gt; equal_range(const key_type&amp; x);</span><br><span class="line"><span class="comment">//返回不小于k的第一个节点迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line"><span class="comment">//返回大于k的第一个节点迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其实现函数也一并贴出来，让大家好理解一下吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算RBTree的节点值为k的节点个数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:size_type </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::count(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  pair&lt;const_iterator, const_iterator&gt; p = equal_range(k);</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line">  distance(p.first, p.second, n);</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询与键值k相等的节点迭代器范围</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;typename rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator,</span></span><br><span class="line"><span class="class">            typename rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator&gt;</span></span><br><span class="line"><span class="class"><span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:equal_range(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator, iterator&gt;(lower_bound(k), upper_bound(k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回不小于k的第一个节点迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:iterator </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::lower_bound(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  link_type y = header; <span class="comment">/* Last node which is not less than k. */</span></span><br><span class="line">  link_type x = root(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">if</span> (!key_compare(key(x), k))</span><br><span class="line">      y = x, x = left(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      x = right(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> iterator(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回大于k的第一个节点迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:iterator </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::upper_bound(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  link_type y = header; <span class="comment">/* Last node which is greater than k. */</span></span><br><span class="line">  link_type x = root(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (x != <span class="number">0</span>) </span><br><span class="line">     <span class="keyword">if</span> (key_compare(k, key(x)))</span><br><span class="line">       y = x, x = left(x);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       x = right(x);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> iterator(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/Permutation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/Permutation/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文讲解的是STL算法中的permutation排列组合算法，根据输入序列，排列出下一个排列组合或前一个排列组合。</p>
<h3 id="permutation排列组合源码剖析"><a href="#permutation排列组合源码剖析" class="headerlink" title="permutation排列组合源码剖析"></a>permutation排列组合源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next_permutation and prev_permutation, with and without an explicitly </span></span><br><span class="line"><span class="comment">// supplied comparison function.</span></span><br><span class="line"><span class="comment">//next_permutation获取[first,last)区间所标示序列的下一个排列组合，若果没有下一个排序组合，则返回false;否则返回true;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last) into the next lexicographically greater permutation.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用less-than操作符</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator&gt;</span></span><br><span class="line"><span class="comment">	bool next_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp决定</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	bool next_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">next_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//若为空，则返回false</span></span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)<span class="comment">//区间只有一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//若区间元素个数不小于两个</span></span><br><span class="line">  __i = __last;<span class="comment">//i指向尾端</span></span><br><span class="line">  --__i;<span class="comment">//不断后移</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">	  <span class="comment">//下面两行是让ii和i成为相邻的元素</span></span><br><span class="line">	  <span class="comment">//其中i为第一个元素，ii为第二个元素</span></span><br><span class="line">    _BidirectionalIter __ii = __i;<span class="comment">//</span></span><br><span class="line">    --__i;</span><br><span class="line">	<span class="comment">//以下在相邻元素判断</span></span><br><span class="line">    <span class="keyword">if</span> (*__i &lt; *__ii) &#123;<span class="comment">//若前一个元素小于后一个元素，</span></span><br><span class="line">		<span class="comment">//则再从最尾端开始往前检查，找出第一个大于*i的元素，令该元素为*j，将*i和*j交换</span></span><br><span class="line">		<span class="comment">//再将ii之后的所有元素颠倒排序</span></span><br><span class="line">      _BidirectionalIter __j = __last;<span class="comment">//令j指向最尾端</span></span><br><span class="line">      <span class="keyword">while</span> (!(*__i &lt; *--__j))<span class="comment">//由尾端往前检查，直到遇到比*i大的元素</span></span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j);<span class="comment">//交换迭代器i和迭代器j所指的元素</span></span><br><span class="line">      reverse(__ii, __last);<span class="comment">//将ii之后的元素全部逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;<span class="comment">//进行到最前面</span></span><br><span class="line">      reverse(__first, __last);<span class="comment">//整个区间全部逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">next_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  __i = __last;</span><br><span class="line">  --__i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    _BidirectionalIter __ii = __i;</span><br><span class="line">    --__i;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__i, *__ii)) &#123;</span><br><span class="line">      _BidirectionalIter __j = __last;</span><br><span class="line">      <span class="keyword">while</span> (!__comp(*__i, *--__j))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j);</span><br><span class="line">      reverse(__ii, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;</span><br><span class="line">      reverse(__first, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//next_permutation函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::next_permutation, std::sort</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;1,2,3,4&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (myints,myints+4);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The 3! possible permutations with 3 elements:\n";</span></span><br><span class="line"><span class="comment">	  do &#123;</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt;' ' &lt;&lt; myints[3]&lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  &#125; while ( std::next_permutation(myints,myints+4) );</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">	  //std::next_permutation(myints,myints+4);</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "After loop: " &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt; ' ' &lt;&lt; myints[3]&lt;&lt;'\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The 3! possible permutations with 3 elements:</span></span><br><span class="line"><span class="comment">	1 2 3 4</span></span><br><span class="line"><span class="comment">	1 2 4 3</span></span><br><span class="line"><span class="comment">	1 3 2 4</span></span><br><span class="line"><span class="comment">	1 3 4 2</span></span><br><span class="line"><span class="comment">	1 4 2 3</span></span><br><span class="line"><span class="comment">	1 4 3 2</span></span><br><span class="line"><span class="comment">	2 1 3 4</span></span><br><span class="line"><span class="comment">	2 1 4 3</span></span><br><span class="line"><span class="comment">	2 3 1 4</span></span><br><span class="line"><span class="comment">	2 3 4 1</span></span><br><span class="line"><span class="comment">	2 4 1 3</span></span><br><span class="line"><span class="comment">	2 4 3 1</span></span><br><span class="line"><span class="comment">	3 1 2 4</span></span><br><span class="line"><span class="comment">	3 1 4 2</span></span><br><span class="line"><span class="comment">	3 2 1 4</span></span><br><span class="line"><span class="comment">	3 2 4 1</span></span><br><span class="line"><span class="comment">	3 4 1 2</span></span><br><span class="line"><span class="comment">	3 4 2 1</span></span><br><span class="line"><span class="comment">	4 1 2 3</span></span><br><span class="line"><span class="comment">	4 1 3 2</span></span><br><span class="line"><span class="comment">	4 2 1 3</span></span><br><span class="line"><span class="comment">	4 2 3 1</span></span><br><span class="line"><span class="comment">	4 3 1 2</span></span><br><span class="line"><span class="comment">	4 3 2 1</span></span><br><span class="line"><span class="comment">	After loop: 1 2 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prev_permutation获取[first,last)区间所标示序列的上一个排列组合，若果没有上一个排序组合，则返回false;否则返回true;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last) into the previous lexicographically-ordered permutation.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用less-than操作符</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator&gt;</span></span><br><span class="line"><span class="comment">	bool prev_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last );</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	bool prev_permutation (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                         BidirectionalIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">prev_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//若区间为空，返回false</span></span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)<span class="comment">//区间只有一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回false</span></span><br><span class="line">  <span class="comment">//若区间元素个数不小于两个</span></span><br><span class="line">  __i = __last;</span><br><span class="line">  --__i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">	  <span class="comment">//下面两行是让ii和i成为相邻的元素</span></span><br><span class="line">	  <span class="comment">//其中i为第一个元素，ii为第二个元素</span></span><br><span class="line">    _BidirectionalIter __ii = __i;</span><br><span class="line">    --__i;</span><br><span class="line">	<span class="comment">//以下在相邻元素判断</span></span><br><span class="line">    <span class="keyword">if</span> (*__ii &lt; *__i) &#123;<span class="comment">//若前一个元素大于后一个元素，</span></span><br><span class="line">		<span class="comment">//则再从最尾端开始往前检查，找出第一个小于*i的元素，令该元素为*j，将*i和*j交换</span></span><br><span class="line">		<span class="comment">//再将ii之后的所有元素颠倒排序</span></span><br><span class="line">      _BidirectionalIter __j = __last;<span class="comment">//令j指向最尾端      </span></span><br><span class="line">      <span class="keyword">while</span> (!(*--__j &lt; *__i))<span class="comment">//由尾端往前检查，直到遇到比*i小的元素</span></span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j); <span class="comment">//交换迭代器i和迭代器j所指的元素</span></span><br><span class="line">      reverse(__ii, __last);<span class="comment">//将ii之后的元素全部逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;<span class="comment">//进行到最前面</span></span><br><span class="line">      reverse(__first, __last);<span class="comment">//把区间所有元素逆向重排</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">prev_permutation</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  _BidirectionalIter __i = __first;</span><br><span class="line">  ++__i;</span><br><span class="line">  <span class="keyword">if</span> (__i == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  __i = __last;</span><br><span class="line">  --__i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    _BidirectionalIter __ii = __i;</span><br><span class="line">    --__i;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__ii, *__i)) &#123;</span><br><span class="line">      _BidirectionalIter __j = __last;</span><br><span class="line">      <span class="keyword">while</span> (!__comp(*--__j, *__i))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      iter_swap(__i, __j);</span><br><span class="line">      reverse(__ii, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__i == __first) &#123;</span><br><span class="line">      reverse(__first, __last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//prev_permutation函数举例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::next_permutation, std::sort, std::reverse</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (myints,myints+3);</span></span><br><span class="line"><span class="comment">	  std::reverse (myints,myints+3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The 3! possible permutations with 3 elements:\n";</span></span><br><span class="line"><span class="comment">	  do &#123;</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  &#125; while ( std::prev_permutation(myints,myints+3) );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "After loop: " &lt;&lt; myints[0] &lt;&lt; ' ' &lt;&lt; myints[1] &lt;&lt; ' ' &lt;&lt; myints[2] &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The 3! possible permutations with 3 elements:</span></span><br><span class="line"><span class="comment">	3 2 1</span></span><br><span class="line"><span class="comment">	3 1 2</span></span><br><span class="line"><span class="comment">	2 3 1</span></span><br><span class="line"><span class="comment">	2 1 3</span></span><br><span class="line"><span class="comment">	1 3 2</span></span><br><span class="line"><span class="comment">	1 2 3</span></span><br><span class="line"><span class="comment">	After loop: 3 2 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/merge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/merge/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的merge合并算法。源码中介绍了函数merge、inplace_merge。并对这些函数的源码进行详细的剖析，并适当给出使用例子，具体详见下面源码剖析。</p>
<h3 id="merge合并算法源码剖析"><a href="#merge合并算法源码剖析" class="headerlink" title="merge合并算法源码剖析"></a>merge合并算法源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge, with and without an explicitly supplied comparison function.</span></span><br><span class="line"><span class="comment">//将两个已排序的区间[first1,last1)和区间[first2,last2)合并</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Combines the elements in the sorted ranges [first1,last1) and [first2,last2), </span></span><br><span class="line"><span class="comment">into a new range beginning at result with all its elements sorted.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator merge (InputIterator1 first1, InputIterator1 last1,</span></span><br><span class="line"><span class="comment">                        InputIterator2 first2, InputIterator2 last2,</span></span><br><span class="line"><span class="comment">                        OutputIterator result);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator1, class InputIterator2,</span></span><br><span class="line"><span class="comment">          class OutputIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	OutputIterator merge (InputIterator1 first1, InputIterator1 last1,</span></span><br><span class="line"><span class="comment">                        InputIterator2 first2, InputIterator2 last2,</span></span><br><span class="line"><span class="comment">                        OutputIterator result, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="title">class</span> _<span class="title">InputIter2</span>, <span class="title">class</span> _<span class="title">OutputIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">merge</span>(_<span class="title">InputIter1</span> __<span class="title">first1</span>, _<span class="title">InputIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">InputIter2</span> __<span class="title">first2</span>, _<span class="title">InputIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">OutputIter</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter1, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_InputIter2, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter2&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="comment">//两个序列都尚未到达尾端，则执行while循环</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  情况1：若序列二元素较小,则记录到目标区，且移动序列二的迭代器，但是序列一的迭代器不变.</span></span><br><span class="line"><span class="comment">  情况2：若序列一元素较小或相等,则记录到目标区，且移动序列一的迭代器，但是序列二的迭代器不变.</span></span><br><span class="line"><span class="comment">  最后：把剩余元素的序列复制到目标区</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; __first2 != __last2) &#123;</span><br><span class="line">	  <span class="comment">//情况1</span></span><br><span class="line">    <span class="keyword">if</span> (*__first2 &lt; *__first1) &#123;<span class="comment">//若序列二元素较小</span></span><br><span class="line">      *__result = *__first2;<span class="comment">//将元素记录到目标区</span></span><br><span class="line">      ++__first2;<span class="comment">//移动迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//情况2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//若序列一元素较小或相等</span></span><br><span class="line">      *__result = *__first1;<span class="comment">//将元素记录到目标区</span></span><br><span class="line">      ++__first1;<span class="comment">//移动迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++__result;<span class="comment">//更新目标区位置，以便下次记录数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//若有序列到达尾端，则把没到达尾端的序列剩余元素复制到目标区</span></span><br><span class="line">  <span class="comment">//此时，区间[first1,last1)和区间[first2,last2)至少一个必定为空</span></span><br><span class="line">  <span class="keyword">return</span> copy(__first2, __last2, copy(__first1, __last1, __result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="title">class</span> _<span class="title">InputIter2</span>, <span class="title">class</span> _<span class="title">OutputIter</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">merge</span>(_<span class="title">InputIter1</span> __<span class="title">first1</span>, _<span class="title">InputIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">InputIter2</span> __<span class="title">first2</span>, _<span class="title">InputIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">OutputIter</span> __<span class="title">result</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter1, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_InputIter2, _InputIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter2&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter1&gt;::value_type);</span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; __first2 != __last2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__first2, *__first1)) &#123;</span><br><span class="line">      *__result = *__first2;</span><br><span class="line">      ++__first2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *__result = *__first1;</span><br><span class="line">      ++__first1;</span><br><span class="line">    &#125;</span><br><span class="line">    ++__result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy(__first2, __last2, copy(__first1, __last1, __result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//merge函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::merge, std::sort</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int first[] = &#123;5,10,15,20,25&#125;;</span></span><br><span class="line"><span class="comment">	  int second[] = &#123;50,40,30,20,10&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(10);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (first,first+5);</span></span><br><span class="line"><span class="comment">	  std::sort (second,second+5);</span></span><br><span class="line"><span class="comment">	  std::merge (first,first+5,second,second+5,v.begin());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The resulting vector contains:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The resulting vector contains: 5 10 10 15 20 20 25 30 40 50</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// inplace_merge and its auxiliary functions. </span></span><br><span class="line"><span class="comment">//版本一的辅助函数，无缓冲区的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_without_buffer</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 == <span class="number">0</span> || __len2 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 + __len2 == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__middle &lt; *__first)</span><br><span class="line">      iter_swap(__first, __middle);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __first_cut = __first;</span><br><span class="line">  _BidirectionalIter __second_cut = __middle;</span><br><span class="line">  _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">  _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 &gt; __len2) &#123;</span><br><span class="line">    __len11 = __len1 / <span class="number">2</span>;</span><br><span class="line">    advance(__first_cut, __len11);</span><br><span class="line">    __second_cut = lower_bound(__middle, __last, *__first_cut);</span><br><span class="line">    distance(__middle, __second_cut, __len22);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __len22 = __len2 / <span class="number">2</span>;</span><br><span class="line">    advance(__second_cut, __len22);</span><br><span class="line">    __first_cut = upper_bound(__first, __middle, *__second_cut);</span><br><span class="line">    distance(__first, __first_cut, __len11);</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __new_middle</span><br><span class="line">    = rotate(__first_cut, __middle, __second_cut);</span><br><span class="line">  __merge_without_buffer(__first, __first_cut, __new_middle,</span><br><span class="line">                         __len11, __len22);</span><br><span class="line">  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                         __len2 - __len22);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_without_buffer</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 == <span class="number">0</span> || __len2 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 + __len2 == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__middle, *__first))</span><br><span class="line">      iter_swap(__first, __middle);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __first_cut = __first;</span><br><span class="line">  _BidirectionalIter __second_cut = __middle;</span><br><span class="line">  _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">  _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__len1 &gt; __len2) &#123;</span><br><span class="line">    __len11 = __len1 / <span class="number">2</span>;</span><br><span class="line">    advance(__first_cut, __len11);</span><br><span class="line">    __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);</span><br><span class="line">    distance(__middle, __second_cut, __len22);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __len22 = __len2 / <span class="number">2</span>;</span><br><span class="line">    advance(__second_cut, __len22);</span><br><span class="line">    __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);</span><br><span class="line">    distance(__first, __first_cut, __len11);</span><br><span class="line">  &#125;</span><br><span class="line">  _BidirectionalIter __new_middle</span><br><span class="line">    = rotate(__first_cut, __middle, __second_cut);</span><br><span class="line">  __merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22,</span><br><span class="line">                         __comp);</span><br><span class="line">  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                         __len2 - __len22, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一的辅助函数，有缓冲区的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter1</span> __<span class="title">rotate_adaptive</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">BidirectionalIter1</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">BidirectionalIter1</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">BidirectionalIter2</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">Distance</span> __<span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  _BidirectionalIter2 __buffer_end;</span><br><span class="line">  <span class="keyword">if</span> (__len1 &gt; __len2 &amp;&amp; __len2 &lt;= __buffer_size) &#123;<span class="comment">//缓冲区足够放置序列二</span></span><br><span class="line">    __buffer_end = copy(__middle, __last, __buffer);</span><br><span class="line">    copy_backward(__first, __middle, __last);</span><br><span class="line">    <span class="keyword">return</span> copy(__buffer, __buffer_end, __first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__len1 &lt;= __buffer_size) &#123;<span class="comment">//缓冲区足够放置序列一</span></span><br><span class="line">    __buffer_end = copy(__first, __middle, __buffer);</span><br><span class="line">    copy(__middle, __last, __first);</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__buffer, __buffer_end, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//若缓冲区仍然不够，则调用STL算法rotate，不使用缓冲区</span></span><br><span class="line">    <span class="keyword">return</span> rotate(__first, __middle, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BidirectionalIter3</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter3</span> __<span class="title">merge_backward</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter3</span> __<span class="title">result</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first2, __last2, __result);</span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first1, __last1, __result);</span><br><span class="line">  --__last1;</span><br><span class="line">  --__last2;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__last2 &lt; *__last1) &#123;</span><br><span class="line">      *--__result = *__last1;</span><br><span class="line">      <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first2, ++__last2, __result);</span><br><span class="line">      --__last1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *--__result = *__last2;</span><br><span class="line">      <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first1, ++__last1, __result);</span><br><span class="line">      --__last2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BidirectionalIter3</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter3</span> __<span class="title">merge_backward</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">BidirectionalIter3</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first2, __last2, __result);</span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> copy_backward(__first1, __last1, __result);</span><br><span class="line">  --__last1;</span><br><span class="line">  --__last2;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__last2, *__last1)) &#123;</span><br><span class="line">      *--__result = *__last1;</span><br><span class="line">      <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first2, ++__last2, __result);</span><br><span class="line">      --__last1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *--__result = *__last2;</span><br><span class="line">      <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">        <span class="keyword">return</span> copy_backward(__first1, ++__last1, __result);</span><br><span class="line">      --__last2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一的辅助函数，有缓冲区的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Pointer</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_adaptive</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>, </span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Pointer</span> __<span class="title">buffer</span>, _<span class="title">Distance</span> __<span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 &lt;= __len2 &amp;&amp; __len1 &lt;= __buffer_size) &#123;</span><br><span class="line">	  <span class="comment">//case1：把序列一放在缓冲区</span></span><br><span class="line">    _Pointer __buffer_end = copy(__first, __middle, __buffer);</span><br><span class="line">	<span class="comment">//直接调用归并函数merge</span></span><br><span class="line">    merge(__buffer, __buffer_end, __middle, __last, __first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__len2 &lt;= __buffer_size) &#123;</span><br><span class="line">	  <span class="comment">//case2：把序列二放在缓冲区</span></span><br><span class="line">    _Pointer __buffer_end = copy(__middle, __last, __buffer);</span><br><span class="line">    __merge_backward(__first, __middle, __buffer, __buffer_end, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//case3：缓冲区不足放置任何一个序列</span></span><br><span class="line">    _BidirectionalIter __first_cut = __first;</span><br><span class="line">    _BidirectionalIter __second_cut = __middle;</span><br><span class="line">    _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">    _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (__len1 &gt; __len2) &#123;<span class="comment">//若序列一比较长</span></span><br><span class="line">      __len11 = __len1 / <span class="number">2</span>;<span class="comment">//计算序列一的一半</span></span><br><span class="line">      advance(__first_cut, __len11);<span class="comment">//让first_cut指向序列一的中间位置</span></span><br><span class="line">	  <span class="comment">//找出*__first_cut在[middle,last)区间中的第一个不小于*__first_cut的元素位置</span></span><br><span class="line">      __second_cut = lower_bound(__middle, __last, *__first_cut);</span><br><span class="line">	  <span class="comment">//计算middle到__second_cut之间的距离，保存在__len22</span></span><br><span class="line">      distance(__middle, __second_cut, __len22); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//若序列二比较长</span></span><br><span class="line">      __len22 = __len2 / <span class="number">2</span>;<span class="comment">//计算序列二的一半</span></span><br><span class="line">      advance(__second_cut, __len22);<span class="comment">//让__second_cut指向序列二的中间位置</span></span><br><span class="line">	  <span class="comment">//找出*__second_cut在[first,middle)区间中的第一个大于*__second_cut的元素位置</span></span><br><span class="line">      __first_cut = upper_bound(__first, __middle, *__second_cut);</span><br><span class="line">	  <span class="comment">//计算__first到__first_cut之间的距离，保存在__len11</span></span><br><span class="line">      distance(__first, __first_cut, __len11);</span><br><span class="line">    &#125;</span><br><span class="line">    _BidirectionalIter __new_middle =</span><br><span class="line">      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,</span><br><span class="line">                        __len22, __buffer, __buffer_size);</span><br><span class="line">	<span class="comment">//对左半段递归调用</span></span><br><span class="line">    __merge_adaptive(__first, __first_cut, __new_middle, __len11,</span><br><span class="line">                     __len22, __buffer, __buffer_size);</span><br><span class="line">	<span class="comment">//对右半段递归调用</span></span><br><span class="line">    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                     __len2 - __len22, __buffer, __buffer_size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Pointer</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_adaptive</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>, </span></span><br><span class="line"><span class="class">                      _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Distance</span> __<span class="title">len1</span>, _<span class="title">Distance</span> __<span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Pointer</span> __<span class="title">buffer</span>, _<span class="title">Distance</span> __<span class="title">buffer_size</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len1 &lt;= __len2 &amp;&amp; __len1 &lt;= __buffer_size) &#123;</span><br><span class="line">    _Pointer __buffer_end = copy(__first, __middle, __buffer);</span><br><span class="line">    merge(__buffer, __buffer_end, __middle, __last, __first, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__len2 &lt;= __buffer_size) &#123;</span><br><span class="line">    _Pointer __buffer_end = copy(__middle, __last, __buffer);</span><br><span class="line">    __merge_backward(__first, __middle, __buffer, __buffer_end, __last,</span><br><span class="line">                     __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _BidirectionalIter __first_cut = __first;</span><br><span class="line">    _BidirectionalIter __second_cut = __middle;</span><br><span class="line">    _Distance __len11 = <span class="number">0</span>;</span><br><span class="line">    _Distance __len22 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (__len1 &gt; __len2) &#123;</span><br><span class="line">      __len11 = __len1 / <span class="number">2</span>;</span><br><span class="line">      advance(__first_cut, __len11);</span><br><span class="line">      __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);</span><br><span class="line">      distance(__middle, __second_cut, __len22);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __len22 = __len2 / <span class="number">2</span>;</span><br><span class="line">      advance(__second_cut, __len22);</span><br><span class="line">      __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);</span><br><span class="line">      distance(__first, __first_cut, __len11);</span><br><span class="line">    &#125;</span><br><span class="line">    _BidirectionalIter __new_middle =</span><br><span class="line">      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,</span><br><span class="line">                        __len22, __buffer, __buffer_size);</span><br><span class="line">    __merge_adaptive(__first, __first_cut, __new_middle, __len11,</span><br><span class="line">                     __len22, __buffer, __buffer_size, __comp);</span><br><span class="line">    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,</span><br><span class="line">                     __len2 - __len22, __buffer, __buffer_size, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">inplace_merge_aux</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  _Distance __len1 = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __middle, __len1);<span class="comment">//计算序列一的长度</span></span><br><span class="line">  _Distance __len2 = <span class="number">0</span>;</span><br><span class="line">  distance(__middle, __last, __len2);<span class="comment">//计算序列二的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用暂时缓冲区</span></span><br><span class="line">  _Temporary_buffer&lt;_BidirectionalIter, _Tp&gt; __buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (__buf.begin() == <span class="number">0</span>)<span class="comment">//若缓冲区配置失败</span></span><br><span class="line">	  <span class="comment">//则调用不使用缓冲区的合并操作</span></span><br><span class="line">    __merge_without_buffer(__first, __middle, __last, __len1, __len2);</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//若分配成功</span></span><br><span class="line">	  <span class="comment">//则调用具有缓冲区的合并操作</span></span><br><span class="line">    __merge_adaptive(__first, __middle, __last, __len1, __len2,</span><br><span class="line">                     __buf.begin(), _Distance(__buf.size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">inplace_merge_aux</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                _<span class="title">BidirectionalIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                                _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __len1 = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __middle, __len1);</span><br><span class="line">  _Distance __len2 = <span class="number">0</span>;</span><br><span class="line">  distance(__middle, __last, __len2);</span><br><span class="line"></span><br><span class="line">  _Temporary_buffer&lt;_BidirectionalIter, _Tp&gt; __buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (__buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __merge_adaptive(__first, __middle, __last, __len1, __len2,</span><br><span class="line">                     __buf.begin(), _Distance(__buf.size()),</span><br><span class="line">                     __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将两个已排序的序列[first,middle)和[middle,last)合并成单一有序序列.</span></span><br><span class="line"><span class="comment">//若原来是增序，现在也是递增排序，若原来是递减排序，现在也是递减排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Merges two consecutive sorted ranges: [first,middle) and [middle,last), </span></span><br><span class="line"><span class="comment">putting the result into the combined sorted range [first,last).</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator&gt;</span></span><br><span class="line"><span class="comment">	void inplace_merge (BidirectionalIterator first, BidirectionalIterator middle,</span></span><br><span class="line"><span class="comment">                      BidirectionalIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void inplace_merge (BidirectionalIterator first, BidirectionalIterator middle,</span></span><br><span class="line"><span class="comment">                      BidirectionalIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">inplace_merge</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __middle || __middle == __last)<span class="comment">//若有空序列，则之间返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __inplace_merge_aux(__first, __middle, __last,</span><br><span class="line">                      __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">inplace_merge</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">BidirectionalIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">           <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type,</span><br><span class="line">           <span class="keyword">typename</span> iterator_traits&lt;_BidirectionalIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __middle || __middle == __last)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __inplace_merge_aux(__first, __middle, __last,</span><br><span class="line">                      __VALUE_TYPE(__first), __DISTANCE_TYPE(__first),</span><br><span class="line">                      __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//inplace_merge函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::inplace_merge, std::sort, std::copy</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int first[] = &#123;5,10,15,20,25&#125;;</span></span><br><span class="line"><span class="comment">	  int second[] = &#123;50,40,30,20,10&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(10);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (first,first+5);</span></span><br><span class="line"><span class="comment">	  std::sort (second,second+5);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  it=std::copy (first, first+5, v.begin());</span></span><br><span class="line"><span class="comment">		 std::copy (second,second+5,it);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::inplace_merge (v.begin(),v.begin()+5,v.end());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The resulting vector contains:";</span></span><br><span class="line"><span class="comment">	  for (it=v.begin(); it!=v.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output：</span></span><br><span class="line"><span class="comment">	The resulting vector contains: 5 10 10 15 20 20 25 30 40 50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/List/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://zcheng.ren/2016/08/24/STLVector/" target="_blank" rel="noopener">上一篇博客</a>中介绍的vector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，很好的支持了随机存取，但由于是连续空间，所以在中间进行插入、删除等操作时都造成了内存块的拷贝和移动，另外在内存空间不足时还需要重新申请一块大内存来进行内存的拷贝。为了克服这些缺陷，STL定义了另一种容器List，它对于数据插入和删除的时间复杂度均为O(1)，而且再内存方面不用频繁的拷贝转移。下面，就一起来看看List的源码实现吧</p>
<h1 id="List概述"><a href="#List概述" class="headerlink" title="List概述"></a>List概述</h1><p>List和Vector都是STL的序列式容器，唯一不同的地方就在于：Vector是一段连续的内存空间，List则是一段不连续的内存空间，相比于Vector来说，List在每次插入和删除的时候，只需要配置或释放一个元素空间，对于任何位置的插入和删除操作，List永远能做到常数时间。但是，List由于不连续的内存空间，导致不支持随机寻址，所以尺有所长寸有所短，在程序中选择使用那种容器还要视元素的构造复杂度和存取行为而定。</p>
<h1 id="List的节点"><a href="#List的节点" class="headerlink" title="List的节点"></a>List的节点</h1><p>List的节点结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer; </span><br><span class="line">  void_pointer next;	<span class="comment">//型别为void*，也可以设为__list_node&lt;T&gt;*</span></span><br><span class="line">  void_pointer prev;</span><br><span class="line">  T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从节点结构可以看出，List就是一个双向链表，其结构如下图所示：</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79gw1fbkfthawhhj30ri07874t.jpg" alt="STLListNode"></p>
<h1 id="List的迭代器"><a href="#List的迭代器" class="headerlink" title="List的迭代器"></a>List的迭代器</h1><p>在Vector中，由于是连续的存储空间，支持随机存取，所以其迭代器可以直接用普通指针代替。但是，在List中行不通。List必须有能力指向List的节点，并有能力进行正确的递增、递减、取值和成员存取等操作。</p>
<p>List是一个双向链表，迭代器必须具备前移、后退的能力，所以List的迭代器是一个Bidirectional Iterator！在Vector中如果进行插入和删除操作后迭代器会失效，List有一个重要的性质就是插入和接合操作都不会造成原有的List迭代器失效。而且，再删除一个节点时，也仅有指向被删除元素的那个迭代器失效，其他迭代器不受任何影响。下面来看看List迭代器的源码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;   <span class="comment">// 支持Iterator_traits</span></span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt;           self;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以下为支持Iterator_traits而定义的一些类型</span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;	<span class="comment">//List的迭代器类型为双向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;                                </span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;    </span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;                                </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;                     </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个是迭代器实际管理的资源指针</span></span><br><span class="line">  link_type node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代器构造函数</span></span><br><span class="line">  __list_iterator(link_type x) : node(x) &#123;&#125;</span><br><span class="line">  __list_iterator() &#123;&#125;</span><br><span class="line">  __list_iterator(<span class="keyword">const</span> iterator&amp; x) : node(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在STL算法中需要迭代器提供支持</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重载operator *, 返回实际维护的数据</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成员调用操作符</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前缀自加</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">  &#123;</span><br><span class="line">    node = (link_type)((*node).next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后缀自加, 需要先产生自身的一个副本, 然会再对自身操作, 最后返回副本</span></span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">  &#123;</span><br><span class="line">    node = (link_type)((*node).prev);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List的迭代器实现了==,!=,++,–,取值和成员调用等操作，由于是存放在不连续的内存空间，所以并不支持vector那样的p+n的操作。</p>
<h1 id="List的数据结构"><a href="#List的数据结构" class="headerlink" title="List的数据结构"></a>List的数据结构</h1><p>List的数据结构个List的节点数据结构是分开定义的，SGI的List不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针，就能完整表现一个链表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个提供STL标准的allocator接口</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表的头结点，并不存放数据</span></span><br><span class="line">  link_type node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//....以下还有一堆List的操作函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ww2.sinaimg.cn/large/006tNc79gw1fbkftit4nmj30jw0g7ab2.jpg" alt="STLList">)</p>
<h1 id="List构造函数"><a href="#List构造函数" class="headerlink" title="List构造函数"></a>List构造函数</h1><p>List提供了一个空构造函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>() &#123; empty_initialize(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于空链表的建立</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">empty_initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node = get_node();</span><br><span class="line">  node-&gt;next = node;  <span class="comment">// 前置节点指向自己</span></span><br><span class="line">  node-&gt;prev = node;  <span class="comment">// 后置节点指向自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，List还提供了带参的构造函数，支持如下初始化操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; myList(<span class="number">5</span>,<span class="number">1</span>); <span class="comment">// 初始化5个1的链表，&#123;1,1,1,1,1&#125;</span></span><br></pre></td></tr></table></figure>

<p>其构造函数源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参构造函数</span></span><br><span class="line"><span class="built_in">list</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建值为value共n个结点的链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  empty_initialize();  <span class="comment">// 先创建一个空链表</span></span><br><span class="line">  insert(begin(), n, value); <span class="comment">// 插入n个值为value的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入n个值为x的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  insert(pos, (size_type)n, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position前插入n个值为x的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:insert(iterator position, size_type n, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n)</span><br><span class="line">    insert(position, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好吧，到这里才是真正的插入操作</span></span><br><span class="line"><span class="comment">// 很简单的双向链表插入操作</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  link_type tmp = create_node(x);</span><br><span class="line">  tmp-&gt;next = position.node;</span><br><span class="line">  tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">  (link_type(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">  position.node-&gt;prev = tmp;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>STL的List提供了很多种构造函数，此处我列举了其中一个，以此为例。</p>
<h1 id="List的其他操作函数"><a href="#List的其他操作函数" class="headerlink" title="List的其他操作函数"></a>List的其他操作函数</h1><h2 id="get-node"><a href="#get-node" class="headerlink" title="get_node"></a>get_node</h2><p>此函数用来配置一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置一个节点并返回</span></span><br><span class="line"><span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> list_node_allocator::allocate(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="put-node"><a href="#put-node" class="headerlink" title="put_node"></a>put_node</h2><p>此函数用来释放一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放指定结点, 不进行析构, 析构交给全局的destroy,</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">	list_node_allocator::deallocate(p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="create-node"><a href="#create-node" class="headerlink" title="create_node"></a>create_node</h2><p>此函数用来配置并构造一个节点，并初始化其值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置一个节点，并初始化其值为x</span></span><br><span class="line"><span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  link_type p = get_node();</span><br><span class="line">  construct(&amp;p-&gt;data, x);	<span class="comment">//全局函数</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="destory-node"><a href="#destory-node" class="headerlink" title="destory_node"></a>destory_node</h2><p>此函数用来析构一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 析构结点元素, 并释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	destroy(&amp;p-&gt;data);	<span class="comment">//全局函数</span></span><br><span class="line">	put_node(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>此函数用来在制定位置插入一个节点(上面提到过这个函数，这里重复一下，List的主要插入工作都交给这个函数)，该函数是一个重载函数，其有多种形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好吧，到这里才是真正的插入操作</span></span><br><span class="line"><span class="comment">// 很简单的双向链表插入操作</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  link_type tmp = create_node(x);</span><br><span class="line">  tmp-&gt;next = position.node;</span><br><span class="line">  tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">  (link_type(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">  position.node-&gt;prev = tmp;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其还有如下多种形式的重载函数</span></span><br><span class="line"><span class="comment">// 在[first,last]区间内插入元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt; <span class="title">template</span> &lt;class InputIterator&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:insert(iterator position,</span><br><span class="line">                            InputIterator first, InputIterator last)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    insert(position, *first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在position位置插入元素，元素调用该型别默认构造函数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position)</span> </span>&#123; <span class="keyword">return</span> insert(position, T()); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><p>在尾部插入元素，有了上面的insert函数之后，push_back就比较容易实现了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表最后插入结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; insert(end(), x); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表前端插入结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; insert(begin(), x); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="earse"><a href="#earse" class="headerlink" title="earse"></a>earse</h2><p>移除迭代器所指的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 擦除指定结点</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 双向链表移除节点的操作</span></span><br><span class="line">	link_type next_node = link_type(position.node-&gt;next);</span><br><span class="line">	link_type prev_node = link_type(position.node-&gt;prev);</span><br><span class="line">	prev_node-&gt;next = next_node;</span><br><span class="line">	next_node-&gt;prev = prev_node;</span><br><span class="line">	destroy_node(position.node);</span><br><span class="line">	<span class="keyword">return</span> iterator(next_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述函数还有一个重载版本，移除区间内所有的节点</span></span><br><span class="line"><span class="comment">// 擦除[first, last)间的结点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">list</span>&lt;T, Alloc&gt;:</span>:iterator <span class="built_in">list</span>&lt;T, Alloc&gt;::erase(iterator first, iterator last)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (first != last) erase(first++);</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-front"><a href="#pop-front" class="headerlink" title="pop_front"></a>pop_front</h2><p>移除头节点元素，有了上述的erase函数，就很方便的实现了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除链表第一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; erase(begin()); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h2><p>移除链表中最后一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除链表最后一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	iterator tmp = end();</span><br><span class="line">	erase(--tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>清除链表中的所有节点，也就是一个一个的清除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁所有结点, 将链表置空</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:clear()</span><br><span class="line">&#123;</span><br><span class="line">  link_type cur = (link_type) node-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (cur != node) &#123;	<span class="comment">//遍历每一个节点</span></span><br><span class="line">    link_type tmp = cur;</span><br><span class="line">    cur = (link_type) cur-&gt;next;</span><br><span class="line">    destroy_node(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  node-&gt;next = node;<span class="comment">// 移除后注意要保持链表是一个循环链表</span></span><br><span class="line">  node-&gt;prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>将链表中值为value的节点移除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除特定值的所有结点</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:remove(<span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	iterator first = begin();</span><br><span class="line">	iterator last = end();</span><br><span class="line">	<span class="keyword">while</span> (first != last) &#123;	<span class="comment">//保证链表非空</span></span><br><span class="line">		iterator next = first;</span><br><span class="line">		++next;</span><br><span class="line">		<span class="keyword">if</span> (*first == value) erase(first);	<span class="comment">//擦除该节点</span></span><br><span class="line">		first = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h2><p>将某段连续范围内的元素迁移到指定位置。（非公开接口）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (position != last)</span><br><span class="line">	&#123;</span><br><span class="line">		(*(link_type((*last.node).prev))).next = position.node;</span><br><span class="line">		(*(link_type((*first.node).prev))).next = last.node;</span><br><span class="line">		(*(link_type((*position.node).prev))).next = first.node;</span><br><span class="line">		link_type tmp = link_type((*position.node).prev);</span><br><span class="line">		(*position.node).prev = (*last.node).prev;</span><br><span class="line">		(*last.node).prev = (*first.node).prev;</span><br><span class="line">		(*first.node).prev = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里借用侯捷先生的《STL源码剖析》中的一幅图来说明这个过程。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkftghh04j30eq0exwfs.jpg" alt="STLTransfer"></p>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>List提供的接合函数是Splice，上述transfer是非公开的函数。splice函数有如下几个版本:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表x移动到position之前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x.empty())</span><br><span class="line">		transfer(position, x.begin(), x.end());	<span class="comment">//仅仅调用了transfer函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表中i指向的内容移动到position之前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	iterator j = i;</span><br><span class="line">	++j;</span><br><span class="line">	<span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>;</span><br><span class="line">	transfer(position, i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将[first, last&#125;元素移动到position之前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first != last)</span><br><span class="line">		transfer(position, first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>此函数用来合并两个链表，这里两个链表必须是已拍好序的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设当前容器和x都已序, 保证两容器合并后仍然有序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:merge(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  iterator first1 = begin();</span><br><span class="line">  iterator last1 = end();</span><br><span class="line">  iterator first2 = x.begin();</span><br><span class="line">  iterator last2 = x.end();</span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">      iterator next = first2;</span><br><span class="line">      transfer(first1, first2, ++next);	<span class="comment">//将first2节点迁移到first1之后</span></span><br><span class="line">      first2 = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++first1;</span><br><span class="line">  <span class="keyword">if</span> (first2 != last2) transfer(last1, first2, last2);	<span class="comment">//如果first2还有剩余的，直接接合再链表1尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p>此函数用来反转链表，其具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表倒置</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:reverse()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;</span><br><span class="line">  iterator first = begin();</span><br><span class="line">  ++first;</span><br><span class="line">  <span class="keyword">while</span> (first != end()) &#123;</span><br><span class="line">    iterator old = first;	<span class="comment">// 取出一个节点</span></span><br><span class="line">    ++first;</span><br><span class="line">    transfer(begin(), old, first);	<span class="comment">// 插入到begin()之后</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>此函数对链表进行升序排序，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照升序排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:sort()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">list</span>&lt;T, Alloc&gt; carry;</span><br><span class="line">  <span class="built_in">list</span>&lt;T, Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">int</span> fill = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line">  	<span class="comment">// 从链表中取出一个节点</span></span><br><span class="line">    carry.splice(carry.begin(), *<span class="keyword">this</span>, begin());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把carry中的新元素和counter中的结果逐一进行归并</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; fill &amp;&amp; !counter[i].empty()) &#123;</span><br><span class="line">      counter[i].merge(carry);</span><br><span class="line">      carry.swap(counter[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把归并后的结果存放在counter[i]中</span></span><br><span class="line">    carry.swap(counter[i]);</span><br><span class="line">    <span class="comment">// 已经达到2*fill，fill自增1</span></span><br><span class="line">    <span class="keyword">if</span> (i == fill) ++fill;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将counter中的所有元素进行归并</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; fill; ++i) counter[i].merge(counter[i - <span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// 将counter链表和本链表进行交换</span></span><br><span class="line">  swap(counter[fill - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换本链表和链表x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span> </span>&#123; </span><br><span class="line">	swap(node, x.node); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以举个例子来说明一下这个过程：(以链表5,3,6,4,7,9,1,2,8)</p>
<p>carry每次从数组中取一个数，然后归并到counter数组中，该算法最多只能排序2的64次方个数。</p>
<p>《STL源码剖析》中写到此处是快速排序，其实我觉得应该是归并排序。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/find/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:15+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的find、search查找算法。在STL源码中有关算法的函数大部分在本文介绍，包含findand find_if、adjacent_find、search、search_n、lower_bound、upper_bound、equal_range、binary_search、find_first_of、find_end相关算法，下面对这些算法的源码进行了详细的剖析，并且适当给出应用例子，增加我们对其理解，方便我们使用这些算法。具体详见下面源码剖析。</p>
<h3 id="查找算法源码剖析"><a href="#查找算法源码剖析" class="headerlink" title="查找算法源码剖析"></a>查找算法源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find and find_if.</span></span><br><span class="line"><span class="comment">//查找区间[first,last)内元素第一个与value值相等的元素，并返回其位置</span></span><br><span class="line"><span class="comment">//其中find函数是采用默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//find_if是采用用户自行指定的操作pred</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若find函数萃取出来的迭代器类型为输入迭代器input_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//若尚未到达区间的尾端，且未找到匹配的值，则继续查找</span></span><br><span class="line">  <span class="keyword">while</span> (__first != __last &amp;&amp; !(*__first == __val))</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="comment">//若找到匹配的值，则返回该位置</span></span><br><span class="line">  <span class="comment">//若找不到，即到达区间尾端，此时first=last，则返回first</span></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若find_if函数萃取出来的迭代器类型为输入迭代器input_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find_if</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">Predicate</span> __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//若尚未到达区间的尾端，且未找到匹配的值，则继续查找</span></span><br><span class="line">  <span class="keyword">while</span> (__first != __last &amp;&amp; !__pred(*__first))</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="comment">//若找到匹配的值，则返回该位置</span></span><br><span class="line">  <span class="comment">//若找不到，即到达区间尾端，此时first=last，则返回first</span></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="comment">//若find函数萃取出来的迭代器类型为随机访问迭代器random_access_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> <span class="title">find</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::difference_type __trip_count</span><br><span class="line">    = (__last - __first) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __trip_count &gt; <span class="number">0</span> ; --__trip_count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(__last - __first) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> (*__first == __val) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若find_if函数萃取出来的迭代器类型为随机访问迭代器random_access_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> <span class="title">find_if</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">Predicate</span> __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::difference_type __trip_count</span><br><span class="line">    = (__last - __first) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __trip_count &gt; <span class="number">0</span> ; --__trip_count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(__last - __first) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__first)) <span class="keyword">return</span> __first;</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line"><span class="comment">/*find函数功能：Returns an iterator to the first element in the range [first,last) that compares equal to val. </span></span><br><span class="line"><span class="comment">If no such element is found, the function returns last.</span></span><br><span class="line"><span class="comment">find函数原型：</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	InputIterator find (InputIterator first, InputIterator last, const T&amp; val);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//find函数对外接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>, </span><br><span class="line">            <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type, _Tp);</span><br><span class="line">  <span class="comment">//首先萃取出first迭代器的类型，根据迭代器的类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> find(__first, __last, __val, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*find_if函数功能：Returns an iterator to the first element in the range [first,last) for which pred returns true. </span></span><br><span class="line"><span class="comment">If no such element is found, the function returns last.</span></span><br><span class="line"><span class="comment">find_if函数原型：</span></span><br><span class="line"><span class="comment">	template &lt;class InputIterator, class UnaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	InputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//find_if 函数对外接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InputIter</span> <span class="title">find_if</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先萃取出first迭代器的类型，根据迭代器的类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> find_if(__first, __last, __pred, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find和find_if函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::find_if</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool IsOdd (int i) &#123;</span></span><br><span class="line"><span class="comment">	  return ((i%2)==1);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  myvector.push_back(10);</span></span><br><span class="line"><span class="comment">	  myvector.push_back(25);</span></span><br><span class="line"><span class="comment">	  myvector.push_back(40);</span></span><br><span class="line"><span class="comment">	  myvector.push_back(55);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it = std::find_if (myvector.begin(), myvector.end(), IsOdd);</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "The first odd value is " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using std::find with vector and iterator:</span></span><br><span class="line"><span class="comment">	  it = find (myvector.begin(), myvector.end(), 40);</span></span><br><span class="line"><span class="comment">	  if (it != myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "Element found in myvector: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "Element not found in myints\n";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The first odd value is 25</span></span><br><span class="line"><span class="comment">	Element found in myvector: 40</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// adjacent_find.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找区间[first,last)内第一次重复的相邻元素</span></span><br><span class="line"><span class="comment">//若存在返回相邻元素的第一个元素位置</span></span><br><span class="line"><span class="comment">//若不存在返回last位置</span></span><br><span class="line"><span class="comment">/*该函数有两个版本：第一版本是默认操作operator==；第二版本是用户指定的二元操作pred</span></span><br><span class="line"><span class="comment">函数对外接口的原型：</span></span><br><span class="line"><span class="comment">equality (1)：默认操作是operator==</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last);</span></span><br><span class="line"><span class="comment">predicate (2)：用户指定的二元操作pred	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                                  BinaryPredicate pred);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：默认操作是operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">adjacent_find</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  情况1：若输入区间为空，则直接返回尾端last；</span></span><br><span class="line"><span class="comment">  情况2：若输入区间不为空，且存在相邻重复元素，则返回相邻元素的第一个元素的位置；</span></span><br><span class="line"><span class="comment">  情况3：若输入区间不为空，但是不存在相邻重复元素，则直接返回尾端last；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//情况1：</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last)<span class="comment">//若输入区间为空</span></span><br><span class="line">    <span class="keyword">return</span> __last;<span class="comment">//直接返回last</span></span><br><span class="line">  <span class="comment">//情况2：</span></span><br><span class="line">  _ForwardIter __next = __first;<span class="comment">//定义当前位置的下一个位置(即当前元素的相邻元素)</span></span><br><span class="line">  <span class="keyword">while</span>(++__next != __last) &#123;<span class="comment">//若还没到达尾端，执行while循环</span></span><br><span class="line">    <span class="keyword">if</span> (*__first == *__next)<span class="comment">//相邻元素值相等，则找到相邻重复元素</span></span><br><span class="line">      <span class="keyword">return</span> __first;<span class="comment">//返回第一个元素的位置</span></span><br><span class="line">    __first = __next;<span class="comment">//若暂时找不到，则继续找，直到到达区间尾端</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//情况3：</span></span><br><span class="line">  <span class="keyword">return</span> __last;<span class="comment">//直接返回尾端last</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：用户指定的二元操作pred	</span></span><br><span class="line"><span class="comment">//实现过程和版本一一样，只是判断规则不同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">adjacent_find</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  _ForwardIter __next = __first;</span><br><span class="line">  <span class="keyword">while</span>(++__next != __last) &#123;</span><br><span class="line">	  <span class="comment">//如果找到相邻元素符合用户指定条件，就返回第一元素位置</span></span><br><span class="line">    <span class="keyword">if</span> (__binary_pred(*__first, *__next))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    __first = __next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//adjacent_find函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::adjacent_find</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool myfunction (int i, int j) &#123;</span></span><br><span class="line"><span class="comment">	  return (i==j);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;5,20,5,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector (myints,myints+8);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = std::adjacent_find (myvector.begin(), myvector.end());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "the first pair of repeated elements are: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  //using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = std::adjacent_find (++it, myvector.end(), myfunction);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "the second pair of repeated elements are: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	the first pair of repeated elements are: 30</span></span><br><span class="line"><span class="comment">	the second pair of repeated elements are: 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// search.</span></span><br><span class="line"><span class="comment">//在序列一[first1,last1)所涵盖的区间中，查找序列二[first2,last2)的首次出现点</span></span><br><span class="line"><span class="comment">//该查找函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="comment">/*search函数功能：Searches the range [first1,last1) for the first occurrence of the sequence defined by [first2,last2), </span></span><br><span class="line"><span class="comment">and returns an iterator to its first element, or last1 if no occurrences are found.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">search函数的原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 search (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                            ForwardIterator2 first2, ForwardIterator2 last2);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 search (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                            ForwardIterator2 first2, ForwardIterator2 last2,</span></span><br><span class="line"><span class="comment">                            BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> <span class="title">search</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for empty ranges</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1 || __first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> __first1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for a pattern of length 1.</span></span><br><span class="line">  _ForwardIter2 __tmp(__first2);</span><br><span class="line">  ++__tmp;</span><br><span class="line">  <span class="keyword">if</span> (__tmp == __last2)</span><br><span class="line">    <span class="keyword">return</span> find(__first1, __last1, *__first2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// General case.</span></span><br><span class="line"></span><br><span class="line">  _ForwardIter2 __p1, __p;</span><br><span class="line"></span><br><span class="line">  __p1 = __first2; ++__p1;</span><br><span class="line"></span><br><span class="line">  _ForwardIter1 __current = __first1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1) &#123;<span class="comment">//若还没到达区间尾端</span></span><br><span class="line">    __first1 = find(__first1, __last1, *__first2);<span class="comment">//查找*first2在区间[first1,last1)首次出现的位置</span></span><br><span class="line">    <span class="keyword">if</span> (__first1 == __last1)<span class="comment">//若在[first1,last1)中不存在*first2，即在[first1,last1)不存在子序列[first2,last2)</span></span><br><span class="line">      <span class="keyword">return</span> __last1;<span class="comment">//则直接返回区间尾端</span></span><br><span class="line"></span><br><span class="line">    __p = __p1;</span><br><span class="line">    __current = __first1; </span><br><span class="line">    <span class="keyword">if</span> (++__current == __last1)<span class="comment">//若[first1,last1)只有一个元素，即序列[first1,last1)小于序列[first2,last2)</span></span><br><span class="line">      <span class="keyword">return</span> __last1;<span class="comment">//不可能成为其子序列，返回last1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*__current == *__p) &#123;<span class="comment">//若两个序列相对应的值相同</span></span><br><span class="line">      <span class="keyword">if</span> (++__p == __last2)<span class="comment">//若序列[first2,last2)只有两个元素，且与序列一匹配</span></span><br><span class="line">        <span class="keyword">return</span> __first1;<span class="comment">//则返回匹配的首次位置</span></span><br><span class="line">      <span class="keyword">if</span> (++__current == __last1)<span class="comment">//若第一个序列小于第二个序列</span></span><br><span class="line">        <span class="keyword">return</span> __last1;<span class="comment">//返回last1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++__first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>, <span class="title">class</span> _<span class="title">BinaryPred</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> <span class="title">search</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                     _<span class="title">BinaryPred</span>  __<span class="title">predicate</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPred, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for empty ranges</span></span><br><span class="line">  <span class="keyword">if</span> (__first1 == __last1 || __first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> __first1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for a pattern of length 1.</span></span><br><span class="line">  _ForwardIter2 __tmp(__first2);</span><br><span class="line">  ++__tmp;</span><br><span class="line">  <span class="keyword">if</span> (__tmp == __last2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; !__predicate(*__first1, *__first2))</span><br><span class="line">      ++__first1;</span><br><span class="line">    <span class="keyword">return</span> __first1;    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// General case.</span></span><br><span class="line"></span><br><span class="line">  _ForwardIter2 __p1, __p;</span><br><span class="line"></span><br><span class="line">  __p1 = __first2; ++__p1;</span><br><span class="line"></span><br><span class="line">  _ForwardIter1 __current = __first1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first1 != __last1) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__first1 != __last1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__predicate(*__first1, *__first2))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ++__first1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; !__predicate(*__first1, *__first2))</span><br><span class="line">      ++__first1;</span><br><span class="line">    <span class="keyword">if</span> (__first1 == __last1)</span><br><span class="line">      <span class="keyword">return</span> __last1;</span><br><span class="line"></span><br><span class="line">    __p = __p1;</span><br><span class="line">    __current = __first1; </span><br><span class="line">    <span class="keyword">if</span> (++__current == __last1) <span class="keyword">return</span> __last1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (__predicate(*__current, *__p)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (++__p == __last2)</span><br><span class="line">        <span class="keyword">return</span> __first1;</span><br><span class="line">      <span class="keyword">if</span> (++__current == __last1)</span><br><span class="line">        <span class="keyword">return</span> __last1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++__first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search_n.  Search for __count consecutive copies of __val.</span></span><br><span class="line"><span class="comment">//在序列[first,last)查找连续count个符合条件值value元素的位置</span></span><br><span class="line"><span class="comment">//该查找函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="comment">/*search_n函数功能：Searches the range [first,last) for a sequence of count elements, </span></span><br><span class="line"><span class="comment">each comparing equal to val (or for which pred returns true).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">search_n函数的原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class Size, class T&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator search_n (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                             Size count, const T&amp; val);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator search_n ( ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                              Size count, const T&amp; val, BinaryPredicate pred );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：使用默认的equality操作operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Integer</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">search_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Integer</span> __<span class="title">count</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _EqualityComparable);</span><br><span class="line">  __STL_REQUIRES(_Tp, _EqualityComparable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__count &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//首先查找value第一次出现的位置</span></span><br><span class="line">    __first = find(__first, __last, __val);</span><br><span class="line">    <span class="keyword">while</span> (__first != __last) &#123;<span class="comment">//若出现的位置不是区间尾端</span></span><br><span class="line">      _Integer __n = __count - <span class="number">1</span>;<span class="comment">//更新个数，下面只需查找n=count-1个连续相同value即可</span></span><br><span class="line">      _ForwardIter __i = __first;</span><br><span class="line">      ++__i;<span class="comment">//从当前位置的下一个位置开始查找</span></span><br><span class="line">	  <span class="comment">//若没有到达区间尾端，且个数n大于0，且区间元素与value值相等</span></span><br><span class="line">      <span class="keyword">while</span> (__i != __last &amp;&amp; __n != <span class="number">0</span> &amp;&amp; *__i == __val) &#123;</span><br><span class="line">        ++__i;<span class="comment">//继续查找</span></span><br><span class="line">        --__n;<span class="comment">//减少查找的次数，因为已经找到value再次出现</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__n == <span class="number">0</span>)<span class="comment">//若区间尚未到达尾端，但是count个value已经查找到</span></span><br><span class="line">        <span class="keyword">return</span> __first;<span class="comment">//则输出查找到的首次出现value的位置</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        __first = find(__i, __last, __val);<span class="comment">//若尚未找到连续count个value值的位置，则找出value下次出现的位置，并准备下一次while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：用户根据需要自行指定操作规则</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Integer</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">BinaryPred</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> <span class="title">search_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">Integer</span> __<span class="title">count</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">BinaryPred</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPred, <span class="keyword">bool</span>, </span><br><span class="line">             <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type, _Tp);</span><br><span class="line">  <span class="keyword">if</span> (__count &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__binary_pred(*__first, __val))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ++__first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">      _Integer __n = __count - <span class="number">1</span>;</span><br><span class="line">      _ForwardIter __i = __first;</span><br><span class="line">      ++__i;</span><br><span class="line">      <span class="keyword">while</span> (__i != __last &amp;&amp; __n != <span class="number">0</span> &amp;&amp; __binary_pred(*__i, __val)) &#123;</span><br><span class="line">        ++__i;</span><br><span class="line">        --__n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> __first;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (__i != __last) &#123;</span><br><span class="line">          <span class="keyword">if</span> (__binary_pred(*__i, __val))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          ++__i;</span><br><span class="line">        &#125;</span><br><span class="line">        __first = __i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//search和search_n函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::search_n</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool mypredicate (int i, int j) &#123;</span></span><br><span class="line"><span class="comment">	  return (i==j);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[]=&#123;10,20,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector (myints,myints+8);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = std::search_n (myvector.begin(), myvector.end(), 2, 30);</span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "two 30s found at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "match not found\n";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = std::search_n (myvector.begin(), myvector.end(), 2, 10, mypredicate);</span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "two 10s found at position " &lt;&lt; int(it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "match not found\n";</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">	  int needle1[] = &#123;10,20&#125;;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = std::search (myvector.begin(), myvector.end(), needle1, needle1+2);  </span></span><br><span class="line"><span class="comment">	   if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle1 found at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle1 not found\n";</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  int needle2[] = &#123;30,20,10&#125;;</span></span><br><span class="line"><span class="comment">	  it = std::search (myvector.begin(), myvector.end(), needle2, needle2+3, mypredicate);</span></span><br><span class="line"><span class="comment">	  if (it!=myvector.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle2 found at position " &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle2 not found\n";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	two 30s found at position 2</span></span><br><span class="line"><span class="comment">	two 10s found at position 5</span></span><br><span class="line"><span class="comment">	needle1 found at position 0</span></span><br><span class="line"><span class="comment">	needle2 found at position 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary search (lower_bound, upper_bound, equal_range, binary_search).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Distance</span>*) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;<span class="comment">//定义区间的中间迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间不为空，则在区间[first,last)开始查找value值</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移一位，相当于除以2，即取区间的中间值</span></span><br><span class="line">    __middle = __first;<span class="comment">//middle初始化为区间的起始位置</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//middle向后移half位，此时middle为区间的中间值</span></span><br><span class="line">    <span class="keyword">if</span> (*__middle &lt; __val) &#123;<span class="comment">//将value值与中间值比较，即是二分查找,若中间值小于value，则继续查找右半部分</span></span><br><span class="line">		<span class="comment">//下面两行令first指向middle的下一个位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//调整查找区间的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __len = __half;<span class="comment">//否则查找左半部分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在已排序区间[first,last)查找value值</span></span><br><span class="line"><span class="comment">//若该区间存在与value相等的元素，则返回指向第一个与value相等的迭代器</span></span><br><span class="line"><span class="comment">//若该区间不存在与value相等的元素，则返回指向第一个不小于value值的迭代器</span></span><br><span class="line"><span class="comment">//若该区间的任何元素都比value值小，则返回last</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用operator&lt;比较</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp比较规则</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">				<span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __lower_bound(__first, __last, __val,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;<span class="comment">//定义区间的中间迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间不为空，则在区间[first,last)开始查找value值</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移一位，相当于除以2，即取区间的中间值</span></span><br><span class="line">    __middle = __first;<span class="comment">//middle初始化为区间的起始位置</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//middle向后移half位，此时middle为区间的中间值</span></span><br><span class="line">    <span class="keyword">if</span> (__comp(*__middle, __val)) &#123;<span class="comment">//若comp判断为true，则继续在右半部分查找</span></span><br><span class="line">		<span class="comment">//下面两行令first指向middle的下一个位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//调整查找区间的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __len = __half;<span class="comment">//否则查找左半部分</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">lower_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">return</span> __lower_bound(__first, __last, __val, __comp,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;<span class="comment">//定义区间的中间迭代器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间不为空，则在区间[first,last)开始查找value值</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//向右移一位，相当于除以2，即取区间的中间值</span></span><br><span class="line">    __middle = __first;<span class="comment">//middle初始化为区间的起始位置</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//middle向后移half位，此时middle为区间的中间值</span></span><br><span class="line">    <span class="keyword">if</span> (__val &lt; *__middle)<span class="comment">//若value小于中间元素值</span></span><br><span class="line">      __len = __half;<span class="comment">//查找左半部分</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//下面两行令first指向middle的下一个位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//更新len的值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在已排序区间[first,last)查找value值</span></span><br><span class="line"><span class="comment">//返回大于value值的第一个元素的迭代器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用operator&lt;比较</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp比较规则</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                               const T&amp; val, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __upper_bound(__first, __last, __val,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);</span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    __middle = __first;</span><br><span class="line">    advance(__middle, __half);</span><br><span class="line">    <span class="keyword">if</span> (__comp(__val, *__middle))</span><br><span class="line">      __len = __half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">upper_bound</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">return</span> __upper_bound(__first, __last, __val, __comp,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数举例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::lower_bound, std::upper_bound, std::sort</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;10,20,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(myints,myints+8);           // 10 20 30 30 20 10 10 20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator low,up;</span></span><br><span class="line"><span class="comment">	  low=std::lower_bound (v.begin(), v.end(), 20); //          ^</span></span><br><span class="line"><span class="comment">	  up= std::upper_bound (v.begin(), v.end(), 20); //                   ^</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "lower_bound at position " &lt;&lt; (low- v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "upper_bound at position " &lt;&lt; (up - v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	lower_bound at position 3</span></span><br><span class="line"><span class="comment">	upper_bound at position 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class">__<span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);<span class="comment">//计算区间的长度len</span></span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle, __left, __right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;<span class="comment">//若区间非空</span></span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;<span class="comment">//len右移一位，相等于除以2，即half为区间的长度的一半</span></span><br><span class="line">    __middle = __first;<span class="comment">//初始化middle的值</span></span><br><span class="line">    advance(__middle, __half);<span class="comment">//前进middle位置，使其指向区间中间位置</span></span><br><span class="line">    <span class="keyword">if</span> (*__middle &lt; __val) &#123;<span class="comment">//若指定元素value大于中间元素值，则在右半部分继续查找</span></span><br><span class="line">		<span class="comment">//下面两行使first指向middle的下一个位置，即右半区间的起始位置</span></span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;<span class="comment">//更新待查找区间的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__val &lt; *__middle)<span class="comment">//若指定元素value小于中间元素值，则在左半部分继续查找</span></span><br><span class="line">      __len = __half;<span class="comment">//更新待查找区间的长度</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//若指定元素value等于中间元素值</span></span><br><span class="line">		<span class="comment">//在前半部分找lower_bound位置</span></span><br><span class="line">      __left = lower_bound(__first, __middle, __val);</span><br><span class="line">      advance(__first, __len);</span><br><span class="line">	  <span class="comment">//在后半部分找upper_bound</span></span><br><span class="line">      __right = upper_bound(++__middle, __first, __val);</span><br><span class="line">      <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__left, __right);<span class="comment">//返回pair对象，第一个迭代器为left，第二个迭代器为right</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__first, __first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找区间与value相等的相邻重复元素的起始位置和结束位置</span></span><br><span class="line"><span class="comment">//注意：[first,last)是已排序，思想还是采用二分查找法</span></span><br><span class="line"><span class="comment">//同样也有两个版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns the bounds of the subrange that includes all the elements of the range [first,last) with values equivalent to val.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一默认operator&lt;</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">		pair&lt;ForwardIterator,ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">    equal_range (ForwardIterator first, ForwardIterator last, const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">		pair&lt;ForwardIterator,ForwardIterator&gt;</span></span><br><span class="line"><span class="comment">    equal_range (ForwardIterator first, ForwardIterator last, const T&amp; val,</span></span><br><span class="line"><span class="comment">                  Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class"><span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp, </span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __equal_range(__first, __last, __val,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class">__<span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __len = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __len);</span><br><span class="line">  _Distance __half;</span><br><span class="line">  _ForwardIter __middle, __left, __right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    __half = __len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    __middle = __first;</span><br><span class="line">    advance(__middle, __half);</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__middle, __val)) &#123;</span><br><span class="line">      __first = __middle;</span><br><span class="line">      ++__first;</span><br><span class="line">      __len = __len - __half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__comp(__val, *__middle))</span><br><span class="line">      __len = __half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __left = lower_bound(__first, __middle, __val, __comp);</span><br><span class="line">      advance(__first, __len);</span><br><span class="line">      __right = upper_bound(++__middle, __first, __val, __comp);</span><br><span class="line">      <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__left, __right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;_ForwardIter, _ForwardIter&gt;(__first, __first);</span><br><span class="line">&#125;           </span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;_ForwardIter, _ForwardIter&gt;</span></span><br><span class="line"><span class="class"><span class="title">equal_range</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">            _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp, </span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">return</span> __equal_range(__first, __last, __val, __comp,</span><br><span class="line">                       __DISTANCE_TYPE(__first));</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//equal_range函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::equal_range, std::sort</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool mygreater (int i,int j) &#123; return (i&gt;j); &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;10,20,30,30,20,10,10,20&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; v(myints,myints+8);                         // 10 20 30 30 20 10 10 20</span></span><br><span class="line"><span class="comment">	  std::pair&lt;std::vector&lt;int&gt;::iterator,std::vector&lt;int&gt;::iterator&gt; bounds;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  std::sort (v.begin(), v.end());                              // 10 10 10 20 20 20 30 30</span></span><br><span class="line"><span class="comment">	  bounds=std::equal_range (v.begin(), v.end(), 20);            //          ^        ^</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "bounds at positions " &lt;&lt; (bounds.first - v.begin());</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; " and " &lt;&lt; (bounds.second - v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	  // using "mygreater" as comp:</span></span><br><span class="line"><span class="comment">	  std::sort (v.begin(), v.end(), mygreater);                   // 30 30 20 20 20 10 10 10</span></span><br><span class="line"><span class="comment">	  bounds=std::equal_range (v.begin(), v.end(), 20, mygreater); //       ^        ^</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "bounds at positions " &lt;&lt; (bounds.first - v.begin());</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; " and " &lt;&lt; (bounds.second - v.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output：</span></span><br><span class="line"><span class="comment">	bounds at positions 3 and 6</span></span><br><span class="line"><span class="comment">	bounds at positions 2 and 5 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找法</span></span><br><span class="line"><span class="comment">//注意：[first,last)是已排序</span></span><br><span class="line"><span class="comment">//同样也有两个版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns true if any element in the range [first,last) is equivalent to val, and false otherwise.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一默认operator&lt;</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T&gt;</span></span><br><span class="line"><span class="comment">	bool binary_search (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                      const T&amp; val);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator, class T, class Compare&gt;</span></span><br><span class="line"><span class="comment">	bool binary_search (ForwardIterator first, ForwardIterator last,</span></span><br><span class="line"><span class="comment">                      const T&amp; val, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  _ForwardIter __i = lower_bound(__first, __last, __val);<span class="comment">//调用二分查找函数，并返回不小于value值的第一个迭代器位置i</span></span><br><span class="line">  <span class="keyword">return</span> __i != __last &amp;&amp; !(__val &lt; *__i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                   _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_SAME_TYPE(_Tp,</span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, _Tp, _Tp);</span><br><span class="line">  _ForwardIter __i = lower_bound(__first, __last, __val, __comp);<span class="comment">//调用二分查找函数，并返回不小于value值的第一个迭代器位置i</span></span><br><span class="line">  <span class="keyword">return</span> __i != __last &amp;&amp; !__comp(__val, *__i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// find_first_of, with and without an explicitly supplied comparison function.</span></span><br><span class="line"><span class="comment">//以[first2,last2)区间内的某些元素为查找目标，寻找他们在[first1,last1)区间首次出现的位置</span></span><br><span class="line"><span class="comment">//find_first_of函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：提供默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：提供用户自行指定的操作规则comp</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Returns an iterator to the first element in the range [first1,last1) that matches any of the elements in [first2,last2). </span></span><br><span class="line"><span class="comment">If no such element is found, the function returns last1.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_first_of (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                                   ForwardIterator2 first2, ForwardIterator2 last2);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_first_of (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                                   ForwardIterator2 first2, ForwardIterator2 last2,</span></span><br><span class="line"><span class="comment">                                   BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一：提供默认的equality操作operator==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">InputIter</span> <span class="title">find_first_of</span>(_<span class="title">InputIter</span> __<span class="title">first1</span>, _<span class="title">InputIter</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter</span> __<span class="title">first2</span>, _<span class="title">ForwardIter</span> __<span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>, </span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1) <span class="comment">//若序列一不为空，则遍历序列一，每次指定一个元素</span></span><br><span class="line">	  <span class="comment">//以下，根据序列二的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)</span><br><span class="line">      <span class="keyword">if</span> (*__first1 == *__iter)<span class="comment">//若序列一的元素等于序列二的元素，则表示找到</span></span><br><span class="line">        <span class="keyword">return</span> __first1;<span class="comment">//返回找到的位置</span></span><br><span class="line">  <span class="keyword">return</span> __last1;<span class="comment">//否则没找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：提供用户自行指定的操作规则comp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">InputIter</span> <span class="title">find_first_of</span>(_<span class="title">InputIter</span> __<span class="title">first1</span>, _<span class="title">InputIter</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter</span> __<span class="title">first2</span>, _<span class="title">ForwardIter</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1) </span><br><span class="line">    <span class="keyword">for</span> (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)</span><br><span class="line">      <span class="keyword">if</span> (__comp(*__first1, *__iter))</span><br><span class="line">        <span class="keyword">return</span> __first1;</span><br><span class="line">  <span class="keyword">return</span> __last1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find_first_of函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::find_first_of</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment">	#include &lt;cctype&gt;       // std::tolower</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool comp_case_insensitive (char c1, char c2) &#123;</span></span><br><span class="line"><span class="comment">	  return (std::tolower(c1)==std::tolower(c2));</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int mychars[] = &#123;'a','b','c','A','B','C'&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;char&gt; haystack (mychars,mychars+6);</span></span><br><span class="line"><span class="comment">	  std::vector&lt;char&gt;::iterator it;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  int needle[] = &#123;'A','B','C'&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  it = find_first_of (haystack.begin(), haystack.end(), needle, needle+3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "The first match is: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = find_first_of (haystack.begin(), haystack.end(),</span></span><br><span class="line"><span class="comment">						  needle, needle+3, comp_case_insensitive);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "The first match is: " &lt;&lt; *it &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	The first match is: A</span></span><br><span class="line"><span class="comment">	The first match is: a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end, with and without an explicitly supplied comparison function.</span></span><br><span class="line"><span class="comment">// Search [first2, last2) as a subsequence in [first1, last1), and return</span></span><br><span class="line"><span class="comment">// the *last* possible match.  Note that find_end for bidirectional iterators</span></span><br><span class="line"><span class="comment">// is much faster than for forward iterators.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end for forward iterators. </span></span><br><span class="line"><span class="comment">//若萃取出来的迭代器类型为正向迭代器forward_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> __<span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">forward_iterator_tag</span>, <span class="title">forward_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)<span class="comment">//若第二个区间为空</span></span><br><span class="line">    <span class="keyword">return</span> __last1;<span class="comment">//则直接返回第一个区间的尾端</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _ForwardIter1 __result = __last1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//以下利用search函数查找出某个子序列的首次出现点；若找不到直接返回last1</span></span><br><span class="line">      _ForwardIter1 __new_result</span><br><span class="line"></span><br><span class="line">        = search(__first1, __last1, __first2, __last2);</span><br><span class="line">      <span class="keyword">if</span> (__new_result == __last1)<span class="comment">//若返回的位置为尾端，则表示没找到</span></span><br><span class="line">        <span class="keyword">return</span> __result;<span class="comment">//返回last1</span></span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="comment">//若在[first1,last1)中找到[first2,last2)首次出现的位置，继续准备下一次查找</span></span><br><span class="line">		  </span><br><span class="line">        __result = __new_result;<span class="comment">//更新返回的位置</span></span><br><span class="line">        __first1 = __new_result;<span class="comment">//更新查找的起始位置</span></span><br><span class="line">        ++__first1;<span class="comment">//确定正确查找起始位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：指定规则</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter1</span> __<span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">forward_iterator_tag</span>, <span class="title">forward_iterator_tag</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first2 == __last2)</span><br><span class="line">    <span class="keyword">return</span> __last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _ForwardIter1 __result = __last1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      _ForwardIter1 __new_result</span><br><span class="line">        = search(__first1, __last1, __first2, __last2, __comp);</span><br><span class="line">      <span class="keyword">if</span> (__new_result == __last1)</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __result = __new_result;</span><br><span class="line">        __first1 = __new_result;</span><br><span class="line">        ++__first1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end for bidirectional iterators.  Requires partial specialization.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="comment">//若萃取出来的迭代器类型为双向迭代器bidirectional_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter1</span></span></span><br><span class="line"><span class="class">__<span class="title">find_end</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>, _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">           _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>, _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">           <span class="title">bidirectional_iterator_tag</span>, <span class="title">bidirectional_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter1, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter2, _BidirectionalIterator);</span><br><span class="line">  <span class="comment">//利用反向迭代器很快就可以找到</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter1&gt; _RevIter1;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter2&gt; _RevIter2;</span><br><span class="line"></span><br><span class="line">  _RevIter1 __rlast1(__first1);</span><br><span class="line">  _RevIter2 __rlast2(__first2);</span><br><span class="line">  <span class="comment">//查找时将序列一和序列二逆方向</span></span><br><span class="line">  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,</span><br><span class="line">                               _RevIter2(__last2), __rlast2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__rresult == __rlast1)<span class="comment">//表示没找到</span></span><br><span class="line">    <span class="keyword">return</span> __last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//找到了</span></span><br><span class="line">    _BidirectionalIter1 __result = __rresult.base();<span class="comment">//转会正常迭代器</span></span><br><span class="line">    advance(__result, -distance(__first2, __last2));<span class="comment">//调整回到子序列的起始位置</span></span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二：指定规则comp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter1</span>, <span class="title">class</span> _<span class="title">BidirectionalIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter1</span></span></span><br><span class="line"><span class="class">__<span class="title">find_end</span>(_<span class="title">BidirectionalIter1</span> __<span class="title">first1</span>, _<span class="title">BidirectionalIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">           _<span class="title">BidirectionalIter2</span> __<span class="title">first2</span>, _<span class="title">BidirectionalIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">           <span class="title">bidirectional_iterator_tag</span>, <span class="title">bidirectional_iterator_tag</span>, </span></span><br><span class="line"><span class="class">           _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter1, _BidirectionalIterator);</span><br><span class="line">  __STL_REQUIRES(_BidirectionalIter2, _BidirectionalIterator);</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter1&gt; _RevIter1;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;_BidirectionalIter2&gt; _RevIter2;</span><br><span class="line"></span><br><span class="line">  _RevIter1 __rlast1(__first1);</span><br><span class="line">  _RevIter2 __rlast2(__first2);</span><br><span class="line">  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,</span><br><span class="line">                               _RevIter2(__last2), __rlast2,</span><br><span class="line">                               __comp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__rresult == __rlast1)</span><br><span class="line">    <span class="keyword">return</span> __last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _BidirectionalIter1 __result = __rresult.base();</span><br><span class="line">    advance(__result, -distance(__first2, __last2));</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">		  <span class="comment">// Dispatching functions for find_end.</span></span><br><span class="line"><span class="comment">//find_end函数有两个版本：</span></span><br><span class="line"><span class="comment">//版本一：提供默认的equality操作operator==</span></span><br><span class="line"><span class="comment">//版本二：提供用户自行指定的操作规则comp</span></span><br><span class="line"><span class="comment">//注意：这里也有偏特化的知识</span></span><br><span class="line"><span class="comment">/*函数功能：Searches the range [first1,last1) for the last occurrence of the sequence defined by [first2,last2), </span></span><br><span class="line"><span class="comment">and returns an iterator to its first element, or last1 if no occurrences are found.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">equality (1)：版本一	</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                              ForwardIterator2 first2, ForwardIterator2 last2);</span></span><br><span class="line"><span class="comment">predicate (2)：版本二</span></span><br><span class="line"><span class="comment">	template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1,</span></span><br><span class="line"><span class="comment">                              ForwardIterator2 first2, ForwardIterator2 last2,</span></span><br><span class="line"><span class="comment">                              BinaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//对外接口的版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter1</span> </span></span><br><span class="line"><span class="class"><span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>, </span></span><br><span class="line"><span class="class">         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先通过iterator_traits萃取出first1和first2的迭代器类型</span></span><br><span class="line">  <span class="comment">//根据不同的迭代器类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __find_end(__first1, __last1, __first2, __last2,</span><br><span class="line">                    __ITERATOR_CATEGORY(__first1),</span><br><span class="line">                    __ITERATOR_CATEGORY(__first2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对外接口的版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter1</span> </span></span><br><span class="line"><span class="class"><span class="title">find_end</span>(_<span class="title">ForwardIter1</span> __<span class="title">first1</span>, _<span class="title">ForwardIter1</span> __<span class="title">last1</span>, </span></span><br><span class="line"><span class="class">         _<span class="title">ForwardIter2</span> __<span class="title">first2</span>, _<span class="title">ForwardIter2</span> __<span class="title">last2</span>,</span></span><br><span class="line"><span class="class">         _<span class="title">BinaryPredicate</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, <span class="keyword">bool</span>,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter1&gt;::value_type,</span><br><span class="line">   <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter2&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先通过iterator_traits萃取出first1和first2的迭代器类型</span></span><br><span class="line">  <span class="comment">//根据不同的迭代器类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __find_end(__first1, __last1, __first2, __last2,</span><br><span class="line">                    __ITERATOR_CATEGORY(__first1),</span><br><span class="line">                    __ITERATOR_CATEGORY(__first2),</span><br><span class="line">                    __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find_end函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::find_end</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool myfunction (int i, int j) &#123;</span></span><br><span class="line"><span class="comment">	  return (i==j);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  int myints[] = &#123;1,2,3,4,5,1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; haystack (myints,myints+10);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  int needle1[] = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using default comparison:</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator it;</span></span><br><span class="line"><span class="comment">	  it = std::find_end (haystack.begin(), haystack.end(), needle1, needle1+3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle1 last found at position " &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  int needle2[] = &#123;4,5,1&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // using predicate comparison:</span></span><br><span class="line"><span class="comment">	  it = std::find_end (haystack.begin(), haystack.end(), needle2, needle2+3, myfunction);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  if (it!=haystack.end())</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; "needle2 last found at position " &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	needle1 found at position 5</span></span><br><span class="line"><span class="comment">	needle2 found at position 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/Deque/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/Deque/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:15+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在介绍STL的deque的容器之前，我们先来总结一下vector和list的优缺点。vector在内存中是分配一段连续的内存空间进行存储，其迭代器采用原生指针即可，因此其支持随机访问和存储，支持下标操作符，节省空间。但是其在分配的内存不够的情况下，需要对容器整体进行重新分配、拷贝和释放等操作，而且在vector中间插入或删除元素效率很低。</p>
<p>而list是以节点形式来存放数据，使用的是非连续的内存空间来存放数据，因此，在其内部插入和删除元素的时间复杂度都是O(1),但是其不支持随机访问和存取，不支持下标，而且比vector占用的内存要多。</p>
<p>综合上述的优缺点，我们貌似需要一个支持随机访问和存取，支持下标访问，而且插入和删除的效率高的容器。于是，STL的deque诞生了，下面就跟着我一起去看看deque的设计和源码实现吧！</p>
<h1 id="Deque概述"><a href="#Deque概述" class="headerlink" title="Deque概述"></a>Deque概述</h1><p>vector是一个单向开口的容器，deque则是一个双向开口的容器，所谓双向开口就是再头尾两端均可以做元素的插入和删除操作。deque容器给我们的直观感觉大概是下面这样的(配图来自STL源码剖析)：</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79gw1fbkfqlslx9j30jk064jrp.jpg" alt="Deque"></p>
<p>deque相比于vector最大的差异就在于支持常熟时间内对首尾两端进行插入和删除操作，而且deque没有容量的概念，其内部采用分段连续内存空间来存储元素，在插入元素的时候随时都可以重新增加一段新的空间并链接起来。</p>
<p>deque提供了Ramdon Access Iterator，同时也支持随机访问和存取，但是它也为此付出了昂贵的代价，其复杂度不能跟vector的原生指针迭代器相提并论。在下面的讲解中会一一为大家介绍STL是怎样”辛苦地”维持一个随机访问迭代器的。</p>
<h1 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h1><p>deque为了维持整体连续的假象，设计一个中控器，其用来记录deque内部每一段连续空间的地址。大体上可以理解为deque中的每一段连续空间分布在内存的不连续空间上，然后用一个所谓的map作为主控，记录每一段内存空间的入口，从而做到整体连续的假象。其布局大概如下(配图来自STL源码剖析)</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkfql0k0oj30ig0fdq4a.jpg" alt="STLDequeMap"></p>
<p>看完图解，再来看看源码会很好理解的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向map, map是一个连续的空间, 其每个元素都是一个指向缓冲区的指针</span></span><br><span class="line">  map_pointer <span class="built_in">map</span>;</span><br><span class="line">  size_type map_size;   <span class="comment">// map容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛弃型别定义，我们可以看到map实际上就是一个指向指针的指针(T**)，map所指向的是一个指针，该指针指向型别为T的一块内存空间。理解到这里，大概就清楚了deque的实现原理，不过，这些都不是重点！重点是deque的各种运算符的实现。做好心理准备，咱们继续往下看！！！</p>
<h1 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h1><p>deque提供的是一个随机访问迭代器，由于是分段连续空间，其必须记录当前元素所在段的信息，从而在该段连续空间的边缘进行前进或者后退的时候能知道跳跃到的上一个或下一个缓冲区。deque必须完完全全地掌握和控制这些信息，以达到正确地跳跃！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意deque的迭代器没有重载STL的Iterator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下为支持Iterator_traits而定义的一些类型</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;      </span><br><span class="line">  <span class="keyword">typedef</span> T value_type;                                      </span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;                                       </span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;                                     </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;                        </span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存容器中的结点</span></span><br><span class="line">  T* cur;       <span class="comment">// 指向当前缓冲区中的元素</span></span><br><span class="line">  T* first;     <span class="comment">// 当前缓冲区的起点</span></span><br><span class="line">  T* last;      <span class="comment">// 当前缓冲区的终点</span></span><br><span class="line"></span><br><span class="line">  map_pointer node;   <span class="comment">// 指向管控中心</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">random_access_iterator_tag</span></span></span><br><span class="line"><span class="class"><span class="title">iterator_category</span>(<span class="title">const</span> __<span class="title">deque_iterator</span>&lt;T, Ref, Ptr, BufSiz&gt;&amp;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> random_access_iterator_tag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">value_type</span>(<span class="title">const</span> __<span class="title">deque_iterator</span>&lt;T, Ref, Ptr, BufSiz&gt;&amp;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ptrdiff_t</span>* <span class="title">distance_type</span>(<span class="title">const</span> __<span class="title">deque_iterator</span>&lt;T, Ref, Ptr, BufSiz&gt;&amp;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出，deque的迭代器中有cur,first,last和node四个指针，前三个记录了迭代器与缓冲区的联系，最后一个记录了迭代器于中控器的关系。从下面这张图可以很好的看出其关系：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfqm9euaj30mh0cft9h.jpg" alt="STLDequeIterator"></p>
<p>仅仅定义了迭代器结构还只是开始，迭代器是一个随机访问迭代器，所以其必须提供++，–，下标操作符等运算符。下面就来一一剖析吧！</p>
<h2 id="buffer-size函数"><a href="#buffer-size函数" class="headerlink" title="buffer_size函数"></a>buffer_size函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回deque的buffer_size大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(T)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果n不为0，传回n，表示buffer size由用户自己定义</span></span><br><span class="line"><span class="comment"> * 如果n为0，表示buffer_size采用默认值，</span></span><br><span class="line"><span class="comment"> * 				  那么如果sz(元素大小)小于512，传回512/sz</span></span><br><span class="line"><span class="comment"> * 					如果sz不小于512，传回1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-node函数"><a href="#set-node函数" class="headerlink" title="set_node函数"></a>set_node函数</h2><p>当迭代器处在当前缓冲区的边缘时，一旦前进或者后退，就要考虑超过当前缓冲区的情况，此时需要跳转到下一个缓冲区，这时候set_node就派上用场了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node = new_node;		<span class="comment">// 跳转到相应缓冲区</span></span><br><span class="line">  first = *new_node;	<span class="comment">// 更新跳转后缓冲区first信息</span></span><br><span class="line">  last = first + difference_type(buffer_size());  <span class="comment">// 更新跳转后缓冲区last的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="各种运算子"><a href="#各种运算子" class="headerlink" title="各种运算子"></a>各种运算子</h2><p>以下源码都是deque迭代器重载的运算子，以满足随机访问迭代器的要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断两个迭代器之间的距离，重载了‘-’运算子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +</span><br><span class="line">    (cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前缀自增，注意前缀自增返回自身引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">  ++cur;	<span class="comment">// 先自增当前元素的指针</span></span><br><span class="line">  <span class="keyword">if</span> (cur == last) &#123;	<span class="comment">// 判断是否为当前缓冲区最后一个</span></span><br><span class="line">    set_node(node + <span class="number">1</span>);	<span class="comment">// 如果为当前缓冲区最后一个，则跳转到下一个缓冲区</span></span><br><span class="line">    cur = first;	<span class="comment">// 更新为下一缓冲区的起始点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	后缀自增</span></span><br><span class="line"><span class="comment"> *	返回当前迭代器的一个副本, 并调用前缀自增运算符实现迭代器自身的自增</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line">  ++*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	前缀自减, 处理方式类似于前缀自增</span></span><br><span class="line"><span class="comment"> *	如果当前迭代器指向元素是当前缓冲区的第一个元素</span></span><br><span class="line"><span class="comment"> *	则将迭代器状态调整为前一个缓冲区的最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (cur == first) &#123;</span><br><span class="line">    set_node(node - <span class="number">1</span>);</span><br><span class="line">    cur = last;</span><br><span class="line">  &#125;</span><br><span class="line">  --cur;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理方法同后缀自增</span></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line">  --*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	实现p+=n的功能</span></span><br><span class="line"><span class="comment"> *	迭代器向前移动n个元素，其中n可能为负。实现步骤如下：</span></span><br><span class="line"><span class="comment"> *	1、计算相对于该缓冲区起始位置的偏移量offset</span></span><br><span class="line"><span class="comment"> *	2、如果offset没有超出缓冲区，则直接cur+=n</span></span><br><span class="line"><span class="comment"> *	3、如果offset超过了缓冲区空间</span></span><br><span class="line"><span class="comment"> *			-- 如果offset大于0，计算向前移动多少个缓冲区，offset / difference_type(buffer_size())</span></span><br><span class="line"><span class="comment"> *			-- 如果offset小于0，计算向后移动多少个缓冲区,-difference_type((-offset - 1) / buffer_size()) - 1;</span></span><br><span class="line"><span class="comment"> *	4、调整到移动后的位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)</span><br><span class="line">&#123;</span><br><span class="line">  difference_type offset = n + (cur - first);</span><br><span class="line">  <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))</span><br><span class="line">    cur += n;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    difference_type node_offset =</span><br><span class="line">      offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size())</span><br><span class="line">                 : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;</span><br><span class="line">    set_node(node + node_offset);</span><br><span class="line">    cur = first + (offset - node_offset * difference_type(buffer_size()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现诸如p+n的功能</span></span><br><span class="line"><span class="comment"> * 此函数中直接调用operator +=的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里调用了operator +=()可以自动调整指针状态</span></span><br><span class="line">  <span class="keyword">return</span> tmp += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现p-=n的功能</span></span><br><span class="line"><span class="comment"> * 此处直接利用operator += ，改变一下n的正负即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现p-n的功能</span></span><br><span class="line"><span class="comment"> * 直接调用operator -=的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">  self tmp = *<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp -= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下标运算子，支持随机存取的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下述都是一些判断运算的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h1><p>先前在deque的中控器中讲到，deque维护着一个map，用来记录每个缓冲区的位置。除了map外，deque的数据结构中还维护着start和finish两个迭代器，分别指向deque的首尾。此外，它还必须知道map的大小，一旦map所提供的节点不足，就需要配置一块更大的map。</p>
<p>接下来，我们来看看deque的数据结构源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="comment">// 这里省略一堆支持iterator_traits型别定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;  iterator;	<span class="comment">// deque的迭代器</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  iterator start;               <span class="comment">// 表中第一个节点</span></span><br><span class="line">  iterator finish;              <span class="comment">// 表中最后一个节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是前面讲到map指针，用来记录每一个缓冲区的地址</span></span><br><span class="line">  map_pointer <span class="built_in">map</span>;</span><br><span class="line">  size_type map_size;   <span class="comment">// map容量 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//	deque专属空间配置器，每次配置一个元素大小</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">  <span class="comment">//	deque专属空间配置器，每次配置一个指针大小</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配内存, 不进行构造</span></span><br><span class="line">	<span class="function">pointer <span class="title">allocate_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_allocator::allocate(buffer_size()); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放内存, 不进行析构</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate_node</span><span class="params">(pointer n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		data_allocator::deallocate(n, buffer_size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述结构体下，可以很轻松地实现“连续”容器的各种机能函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;	<span class="comment">// 返回第一个节点的迭代器</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;		<span class="comment">// 返回最后一个节点的迭代器</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;	<span class="comment">// const版本</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;		<span class="comment">// const版本</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *	提供随机访问的下标运算子</span></span><br><span class="line"><span class="comment">   *	这里计算实际地址的时候是经过一系列的计算得到的，效率上有缺失</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> start[difference_type(n)]; &#125;</span><br><span class="line">  const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> start[difference_type(n)];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 以下函数分别返回首尾元素的引用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> *tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    const_iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> *tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//	返回deque的大小，这里直接调用迭代器重载的‘-’运算符 </span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish - start;; &#125;</span><br><span class="line">  <span class="comment">//	返回deque最大容量</span></span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// deque为空的时, 只有一个缓冲区</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="deque的构造函数"><a href="#deque的构造函数" class="headerlink" title="deque的构造函数"></a>deque的构造函数</h1><p>deque和vector、list一样，提供了多种构造函数。我们先来看看默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>() : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  create_map_and_nodes(<span class="number">0</span>);	<span class="comment">// 直接调用create_map_and_nodes函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map最少为8个</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_type <span class="title">initial_map_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建内部使用的map，并配置每一个缓冲区</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:create_map_and_nodes(size_type num_elements)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 需要的结点数, 元素个数 / 每个缓冲区能容纳的元素数 + 1</span></span><br><span class="line">  <span class="comment">// 这里如果能整除，会多分配一个</span></span><br><span class="line">  size_type num_nodes = num_elements / buffer_size() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map要维护的结点, 这里最小的值为8，最多为所需节点数+1，前后各留一个以便扩充</span></span><br><span class="line">  map_size = max(initial_map_size(), num_nodes + <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 调用deque专属空间配置器，配置map空间</span></span><br><span class="line">  <span class="built_in">map</span> = map_allocator::allocate(map_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将[nstart, nfinish)区间设置在map的中间,</span></span><br><span class="line">  <span class="comment">// 这样就能保证前后增长而尽可能减少map的重新分配次数</span></span><br><span class="line">  map_pointer nstart = <span class="built_in">map</span> + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">  map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配结点空间</span></span><br><span class="line">  map_pointer cur;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> (cur = nstart; cur &lt;= nfinish; ++cur)</span><br><span class="line">    	<span class="comment">// 为每一个map指针指向的缓冲区的每一个元素分配内存空间 </span></span><br><span class="line">      *cur = allocate_node();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 维护指针状态，为deque的两个迭代器start和finish赋初值</span></span><br><span class="line">  start.set_node(nstart);</span><br><span class="line">  finish.set_node(nfinish);</span><br><span class="line">  start.cur = start.first;</span><br><span class="line">  finish.cur = finish.first + num_elements % buffer_size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了默认构造函数，deque还提供了一系列的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span>&amp; x)</span><br><span class="line">  : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 配置map和元素</span></span><br><span class="line">  create_map_and_nodes(x.size());</span><br><span class="line">  <span class="comment">// 将x的元素拷贝到本deque内</span></span><br><span class="line">  uninitialized_copy(x.begin(), x.end(), start);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个deque，含有n个值为value的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">deque</span>(size_type n, <span class="keyword">const</span> value_type&amp; value)</span><br><span class="line">  : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  fill_initialize(n, value);	<span class="comment">// 调用fill_initialize函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配n个结点, 并以value为元素值初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:fill_initialize(size_type n,</span><br><span class="line">    <span class="keyword">const</span> value_type&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">  create_map_and_nodes(n);	<span class="comment">// 配置map和缓冲区</span></span><br><span class="line">  map_pointer cur;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">  	<span class="comment">// 为每一个缓冲区设定初值</span></span><br><span class="line">    <span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur)</span><br><span class="line">      uninitialized_fill(*cur, *cur + buffer_size(), value);</span><br><span class="line">    <span class="comment">// 尾端可能留有备用空间，不必设初值</span></span><br><span class="line">    uninitialized_fill(finish.first, finish.cur, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (map_pointer n = start.node; n &lt; cur; ++n)</span><br><span class="line">      destroy(*n, *n + buffer_size());</span><br><span class="line">    destroy_map_and_nodes();</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以区间值来构造deque</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">deque</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  :</span> start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  range_initialize(first, last, iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;class ForwardIterator&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:range_initialize(ForwardIterator first,</span><br><span class="line">    ForwardIterator last,</span><br><span class="line">    forward_iterator_tag) &#123;</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line">  distance(first, last, n);	<span class="comment">// 计算有多少个元素</span></span><br><span class="line">  create_map_and_nodes(n);	<span class="comment">// 配置map和缓冲区</span></span><br><span class="line">  uninitialized_copy(first, last, start);	<span class="comment">// 调用全局函数，将[first,last)拷贝到新配置的空间上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，deque还提供了很多种构造函数，基本上都调用上述函数来构造map和缓冲区，这里就不在赘述！</p>
<h1 id="deque的析构函数"><a href="#deque的析构函数" class="headerlink" title="deque的析构函数"></a>deque的析构函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">deque</span>()</span><br><span class="line">&#123;</span><br><span class="line">  destroy(start, finish);     <span class="comment">// 调用全局函数</span></span><br><span class="line">  destroy_map_and_nodes();		<span class="comment">// 释放map和缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:destroy_map_and_nodes()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt;= finish.node; ++cur)</span><br><span class="line">    deallocate_node(*cur);	<span class="comment">// 释放每一个节点</span></span><br><span class="line">  map_allocator::deallocate(<span class="built_in">map</span>, map_size);	<span class="comment">// 释放map空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="deque支持的操作函数"><a href="#deque支持的操作函数" class="headerlink" title="deque支持的操作函数"></a>deque支持的操作函数</h1><h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><p>push_back完成在尾部插入一个元素，根绝上述的deque的结构特点，里面有很多情况需要考虑。</p>
<ul>
<li>如果备用空间足够，就直接push进去</li>
<li>如果备用空间不足，就要考虑配置一个新的缓冲区</li>
</ul>
<p>配置新缓冲区的时候，还需要考虑map空间是否足够</p>
<ul>
<li>如果map空间足够，就直接配置一块新的缓冲区，链接到map中</li>
<li>如果map空间不足，就需要考虑重新配置一块map</li>
</ul>
<p>可见，为了维持整体连续的假象，确确实实，deque的操作函数需要考虑各个方面。下面来看看源代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在deque的尾部压入一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 注意这里采用STL的前闭后开原则</span></span><br><span class="line">  <span class="comment">// 所以last要-1</span></span><br><span class="line">  <span class="comment">// 如果deque里面还有备用空间，则直接压入</span></span><br><span class="line">  <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">    construct(finish.cur, t);</span><br><span class="line">    ++finish.cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 容量已满就要新申请内存了</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    push_back_aux(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅当finish.cur == finish.last - 1才调用</span></span><br><span class="line"><span class="comment"> * 即最后一个缓冲区没有空间才调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:push_back_aux(<span class="keyword">const</span> value_type&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">  value_type t_copy = t;</span><br><span class="line">  <span class="comment">// 判断是否需要调整map空间</span></span><br><span class="line">  reserve_map_at_back();</span><br><span class="line">  *(finish.node + <span class="number">1</span>) = allocate_node();	<span class="comment">// 配置一块新的缓冲区</span></span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    construct(finish.cur, t_copy);	<span class="comment">// 构造新加入的元素</span></span><br><span class="line">    finish.set_node(finish.node + <span class="number">1</span>);	<span class="comment">// 调整finish</span></span><br><span class="line">    finish.cur = finish.first;</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(deallocate_node(*(finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map空间不足，需要调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - <span class="built_in">map</span>))</span><br><span class="line">		<span class="comment">// 此时，需要调整map，更换一个更大的map</span></span><br><span class="line">		reallocate_map(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新配置map, 不会对缓冲区进行操作, map维护的是指向缓冲区的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:reallocate_map(size_type nodes_to_add,</span><br><span class="line">    <span class="keyword">bool</span> add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">  size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line"></span><br><span class="line">  map_pointer new_nstart;</span><br><span class="line">  <span class="comment">// 此处为了防止出现一端已经用完，另一端却还有很多剩余的情况</span></span><br><span class="line">  <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">  	<span class="comment">// 调整新的map中的起始点</span></span><br><span class="line">    new_nstart = <span class="built_in">map</span> + (map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                 + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果前端剩余很多</span></span><br><span class="line">    <span class="keyword">if</span> (new_nstart &lt; start.node)</span><br><span class="line">      copy(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">// 尾端剩余很多</span></span><br><span class="line">      copy_backward(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;	<span class="comment">// map不够用了，就需要配置一块更大的map</span></span><br><span class="line">    size_type new_map_size = map_size + max(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 配置一块大的map</span></span><br><span class="line">    map_pointer new_map = map_allocator::allocate(new_map_size);</span><br><span class="line">    <span class="comment">// 始终要使start和finish处在map空间的中间</span></span><br><span class="line">    new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                 + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 拷贝到新的map空间中去</span></span><br><span class="line">    copy(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">    <span class="comment">// 释放旧的空间</span></span><br><span class="line">    map_allocator::deallocate(<span class="built_in">map</span>, map_size);</span><br><span class="line">    <span class="comment">// 改变map和size参数</span></span><br><span class="line">    <span class="built_in">map</span> = new_map;</span><br><span class="line">    map_size = new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调整新的start和finish</span></span><br><span class="line">  start.set_node(new_nstart);</span><br><span class="line">  finish.set_node(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h2><p>pop_back是将deque的尾部元素弹出，即拿掉该元素并释放空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果尾端不是该缓冲区最开始的那个元素</span></span><br><span class="line">  <span class="keyword">if</span> (finish.cur != finish.first) &#123;</span><br><span class="line">    --finish.cur;</span><br><span class="line">    destroy(finish.cur);  <span class="comment">// 直接拿掉并释放空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pop_back_aux();   <span class="comment">// 需要调整map的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在pop_back中，如果碰到为首元素的情况，调用此函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>: pop_back_aux()</span><br><span class="line">&#123;</span><br><span class="line">  deallocate_node(finish.first);	<span class="comment">// 释放节点</span></span><br><span class="line">  finish.set_node(finish.node - <span class="number">1</span>);	<span class="comment">// 重新设定finish</span></span><br><span class="line">  finish.cur = finish.last - <span class="number">1</span>;</span><br><span class="line">  destroy(finish.cur);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h2><p>此函数用来在deque的头部压入一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 还是一样，不需要调整map的情况，直接压入</span></span><br><span class="line">  <span class="keyword">if</span> (start.cur != start.first) &#123;</span><br><span class="line">    construct(start.cur - <span class="number">1</span>, t);</span><br><span class="line">    --start.cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    push_front_aux(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有再start.cur== start.first的情况下调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:push_front_aux(<span class="keyword">const</span> value_type&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">  value_type t_copy = t;</span><br><span class="line">  reserve_map_at_front();	<span class="comment">// 同push_back()，检查是否需要调整map</span></span><br><span class="line">  *(start.node - <span class="number">1</span>) = allocate_node();	<span class="comment">// 配置一块新的缓冲区</span></span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    start.set_node(start.node - <span class="number">1</span>);	<span class="comment">// 调整start</span></span><br><span class="line">    start.cur = start.last - <span class="number">1</span>;</span><br><span class="line">    construct(start.cur, t_copy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    start.set_node(start.node + <span class="number">1</span>);</span><br><span class="line">    start.cur = start.first;</span><br><span class="line">    deallocate_node(*(start.node - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-front"><a href="#pop-front" class="headerlink" title="pop_front"></a>pop_front</h2><p>此函数实现从头部弹出一个元素，同pop_back()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    destroy(start.cur);</span><br><span class="line">    ++start.cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pop_front_aux();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在start.cur == start.last - 1的时候调用</span></span><br><span class="line"><span class="comment"> * 此时需要调整map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:pop_front_aux()</span><br><span class="line">&#123;</span><br><span class="line">  destroy(start.cur);</span><br><span class="line">  deallocate_node(start.first);</span><br><span class="line">  start.set_node(start.node + <span class="number">1</span>);</span><br><span class="line">  start.cur = start.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>擦除deque中的每一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:clear()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 首先析构除起点和终点的所有元素, 并释放相应空间</span></span><br><span class="line">  <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;</span><br><span class="line">    destroy(*node, *node + buffer_size());</span><br><span class="line">    data_allocator::deallocate(*node, buffer_size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果deque本身不为空, 析构所有对象, 并释放掉结尾的内存</span></span><br><span class="line">  <span class="keyword">if</span> (start.node != finish.node) &#123;</span><br><span class="line">    destroy(start.cur, start.last);  <span class="comment">// 将头缓冲区的元素清除</span></span><br><span class="line">    destroy(finish.first, finish.cur);  <span class="comment">//将尾缓冲区的元素清除</span></span><br><span class="line">    data_allocator::deallocate(finish.first, buffer_size()); <span class="comment">// 头缓冲区保留，释放尾缓冲区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 析构所有元素, 但是不释放空间, 因为deque要满足这个前置条件</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    destroy(start.cur, finish.cur);</span><br><span class="line"></span><br><span class="line">  finish = start; <span class="comment">// 调整finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><p>erase实现了擦除单个指定元素和擦出区间两个版本，源代码分析如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此函数实现擦除单个指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  iterator next = pos;</span><br><span class="line">  ++next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算待擦除点前的元素个数</span></span><br><span class="line">  difference_type index = pos - start;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断待擦除结点前后元素的个数, 哪部分少就移动哪部分</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 前面部分的元素少</span></span><br><span class="line">    copy_backward(start, pos, next);  </span><br><span class="line">    pop_front();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后面部分的元素少</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    copy(next, finish, pos); </span><br><span class="line">    pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> start + index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>擦除[first,last)区间的元素。此函数按下列步骤来擦除区间。</p>
<ul>
<li>需要擦除整个空间，直接调用clear()</li>
<li>需要擦出中间指定区间</li>
</ul>
<p>擦除中间指定区间，需要考虑一下两种情况</p>
<ul>
<li>区间前面的元素少，就移动前面的元素</li>
<li>区间后面的元素少，就移动后面的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123;	<span class="comment">// 需要擦除整个deque</span></span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">return</span> finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    difference_type n = last - first;	<span class="comment">// 清除区间的长度</span></span><br><span class="line">    difference_type elems_before = first - start;  <span class="comment">// 待清除区间前方的元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (elems_before &lt; (size() - n) / <span class="number">2</span>) &#123;	<span class="comment">// 如果前方的元素个数较少</span></span><br><span class="line">      copy_backward(start, first, last);	<span class="comment">// 向后移动前方元素</span></span><br><span class="line">      iterator new_start = start + n;     <span class="comment">// 调整新的起始点</span></span><br><span class="line">      destroy(start, new_start);          <span class="comment">// 全局函数，析构节点元素</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());   <span class="comment">// 释放缓冲区空间</span></span><br><span class="line">      start = new_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">// 后方元素比较少的情况</span></span><br><span class="line">      copy(last, finish, first);	<span class="comment">// 向前移动后方元素</span></span><br><span class="line">      iterator new_finish = finish - n; <span class="comment">// 调整新的finish迭代器</span></span><br><span class="line">      destroy(new_finish, finish);      <span class="comment">// 全局函数，析构节点元素</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());  <span class="comment">// 释放缓冲区空间</span></span><br><span class="line">      finish = new_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + elems_before;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>在指定位置前插入元素，deque的源码中，为insert提供了多个版本，这里列举插入一个元素和n和元素的版本。</p>
<p>在指定位置插入一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果是在deque的最前端插入, 那么直接push_front()即可</span></span><br><span class="line">  <span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">    push_front(x);</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是在deque的末尾插入, 直接调用push_back()</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;</span><br><span class="line">    push_back(x);</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> insert_aux(position, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不在首尾插入元素的时候调用此函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  difference_type index = pos - start;  <span class="comment">// 插入元素前面的元素个数</span></span><br><span class="line">  value_type x_copy = x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>) &#123;  <span class="comment">// 如果前端的元素比较少</span></span><br><span class="line">    push_front(front());  <span class="comment">// 在最前面插入一个与第一个元素一样的数</span></span><br><span class="line">    iterator front1 = start;  <span class="comment">// 记录起始点</span></span><br><span class="line">    ++front1;</span><br><span class="line">    iterator front2 = front1; </span><br><span class="line">    ++front2;</span><br><span class="line">    pos = start + index;</span><br><span class="line">    iterator pos1 = pos;</span><br><span class="line">    ++pos1;</span><br><span class="line">    copy(front2, pos1, front1); <span class="comment">// 拷贝空间，将[front2,pos1)拷贝到front1以后</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;   <span class="comment">// 后端的元素比较少，原理用上</span></span><br><span class="line">    push_back(back());</span><br><span class="line">    iterator back1 = finish;</span><br><span class="line">    --back1;</span><br><span class="line">    iterator back2 = back1;</span><br><span class="line">    --back2;</span><br><span class="line">    pos = start + index;</span><br><span class="line">    copy_backward(pos, back2, back1);</span><br><span class="line">  &#125;</span><br><span class="line">  *pos = x_copy;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在指定位置插入n个元素的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:insert(iterator pos,</span><br><span class="line">                                      size_type n, <span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos.cur == start.cur) &#123;   <span class="comment">// 如果插入点再最前端</span></span><br><span class="line">    iterator new_start = reserve_elements_at_front(n); <span class="comment">// 调整新的start位置</span></span><br><span class="line">    uninitialized_fill(new_start, start, x);	<span class="comment">//直接在前端构造n个元素</span></span><br><span class="line">    start = new_start;  <span class="comment">// 调整新的start</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pos.cur == finish.cur) &#123;</span><br><span class="line">  	<span class="comment">// 与reserve_elements_at_front相同</span></span><br><span class="line">  	<span class="comment">// 考虑篇幅，这里不列出源代码</span></span><br><span class="line">    iterator new_finish = reserve_elements_at_back(n); </span><br><span class="line">    uninitialized_fill(finish, new_finish, x);</span><br><span class="line">    finish = new_finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    insert_aux(pos, n, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入区间前方备用空间能否容纳n个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">iterator <span class="title">reserve_elements_at_front</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  size_type vacancies = start.cur - start.first;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; vacancies)   <span class="comment">// 如果容纳不了，就需要重新配置map</span></span><br><span class="line">    new_elements_at_front(n - vacancies);</span><br><span class="line">  <span class="keyword">return</span> start - difference_type(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在前方备用空间容纳不了待插入的n个元素的情况下调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:new_elements_at_front(size_type new_elements)</span><br><span class="line">&#123;</span><br><span class="line">  size_type new_nodes = (new_elements + buffer_size() - <span class="number">1</span>) / buffer_size();</span><br><span class="line">  reserve_map_at_front(new_nodes);  <span class="comment">// 调整map</span></span><br><span class="line">  size_type i;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= new_nodes; ++i)</span><br><span class="line">      *(start.node - i) = allocate_node(); <span class="comment">// 为每一个map指针配置空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">      deallocate_node(*(start.node - j));</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整map的前端，以在前端能连接更多缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nodes_to_add &gt; start.node - <span class="built_in">map</span>)</span><br><span class="line">    reallocate_map(nodes_to_add, <span class="literal">true</span>);  <span class="comment">// 此函数上面有说明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 好吧，这里才是最重要的insert_aux函数，实现在中间某个位置插入n个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:insert_aux(iterator pos,</span><br><span class="line">    size_type n, <span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> difference_type elems_before = pos - start;  <span class="comment">// 计算该位置前面的元素个数</span></span><br><span class="line">  size_type length = size();</span><br><span class="line">  value_type x_copy = x;</span><br><span class="line">  <span class="keyword">if</span> (elems_before &lt; length / <span class="number">2</span>) &#123;  <span class="comment">// 如果位置前面的元素比较少</span></span><br><span class="line">    iterator new_start = reserve_elements_at_front(n); <span class="comment">// 同上</span></span><br><span class="line">    iterator old_start = start;</span><br><span class="line">    pos = start + elems_before;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_before &gt;= difference_type(n)) &#123; </span><br><span class="line">        iterator start_n = start + difference_type(n);</span><br><span class="line">        uninitialized_copy(start, start_n, new_start);</span><br><span class="line">        start = new_start;</span><br><span class="line">        copy(start_n, pos, old_start);</span><br><span class="line">        fill(pos - difference_type(n), pos, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __uninitialized_copy_fill(start, pos, new_start, start, x_copy);</span><br><span class="line">        start = new_start;</span><br><span class="line">        fill(old_start, pos, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(destroy_nodes_at_front(new_start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;   <span class="comment">// 该位置后面的元素比较少</span></span><br><span class="line">    iterator new_finish = reserve_elements_at_back(n);</span><br><span class="line">    iterator old_finish = finish;</span><br><span class="line">    <span class="keyword">const</span> difference_type elems_after = difference_type(length) - elems_before;</span><br><span class="line">    pos = finish - elems_after;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; difference_type(n)) &#123;</span><br><span class="line">        iterator finish_n = finish - difference_type(n);</span><br><span class="line">        uninitialized_copy(finish_n, finish, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        copy_backward(pos, finish_n, old_finish);</span><br><span class="line">        fill(pos, pos + difference_type(n), x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __uninitialized_fill_copy(finish, pos + difference_type(n),</span><br><span class="line">        x_copy,</span><br><span class="line">        pos, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        fill(pos, old_finish, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(destroy_nodes_at_back(new_finish));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/LeeCode/下一个排列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/LeeCode/下一个排列/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:15+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a><strong>下一个排列</strong></h4><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<ol>
<li>判断按照字典序有木有下一个，如果完全降序就没有下一个</li>
<li>如何判断有木有下一个呢？只要存在a[i-1] &lt; a[i]的升序结构，就有，而且我们应该从右往左找，一旦找到，因为这样才是真正下一个</li>
<li>当发现a[i-1] &lt; a[i]的结构时，从在[i, ∞]中找到最接近a[i-1]并且又大于a[i-1]的数字，由于降序，从右往左遍历即可得到k</li>
<li>然后交换a[i-1]与a[k]，然后对[i, ∞]排序即可，排序只需要首尾不停交换即可，因为已经是降序 上面说的很抽象，还是需要拿一些例子思考才行，比如[0,5,4,3,2,1]，下一个是[1,0,2,3,4,5]</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;nums[j]&lt;=nums[j<span class="number">-1</span>])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="comment">//在这里去判断排列的情况 看看是不是一直降序</span></span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()/<span class="number">2</span>;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i],nums[nums.size()<span class="number">-1</span>-i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1 2 4</span></span><br><span class="line">        <span class="keyword">int</span> r=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r]&gt;nums[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[r], nums[j<span class="number">-1</span>]);</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">int</span> cnt = (nums.size() - j)/<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            swap(nums[j+i], nums[nums.size() - <span class="number">1</span> - i]);</span><br><span class="line">            ++i; --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/C++基础知识/链表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/C++基础知识/链表/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:15+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2></li>
<li><p>双向链表属于链表的一种，也叫双链表双向即是说它的链接方向是双向的，它由若干个节点组成，每个节点都包含下一个节点和上一个节点的指针，所以从双向链表的任意节点开始，都能很方便访问他的前驱结点和后继节点。（此时可以前项访问前面一个节点和后面的节点）</p>
</li>
<li></li>
<li><p>特点</p>
</li>
<li><ul>
<li>创建双链表时无需指定链表的长度。(和单链表一样)</li>
<li>比起单链表，双链表需要多一个指针用于指向前驱节点，所以需要存储空间比单链表多一点。(多一个节点存储数据)</li>
<li>双链表的插入和删除需要同时维护       next 和 prev 两个指针。</li>
<li>双链表中的元素访问需要通过顺序访问，即要通过遍历的方式来寻找元素。</li>
</ul>
</li>
<li></li>
<li><p><img src="file:///C:/Users/CCTVZYX/AppData/Local/Temp/msohtmlclip1/01/clip_image001.jpg" alt="âååé¾è¡¨c++ å¾âçå¾çæç´¢ç»æ"></p>
</li>
<li><p><strong>（1）定义双向链表的基本结构</strong></p>
</li>
<li><p>typedef struct  _DOUBLE_LINK_NODE<br>   {</p>
<pre><code>int data;  //存放的数据</code></pre></li>
<li><p>​    struct _DOUBLE_LINK_NODE* prev;//指向前一个节点</p>
</li>
<li><p>​     struct _DOUBLE_LINK_NODE* next;//指向后一个节点</p>
</li>
<li><p>}DOUBLE_LINK_NODE;</p>
</li>
<li><p>（2）创建双向链表节点</p>
</li>
<li><p>DOUBLE_LINK_NODE*  create_double_link_node(int value) //传入一个值</p>
</li>
<li><p>{</p>
<pre><code>DOUBLE_LINK_NODE* pDLinkNode =  NULL;
pDLinkNode = (DOUBLE_LINK_NODE*)malloc(sizeof(DOUBLE_LINK_NODE));//配值空间</code></pre></li>
<li><p>​    assert(NULL != pDLinkNode);</p>
</li>
<li><p>​       memset(pDLinkNode, 0,  sizeof(DOUBLE_LINK_NODE)); //初始化函数</p>
</li>
<li></li>
<li><p>void *memset(void *s, int ch, size_t n);</p>
</li>
<li><p>函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t  ）用 ch 替换并返回 s 。</p>
</li>
<li></li>
<li><p>​    pDLinkNode-&gt;data =  value;<br>​       return pDLinkNode;<br>   }</p>
</li>
<li><p><strong>（**</strong>3<strong>**）删除双向链表</strong></p>
</li>
<li><p>void  delete_all_double_link_node(DOUBLE_LINK_NODE** pDLinkNode)<br>   {</p>
<pre><code>DOUBLE_LINK_NODE* pNode;
if(NULL == *pDLinkNode)
    return ;</code></pre></li>
<li></li>
<li><p>pNode = *pDLinkNode;</p>
<pre><code>*pDLinkNode = pNode-&gt;next;//下一个节点</code></pre></li>
<li><p>​    free(pNode);</p>
</li>
<li><p>下面是递归调用delete_all_double_link_node（）;一直到把所有节点释放完毕</p>
</li>
<li><p>​     delete_all_double_link_node(pDLinkNode);<br>   }</p>
</li>
<li><p><strong>（**</strong>4<strong>**）在双向链表中查找数据</strong></p>
</li>
<li><p>DOUBLE_LINK_NODE*  find_data_in_double_link(const DOUBLE_LINK_NODE* pDLinkNode, int data)<br>   {</p>
<pre><code>DOUBLE_LINK_NODE* pNode =  NULL;
if(NULL == pDLinkNode)
    return NULL;</code></pre></li>
<li><p>pNode =  (DOUBLE_LINK_NODE*)pDLinkNode;</p>
</li>
<li><p>简单的循环查找数据</p>
</li>
<li><p>​    while(NULL != pNode){<br>​           if(data ==  pNode-&gt;data)<br>​               return pNode;<br>​           pNode = pNode -&gt;next;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>return  NULL;<br>   }</p>
</li>
<li><p><strong>（**</strong>5<strong>**）双向链表中插入数据（相当的不严谨，你是插在前面呢？还是插在后面？）</strong></p>
</li>
<li><p>STATUS  insert_data_into_double_link(DOUBLE_LINK_NODE** ppDLinkNode, int data)<br>   {</p>
<pre><code>DOUBLE_LINK_NODE* pNode;
DOUBLE_LINK_NODE* pIndex;</code></pre></li>
<li><p>if(NULL == ppDLinkNode)</p>
<pre><code>return FALSE;</code></pre></li>
<li><p>整个双向链表中没有数据，插入的是第一个数据</p>
</li>
<li><p>if(NULL == *ppDLinkNode){</p>
<pre><code>    pNode =  create_double_link_node(data);
    assert(NULL != pNode);
    *ppDLinkNode = pNode;
    (*ppDLinkNode)-&gt;prev =  (*ppDLinkNode)-&gt;next = NULL;
    return TRUE;
}</code></pre></li>
<li></li>
<li><p>if(NULL !=  find_data_in_double_link(*ppDLinkNode, data))</p>
<pre><code>return FALSE;</code></pre></li>
<li></li>
<li><p>pNode = create_double_link_node(data);</p>
<pre><code>assert(NULL != pNode);</code></pre></li>
<li><p>pIndex = *ppDLinkNode;</p>
<pre><code>while(NULL !=  pIndex-&gt;next)
pIndex =  pIndex-&gt;next;</code></pre></li>
<li><p>​        pNode-&gt;prev = pIndex;<br>​       pNode-&gt;next =  pIndex-&gt;next;<br>​       pIndex-&gt;next = pNode;<br>​       return TRUE;<br>   }</p>
</li>
<li><p>（<strong>5**</strong>）双向链表中插入数据（自己手写严谨代码明确要求插入在之前好是之后，不是直接乱码七八遭的插入，我<strong><strong>c</strong></strong>你大爷的<strong><strong>C</strong></strong>）**</p>
</li>
<li><p>void  DoubleList::insertNode_before_i(DOUBLE_LINK_NODE*head,int cahdata,int i)</p>
</li>
<li><p>{</p>
</li>
<li><p>if(DOUBLE_LINK_NODE==null)</p>
</li>
<li><p>​    return null; </p>
</li>
<li><p>//因为要插入一个节点，所以需要分配一个节点的空间，这里应该也可以直接使用creat</p>
</li>
<li><p>DOUBLE_LINK_NODE<em>one,</em>two;</p>
</li>
<li><p>one=(DOUBLE_LINK_NODE*)malloc(sizeof(DOUBLE_LINK_NODE));</p>
</li>
<li><p>one-&gt;data=chadata;</p>
</li>
<li><p>//插入的时候考虑到插入的位置，没有节点,，要在头节点插入</p>
</li>
<li><p>if(i==0)</p>
</li>
<li><p>​    {</p>
</li>
<li><p>​      one-&gt;next=head-&gt;next;</p>
</li>
<li><p>​    if(head-&gt;next!=null)</p>
</li>
<li><p>​     head-&gt;next-prev=one;   </p>
</li>
<li><p>else {</p>
</li>
<li><p>​           one-&gt;prev=head;</p>
</li>
<li><p>​           head-&gt;next=one;</p>
</li>
<li><p>​         }   </p>
</li>
<li><p>​     }</p>
</li>
<li><p>//如果此时要插入的并不是第一个，那么需要找到待插入的前一个节点</p>
</li>
<li><p>else{</p>
</li>
<li><p>​       int k=0;</p>
</li>
<li><p>​       two=head-&gt;next;</p>
</li>
<li><p>​      while(k&lt;i-1&amp;&amp;two!=null)</p>
</li>
<li><p>​            {</p>
</li>
<li><p>​               two=two-&gt;next;</p>
</li>
<li><p>​                k++</p>
</li>
<li><p>​               }</p>
</li>
<li><p>​         if(two==null)</p>
</li>
<li><p>​          return false;</p>
</li>
<li><p>​        else{   </p>
</li>
<li><p>​                 if(two-&gt;next!=null){</p>
</li>
<li><p>​                 two-&gt;next-&gt;prve=one;</p>
</li>
<li><p>​                 one-&gt;next=two-&gt;next;</p>
</li>
<li><p>​                 two-&gt;next=one;</p>
</li>
<li><p>​                 one-&gt;prve=two;</p>
</li>
<li><p>​                                          }</p>
</li>
<li><p>​                 else{</p>
</li>
<li><p>​                         two-&gt;next=one;</p>
</li>
<li><p>​                        one-&gt;prve=two;</p>
</li>
<li><p>​                       }</p>
</li>
<li><p>​                }</p>
</li>
<li><p>​             }</p>
</li>
<li></li>
<li><p>}</p>
</li>
<li></li>
<li><p><strong>（**</strong>6<strong><strong>.1</strong></strong>）双向链表中删除数据<strong><strong>(</strong></strong>直接删除的指明的数据<strong>**)</strong></p>
</li>
<li><p>STATUS  delete_data_from_double_link(DOUBLE_LINK_NODE** ppDLinkNode, int data)<br>   {</p>
</li>
<li><p>DOUBLE_LINK_NODE*one; </p>
</li>
<li><p>if(ppDLinkNode==null||*ppDLinkNode==null)</p>
</li>
<li><p>return false;</p>
</li>
<li><p>one=find_dat_in_double_Link(*ppDLinkNode,data);</p>
</li>
<li><p>if(one==null)</p>
</li>
<li><p>{</p>
</li>
<li><p>return false;</p>
</li>
<li><p>cout&lt;&lt;”链表中节点中没有对应的数据”&lt;&lt;endl;</p>
</li>
<li><p>}</p>
</li>
<li></li>
<li><p>if(one==*ppDLinkNode)</p>
</li>
<li><p>​    {</p>
</li>
<li><p>​     if((*ppDLinkNode)-&gt;next==null)</p>
</li>
<li><p>​     *ppDLinkNode=null;</p>
</li>
<li><p>cout&lt;&lt;”我成功的删除的第一个节点，此时链表中没有数据了”</p>
</li>
<li><p>​     else{</p>
</li>
<li><p>​          <em>ppDLinkNode=</em>ppDlinkNode-&gt;nxet;</p>
</li>
<li><p>​            (*ppDlinkNode)-&gt;prve=null;</p>
</li>
<li><p>​       cout&lt;&lt;”成功删除第一个头结点，此时还有数据”;</p>
</li>
<li><p>​       }</p>
</li>
<li><p>​     }</p>
</li>
<li><p>else{</p>
</li>
<li><p>​     if(one-next=null)</p>
</li>
<li><p>​       {</p>
</li>
<li><p>​       one-&gt;prve-&gt;next=null;</p>
</li>
<li><p>​      cout&lt;&lt;”成功删除尾部节点”;</p>
</li>
<li><p>​        }</p>
</li>
<li><p>​      else{</p>
</li>
<li><p>​              one-&gt;prev-&gt;next=one-&gt;next;</p>
</li>
<li><p>​              one-&gt;next-&gt;prve=one-&gt;prev</p>
</li>
<li><p>​            cout&lt;&lt;”成功删除中间节点”;</p>
</li>
<li><p>​            }</p>
</li>
<li><p>​        }</p>
</li>
<li><p>free(one);</p>
</li>
<li><p>​    return ture;</p>
</li>
<li><p>}</p>
</li>
<li><p><strong>（**</strong>6<strong><strong>.2</strong></strong>）双向链表中删除数据<strong><strong>(</strong></strong>直接删除指定节点位置的数据<strong>**)</strong></p>
</li>
<li><p>STATUS  delete_data_from_double_link(DOUBLE_LINK_NODE** ppDLinkNode, int i)</p>
</li>
<li><p>{</p>
</li>
<li><p>DOUBLE_LINK_NODE<em>one,</em>two;</p>
</li>
<li><p>​     if(*ppDLInkNode==null&amp;&amp;ppDLinkNode==null)</p>
</li>
<li><p>​     return false;</p>
</li>
<li><p>​    if(*ppDLinkNode-&gt;next==null)</p>
</li>
<li><p>​    {</p>
</li>
<li><p>​     cout&lt;&lt;”It’s null List!!”;</p>
</li>
<li><p>​    return </p>
</li>
<li><p>​      } </p>
</li>
<li></li>
<li><p>if(i==0)</p>
</li>
<li><p>​     {</p>
</li>
<li><p>​      if((*ppDlinkNode)-&gt;next==null)</p>
</li>
<li><p>​    </p>
</li>
<li><p>​       cout&lt;&lt;”delete the List!and  the List don’t exist any node;”</p>
</li>
<li><p>​     else{</p>
</li>
<li><p>​          one=*ppDLinkNode-&gt;next;</p>
</li>
<li><p>​         *ppDLinkNode=one;</p>
</li>
<li><p>​          one-&gt;prev=Null;</p>
</li>
<li><p>​           cout&lt;&lt;”free the first  node!” </p>
</li>
<li><p>​       }</p>
</li>
<li><p>​        free(*ppDLinkNode); </p>
</li>
<li><p>​     }</p>
</li>
<li><p>else{</p>
</li>
<li><p>int k=0;</p>
</li>
<li><p>two=*ppDlLinkNode-&gt;next;</p>
</li>
<li><p>while(k&lt;i&amp;&amp;two-&gt;next!=null) </p>
</li>
<li><p>​    {</p>
</li>
<li><p>​    two=two-&gt;next;</p>
</li>
<li><p>​    k++;     </p>
</li>
<li><p>​    }</p>
</li>
<li><p>​    if(two-&gt;next-next==null)         </p>
</li>
<li><p>​         two-&gt;next=null;</p>
</li>
<li><p>​         cout&lt;&lt;”free the last  node,and the previous is link to null”;    </p>
</li>
<li><p>​     else{</p>
</li>
<li><p>​       one=two-&gt;next;</p>
</li>
<li><p>​        two-&gt;next=one-&gt;next;</p>
</li>
<li><p>​         one-&gt;next-prev=two;</p>
</li>
<li><p>​          cout&lt;&lt;”free  the node ,normally!”;  </p>
</li>
<li><p>​          }</p>
</li>
<li><p>​      free(two); </p>
</li>
<li><p>​      retuen true;    </p>
</li>
<li><p>​     }</p>
</li>
<li><p>}</p>
</li>
<li><p><strong>（**</strong>7<strong>**）统计双向链表中数据的个数</strong></p>
</li>
<li><p>int  count_number_in_double_link(const DOUBLE_LINK_NODE* pDLinkNode)<br>   {</p>
<pre><code>if(pDLinkNode==null){</code></pre></li>
<li><p>​    cout&lt;&lt;”no List”;</p>
</li>
<li><p>}   </p>
</li>
<li><p>int count = 0;</p>
<pre><code>DOUBLE_LINK_NODE* pNode =  (DOUBLE_LINK_NODE*)pDLinkNode;</code></pre></li>
<li><p>while(NULL  != pNode){</p>
<pre><code>    count ++;
    pNode = pNode-&gt;next;
}
return count;</code></pre><p>   }</p>
</li>
<li><p><strong>（**</strong>8<strong>**）打印双向链表中数据</strong></p>
</li>
<li><p>void  dispaly_ldouble_ink_node(DOUBLE_LINK_NODE* pDLinkNode){</p>
</li>
<li><p>if(pDLinkNode==null)</p>
</li>
<li><p>​    cout&lt;&lt;”no List”;</p>
</li>
<li><p>​    DOUBLE_LINK_NODE* one=pDLinkNode;</p>
</li>
<li><p>​    while(one!=null)</p>
</li>
<li><p>​         {</p>
</li>
<li><p>​    cout&lt;<one->data&lt;&lt;endl;</one-></p>
</li>
<li><p>​     one=one-&gt;next;</p>
</li>
<li><p>​        }</p>
</li>
<li><p>}</p>
<p>   【+|</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/C++基础知识/数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/C++基础知识/数组/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:15+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、-请你回答一下Array-amp-List，-数组和链表的区别"><a href="#1、-请你回答一下Array-amp-List，-数组和链表的区别" class="headerlink" title="1、 请你回答一下Array&amp;List， 数组和链表的区别"></a>1、 请你回答一下Array&amp;List， 数组和链表的区别</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>数组的特点：</p>
<p>数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。</p>
<p>链表的特点：</p>
<p>链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。</p>
<p>各自的优缺点</p>
<p>数组的优点：</p>
<ol>
<li><p>随机访问性强</p>
</li>
<li><p>查找速度快</p>
</li>
</ol>
<p>数组的缺点:</p>
<ol>
<li><p>插入和删除效率低</p>
</li>
<li><p>可能浪费内存</p>
</li>
<li><p>内存空间要求高，必须有足够的连续内存空间。</p>
</li>
<li><p>数组大小固定，不能动态拓展</p>
</li>
</ol>
<p>链表的优点:</p>
<ol>
<li><p>插入删除速度快</p>
</li>
<li><p>内存利用率高，不会浪费内存</p>
</li>
<li><p>大小没有固定，拓展很灵活。</p>
</li>
</ol>
<p>链表的缺点:</p>
<p>不能随机查找，必须从第一个开始遍历，查找效率低</p>
<h2 id="●-一个长度为N的整形数组，数组中每个元素的取值范围是-0-n-1-判断该数组否有重复的数，请说一下你的思路并手写代码"><a href="#●-一个长度为N的整形数组，数组中每个元素的取值范围是-0-n-1-判断该数组否有重复的数，请说一下你的思路并手写代码" class="headerlink" title="● 一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码"></a>● 一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为有重复的数值。时间复杂度为O(N),同时为了节省空间复杂度，可以在原数组上进行操作，空间复杂度为O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`bool` `IsDuplicateNumber(``int` `*array, ``int` `n)``&#123;``if``(array==NULL) ``return` `false``;``int` `i,temp;``for``(i=0;i&lt;n;i++)``&#123;``while``(array[i]!=i)``&#123;``if``(array[array[i]]==array[i])``return` `true``;``temp=array[array[i]];``array[array[i]]=array[i];``array[i]=temp;``&#125;``&#125;``return` `false``;``&#125;`</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/bolgzxy.github.io/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/bolgzxy.github.io/">1</a><a class="page-number" href="/bolgzxy.github.io/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/bolgzxy.github.io/page/4/">4</a><a class="page-number" href="/bolgzxy.github.io/page/5/">5</a><a class="extend next" rel="next" href="/bolgzxy.github.io/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/bolgzxy.github.io/images/user.jpg" alt="半世烟尘">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/bolgzxy.github.io/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/bolgzxy.github.io/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/bolgzxy.github.io/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/COTVZHAOYUEXING" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1998lovexs@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/bolgzxy.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
