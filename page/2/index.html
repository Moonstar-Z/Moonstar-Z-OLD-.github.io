<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/bolgzxy.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/bolgzxy.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/bolgzxy.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/bolgzxy.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/bolgzxy.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/bolgzxy.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:type" content="website">
<meta property="og:title" content="し半世烟尘">
<meta property="og:url" content="https://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="し半世烟尘">
<meta name="twitter:description" content="黄沙百战穿金甲，不破楼兰誓不还。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/bolgzxy.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/page/2/">





  <title>し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/bolgzxy.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/bolgzxy.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/bolgzxy.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/bolgzxy.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/bolgzxy.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/操作系统/操作系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/操作系统/操作系统/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、-请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"><a href="#1、-请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的" class="headerlink" title="1、 请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"></a>1、 请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的</h3><p>基本概念：</p>
<p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p>
<p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，==实现进程内部的并发==；==线程是操作系统可识别的最小执行和调度单位。==每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。==每个线程完成不同的任务==，但是共享同一地址空间（==也就是同样的动态内存，映射文件，目标代码等==等），打开的文件队列和其他内核资源。</p>
<p>区别：</p>
<p>1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
<p>2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫==运行时段==，用来存放所有局部变量和临时变量。）</p>
<p>3.进程是资源分配的最小单位，线程是CPU调度的最小单位；</p>
<p>4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
<p>5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——==需要进程同步和互斥手段==的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p>
<p>6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
<p>7.进程间不会相互影响 ；==线程一个线程挂掉将导致整个进程挂掉==</p>
<p>8.进程适应于多核、多机分布；线程适用于多核</p>
<p>进程间通信的方式：</p>
<p>进程间通信主要包括==管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。==</p>
<p>1.管道：</p>
<p>管道主要包括==无名管道和命名管道==:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p>
<p>1.1 普通管道PIPE：</p>
<p>1)==它是半双工的==（即数据只能在一个方向上流动），具有固定的读端和写端</p>
<p>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p>
<p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
<p>1.2 命名管道FIFO：</p>
<p>1==)FIFO可以在无关的进程之间交换数据==</p>
<p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
<ol start="2">
<li>系统IPC：</li>
</ol>
<p>2.1 消息队列</p>
<p>消息队列，是消息的==链接表==，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；权限得进程则可以从消息队列中读取信息；</p>
<p>特点：</p>
<p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
<p>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
<p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
<p>2.2 信号量semaphore</p>
<p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。==信号量用于实现进程间的互斥与同步==，而不是用于存储进程间通信数据。</p>
<p>特点：</p>
<p>1)==信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。==</p>
<p>2)信号量基于操作系统的 PV 操作，==程序对信号量的操作都是原子操作。==</p>
<p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
<p>4)支持信号量组。</p>
<p>2.3 信号signal</p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p>2.4 共享内存（Shared Memory）</p>
<p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如==互斥锁和信号量等==</p>
<p>特点：</p>
<p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p>
<p>2)因为多个进程可以同时操作，所以需要进行同步</p>
<p>3)信号量+共享内存通常结合在一起使用，==信号量用来同步对共享内存的访问==</p>
<p>3.套接字SOCKET：</p>
<p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p>
<p>线程间通信的方式:</p>
<p>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p>
<p>==互斥量Synchronized/Lock==：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p>
<p>==信号量Semphare==：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p>
<p>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>
<h3 id="2、请你说一说Linux虚拟地址空间"><a href="#2、请你说一说Linux虚拟地址空间" class="headerlink" title="2、请你说一说Linux虚拟地址空间"></a>2、请你说一说Linux虚拟地址空间</h3><p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。</p>
<p>虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<p>请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p>
<p>虚拟内存的好处：</p>
<p>1.扩大地址空间；</p>
<p>2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</p>
<p>3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</p>
<p>4==.当进程通信时，可采用虚存共享的方式实现。==</p>
<p>5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</p>
<p>6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高</p>
<p>7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</p>
<p>虚拟内存的代价：</p>
<p>1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</p>
<p>2.虚拟地址到物理地址的转换，增加了指令的执行时间。</p>
<p>3.页面的换入换出需要磁盘I/O，这是很耗时的</p>
<p>4.如果一页中只有一部分数据，会浪费内存。</p>
<h3 id="3、-请你说一说操作系统中的程序的内存结构"><a href="#3、-请你说一说操作系统中的程序的内存结构" class="headerlink" title="3、 请你说一说操作系统中的程序的内存结构"></a>3、 请你说一说操作系统中的程序的内存结构</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153" alt="img"></p>
<h3 id="4、请你说一说操作系统中的缺页中断"><a href="#4、请你说一说操作系统中的缺页中断" class="headerlink" title="4、请你说一说操作系统中的缺页中断"></a>4、请你说一说操作系统中的缺页中断</h3><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</p>
<p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<p>1、保护CPU现场</p>
<p>2、分析中断原因</p>
<p>3、转入缺页中断处理程序进行处理</p>
<p>4、恢复CPU现场，继续执行</p>
<p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p>
<p>1、在指令执行期间产生和处理缺页中断信号</p>
<p>2、一条指令在执行期间，可能产生多次缺页中断</p>
<p>3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</p>
<h3 id="5、-请你回答一下fork和vfork的区别"><a href="#5、-请你回答一下fork和vfork的区别" class="headerlink" title="5、 请你回答一下fork和vfork的区别"></a>5、 请你回答一下fork和vfork的区别</h3><p>fork的基础知识：</p>
<p>fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t fork(void);</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<p>vfork的基础知识：</p>
<p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t vfork(void);</p>
<p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。==vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像==。通过这样的方式，vfork( )避免了地址空间的按页复制。==在这个过程中，父进程和子进程共享相同的地址空间和页表项。==实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。</p>
<p>vfork( )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了写时复制，vfork( )也要比fork( )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork( )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。</p>
<p>补充知识点：写时复制</p>
<p>Linux采用了写时复制的方法，以减少fork时对父进程空间进程整体复制带来的开销。</p>
<p>写时复制是一种采取了惰性优化方法来避免复制时的系统开销。它的前提很简单：如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。==只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。==</p>
<p>写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。</p>
<p>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。</p>
<p>写时复制在内核中的实现非常简单。与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。</p>
<p>现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。</p>
<p>在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。</p>
<p>fork和vfork的区别：</p>
<ol>
<li><p>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</p>
</li>
<li><p>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</p>
</li>
<li><p>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p>
<p>4.当需要改变共享数据段中变量的值，则拷贝父进程。</p>
</li>
</ol>
<h3 id="6、-请问如何修改文件最大句柄数？"><a href="#6、-请问如何修改文件最大句柄数？" class="headerlink" title="6、 请问如何修改文件最大句柄数？"></a>6、 请问如何修改文件最大句柄数？</h3><p>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。</p>
<p>有两种方法：</p>
<ol>
<li>ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）</li>
</ol>
<p>首先用ulimit -a查询Linux相关的参数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 94739</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 94739</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<p>其中，open files就是最大文件句柄数，默认是1024个。</p>
<p>修改Linux最大文件句柄数：  ulimit -n 2048， 将最大句柄数修改为 2048个。</p>
<ol start="2">
<li>对所有进程都有效的方法，修改Linux系统参数</li>
</ol>
<p>vi /etc/security/limits.conf 添加</p>
<p>*　　soft　　nofile　　65536</p>
<p>*　　hard　　nofile　　65536</p>
<p>将最大句柄数改为65536</p>
<p>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了</p>
<h3 id="7、请你说一说并发-concurrency-和并行-parallelism"><a href="#7、请你说一说并发-concurrency-和并行-parallelism" class="headerlink" title="7、请你说一说并发(concurrency)和并行(parallelism)"></a>7、请你说一说并发(concurrency)和并行(parallelism)</h3><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
<p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
<h3 id="8、请问MySQL的端口号是多少，如何修改这个端口号"><a href="#8、请问MySQL的端口号是多少，如何修改这个端口号" class="headerlink" title="8、请问MySQL的端口号是多少，如何修改这个端口号"></a>8、请问MySQL的端口号是多少，如何修改这个端口号</h3><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>查看端口号：</p>
<p>使用命令show global variables like ‘port’;查看端口号 ，mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）</p>
<p>修改端口号：</p>
<p>修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。</p>
<h3 id="9、请你说一说操作系统中的页表寻址"><a href="#9、请你说一说操作系统中的页表寻址" class="headerlink" title="9、请你说一说操作系统中的页表寻址"></a>9、请你说一说操作系统中的页表寻址</h3><p>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</p>
<p>Linux最初的两级页表机制：</p>
<p>两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。</p>
<p>* PGD(Page Global Directory): 最高10位，全局页目录表索引</p>
<p>* PTE(Page Table Entry)：中间10位，页表入口索引</p>
<p>当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是不断深入页表层次，逐渐定位到最终地址的过程，所以这一过程被叫做page talbe walk。</p>
<p>Linux的三级页表机制：</p>
<p>当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：</p>
<p>字段            描述                        位数</p>
<p>cr3            指向一个PDPT            crs寄存器存储</p>
<p>PGD        指向PDPT中4个项中的一个    位31~30</p>
<p>PMD        指向页目录中512项中的一个    位29~21</p>
<p>PTE            指向页表中512项中的一个    位20~12</p>
<p>page offset    4KB页中的偏移            位11~0</p>
<p>现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -&gt; PMD -&gt; PTE。那只使用2级页表(如非PAE的X86)怎么办？</p>
<p>办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。</p>
<p>Linux的四级页表机制：</p>
<p>硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：</p>
<p>字段            描述                        位数</p>
<p>PML4        指向一个PDPT            位47~39</p>
<p>PGD        指向PDPT中4个项中的一个    位38~30</p>
<p>PMD        指向页目录中512项中的一个    位29~21</p>
<p>PTE            指向页表中512项中的一个    位20~12</p>
<p>page offset    4KB页中的偏移            位11~0</p>
<p>Linux内核针为使用原来的3级列表(PGD-&gt;PMD-&gt;PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。</p>
<p>在2004年10月，当时的X86_64架构代码的维护者Andi Kleen提交了一个叫做4level page tables for Linux的PATCH系列，为Linux内核带来了4级页表的支持。在他的解决方案中，不出意料地，按照X86_64规范，新增了一个PML4的层级, 在这种解决方案中，X86_64拥一个有512条目的PML4, 512条目的PGD, 512条目的PMD, 512条目的PTE。对于仍使用3级目录的架构来说，它们依然拥有一个虚拟的PML4,相关的代码会在编译时被优化掉。 这样，就把Linux内核的3级列表扩充为4级列表。这系列PATCH工作得不错，不久被纳入Andrew Morton的-mm树接受测试。不出意外的话，它将在v2.6.11版本中释出。但是，另一个知名开发者Nick Piggin提出了一些看法，他认为Andi的Patch很不错，不过他认为最好还是把PGD作为第一级目录，把新增加的层次放在中间，并给出了他自己的Patch:alternate 4-level page tables patches。Andi更想保持自己的PATCH, 他认为Nick不过是玩了改名的游戏，而且他的PATCH经过测试很稳定，快被合并到主线了，不宜再折腾。不过Linus却表达了对Nick Piggin的支持，理由是Nick的做法conceptually least intrusive。毕竟作为Linux的扛把子，稳定对于Linus来说意义重大。最终，不意外地，最后Nick Piggin的PATCH在v2.6.11版本中被合并入主线。在这种方案中，4级页表分别是：PGD -&gt; PUD -&gt; PMD -&gt; PTE。</p>
<h3 id="10、-请你说一说有了进程，为什么还要有线程？"><a href="#10、-请你说一说有了进程，为什么还要有线程？" class="headerlink" title="10、 请你说一说有了进程，为什么还要有线程？"></a>10、 请你说一说有了进程，为什么还要有线程？</h3><p>线程产生的原因：</p>
<p>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：</p>
<p>进程在同一时间只能干一件事</p>
<p>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。</p>
<p>因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：</p>
<p>从资源上来讲，线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</p>
<p>从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（</p>
<p>从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</p>
<p>除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：</p>
<p>1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p>
<p>2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</p>
<h3 id="11、-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#11、-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="11、 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>11、 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？</h3><p>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</p>
<h3 id="12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"><a href="#12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的" class="headerlink" title="12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"></a>12、请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h3><p>线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：</p>
<p>SP:堆栈指针，指向当前栈的栈顶地址</p>
<p>PC:程序计数器，存储下一条将要执行的指令</p>
<p>EAX:累加寄存器，用于加法乘法的缺省寄存器</p>
<h3 id="13、-请你说一说线程间的同步方式，最好说出具体的系统调用"><a href="#13、-请你说一说线程间的同步方式，最好说出具体的系统调用" class="headerlink" title="13、 请你说一说线程间的同步方式，最好说出具体的系统调用"></a>13、 请你说一说线程间的同步方式，最好说出具体的系统调用</h3><p>信号量</p>
<p>信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</p>
<p>P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。</p>
<p>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。</p>
<p>其系统调用为：</p>
<p>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</p>
<p>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</p>
<p>互斥量</p>
<p>互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区      时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：</p>
<p>pthread_mutex_init:初始化互斥锁</p>
<p>pthread_mutex_destroy：销毁互斥锁</p>
<p>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</p>
<p>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</p>
<p>条件变量</p>
<p>条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：</p>
<p>pthread_cond_init:初始化条件变量</p>
<p>pthread_cond_destroy：销毁条件变量</p>
<p>pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</p>
<p>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</p>
<h3 id="14、请你说一下多线程和多进程的不同"><a href="#14、请你说一下多线程和多进程的不同" class="headerlink" title="14、请你说一下多线程和多进程的不同"></a>14、请你说一下多线程和多进程的不同</h3><p>进程是资源分配的最小单位，而线程时CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。</p>
<h3 id="15、-请你说一说进程和线程的区别"><a href="#15、-请你说一说进程和线程的区别" class="headerlink" title="15、 请你说一说进程和线程的区别"></a>15、 请你说一说进程和线程的区别</h3><p>1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</p>
<p>2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。</p>
<p>3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。</p>
<p>4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。</p>
<p>5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。</p>
<h3 id="16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"><a href="#16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？" class="headerlink" title="16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"></a>16、游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？</h3><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程</p>
<h3 id="17、请你说一说OS缺页置换算法"><a href="#17、请你说一说OS缺页置换算法" class="headerlink" title="17、请你说一说OS缺页置换算法"></a>17、请你说一说OS缺页置换算法</h3><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p>
<p>先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</p>
<p>最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p>
<p>当前最常采用的就是LRU算法。</p>
<h3 id="18、请你说一下多进程和多线程的使用场景"><a href="#18、请你说一下多进程和多线程的使用场景" class="headerlink" title="18、请你说一下多进程和多线程的使用场景"></a>18、请你说一下多进程和多线程的使用场景</h3><p>多进程模型的优势是CPU</p>
<p>多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</p>
<p>多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</p>
<h3 id="19、-请你说一说死锁发生的条件以及如何解决死锁"><a href="#19、-请你说一说死锁发生的条件以及如何解决死锁" class="headerlink" title="19、 请你说一说死锁发生的条件以及如何解决死锁"></a>19、 请你说一说死锁发生的条件以及如何解决死锁</h3><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：</p>
<p>==互斥条件==：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</p>
<p>==请求和保持条件==：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</p>
<p>==不可剥夺条件==：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p>
<p>==环路等待条件==：进程发生死锁后，必然存在一个进程-资源之间的环形链</p>
<p>解决死锁的方法即破坏上述四个条件之一，主要方法如下：</p>
<p>资源一次性分配，从而剥夺请求和保持条件</p>
<p>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</p>
<p>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</p>
<h3 id="20、请问虚拟内存和物理内存怎么对应"><a href="#20、请问虚拟内存和物理内存怎么对应" class="headerlink" title="20、请问虚拟内存和物理内存怎么对应"></a>20、请问虚拟内存和物理内存怎么对应</h3><p>1、概念：</p>
<p>物理地址(physical address)</p>
<p>用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。</p>
<p>虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。</p>
<p>虚拟地址(virtual memory)</p>
<p>这是对整个内存（不要与机器上插那条对上号）的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素；</p>
<p>之所以是这样，是因为现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。这个“转换”，是所有问题讨论的关键。</p>
<p>有了这样的抽像，一个程序，就可以使用比真实物理地址大得多的地址空间。甚至多个进程可以使用相同的地址。不奇怪，因为转换后的物理地址并非相同的。</p>
<p>——可以把连接后的程序反编译看一下，发现连接器已经为程序分配了一个地址，例如，要调用某个函数A，代码不是call A，而是call 0x0811111111 ，也就是说，函数A的地址已经被定下来了。没有这样的“转换”，没有虚拟地址的概念，这样做是根本行不通的。</p>
<p>2、地址转换</p>
<p>第一步：CPU段式管理中——逻辑地址转线性地址</p>
<p>CPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址。</p>
<p>一个逻辑地址由两部份组成，【段标识符：段内偏移量】。</p>
<p>段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470210037_13DB46E4DEE567FEF6756A26C5A0EC62" alt="img"></p>
<p>通过段标识符中的索引号从GDT或者LDT找到该段的段描述符，段描述符中的base字段是段的起始地址</p>
<p>段描述符：Base字段，它描述了一个段的开始位置的线性地址。</p>
<p>一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。</p>
<p>GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。</p>
<p>段起始地址+ 段内偏移量 = 线性地址</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470239469_B327A1776BDD614C1FA189B123676D44" alt="img"></p>
<p>首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，</p>
<p>1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。</p>
<p>2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。</p>
<p>3、把Base + offset，就是要转换的线性地址了。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470270211_A8B080AAD8609459CD745F5E2480B919" alt="img"></p>
<p>第一步：页式管理——线性地址转物理地址</p>
<p>再利用其页式内存管理单元，转换为最终物理地址。</p>
<p>linux假的段式管理</p>
<p>Intel要求两次转换，这样虽说是兼容了，但是却是很冗余，但是这是intel硬件的要求。</p>
<p>其它某些硬件平台，没有二次转换的概念，Linux也需要提供一个高层抽像，来提供一个统一的界面。</p>
<p>所以，Linux的段式管理，事实上只是“哄骗”了一下硬件而已。</p>
<p>按照Intel的本意，全局的用GDT，每个进程自己的用LDT——不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。</p>
<p>在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。</p>
<p>linux页式管理</p>
<p>CPU的页式内存管理单元，负责把一个线性地址，最终翻译为一个物理地址。</p>
<p>线性地址被分为以固定长度为单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20个次方个页。</p>
<p>另一类“页”，我们称之为物理页，或者是页框、页桢的。是分页单元把所有的物理内存也划分为固定长度的管理单位，它的长度一般与内存页是一一对应的。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470300375_E395C4896EA5D7621E9211A0C3817BB5" alt="img"></p>
<p>每个进程都有自己的页目录，当进程处于运行态的时候，其页目录地址存放在cr3寄存器中。</p>
<p>每一个32位的线性地址被划分为三部份，【页目录索引(10位)：页表索引(10位)：页内偏移(12位)】</p>
<p>依据以下步骤进行转换：</p>
<p>从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；</p>
<p>根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。</p>
<p>根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；</p>
<p>将页的起始地址与线性地址中最后12位相加。</p>
<p>目的：</p>
<p>内存节约：如果一级页表中的一个页表条目为空，那么那所指的二级页表就根本不会存在。这表现出一种巨大的潜在节约，因为对于一个典型的程序，4GB虚拟地址空间的大部份都会是未分配的；</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470330729_28397F90C2D7C059A122BFF0B4DFD63A" alt="img"></p>
<p>32位，PGD = 10bit，PUD = PMD = 0，table = 10bit，offset = 12bit</p>
<p>64位，PUD和PMD ≠ 0</p>
<h3 id="21、-请你说一说操作系统中的结构体对齐，字节对齐"><a href="#21、-请你说一说操作系统中的结构体对齐，字节对齐" class="headerlink" title="21、 请你说一说操作系统中的结构体对齐，字节对齐"></a>21、 请你说一说操作系统中的结构体对齐，字节对齐</h3><p>1、原因：</p>
<p>1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
<p>2、规则</p>
<p>1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<p>2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<p>3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p>
<p>3、定义结构体对齐</p>
<p>可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</p>
<p>4、举例</p>
<p>#pragma pack(2)</p>
<p>struct AA {</p>
<p>int a;       //长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</p>
<p>char b;  //长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</p>
<p>short c;     //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</p>
<p>char d;  //长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节</p>
<p>};</p>
<p>#pragma pack()</p>
<h3 id="22、-请你说一下虚拟内存置换的方式"><a href="#22、-请你说一下虚拟内存置换的方式" class="headerlink" title="22、 请你说一下虚拟内存置换的方式"></a>22、 请你说一下虚拟内存置换的方式</h3><p>比较常见的内存替换算法有：FIFO，LRU，LFU，LRU-K，2Q。</p>
<p>1、FIFO（先进先出淘汰算法）</p>
<p>思想：最近刚访问的，将来访问的可能性比较大。</p>
<p>实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。</p>
<p>弊端：无法体现页面冷热信息</p>
<p>2、LFU（最不经常访问淘汰算法）</p>
<p>思想：如果数据过去被访问多次，那么将来被访问的频率也更高。</p>
<p>实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</p>
<p>开销：排序开销。</p>
<p>弊端：缓存颠簸。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470476683_909843CE326FD7243A252E09C80772B8" alt="img"></p>
<p>3、LRU（最近最少使用替换算法）</p>
<p>思想：如果数据最近被访问过，那么将来被访问的几率也更高。</p>
<p>实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。</p>
<p>优点：LRU算法对热点数据命中率是很高的。</p>
<p>缺陷：</p>
<p>1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。</p>
<p>2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。</p>
<p>4、LRU-K（LRU-2、LRU-3）</p>
<p>思想：最久未使用K次淘汰算法。</p>
<p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p>
<p>实现：</p>
<p>1）数据第一次被访问，加入到访问历史列表；</p>
<p>2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p>
<p>3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p>
<p>4）缓存数据队列中被再次访问后，重新排序；</p>
<p>5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p>
<p>针对问题：</p>
<p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>5、2Q</p>
<p>类似LRU-2。使用一个FIFO队列和一个LRU队列。</p>
<p>实现：</p>
<p>1）新访问的数据插入到FIFO队列；</p>
<p>2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p>
<p>3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</p>
<p>4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</p>
<p>5）LRU队列淘汰末尾的数据。</p>
<p>针对问题：LRU的缓存污染</p>
<p>弊端：</p>
<p>当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。</p>
<h3 id="23、-请你说一下多线程，线程同步的几种方式"><a href="#23、-请你说一下多线程，线程同步的几种方式" class="headerlink" title="23、 请你说一下多线程，线程同步的几种方式"></a>23、 请你说一下多线程，线程同步的几种方式</h3><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>概念：</p>
<p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p>
<p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p>
<p>线程间通信的方式:</p>
<p>1、临界区：</p>
<p>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p>
<p>2、互斥量 Synchronized/Lock：</p>
<p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p>
<p>3、信号量 Semphare：</p>
<p>为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p>
<p>4、事件(信号)，Wait/Notify：</p>
<p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>
<h3 id="24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别"><a href="#24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别" class="headerlink" title="24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别"></a>24、请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别</h3><p>1、互斥锁和读写锁区别：</p>
<p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p>
<p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
<p>互斥锁和读写锁的区别：</p>
<p>1）读写锁区分读者和写者，而互斥锁不区分</p>
<p>2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</p>
<p>2、Linux的4种锁机制：</p>
<p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p>
<p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
<p>自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p>
<p>RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</p>
<h3 id="25、请回答一下进程和线程的区别"><a href="#25、请回答一下进程和线程的区别" class="headerlink" title="25、请回答一下进程和线程的区别"></a>25、请回答一下进程和线程的区别</h3><p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
<p>2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p>
<p>3、进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>
<p>4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
<p>5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p>
<p>6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
<p>7、进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉。</p>
<p>8、进程适应于多核、多机分布；线程适用于多核。</p>
<h3 id="26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"><a href="#26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞" class="headerlink" title="26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"></a>26、请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞</h3><p>1、进程的五种基本状态：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F" alt="img"></p>
<p>1）创建状态：进程正在被创建</p>
<p>2）就绪状态：进程被加入到就绪队列中等待CPU调度运行</p>
<p>3）执行状态：进程正在被运行</p>
<p>4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。</p>
<p>5）终止状态：进程运行完</p>
<p>2、交换技术</p>
<p>当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。</p>
<p>针对以上问题，提出了两种解决方法：</p>
<p>1）交换技术：换出一部分进程到外存，腾出内存空间。</p>
<p>2）虚拟存储技术：每个进程只能装入一部分程序和数据。</p>
<p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</p>
<p>从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。</p>
<p>3、活动阻塞，静止阻塞，活动就绪，静止就绪</p>
<p>1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。</p>
<p>2）静止阻塞：进程在外存，同时被某种原因阻塞了。</p>
<p>3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</p>
<p>4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</p>
<p>从而出现了：</p>
<p>活动就绪 ——  静止就绪        （内存不够，调到外存）</p>
<p>活动阻塞 ——  静止阻塞        （内存不够，调到外存）</p>
<p>执行     ——  静止就绪         （时间片用完）</p>
<h3 id="27、A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><a href="#27、A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？" class="headerlink" title="27、A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？"></a>27、A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h3><p>1、程序内存管理：</p>
<p>一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470750551_BF3BB3BB445EFF96BEAE1410CE2CDA74" alt="img"></p>
<p>BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p>
<p>数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</p>
<p>代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p>
<p>text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</p>
<p>bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</p>
<p>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中</p>
<p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p>
<p>可执行程序在运行时又多出两个区域：栈区和堆区。</p>
<p>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p>
<p>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的 malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p>
<p>2、A* a = new A; a-&gt;i = 10：</p>
<p>1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。</p>
<p>2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。</p>
<p>3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。</p>
<p>4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。</p>
<h3 id="28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"><a href="#28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布" class="headerlink" title="28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"></a>28、给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</h3><p>1、static修饰符</p>
<p>1）static修饰成员变量</p>
<p>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</p>
<p>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</p>
<p>2）static修饰成员函数</p>
<p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</p>
<p>Static修饰的成员函数，在代码区分配内存。</p>
<p>2、C++继承和虚函数</p>
<p>C++多态分为静态多态和动态多态。==静态多态是通过重载和模板技术实现==，在编译的时候确定。==动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。==</p>
<p>动态多态实现有几个条件：</p>
<p>(1) 虚函数；</p>
<p>(2) 一个基类的指针或引用指向派生类的对象；</p>
<p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。</p>
<p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。</p>
<p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p>
<p>3、virtual修饰符</p>
<p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。</p>
<p>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。</p>
<p>如果类中成员是virtual属性，会隐藏父类对应的属性。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA" alt="img"></p>
<h3 id="29、请你回答一下软链接和硬链接区别"><a href="#29、请你回答一下软链接和硬链接区别" class="headerlink" title="29、请你回答一下软链接和硬链接区别"></a>29、请你回答一下软链接和硬链接区别</h3><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>为了解决文件共享问题，Linux引入了软链接和硬链接。除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。</p>
<p>若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。</p>
<p>若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。</p>
<h3 id="30、请问什么是大端小端以及如何判断大端小端"><a href="#30、请问什么是大端小端以及如何判断大端小端" class="headerlink" title="30、请问什么是大端小端以及如何判断大端小端"></a>30、请问什么是大端小端以及如何判断大端小端</h3><p>大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470995798_E694EFF3D7CC8BA2BB2EE978CE1EB6FB" alt="img"></p>
<h3 id="31、请你回答一下静态变量什么时候初始化"><a href="#31、请你回答一下静态变量什么时候初始化" class="headerlink" title="31、请你回答一下静态变量什么时候初始化"></a>31、请你回答一下静态变量什么时候初始化</h3><p>静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</p>
<h3 id="32、请你说一说用户态和内核态区别"><a href="#32、请你说一说用户态和内核态区别" class="headerlink" title="32、请你说一说用户态和内核态区别"></a>32、请你说一说用户态和内核态区别</h3><p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p>
<h3 id="33、如何设计server，使得能够接收多个客户端的请求"><a href="#33、如何设计server，使得能够接收多个客户端的请求" class="headerlink" title="33、如何设计server，使得能够接收多个客户端的请求"></a>33、如何设计server，使得能够接收多个客户端的请求</h3><p>多线程，线程池，io复用</p>
<h3 id="34、-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#34、-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="34、 死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>34、 死循环+来连接时新建线程的方法效率有点低，怎么改进？</h3><p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p>
<h3 id="35、-怎么唤醒被阻塞的socket线程？"><a href="#35、-怎么唤醒被阻塞的socket线程？" class="headerlink" title="35、 怎么唤醒被阻塞的socket线程？"></a>35、 怎么唤醒被阻塞的socket线程？</h3><p>给阻塞时候缺少的资源</p>
<h3 id="36、-怎样确定当前线程是繁忙还是阻塞？"><a href="#36、-怎样确定当前线程是繁忙还是阻塞？" class="headerlink" title="36、 怎样确定当前线程是繁忙还是阻塞？"></a>36、 怎样确定当前线程是繁忙还是阻塞？</h3><p>使用ps命令查看</p>
<h3 id="37、请问就绪状态的进程在等待什么？"><a href="#37、请问就绪状态的进程在等待什么？" class="headerlink" title="37、请问就绪状态的进程在等待什么？"></a>37、请问就绪状态的进程在等待什么？</h3><p>被调度使用cpu的运行权</p>
<h3 id="38、请你说一说多线程的同步，锁的机制"><a href="#38、请你说一说多线程的同步，锁的机制" class="headerlink" title="38、请你说一说多线程的同步，锁的机制"></a>38、请你说一说多线程的同步，锁的机制</h3><p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行</p>
<h3 id="39、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#39、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="39、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>39、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h3><p>单核cpu，并且开了抢占可以造成这种情况。</p>
<h3 id="40、-windows消息机制知道吗，请说一说"><a href="#40、-windows消息机制知道吗，请说一说" class="headerlink" title="40、 windows消息机制知道吗，请说一说"></a>40、 windows消息机制知道吗，请说一说</h3><p>当用户有操作(鼠标，键盘等)时，系统会将这些时间转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作。</p>
<h3 id="41、C-的锁你知道几种"><a href="#41、C-的锁你知道几种" class="headerlink" title="41、C++的锁你知道几种?"></a>41、C++的锁你知道几种?</h3><p>锁包括互斥锁，条件变量，自旋锁和读写锁</p>
<h3 id="42、-说一说你用到的锁"><a href="#42、-说一说你用到的锁" class="headerlink" title="42、 说一说你用到的锁"></a>42、 说一说你用到的锁</h3><p>生产者消费者问题利用互斥锁和条件变量可以很容易解决，条件变量这里起到了替代信号量的作用</p>
<h3 id="43、请你说一说死锁产生的必要条件？"><a href="#43、请你说一说死锁产生的必要条件？" class="headerlink" title="43、请你说一说死锁产生的必要条件？"></a>43、请你说一说死锁产生的必要条件？</h3><p>1.互斥条件：一个资源每次只能被一个进程使用。</p>
<h3 id="44、-请你说一说内存溢出和内存泄漏"><a href="#44、-请你说一说内存溢出和内存泄漏" class="headerlink" title="44、 请你说一说内存溢出和内存泄漏"></a>44、 请你说一说内存溢出和内存泄漏</h3><p>1、内存溢出</p>
<p>指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p>
<p>内存溢出原因：</p>
<p>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</p>
<p>集合类中有对对象的引用，使用完后未清空，使得不能回收</p>
<p>代码中存在死循环或循环产生过多重复的对象实体</p>
<p>使用的第三方软件中的BUG</p>
<p>启动参数内存值设定的过小</p>
<p>2、内存泄漏</p>
<p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
<p>内存泄漏的分类：</p>
<p>1、堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</p>
<p>2、系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
<p>3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
<h3 id="45、进程和线程的区别，你都使用什么线程模型"><a href="#45、进程和线程的区别，你都使用什么线程模型" class="headerlink" title="45、进程和线程的区别，你都使用什么线程模型"></a>45、进程和线程的区别，你都使用什么线程模型</h3><p>1）进程和线程区别</p>
<p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
<p>2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p>
<p>3、进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>
<p>4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
<p>5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p>
<p>6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
<p>7、进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉。</p>
<p>8、进程适应于多核、多机分布；线程适用于多核。</p>
<p>2、常用线程模型</p>
<p>1、Future模型</p>
<p>该模型通常在使用的时候需要结合Callable接口配合使用。</p>
<p>Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</p>
<p>Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</p>
<p>2、fork&amp;join模型</p>
<p>该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</p>
<p>这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</p>
<p>3、actor模型</p>
<p>actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</p>
<p>4、生产者消费者模型</p>
<p>生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</p>
<p>5、master-worker模型</p>
<p>master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</p>
<h3 id="46、请你来说一说协程"><a href="#46、请你来说一说协程" class="headerlink" title="46、请你来说一说协程"></a>46、请你来说一说协程</h3><p>1、概念：</p>
<p>协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def A() :</span><br><span class="line">print &apos;1&apos;</span><br><span class="line">print &apos;2&apos;</span><br><span class="line">print &apos;3&apos;</span><br><span class="line">def B() :</span><br><span class="line">print &apos;x&apos;</span><br><span class="line">print &apos;y&apos;</span><br><span class="line">print &apos;z&apos;</span><br></pre></td></tr></table></figure>

<p>由协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p>
<p>2）协程和线程区别</p>
<p>那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>3）其他</p>
<p>在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p>
<h3 id="47、-系统调用是什么，你用过哪些系统调用"><a href="#47、-系统调用是什么，你用过哪些系统调用" class="headerlink" title="47、 系统调用是什么，你用过哪些系统调用"></a>47、 系统调用是什么，你用过哪些系统调用</h3><p>1）概念：</p>
<p>在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。</p>
<p>操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。</p>
<p>应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。</p>
<p>2）系统调用举例：</p>
<p>对文件进行写操作，程序向打开的文件写入字符串“hello world”，open和write都是系统调用。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#include&lt;stdio.h&gt;``#include&lt;stdlib.h&gt;``#include&lt;string.h&gt;``#include&lt;errno.h&gt;``#include&lt;unistd.h&gt;``#include&lt;sys/types.h&gt;``#include&lt;sys/stat.h&gt;``#include&lt;fcntl.h&gt;``int` `main(``int` `argc, ``char` `*argv[])``&#123;``    ``if` `(argc&lt;``2``)``        ``return` `0``;``    ``//用读写追加方式打开一个已经存在的文件``    ``int` `fd = open(argv[``1``], O_RDWR | O_APPEND);``    ``if` `(fd == -``1``)``    ``&#123;``        ``printf(``&quot;error is %s\n&quot;``, strerror(errno));``    ``&#125;``    ``else``    ``&#123;``        ``//打印文件描述符号``        ``printf(``&quot;success fd = %d\n&quot;``, fd);``        ``char` `buf[``100``];``        ``memset(buf, ``0``, sizeof(buf));``        ``strcpy(buf, ``&quot;hello world\n&quot;``);``        ``write(fd, buf, strlen(buf));``        ``close(fd);``    ``&#125;``    ``return` `0``;``&#125;`</span><br></pre></td></tr></table></figure>

<p>还有写数据write，创建进程fork，vfork等都是系统调用。</p>
<h3 id="48、-请你来手写一下fork调用示例"><a href="#48、-请你来手写一下fork调用示例" class="headerlink" title="48、 请你来手写一下fork调用示例"></a>48、 请你来手写一下fork调用示例</h3><p>1、概念：</p>
<p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<p>2、fork实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">pid_t pid;</span><br><span class="line">signal(SIGCHLD, SIG_IGN);</span><br><span class="line">printf(&quot;before fork pid:%d\n&quot;, getpid());</span><br><span class="line">int abc = 10;</span><br><span class="line">pid = fork();</span><br></pre></td></tr></table></figure>

<p>if (pid == -1) {           //错误返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perror(&quot;tile&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if (pid &gt; 0) {              //父进程空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc++;</span><br><span class="line">printf(&quot;parent:pid:%d \n&quot;, getpid());</span><br><span class="line">printf(&quot;abc:%d \n&quot;, abc);</span><br><span class="line">sleep(20);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>else if (pid == 0) {       //子进程空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`abc++;``printf``(``&quot;child:%d,parent: %d\n&quot;``, getpid(), getppid());``printf``(``&quot;abc:%d&quot;``, abc);``&#125;``printf``(``&quot;fork after...\n&quot;``);`` ``&#125;`</span><br></pre></td></tr></table></figure>

<h3 id="49、-请你来说一说用户态到内核态的转化原理"><a href="#49、-请你来说一说用户态到内核态的转化原理" class="headerlink" title="49、 请你来说一说用户态到内核态的转化原理"></a>49、 请你来说一说用户态到内核态的转化原理</h3><p>1）用户态切换到内核态的3种方式</p>
<p>1、系统调用</p>
<p>这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p>
<p>2、异常</p>
<p>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。</p>
<p>3、外围设备的中断</p>
<p>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>2）切换操作</p>
<p>从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：</p>
<p>1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p>
<p>2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</p>
<p>3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p>
<h3 id="50、请你说一下源码到可执行文件的过程"><a href="#50、请你说一下源码到可执行文件的过程" class="headerlink" title="50、请你说一下源码到可执行文件的过程"></a>50、请你说一下源码到可执行文件的过程</h3><p>1）预编译</p>
<p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<p>1、删除所有的#define，展开所有的宏定义。</p>
<p>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p>
<p>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</p>
<p>4、删除所有的注释，“//”和“/**/”。</p>
<p>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</p>
<p>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p>
<p>2）编译</p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<p>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p>
<p>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p>
<p>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p>
<p>4、优化：源代码级别的一个优化过程。</p>
<p>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p>
<p>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
<p>3）汇编</p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p>
<p>4）链接</p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<p>1、静态链接：</p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<p>2、动态链接：</p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
<h3 id="51、请你来说一下微内核与宏内核"><a href="#51、请你来说一下微内核与宏内核" class="headerlink" title="51、请你来说一下微内核与宏内核"></a>51、请你来说一下微内核与宏内核</h3><p>宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</p>
<p>优点：效率高。</p>
<p>缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</p>
<p>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</p>
<p>优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</p>
<p>缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</p>
<h3 id="52、请你说一下僵尸进程"><a href="#52、请你说一下僵尸进程" class="headerlink" title="52、请你说一下僵尸进程"></a>52、请你说一下僵尸进程</h3><p>1）正常进程</p>
<p>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p>
<p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：</p>
<p>1进程号the process ID</p>
<p>2退出状态the termination status of the process</p>
<p>3运行时间the amount of CPU time taken by the process等</p>
<p>2）孤儿进程</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p>3）僵尸进程</p>
<p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p>
<p>僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。</p>
<p>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</p>
<p>如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<p>危害：</p>
<p>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>外部消灭：</p>
<p>通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源</p>
<p>内部解决：</p>
<p>1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</p>
<p>2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p>
<h3 id="53、请问GDB调试用过吗，什么是条件断点"><a href="#53、请问GDB调试用过吗，什么是条件断点" class="headerlink" title="53、请问GDB调试用过吗，什么是条件断点"></a>53、请问GDB调试用过吗，什么是条件断点</h3><p>1、GDB调试</p>
<p>GDB 是自由软件基金会（Free Software Foundation）的软件工具之一。它的作用是协助程序员找到代码中的错误。如果没有GDB的帮助，程序员要想跟踪代码的执行流程，唯一的办法就是添加大量的语句来产生特定的输出。但这一手段本身就可能会引入新的错误，从而也就无法对那些导致程序崩溃的错误代码进行分析。</p>
<p>GDB的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过断点暂时中止程序的执行。此外，他们还能够随时察看变量和内存的当前状态，并监视关键的数据结构是如何影响代码运行的。</p>
<p>2、条件断点</p>
<p>条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。</p>
<p>例如：(gdb)break 666 if testsize==100</p>
<h3 id="54、请你来介绍一下5种IO模型"><a href="#54、请你来介绍一下5种IO模型" class="headerlink" title="54、请你来介绍一下5种IO模型"></a>54、请你来介绍一下5种IO模型</h3><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</p>
<p>2.非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。</p>
<p>3.信号驱动IO:信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。<br>4.IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</p>
<p>5.异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h3 id="55、请你说一说异步编程的事件循环"><a href="#55、请你说一说异步编程的事件循环" class="headerlink" title="55、请你说一说异步编程的事件循环"></a>55、请你说一说异步编程的事件循环</h3><p>事件循环就是不停循环等待时间的发生，然后将这个事件的所有处理器，以及他们订阅这个事件的时间顺序依次依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。当同时并发地处理多个请求时，以上的概念也是正确的，可以这样理解：在单个的线程中，事件处理器是一个一个按顺序执行的。即如果某个事件绑定了两个处理器，那么第二个处理器会在第一个处理器执行完毕后，才开始执行。在这个事件的所有处理器都执行完毕之前，事件循环不会去检查是否有新的事件触发。在单个线程中，一切都是有顺序地一个一个地执行的！</p>
<h3 id="56、请你回答一下操作系统为什么要分内核态和用户态"><a href="#56、请你回答一下操作系统为什么要分内核态和用户态" class="headerlink" title="56、请你回答一下操作系统为什么要分内核态和用户态"></a>56、请你回答一下操作系统为什么要分内核态和用户态</h3><p>为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。</p>
<h3 id="57、请你回答一下为什么要有page-cache，操作系统怎么设计的page-cache"><a href="#57、请你回答一下为什么要有page-cache，操作系统怎么设计的page-cache" class="headerlink" title="57、请你回答一下为什么要有page cache，操作系统怎么设计的page cache"></a>57、请你回答一下为什么要有page cache，操作系统怎么设计的page cache</h3><p>加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache</p>
<h3 id="58、请你说一下多线程的同步，锁的机制"><a href="#58、请你说一下多线程的同步，锁的机制" class="headerlink" title="58、请你说一下多线程的同步，锁的机制"></a>58、请你说一下多线程的同步，锁的机制</h3><p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</p>
<h3 id="59、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#59、-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="59、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>59、 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h3><p>单核cpu，并且开了抢占可以造成这种情况。</p>
<h3 id="60、-请问怎么实现线程池"><a href="#60、-请问怎么实现线程池" class="headerlink" title="60、 请问怎么实现线程池"></a>60、 请问怎么实现线程池</h3><p>1.设置一个生产者消费者队列，作为临界资源</p>
<h3 id="61、-Linux下怎么得到一个文件的100到200行"><a href="#61、-Linux下怎么得到一个文件的100到200行" class="headerlink" title="61、 Linux下怎么得到一个文件的100到200行"></a>61、 Linux下怎么得到一个文件的100到200行</h3><p>sed -n ‘100,200p’ inputfile</p>
<p>awk ‘NR&gt;=100&amp;&amp;NR&lt;=200{print}’ inputfile</p>
<p>head -200 inputfile|tail -100</p>
<h3 id="62、-请你来说一下awk的使用"><a href="#62、-请你来说一下awk的使用" class="headerlink" title="62、 请你来说一下awk的使用"></a>62、 请你来说一下awk的使用</h3><p>1）作用：</p>
<p>样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>
<p>2）用法：</p>
<p>awk [-F  field-separator]  ‘commands’  input-file(s)</p>
<p>3）内置变量</p>
<table>
<thead>
<tr>
<th>ARGC</th>
<th>命令行参数个数</th>
</tr>
</thead>
<tbody><tr>
<td>ARGV</td>
<td>命令行参数排列</td>
</tr>
<tr>
<td>ENVIRON</td>
<td>支持队列中系统环境变量的使用</td>
</tr>
<tr>
<td>FILENAME</td>
<td>awk浏览的文件名</td>
</tr>
<tr>
<td>FNR</td>
<td>浏览文件的记录数</td>
</tr>
<tr>
<td>FS</td>
<td>设置输入域分隔符，等价于命令行 -F选项</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数</td>
</tr>
<tr>
<td>OFS</td>
<td>输出域分隔符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
<tr>
<td>RS</td>
<td>控制记录分隔符</td>
</tr>
</tbody></table>
<p>4）实例：</p>
<p>1、找到当前文件夹下所有的文件和子文件夹,并显示文件大小</p>
<p>&gt; ls -l | awk ‘{print $5 “\t” $9}’</p>
<p>读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域。$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”。</p>
<p>2、找到当前文件夹下所有的文件和子文件夹，并显示文件大小，并显示排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -l | awk &apos;BEGIN &#123;COUNT = -1; print &quot;BEGIN COUNT&quot;&#125;</span><br><span class="line">&#123;COUNT = COUNT + 1; print COUNT&quot;\t&quot;$5&quot;\t&quot;$9&#125;</span><br><span class="line">END &#123;print &quot;END, COUNT = &quot;COUNT&#125;&apos;</span><br></pre></td></tr></table></figure>

<p>先处理BEGIN， 然后进行文本分析，进行第二个{}的操作，分析完进行END操作。</p>
<p>3、找到当前文件夹下所有的子文件夹,并显示排序</p>
<p>&gt; ls -l | awk ‘BEGIN {print “BEGIN COUNT”} /4096/{print NR”\t”$5”\t”$9}</p>
<p>END {print “END”}’</p>
<p>* /4096/ 正则匹配式子</p>
<p>* 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推。</p>
<h3 id="63、-请你来说一下linux内核中的Timer-定时器机制"><a href="#63、-请你来说一下linux内核中的Timer-定时器机制" class="headerlink" title="63、 请你来说一下linux内核中的Timer 定时器机制"></a>63、 请你来说一下linux内核中的Timer 定时器机制</h3><p>1）低精度时钟</p>
<p>Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式：</p>
<p>1、系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。</p>
<p>2、内核会根据HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动tick(节拍)中断。HZ表示1秒种产生多少个时钟硬件中断，tick就表示连续两个中断的间隔时间。</p>
<p>3、设置时钟事件设备后，时钟事件设备会定时产生一个tick中断，触发时钟中断处理函数，更新系统时钟,并检测timer wheel，进行超时事件的处理。</p>
<p>在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用timer wheel多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel的触发是基于系统tick周期性中断。</p>
<p>所以说这之前，linux只能支持ms级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计。</p>
<p>2）高精度时钟</p>
<p>Linux 2.6.16 ，内核支持了高精度的时钟，内核采用新的定时器hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别：</p>
<p>hrtimer采用红黑树进行高精度定时器的管理，而不是时间轮；</p>
<p>高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。</p>
<p>旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel处理超时事件，会更新jiffies，wall time(墙上时间，现实时间)，process的使用时间等等工作。</p>
<p>新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)：于事件触发。</p>
<p>hrtimer的工作原理：</p>
<p>通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。</p>
<p>在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。hrtimer是基于事件的，不会周期性出发tick中断，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。</p>
<p>引入了dynamic tick，是为了能够在使用高精度时钟的同时节约能源，这样会产生tickless 情况下，会跳过一些 tick。</p>
<p>新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：</p>
<p>时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都是支持高精度模式(high-resolution mode)也支持低精度模式(low-resolution mode)。</p>
<p>时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。</p>
<p>当前内核同时存在新旧timer wheel 和 hrtimer两套timer的实现，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/剑指offer/剑指Offer题目解释和对应代码的手写/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/剑指offer/剑指Offer题目解释和对应代码的手写/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>剑指Offer题目知识点（二刷）{1—–33题}</p>
<h3 id="1、赋值运算符"><a href="#1、赋值运算符" class="headerlink" title="1、赋值运算符"></a>1、赋值运算符</h3><blockquote>
<p>题目：为下面的类添加一个赋值运算符</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       CMyString(<span class="keyword">char</span>*Pdata=<span class="literal">nullptr</span>);</span><br><span class="line">       CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">       ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">char</span>* m_pData;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意的地方</strong></p>
<p>1 返回值的类型声明是不是该类型的引用，并在最后返回实例的*this，只有返回一个应用才能连续赋值。</p>
<p>2传入的参数的类型是不是 常量的引用 如果是按值传递会增加额外的开销 </p>
<p>3 释放自身已有的内存，否则会出现程序崩溃的情况</p>
<p>4 判断传入的是不是同一个实例 即是自己给自己赋值 这样子会出错</p>
<p><strong>常规解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMyString &amp;CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[]m_pData;</span><br><span class="line">    m_pData=<span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    m_pData=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData)+<span class="number">1</span>];</span><br><span class="line">    strcopy(m_pData,str.m_pData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 但是上面的代码在安全性上面会有一定的问题，在new新内存的时候假如没有足够的内存，m_pData会是一个空指针，程序会出现问题。</p>
<p><strong>考虑安全性的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       CMyString(<span class="keyword">char</span>*Pdata=<span class="literal">nullptr</span>);</span><br><span class="line">       CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">       ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">       CMyString&amp;CMyString::<span class="keyword">operator</span>(<span class="keyword">const</span> CMyString&amp;str);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">char</span>* m_pData;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> CMyString&amp;CMyString::<span class="keyword">operator</span>(<span class="keyword">const</span> CMyString&amp;str)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(*<span class="keyword">this</span>!=&amp;str)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="function">CMyString <span class="title">strTemp</span><span class="params">(str)</span></span>;<span class="comment">//内存不足的情况会出现在这里，但是这里你没有更改原来的实例。</span></span><br><span class="line">         </span><br><span class="line">         <span class="keyword">char</span> *pTemp=strTemp.m_pData;</span><br><span class="line">         strTemp.m_pData=m_pData;</span><br><span class="line">         m_pData=pTemp;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、数组中的重复数字"><a href="#2、数组中的重复数字" class="headerlink" title="2、数组中的重复数字"></a>2、数组中的重复数字</h3><blockquote>
<p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<p>解决的办法：</p>
<p>1 直接将整个数组排序，然后重头到尾扫描数组，此时的时间复杂度为<code>O（nlogn）</code> </p>
<p>2 用哈希表解决这个问题</p>
<p>3 在原来数组重排这个数组，第三种方法，把每个数字放回对应位置的方法。如果出现一个数字无法放回（所在位置已经是对应数字了），那么说明该数字重复。</p>
<p><strong>哈希解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *resu = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">    duplicate(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>), resu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *resu &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *hashTable = <span class="keyword">new</span> <span class="keyword">int</span>[length]();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashTable[numbers[i]]) &#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hashTable[numbers[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交换元素的解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *item1, <span class="keyword">int</span> *item2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *resu = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">    duplicate(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>), resu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *resu &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == i) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numbers[numbers[i]] != numbers[i]) &#123;</span><br><span class="line">            swap(&amp;numbers[numbers[i]], &amp;numbers[i]);<span class="comment">//外部写一个交换的函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            *duplication = numbers[i];<span class="comment">//numbers[numbers[i]] != numbers[i] 这一句检查是否                                         有重复的数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *item1, <span class="keyword">int</span> *item2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *item1;</span><br><span class="line">    *item1 = *item2;</span><br><span class="line">    *item2 = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1扩展的问题"><a href="#2-1扩展的问题" class="headerlink" title="2.1扩展的问题"></a>2.1扩展的问题</h4><blockquote>
<p>不修改数组找出重复的数字</p>
<p>在一个长度为n+1的数组里的所有数字都在1~n范围内。所以数组中至少有一个数是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，输入长度为8的数组{2，3，5，4，3，2，6，7}，那么对应的输出是重复的数字2或者3。</p>
</blockquote>
<p>1.这个题目可以依照题目一的思路来，不过由于不能修改输入数组，所以可以构建一个n+1大小的辅助数组，构建了辅助数组之后可以<strong>使用hash</strong>表也，可以<strong>使用换位置</strong>的思路来做 。<br>2.使用二分的思想来做，二分基数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *numbers, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>, end = length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> lowCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);<span class="comment">//中间的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &lt;= mid &amp;&amp; numbers[i] &gt;= start) &#123;</span><br><span class="line">                lowCnt++;</span><br><span class="line">                         &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">        <span class="keyword">if</span> (lowCnt &gt; (mid - start + <span class="number">1</span>)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">                                     &#125;</span><br><span class="line">        <span class="keyword">else</span>  &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3，二维数组中的查找"><a href="#3，二维数组中的查找" class="headerlink" title="3，二维数组中的查找"></a>3，二维数组中的查找</h3><blockquote>
<p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下的递增的顺序排序，请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。。</p>
</blockquote>
<p>1.目标数为T，从二维数组的最右上角开始查找，如果T比该数字小，说明T比该数字所在列都小，故剔除列，如果  T比该数字大，说明T比该数字所在行都大，故剔除行，直到最后找到为止。<br>2.也可以从最左下角开始，但是不能从另外两个角开始。(为什么？)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows=<span class="built_in">array</span>.size();</span><br><span class="line">    <span class="keyword">int</span> clos=<span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>||clos==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=clos<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i!=rows&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]==target)/ </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]&gt;target)&#123;</span><br><span class="line">        j--;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i++;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不能从另外两个角开始，因为假如第一个数字是1，但是目标是7，此时7可能会在这一行的右边，也可能在这一行的下面，所以我们没有办法确定怎么进行下一步。</p>
<h3 id="4、替换空格"><a href="#4、替换空格" class="headerlink" title="4、替换空格"></a>4、替换空格</h3><blockquote>
<p>题目：请实现一个函数，把字符串中的每个空格替换成“%20”，例如，输入”We are happy.”,则输出”We%20are%20happy.”</p>
</blockquote>
<p>一般像这种需要向后扩充容量重新整理内存的，最好能够考虑到从尾部开始整理的方法<br>1.指针都可以当作数组使用，但是指针本身不检查是否超出数组范围。<br>2.对字符串的处理都应该考虑最后的空字符’\0’。<br>3.应该一个一个的处理字符串中的字符，不要向一蹴而就。<br>4<strong>.扩充字符串可以考虑从尾部开始</strong>。<br>5.应该警惕内存覆盖，如果改变字符串会导致字符串变长，那应该考虑内存的问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span>*str,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//先计算出整个字符串里面空格的数量</span></span><br><span class="line">   <span class="keyword">int</span> numsofspace=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> originallength=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span> * str1=str;<span class="comment">//复制一份原来的字符串</span></span><br><span class="line">    <span class="keyword">while</span>(*str1!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*str1=='')</span><br><span class="line">            numsofspace++;</span><br><span class="line">        str1++;</span><br><span class="line">        originallength++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//替换成%20整个字符串长度的变化</span></span><br><span class="line">    <span class="keyword">int</span> newlength=originallength+<span class="number">2</span>*numsofspace;</span><br><span class="line">    <span class="keyword">if</span>(newlength&gt;length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//下面开始直接替换字符串</span></span><br><span class="line">    <span class="keyword">int</span> indexoriginal=originallength;</span><br><span class="line">    <span class="keyword">int</span> indexnewlength=newlength;</span><br><span class="line">   <span class="comment">//下面是第一个版本用while循环写</span></span><br><span class="line">    <span class="keyword">while</span>(indexoriginal&gt;<span class="number">0</span>&amp;&amp;indexnewlength&gt;indexoriginal）<span class="comment">//这里的条件是 原来的 指针应该大于                                                    0，新的指针应该一直大于等于旧的指针</span></span><br><span class="line">          &#123;</span><br><span class="line">              if(str[indexoriginal]=='')</span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'0'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'2'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'%'</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=str[indexoriginal--];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    <span class="comment">//下面是第二个版本是用for循环写的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=indexoriginal<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              if(str[i]!='')</span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=str[i];</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'0'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'2'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'%'</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、从尾到头打印链表"><a href="#5、从尾到头打印链表" class="headerlink" title="5、从尾到头打印链表"></a>5、从尾到头打印链表</h3><blockquote>
<p>题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">       ListNode(<span class="keyword">int</span> x) :</span><br><span class="line">              val(x), next(<span class="literal">NULL</span>) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.注意传入函数的是指向链表头的指针，在函数中不应该直接使用这个指针，而是应该用一个指针的临时变量来遍历链表。<br>2.方法一：使用栈来实现（用栈更好）。<br>3.方法二：递归在本质上就是一个栈结构，所以也可以用递归来实现。</p>
<p><strong>用栈实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//先定义一个结构体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;printstack(ListNode*head)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">  <span class="built_in">stack</span>&lt;ListNode*&gt;Node;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      Node.push(head);</span><br><span class="line">      <span class="comment">//还有一种写法，直接在栈里面保存的是节点的值</span></span><br><span class="line">      head=head-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">while</span>(Node!=empty())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> nodeval=Node.top();</span><br><span class="line">      Node.pop();</span><br><span class="line">      result.push_back(nodeval);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用递归实现,但是实际上时间比上面的堆栈更加长</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;printstack(ListNode*head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">//下面开始递归的写法</span></span><br><span class="line">    result=printstack(head-&gt;next);</span><br><span class="line">    result.pusn_back(head-val);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、重建二叉树"><a href="#6、重建二叉树" class="headerlink" title="6、重建二叉树"></a>6、重建二叉树</h3><blockquote>
<p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树（假设没有重复数字）。树节点定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.前序遍历的第一个数字总是树的根节点的值。但在中序遍历中，根节点的值在序列的中间，其中左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。要扫描中序遍历序列，才能找到根节点的值。<br>2.又因为前序遍历总是在根节点后先遍历完左子树，才会遍历右子树，所以由后续遍历推断出左子树中节点的数目之后，前序遍历中根节点之后的相同数目的值都是左子树的节点的值。剩下的就是右子树的值。这样就分别找到了左右子树序列。<br>3.<strong>分别确定了根节点和左右子树的前序、中序遍历，我们可以用同样的方法构建左右子树，剩下的可以用递归来完成。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//数学公式的头文件吧</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode*<span class="title">rebulidTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;prologue,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Mediumorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(prologue.size()==<span class="number">0</span>||Mediumorder.size()!=prologue.size())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//应该新建立一个二叉树</span></span><br><span class="line">    TreeNode* newtree=<span class="keyword">new</span> TreeNode(prologue[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(prologue.size()==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> newtree;</span><br><span class="line">    <span class="comment">//检查错误吧这里是</span></span><br><span class="line">    <span class="keyword">auto</span> position=find(Mediumorder.begin(),Mediumorder.end(),prologue[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(position==Mediumorder.end())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSize = position - Mediumorder.begin();</span><br><span class="line">    <span class="keyword">int</span> rightSize = Mediumorder.end() - position - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  newtree-&gt;left=rebulidTree<span class="comment">//向左边递归求解</span></span><br><span class="line">  (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(prologue.begin()+<span class="number">1</span>,prologue.begin()+<span class="number">1</span>+leftSize),</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(Mediumorder.begin(),Mediumorder.begin()+leftSize));</span><br><span class="line">  </span><br><span class="line">  newtree-&gt;right=rebulidTree<span class="comment">//向右边递归求解</span></span><br><span class="line">  (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(prologue.begin()+<span class="number">1</span>+leftSize,prologue.end()),</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(Mediumorder.begin()+leftSize,Mediumorder.end()));、</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">return</span> newtree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是另外的一个解法</span></span><br></pre></td></tr></table></figure>

<h3 id="7、二叉树的下一个节点"><a href="#7、二叉树的下一个节点" class="headerlink" title="7、二叉树的下一个节点"></a>7、二叉树的下一个节点</h3><blockquote>
<p>给定一颗二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了指向左右子树的指针，还有一个指向父节点的指针。树节点定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">next</span>;</span><span class="comment">//还有一个指向父节点的指针</span></span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.如果该节点有右子树，则它的下一个节点就是其右子树的最左子节点。<br>2.如果该节点没有右子树，但是它本身是其父节点的左子节点，那么它的下一个节点就是其父节点。<br>3.如果该节点没有右子树，并且是其父节点的右子节点，那么它的下一个节点就需要向上不断找父节点，直到找到一个节点是其父节点的左子节点，那么该节点的父节点就要我们要找的下一个节点。<br>4.如果上面的方法都没有找到下一个节点，说明该节点不存在下一个节点，返回nullptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeLinkNode*<span class="title">getNextNode</span><span class="params">(TreeLinkNode*pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeLinkNode*nextNode=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//如果存在右子树</span></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       TreeLinkNode* temporary=pNode-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(temporary-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temporary=temporary-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">       nextNode=temporary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不存在右子树的时候</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       TreeLinkNode* temporary=pNode; </span><br><span class="line">     <span class="comment">//这里是如果该节点没有右子树，但是它本身是其父节点的左子节点，那么它的下一个节点就是其父节点</span></span><br><span class="line">        <span class="keyword">if</span>(temporary==temporary-&gt;next-&gt;left)</span><br><span class="line">            nextNode=temporary-&gt;next;</span><br><span class="line">     <span class="comment">//这里是第三种情况，需要一直上溯到一个节点是其父节点的左子节点，那么该节点的父节点就要我们要找的下一个节点。</span></span><br><span class="line">        <span class="keyword">while</span>(temporary-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temporary==temporary-&gt;next-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                nextNode=temporary-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temporary=temporary-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、用两个栈实现队列"><a href="#8、用两个栈实现队列" class="headerlink" title="8、用两个栈实现队列"></a>8、用两个栈实现队列</h3><blockquote>
<p>题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个成员函数，分别完成在队列尾部插入节点和在队列的头部删除节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>固定一个栈用于入队操作，另一个栈用于出队操作：<br>1.入队列操作，不管stack1和stack2是什么状态，直接向stack1入栈即可。<br>2.出队列操作，如果stack2为空，那么把stack1的元素一个一个弹出并压入到stack2中，完成之后，对stack2进行出栈操作，此元素就是最先入队的元素。<br>3.出队列操作，如果stack2不为空，那么直接从stack2出栈，此元素是当前所有元素中最先入队的那个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> solution::push(<span class="keyword">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> solution::pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2!=empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temporary=stack1.top();</span><br><span class="line">        stack1.pop();</span><br><span class="line">        <span class="keyword">return</span> temporary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1!=empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temporary=stack1.top();</span><br><span class="line">            stack2.push(temporary);</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temporary=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> temporary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1两个队列实现一个栈"><a href="#8-1两个队列实现一个栈" class="headerlink" title="8.1两个队列实现一个栈"></a>8.1两个队列实现一个栈</h4><p>两个栈实现一个队列：使用栈1来入队，栈2来出队，角色是固定了的<br><strong>两个队列实现一个栈：使用非空队列来入栈，使用空队列来出栈，角色会转换：</strong><br>1.入栈操作：哪个队列非空，就把元素插入哪个队列的队尾，如果两个队列都为空，那么就随便使用一个队列。<br>2.出栈操作：把非空队列的元素出队并且按顺序一个一个压入另一个队列，直到剩下一个元素，这个元素就是要出栈的元素。输出该元素即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; deueu1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; deueu2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9、斐波那契数列"><a href="#9、斐波那契数列" class="headerlink" title="9、斐波那契数列"></a>9、斐波那契数列</h3><blockquote>
<p>求斐波那契数列的第n项。斐波那契数列的定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">f(n) = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>); n &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>1.使用递归的方法是最简单的，但是效率成问题，有很多重复的计算。其实就是一种自顶向下的思想。 但是可以考虑用尾递归，会减少很多不必要的计算。</p>
<p>2.也可以考虑使用循环做，这样的也可以减少很多不必要的计算。</p>
<p>3.使用自底向上的思想，从n=2开始计算，并且每次保存前面两次计算的结果，以此进行下一次计算，这样就不会有重复的计算。复杂度为O(n)。<br>4.注意一旦n过大，就会超出long long的范围变成一个大数问题。</p>
<p><strong>循环的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre=<span class="number">0</span>,pre1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result=pre+per1;</span><br><span class="line">        pre=pre1;</span><br><span class="line">        pre2=result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归的解法  时间复杂度最高的一种解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>尾递归的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> pre=<span class="number">0</span>,pre1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> FibonacciTailRecursive(n,pre,pre1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> FibonacciTailRecursive(<span class="keyword">int</span> n,<span class="keyword">int</span> ret1,<span class="keyword">int</span> ret2)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> ret1;</span><br><span class="line">     <span class="keyword">return</span> FibonacciTailRecursive(n<span class="number">-1</span>,ret2,ret1+ret2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、旋转数组的最小数字"><a href="#10、旋转数组的最小数字" class="headerlink" title="10、旋转数组的最小数字"></a>10、旋转数组的最小数字</h3><blockquote>
<p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p>
<p>比如{3，4，5，1,2}和{1,2,3,4,5}</p>
</blockquote>
<p>1.旋转之后的数组实际上可以划分为两个排序的子数组，前面子数组的元素都大于或者等于后面子数组的元素，最小的元素恰好是两个子数组的分界线 </p>
<p>2.找中位数 mid mid，如果中位数大于数组首元素 start start，说明该中位数位于前半段数组，如果该中位数小于数组尾元素 end end，说明该中位数位于后半段数组。</p>
<p>3.不管移动 start start还是 end end的位置，都把它移动到 mid mid上面，保证 start start一直在前半段数组， end end一直在后半段数组 </p>
<p>4.end end的最后值就是最小元素的位置，而终结条件是 start start和 end end的距离为1 </p>
<p>5.旋转零个元素也是一个旋转数组，应该考虑到，即 data[start]&lt;data[end] data[start]&lt;data[end]的情况，这个时候最小元素直接就是第一个元素 </p>
<p>6.考虑到首元素等于尾元素等于中间元素的情况，这种情况下无法判断中间元素属于哪个子数组，所以只能采用顺序查找法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNumberOfarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;rotateArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size=rotateArray.size();</span><br><span class="line">    <span class="keyword">if</span>(size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//整个数组本来就已经是排序好成升序的数组</span></span><br><span class="line">    <span class="keyword">if</span>(rotateArray[<span class="number">0</span>]&lt;rotateArray[size<span class="number">-1</span>]||size==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> befor=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> after=size<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(after-befor&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle=(befor+after)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果第一个元素等于最后一个元素 等于中间的一个元素 那就只能强制进行一一检查</span></span><br><span class="line">        <span class="keyword">if</span>(rotateArray[befor]==rotateArray[middle]==rotateArray[after])</span><br><span class="line">            <span class="keyword">return</span> sortArray(rotateArray);</span><br><span class="line">        <span class="comment">//如果中间的元素小于等于最后的那个元素 &#123;45123&#125; 1&lt;3</span></span><br><span class="line">        <span class="keyword">if</span>(rotateArray[middle]&lt;=rotateArray[after])</span><br><span class="line">            after=middle;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            befor=middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateArray[after];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;rotateArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;itreator::it;</span><br><span class="line">    <span class="keyword">int</span> temp=rotateArray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> it=rotateArray.begin()+<span class="number">1</span>;it!=rotateArray.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;*it)</span><br><span class="line">            temp=*it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11、矩阵中的路径"><a href="#11、矩阵中的路径" class="headerlink" title="11、矩阵中的路径"></a>11、矩阵中的路径</h3><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br>例如在下面的3*4矩阵 </p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">t</th>
<th align="center">g</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c</td>
<td align="center">f</td>
<td align="center">c</td>
<td align="center">s</td>
</tr>
<tr>
<td align="center">j</td>
<td align="center">d</td>
<td align="center">e</td>
<td align="center">h</td>
</tr>
</tbody></table>
<p>矩阵中包含一条字符串”bfce”的路径，但是矩阵中不包含”abfb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><strong>可以用回溯法来解决的典型问题。</strong></p>
<p>回溯法可以看成蛮力法的升级版，它从解决问题的每一步的所有可能选项里系统地选择一个可行的解决方案。回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。就这样重复选择，直到到达最终的状态。<br>用回溯法解决的问题的所有选项可以形象的用树状结构表示。在某一步有n个可能的选项，那么该步骤可以看做是树状结构中的一个节点，每个选项看成树中节点连接线，经过这些连接线到达该节点的n个子节点。树的叶子节点对应着终结状态。如果树的叶节点满足题目的约束条件，那么我们就找到了一个可行的解决方案。<br>如果叶节点的状态不满足约束条件，那么只好回溯到它的上一个节点再尝试其他的选项。如果上一个节点的所有可能选项都已经试过了，并且不能到达满足约束条件的终结状态。则再次回溯到上一个节点。</p>
<p><span style="color:red">首先在矩阵中任意选取一个格子作为起点。假设矩阵中某个格子的字符为ch，并且这个格子对应于路径上的第i个字符。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径的第i个位置上。如果路径的第i个字符恰好是ch，那么到相邻的格子上寻找第i+1个字符。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。由于回溯法的递归特性，路径可以被看做一个栈。</span></p>
<p><strong>1.应该有一个布尔值矩阵来记录矩阵的哪些格子已经被使用过了</strong><br><strong>2.使用递归的方式求解。在使用递归的时候应该注意，在退出递归的时候需要根据需求对计数或者标志进行回退或者清除等操作。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;                </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;                 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>*matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">char</span>*str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断初始条件</span></span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="literal">nullptr</span>||rows&lt;=<span class="number">0</span>||clos&lt;=<span class="number">0</span>||str==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">//建立一个数组访问的visit</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;visit(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(clos,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;<span class="comment">//这个长度应该是整个str判断值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=clos;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasPath(matrix,rows,clos,i,j,str,length,visit))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> length,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;visit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[length]==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> isinpath=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=rows&amp;&amp;j&lt;=clos&amp;&amp;i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>&amp;&amp;matrix(i*clos+j)==str[length]&amp;&amp;!visit[i][j])</span><br><span class="line">    &#123;</span><br><span class="line">        length++;</span><br><span class="line">        visit[i][j]=<span class="literal">true</span>;</span><br><span class="line">        isinpath=hasPath(matrix,rows,clos,i<span class="number">-1</span>,j,str,length,visit)||</span><br><span class="line">                 hasPath(matrix,rows,clos,i+<span class="number">1</span>,j,str,length,visit)||</span><br><span class="line">                 hasPath(matrix,rows,clos,i,j<span class="number">-1</span>,str,length,visit)||</span><br><span class="line">                 hasPath(matrix,rows,clos,i,j+<span class="number">1</span>,str,length,visit);</span><br><span class="line">        <span class="comment">//这里就是回溯的哪一步 </span></span><br><span class="line">        <span class="keyword">if</span>(!isinpath)</span><br><span class="line">        &#123;</span><br><span class="line">            length--;</span><br><span class="line">            visit[i][j]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12、机器人的运动范围"><a href="#12、机器人的运动范围" class="headerlink" title="12、机器人的运动范围"></a>12、机器人的运动范围</h3><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p><strong>1.使用递归</strong><br><strong>2.仍然使用布尔值矩阵记录是否进入过</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoveConut</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;threshould,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span>||threshould.size()&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rows=threshould.size();</span><br><span class="line">    <span class="keyword">int</span> clos=threshould[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;visit(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(clos,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">int</span> count=movingconut(threshould,rows,clos,<span class="number">0</span>,<span class="number">0</span>,visit,k);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是整个代码的核心 判断机器人可不可以进入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingcount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;threshould,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">int</span> i,                                 <span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visit,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//检查这个i j 机器人可否进入</span></span><br><span class="line">    <span class="keyword">if</span>(checkinto(threshould,rows,clos,i,j,visit,k))</span><br><span class="line">    &#123;</span><br><span class="line">        count=<span class="number">1</span>+movingcount(threshould,rows,clos,i<span class="number">-1</span>,j,visit,k)||</span><br><span class="line">                movingcount(threshould,rows,clos,i,j<span class="number">-1</span>,visit,k)||</span><br><span class="line">                movingcount(threshould,rows,clos,i+<span class="number">1</span>,j,visit,k)||</span><br><span class="line">                movingcount(threshould,rows,clos,i,j+<span class="number">1</span>,visit,k)||</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkinto</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;threshould,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">int</span> i,                                 <span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visit,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>&amp;&amp;i&lt;=rows&amp;&amp;j&lt;=clos&amp;&amp;getcountofnumber(i,j)&lt;k&amp;&amp;!visit[i][j])</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcountofnumber</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=i%<span class="number">10</span>;</span><br><span class="line">        i/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">while</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=j%<span class="number">10</span>;</span><br><span class="line">        j/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13、剪绳子（动态规划）"><a href="#13、剪绳子（动态规划）" class="headerlink" title="13、剪绳子（动态规划）"></a>13、剪绳子<span style="color:red">（动态规划）</span></h3><p>给一段长度为n的绳子，把绳子剪成m段（m，n都是整数且n&gt;1,m&gt;1，即至少要剪一次），问每段绳子长度的乘积最大是多少？</p>
<p>1.使用动态规划求解：<br>2.确定子问题:例如绳子的长度为8，那么可以剪成1，7两段，那么此时又要求解长度为7的绳子怎么剪最好。依次类推。<br>3.确定转移方程，设方程f(i)f(i)表示长度为ii的绳子剪成mm段之后的最大的乘积。则<br>$$<br>f(i)=max(f(j)×f(i−j)),0&lt;j&lt;i<br>$$<br>4.为了避免重复计算子问题，我们采用自下而上、从小到大的方式来求解，把先求到的子问题的解储存起来，之后要用到的时候直接进行查表。<br>5.注意边界条件：虽然有f(0)=f(1)=0;f(2)=1;f(3)=2;f(0)=f(1)=0;f(2)=1;f(3)=2;但是在表中存下来却不是这个值，而应该是:p(0)=0;p(1)=1;p(2)=2;p(3)=3;p(0)=0;p(1)=1;p(2)=2;p(3)=3;即在起始条件的时候小问题的最优解并不是我们求解大问题时使用的那个值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Maxlength</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">3</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(i/<span class="number">2</span>);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=dp[j]*dp[i-j];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;temp)</span><br><span class="line">                max=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        dp.pusn_back(max);</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14、二进制中1的个数"><a href="#14、二进制中1的个数" class="headerlink" title="14、二进制中1的个数"></a>14、二进制中1的个数</h3><blockquote>
<p>请实现一个函数，输入是一个整数，输出该数二进制表示中1的个数。例如，把9表示成二进制是1001，有2位是1。因此，如果输入9，则该函数输出为2。</p>
</blockquote>
<p>1.不对数据进行移位，而是移位和数据进行与操作的1。因为移位数据可能会因为符号位而造成死循环<br>2.O(1)的解法。使用公式 </p>
<p>​                                                  n=(n-1)&amp;n</p>
<p>n减去1再和自身进行与操作（&amp;）可以消除一个1。例如10表示成二进制是1010，10减1等于9表示成二进制是1001，两者想与得到1000，和1010比起来正好消去了最低位的1。在把消除为0的过程中这种操作的次数即是1个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Numberfone</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; NumberOf1(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15、数值的整数次方"><a href="#15、数值的整数次方" class="headerlink" title="15、数值的整数次方"></a>15、数值的整数次方</h3><p>实现函数double Power(double base,int exponent),求base的exponent次方。不需要考虑大数问题</p>
<p><strong>1.这个题目看起来很简单，但其实考察的是考虑到边界问题和错误输入</strong><br><strong>2.应该分别分析底数和指数大于0、等于0、小于0的情况</strong></p>
<blockquote>
<p>两种最特殊的情况：<br>1.当底数为0而指数为负数的时候，是错误输入。<br>2.当指数为负数的时候，需要求倒数。</p>
</blockquote>
<p><strong>常规解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断底数是否为0 但是这里的底数是一个double类型的输入 所以不能直接用==判断 需要用其他的技巧</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isZero</span><span class="params">(<span class="keyword">double</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-0.0</span>&lt;<span class="number">0.000000001</span>&amp;&amp;n<span class="number">-0.0</span>&gt;<span class="number">0.000000001</span>)<span class="comment">//小数点后面9位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isZero(base)&amp;&amp;exponent&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//指数小于0的情况是什么养子的</span></span><br><span class="line">    <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        base=<span class="number">1.</span>/base;</span><br><span class="line">        exponen=-exponent;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里是直接相乘的情况</span></span><br><span class="line">    <span class="keyword">while</span>(exponent)</span><br><span class="line">    &#123;</span><br><span class="line">        result*=base;</span><br><span class="line">        exponent--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更加高效的解法</strong></p>
<p><strong>更高效率的方法，即乘法的次数为指数的次数的一半即可，exponent/2</strong> </p>
<p><strong>例如求a的n次方，当n为偶数的时候，</strong><br>$$<br>an=an/2×an/2<br>$$<br><strong>当n为奇数的时候，</strong><br>$$<br>an=a(n−1)/2×a(n−1)/2×a<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;              </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isZero</span><span class="params">(<span class="keyword">double</span> base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((base - <span class="number">0.0</span> &lt; <span class="number">0.000000001</span>) &amp;&amp; (<span class="number">0.0</span> - base &lt; <span class="number">0.000000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isZero(base) &amp;&amp; exponent &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        base = <span class="number">1.</span>/base;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> resu = recursivePower(base,exponent);</span><br><span class="line">    <span class="keyword">return</span> resu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">recursivePower</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>)<span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">double</span> temp=recursivePower(base,exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">double</span> result=temp*temp;</span><br><span class="line">    <span class="keyword">if</span>(exponent&amp;<span class="number">0x01</span>)</span><br><span class="line">        result*=base;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16、打印从1到最大的n位数（有问题）"><a href="#16、打印从1到最大的n位数（有问题）" class="headerlink" title="16、打印从1到最大的n位数（有问题）"></a>16、打印从1到最大的n位数（有问题）</h3><p>输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999</p>
<p><strong>解法1</strong><br>例如输入数字3<br>可以当成排列如下数字：<br>000<br>001<br>002<br>…<br>997<br>998<br>999<br>即打印出数字的全排列。<br>所以可以递归求解</p>
<p><strong>常规解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrinttoMax</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span> * number=<span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number,<span class="string">'0'</span>,n);</span><br><span class="line">    number[n]='/0';</span><br><span class="line">    <span class="keyword">while</span>(!increament(number))</span><br><span class="line">    &#123;</span><br><span class="line">        print(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increament</span><span class="params">(<span class="keyword">char</span> *number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isOverflow=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> nTK=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nlenth=<span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nlength<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17、删除链表的节点"><a href="#17、删除链表的节点" class="headerlink" title="17、删除链表的节点"></a>17、删除链表的节点</h3><p>题目1 ：在O（1）时间内删除链表节点，单向链表，只给一个头结点和一个需要被删除的节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode**head,ListNode*pBedelete)</span></span>;</span><br></pre></td></tr></table></figure>

<p>1 如果按照正常的思路来说，需要遍历一次整个链表，那么这个时候时间复杂度会是O（n），达不到题目需要的要求。</p>
<p>2 我们可以吧需要删除节点的下一个节点的值赋值给当前需要删除的节点，然后需要把需要删除的节点指向下一个节点的下一个节点，最后删除下一个节点，效果等同与删除当前节点。</p>
<p>3 但是，如果需要删除的节点位于链表的最后位置，我们还是需要遍历整个链表。</p>
<p>4 如果删除的节点链表唯一的一个节点，那么我们还需要把整个链表置为nullptr.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode**head,ListNode*pBedelete)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//常规进行非空判断</span></span><br><span class="line">    <span class="keyword">if</span>(!head||!pBedelete)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//正常的删除，非为节点</span></span><br><span class="line">    <span class="keyword">if</span>(pBedelete-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode*pnext=pBedelete-&gt;next;</span><br><span class="line">        pBedelete-&gt;m_nValue=pnext-&gt;m_nValue;</span><br><span class="line">        pBedelete-&gt;next=pnext-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pnext;</span><br><span class="line">        pnext=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表只有一个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*head==pBedelete)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pBedelete;</span><br><span class="line">        pBedelete=<span class="literal">nullptr</span>;</span><br><span class="line">        *head=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       ListNode* pNode=*head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next!=pBedelete)</span><br><span class="line">            &#123;</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head-&gt;next=pBedelete-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> pBedelete;</span><br><span class="line">            pBedelete=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-1删除链表中重复的节点"><a href="#17-1删除链表中重复的节点" class="headerlink" title="17.1删除链表中重复的节点"></a>17.1删除链表中重复的节点</h4><p>在一个排序的链表中，如何删除重复的节点。</p>
<p>1.用tmpNode和current指向头结点，用一个flag标志遇到连续的重复值<br>2.current用来遍历整个链表，在遍历时，每当遇到一个新的值的节点，就用tmpNode指向整个节点<br>3.直到遇到下一个新的值前，current遍历链表，若有相同的值，flag置为false<br>4.遇到下一个新的值时，若flag为true，则tmpNode没有重复；若flag为false，则tmpNode重复了<br>5.遍历结束后还要在判断一次</p>
<p>例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br>1.tmpNode和current指向1<br>2.current遍历到2，flag为true，1则加入新的链表中，tmpNode指向2<br>3.current遍历到3，flag为true，2则加入新的链表中，tmpNode指向3<br>4.current遍历到第二个3，遇到重复值，flag置为false<br>5.current遍历到4，flag为false，3这个节点就不管了，flag重新置为true，tmpNode指向4<br>6.current遍历到第二个4，遇到重复值，flag置为false<br>7.current遍历到5，flag为false，4这个节点就不管了，flag重新置为true，tmpNode指向5<br>8.遍历结束，做最后一次判断，flag为true则将5加入新的链表中（若为false则把最后一个节点的next指向null</p>
<p>​      </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;              </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteDulplication</span><span class="params">(ListNode**phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*phead==<span class="literal">nullptr</span>||head==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ListNode* preNode=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pnextNode=*phead;</span><br><span class="line">    <span class="comment">//进入整个链表的循环</span></span><br><span class="line">    <span class="keyword">while</span>(pnextNode!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* Pnext=pnextNode-&gt;next;<span class="comment">//当前节点的下一个节点</span></span><br><span class="line">        <span class="keyword">bool</span> isDulication=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pnext!=<span class="literal">nullptr</span>&amp;&amp;pnext-&gt;m_nValue==pnextNode-&gt;m_nValue)<span class="comment">//接下来两个节点的值相等？</span></span><br><span class="line">        &#123;</span><br><span class="line">            isDulication=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果接下来的链表的节点不是相同的</span></span><br><span class="line">        <span class="keyword">if</span>(!isDulication)</span><br><span class="line">        &#123;</span><br><span class="line">            preNode=pnextNode;</span><br><span class="line">            pnextNode=pnextNode-&gt;next;<span class="comment">//指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果接下来链表节点是相同的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> value=pnextNode-&gt;m_nValue;</span><br><span class="line">            ListNode* Bedelete=pnextNode;</span><br><span class="line">            <span class="keyword">while</span>(!Bedelete=<span class="literal">nullptr</span>&amp;&amp;Bedelete-&gt;m_nValue==value)</span><br><span class="line">            &#123;</span><br><span class="line">                Pnext=Bedelete-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> Bedelete;</span><br><span class="line">                Bedelete=<span class="literal">nullptr</span>;</span><br><span class="line">                Bedelete=Pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(preNode==<span class="literal">nullptr</span>)</span><br><span class="line">                *head=Pnext;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                preNode-&gt;next=Pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            pnextNode=Pnext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18、-正则表达式匹配"><a href="#18、-正则表达式匹配" class="headerlink" title="18、 正则表达式匹配"></a>18、 正则表达式匹配</h3><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符（指紧挨着的字符）可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>1、考虑特殊情况，当str和pattern都是空字符串时，匹配，返回true</p>
<p>​       当str不为空并且<em>pattern</em>为空时，一定不匹配，返回false（str为空，pattern不为空，有可能匹配）</p>
<p>2、考虑每次递归时的第二个字符是否是‘*’</p>
<p>​             当<em>（pattern+1）！=‘*’</em>‘’时，如果当前字符与模式字符相等(包括’.’），那么接着往下判断</p>
<p>​                                                            如果当前字符与模式字符不相等，直接不匹配，返回false</p>
<p>​             当<em>（pattern+1）==‘*’</em>‘’时，  如果当前字符与模式字符相等，那么考虑两种情况</p>
<p>​                                                             情况一：abc和模式ab*bc,当前字符匹配，模式的后面的字符还与其匹配</p>
<p>​                                                             情况二：abbc和模式ab*c，当前匹配，字符串的下一个字符还与其匹配</p>
<p>​                                                             如果当前字符与模式字符，字符串位置不变，模式后移两位，继续判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>*str,<span class="keyword">char</span>*pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(*str!=<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>)!=<span class="string">'*'</span>)<span class="comment">//如果下一个字符不是'*'</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str==*pattern||*str!=<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>,pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>)==<span class="string">'*'</span>)<span class="comment">//如果下一个是'*'</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str==*pattern||*str!=<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">return</span> match(str,pattern+<span class="number">2</span>)||match(str+<span class="number">1</span>, pattern);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> match(str,pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="20、表示数值的字符串"><a href="#20、表示数值的字符串" class="headerlink" title="20、表示数值的字符串"></a>20、表示数值的字符串</h3><h3 id="21、调整数组顺序使得奇数位于偶数前"><a href="#21、调整数组顺序使得奇数位于偶数前" class="headerlink" title="21、调整数组顺序使得奇数位于偶数前"></a>21、调整数组顺序使得奇数位于偶数前</h3><blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<p>  思路：</p>
<p>感觉这道题并没有比较完美的解法，要么时间复杂度高，要么空间复杂度高</p>
<ul>
<li><p>解法1：</p>
<p>遍历数组，将所有奇数前移，将所有偶数保存在队列里，并统计奇数个数</p>
<p>将队列里的偶数再放到数组中</p>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
</li>
<li><p>解法2：</p>
</li>
</ul>
<p>​        用i表示第一个偶数的下标，j表示i后面第一个奇数的下标（i，j初始化都为-1）</p>
<p>​        当找到符合的i,j时，将下标为[i,j)的值向后移一位（这个范围内都是偶数），</p>
<p>​       将原本下标为i的偶数替换为原本下标为j的奇数</p>
<p>​       最坏时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>*<em>使用解法1  *</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deueu&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven</span><span class="params">(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    deueu&lt;<span class="keyword">int</span>&gt;de;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pData[i]&amp;<span class="number">0x01</span>)==<span class="number">1</span>)</span><br><span class="line">            PData[index]=pData[i]</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             de.push_back(pData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index!=length&amp;&amp;!de.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pData[index++]=de.top();</span><br><span class="line">        de.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用解法2  维护两个指针 一前一后</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven</span><span class="params">(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> *begin=pData;</span><br><span class="line">    <span class="keyword">int</span> *end=pData+length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;(*begin&amp;<span class="number">0x1</span>)!=<span class="number">0</span>)</span><br><span class="line">            begin+;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;(*begin&amp;<span class="number">0x1</span>)==<span class="number">0</span>)</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=*end;</span><br><span class="line">            *begin=*end;</span><br><span class="line">            *end=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以扩展写法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reorder</span><span class="params">(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length,<span class="keyword">bool</span>(*fun)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(pData==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> *begin=pData;</span><br><span class="line">    <span class="keyword">int</span> *end=pData+length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;!func(*begin))</span><br><span class="line">            begin+;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;func(*end)</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=*end;</span><br><span class="line">            *begin=*end;</span><br><span class="line">            *end=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line"><span class="keyword">bool</span> isEven(<span class="keyword">int</span> n)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> (n&amp;<span class="number">1</span>)==<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">void</span> ReorderOddEven(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    Reorder(Pdata,length,isEven)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22、链表中的倒数第k个节点"><a href="#22、链表中的倒数第k个节点" class="headerlink" title="22、链表中的倒数第k个节点"></a>22、链表中的倒数第k个节点</h3><p>输入一个链表，输出该链表中倒数第k个节点。<br>为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。<br>例如，一个链表有6个节点，从头结点开始，它们的值以此是1、2、3、4、5、6。<br>这个链表的倒数第3个节点是值为4的节点。</p>
<p>方法1</p>
<p>定义两个节点node1，node2<br>让node1一开始指向第k个节点，node2指向第1个节点<br>此时node1和node2同时前进，[node1, node2]区间一共有k个节点<br>当node1指向最后一个节点时，node2即指向倒数第k个节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode * next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode*<span class="title">FindToNode</span><span class="params">(ListNode*phead,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||k&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* node1=phead;</span><br><span class="line">    ListNode* node2=phead;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node1=node1-&gt;next;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(node1==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node1!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node1=node1-&gt;next;</span><br><span class="line">        node2=node2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23、链表中环的入口节点（难点）"><a href="#23、链表中环的入口节点（难点）" class="headerlink" title="23、链表中环的入口节点（难点）"></a>23、链表中环的入口节点（难点）</h3><p>一个链表中包含环，请找出该链表的环的入口节点。</p>
<p>1.判断整个链表中有没有环的存在？</p>
<p>​    这里可以用一个快指针和一个满指针完成，如果到最后慢指针追上了快指针就表示有环的存在</p>
<p>2.怎么找到环的入口？</p>
<p>   这里还是用一个快指针和一个慢指针完成，假设这个环中有n个节点，让快指针前进n步，然后让慢指针往和快指针一起前进，一直到他们相遇，此时相遇的节点就是环的入口了。</p>
<p>3，怎么确定链表中有多少个环？</p>
<p>  假如在第一步中，快指针和慢指针相遇，那么肯定是在环里面相遇的，然后在让快慢指针一边向前走，一边计数，当指针回到原点，就可以得到环中的节点数了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">MeetNode</span><span class="params">(ListNode*phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode*slow=phead-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(slow==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     ListNode*Fast=slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span>&amp;&amp;Fast!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(slow==Fast)</span><br><span class="line">            <span class="keyword">return</span> Fast;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        Fast=slow-&gt;next;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode*<span class="title">EntryNodeOfLoop</span><span class="params">(ListNode*phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到相遇的节点</span></span><br><span class="line">    ListNode* meetNdoe=MeetNode(phead);</span><br><span class="line">    <span class="keyword">if</span>(meetNdoe==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">   <span class="comment">//找出环的个数</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    ListNode* tempNode=meetNdoe</span><br><span class="line">    <span class="keyword">while</span>(tempNode-&gt;next!=meetNdoe)</span><br><span class="line">    &#123;</span><br><span class="line">        tempNode=tempNode-&gt;next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找出了环的个数后 先移动快指针k步</span></span><br><span class="line">    ListNode*Fast=phead;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Fast=Fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">     ListNode*slow=phead;</span><br><span class="line">    <span class="comment">//快指针和慢指针一起向前移动</span></span><br><span class="line">    <span class="keyword">while</span>(slow!=Fast)</span><br><span class="line">    &#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        Fast=Fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24、反转链表"><a href="#24、反转链表" class="headerlink" title="24、反转链表"></a>24、反转链表</h3><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p>
<p>1.输入的链表头指针为null<br>2.输入的链表只有一个节点<br>3.输入的链表有多个节点（正常情况）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode*<span class="title">ReverseList</span><span class="params">(ListNode*phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(phead-&gt;next==null)</span><br><span class="line">        <span class="keyword">return</span> phead;</span><br><span class="line">    ListNdoe*Preversehead=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNdoe*pNode=phead;</span><br><span class="line">    ListNdoe*preNode=<span class="literal">nullptr</span>;</span><br><span class="line">   <span class="keyword">while</span>(pNode!=<span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       ListNode*Next=pNode-&gt;next;</span><br><span class="line">       <span class="keyword">if</span>(Next==<span class="literal">nullptr</span>)</span><br><span class="line">           Preversehead=pNode;</span><br><span class="line">       pNode-&gt;next=preNode;</span><br><span class="line">       preNode=pNode;</span><br><span class="line">       pNode=Next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用递归实现反转链表</p>
<h3 id="25、合并两个排序的链表"><a href="#25、合并两个排序的链表" class="headerlink" title="25、合并两个排序的链表"></a>25、合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。<br>例如：<br>链表1：1-&gt;3-&gt;5-&gt;7<br>链表2：2-&gt;4-&gt;6-&gt;8<br>合并后：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</p>
<p>很简单 注意边界问题就好了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode*next;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function">ListNode*<span class="title">Merge</span><span class="params">(ListNode* phead1,ListNode*phead2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(phead1==<span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span> phead2;</span><br><span class="line">     <span class="keyword">if</span>(phead2==<span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span> phead1;</span><br><span class="line">     ListNode*MergeHead=<span class="literal">nullptr</span>;</span><br><span class="line">     <span class="keyword">if</span>(phead1-&gt;val&lt;phead2-&gt;val)</span><br><span class="line">     &#123;</span><br><span class="line">         MergeHead=head1;</span><br><span class="line">         MergeHead-&gt;next=Merge(phead1-&gt;next,phead2);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         MergeHead=head2;</span><br><span class="line">         MergeHead-&gt;next=Merge(phead1,phead2-&gt;next);       </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> MergeHead;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>扩展 vector&lt;ListNode*&gt;vec;里面有n个链表，并且已经排好序，请将这里的链表完全排序</p>
<h3 id="26、树的子结构"><a href="#26、树的子结构" class="headerlink" title="26、树的子结构"></a>26、树的子结构</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。<br>（ps：我们约定空树不是任意一个树的子结构）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 直接递归的版本 */</span></span><br><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSubtree</span><span class="params">(BinaryTreeNode*root1,BinaryTreeNode*root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root1=<span class="literal">nullptr</span>&amp;&amp;!root2=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Equal(root1-&gt;val,root2-&gt;val))</span><br><span class="line">        &#123;</span><br><span class="line">            result=DoesSimTree(root1,root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">            result=hasSubtree(root1-&gt;left,root2);</span><br><span class="line">        <span class="keyword">if</span>(!resuklt)</span><br><span class="line">            result=hasSubtree(root1,root2-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Equal</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a-b&gt;<span class="number">0.00000001</span>)&amp;&amp;(a-b&lt;<span class="number">0.00000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DoesSimTree</span><span class="params">(BinaryTreeNode*root1,BinaryTreeNode*root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root1==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!Equal(root1-&gt;val,root2-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> DoesSimTree(root1-&gt;left,root2-&gt;left)&amp;&amp;DoesSimTree(root1-&gt;right,root2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27、二叉树的镜像"><a href="#27、二叉树的镜像" class="headerlink" title="27、二叉树的镜像"></a>27、二叉树的镜像</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>求一棵树的镜像的过程：先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当交换完所有的左右子节点之后，就得到了树的镜像。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BianryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BianryTreeNode* left;</span><br><span class="line">    BianryTreeNode* right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BianryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BianryTreeNode* left;</span><br><span class="line">    BianryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MirrorRecursively</span><span class="params">(BianryTreeNode * proot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;left==<span class="literal">nullptr</span>&amp;&amp;proot-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BianryTreeNode* temp=proot-&gt;left;</span><br><span class="line">    proot-&gt;left=proot-&gt;right;</span><br><span class="line">    proot-&gt;right=temp;</span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MirrorRecursively(proot-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MirrorRecursively(proot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28、对称的二叉树"><a href="#28、对称的二叉树" class="headerlink" title="28、对称的二叉树"></a>28、对称的二叉树</h3><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>从根节点的左右两个子节点出发</p>
<ul>
<li>左子节点采用 根左右 的方式遍历</li>
<li>右子节点采用 左根右 的方式遍历</li>
<li>每遍历一次就进行比较，一旦出现不同的值就表示不是对称的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BianryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BianryTreeNode* left;</span><br><span class="line">    BianryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">issymmetrytree</span><span class="params">(BianryTreeNode* proot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> issymmetrytree(proot,proot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">issymmetrytree</span><span class="params">(BianryTreeNode* proot1,BianryTreeNode* proot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot1==<span class="literal">nullptr</span>&amp;&amp;proot2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(proot1==<span class="literal">nullptr</span>||proot2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(proot1-&gt;val!=proot2-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> issymmetrytree(proot1-&gt;left,proot2-&gt;right)&amp;&amp; issymmetrytree(proot2&gt;left,proot1&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29、顺时针打印矩阵"><a href="#29、顺时针打印矩阵" class="headerlink" title="29、顺时针打印矩阵"></a>29、顺时针打印矩阵</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，<br>例如，如果输入如下矩阵：<br>1 2 3 4<br>5 6 7 8<br>9 10 11 12<br>13 14 15 16<br>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>从外到里 一次打印 但是要注意到边界条件 防止打印的时候越界了 第一次打印的起来是（0.0）第二次打印的起点是（1,1） 选取起点坐标作为分析的依据</p>
<p>得出一个循环的条件<br>$$<br>columns&gt;startX * 2  并且rows&gt;startY * 2<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printarray</span><span class="params">(<span class="keyword">int</span> **number,<span class="keyword">int</span> columns,<span class="keyword">int</span> rows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="literal">nullptr</span>||columns&lt;=<span class="number">0</span>||rows&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(columns&gt;start*<span class="number">2</span>&amp;&amp;rows&gt;start*<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Printarray(number,columns,rows,start);</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printarray</span><span class="params">(<span class="keyword">int</span> **number,<span class="keyword">int</span> columns,<span class="keyword">int</span> rows,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endX=columns<span class="number">-1</span>-start;</span><br><span class="line">    <span class="keyword">int</span> endY=rows<span class="number">-1</span>-start;</span><br><span class="line">    <span class="comment">//从左往右打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=endX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Print(number[start][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从上到下打印一列</span></span><br><span class="line">   <span class="keyword">if</span>(start&lt;endY)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=endY;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           Print(number[i][endY])</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;endX&amp;&amp;start&lt;endX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="30、包含min函数的栈"><a href="#30、包含min函数的栈" class="headerlink" title="30、包含min函数的栈"></a>30、包含min函数的栈</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<p>定义两个栈，一个栈保存数据，另一个保存新数据入栈后的最小数<br>pop时，两个栈都要pop;<br>则minstack()的栈顶即为最小元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sulotion</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;minstack;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;mystack;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mystack.push(value);</span><br><span class="line">        <span class="keyword">if</span>(!minstack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">          minstack.push(<span class="built_in">std</span>::min(minstack.top(),value));  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          minstack.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        minstack.pop();</span><br><span class="line">        mystack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mystack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用两个vector实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        mystack.push_back(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minstack.empty())</span><br><span class="line">            minstack.push_back(value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value&lt;minstack.back())</span><br><span class="line">            minstack.push_back(value);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            minstack.push_back(minstack.back());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mystack.pop_back();</span><br><span class="line">        minstack.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mystack.back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minstack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="31、栈的压入、弹出序列-没看"><a href="#31、栈的压入、弹出序列-没看" class="headerlink" title="31、栈的压入、弹出序列(没看)"></a>31、栈的压入、弹出序列(没看)</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>这道题思路还是挺简单的<br>用一个辅助栈来解决，把压入序列的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。</p>
<p>例：<br>压入序列：1,2,3,4,5<br>弹出序列：4,5,3,2,1<br>将压入序列的元素依次压入辅助栈，直到栈顶为弹出序列的首个元素，即：<br>压入1，1不等于4（弹出序列首个元素）；<br>继续压入2，2不等于4；<br>继续压入3，3不等于4；<br>继续压入4；<br>此时4等于弹出序列的首个元素，将4弹出。<br>此时栈顶3不等于5（弹出序列的第二个元素），继续压入5；<br>此时5等于弹出序列的第二个元素，将5弹出。<br>此时3等于弹出序列的第三个元素，将3弹出。<br>此时2等于弹出序列的第四个元素，将2弹出。<br>此时1等于弹出序列的第五个元素，将1弹出。<br>此时压入序列遍历完毕，弹出序列也遍历完毕，栈为空，所以该弹出序列和该压入序列是匹配的。<br>————————————————</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">const</span> *<span class="keyword">int</span> Ppush,<span class="keyword">const</span> *<span class="keyword">int</span> pPop,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bossible=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(Ppush!=<span class="literal">nullptr</span>&amp;&amp;pPop!=<span class="literal">nullptr</span>&amp;&amp;length&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>*pNextPush=Ppush;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>*pNextPop=pPop;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;data;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="32、从上往下不分行打印二叉树"><a href="#32、从上往下不分行打印二叉树" class="headerlink" title="32、从上往下不分行打印二叉树"></a>32、从上往下不分行打印二叉树</h3><h4 id="1-从上往下打印出二叉树的每个节点，同层节点从左至右打印"><a href="#1-从上往下打印出二叉树的每个节点，同层节点从左至右打印" class="headerlink" title="1.从上往下打印出二叉树的每个节点，同层节点从左至右打印"></a>1.从上往下打印出二叉树的每个节点，同层节点从左至右打印</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printtreeone</span><span class="params">(BinaryTreeNode*ptreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptreeRoot==null)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>:<span class="built_in">deque</span>&lt;BinaryTreeNode*&gt;De;</span><br><span class="line">    De.push_back(BinaryTreeNode*ptreeRoot);</span><br><span class="line">    <span class="keyword">while</span>(De.size())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* Node=De.front();</span><br><span class="line">        De.pop_front();</span><br><span class="line">        print(Node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;left)</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;right)</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-分行从上到下打印二叉树-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行"><a href="#2-分行从上到下打印二叉树-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行" class="headerlink" title="2 分行从上到下打印二叉树 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行"></a>2 分行从上到下打印二叉树 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printtreetwo</span><span class="params">(BinaryTreeNode*ptreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptreeRoot==null)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>:<span class="built_in">deque</span>&lt;BinaryTreeNode*&gt;De;</span><br><span class="line">    <span class="keyword">int</span> TobePrint=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextNode=<span class="number">0</span>;</span><br><span class="line">    De.push_back(BinaryTreeNode*ptreeRoot);</span><br><span class="line">    <span class="keyword">while</span>(De.size())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* Node=De.front();</span><br><span class="line">        De.pop_front();</span><br><span class="line">        print(Node-&gt;val);</span><br><span class="line">        TobePrint--;</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;left);</span><br><span class="line">            nextNode++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;right!=<span class="literal">nullptr</span>);</span><br><span class="line">            nextNode++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(TobePrint==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(‘换行’);</span><br><span class="line">            TobePrint=nextNode;</span><br><span class="line">            nextNode=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、之字形打印二叉树"><a href="#3、之字形打印二叉树" class="headerlink" title="3、之字形打印二叉树"></a>3、之字形打印二叉树</h3><h4 id="3-请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推"><a href="#3-请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推" class="headerlink" title="3 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推"></a>3 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推</h4><p> 两个栈保存，交替打印</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printtreethree</span><span class="params">(BinaryTreeNode*ptreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(ptreeRoot==<span class="literal">nullptr</span>)</span><br><span class="line">       <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">deque</span>&lt;BinaryTreeNode*&gt;De[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> curr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next=<span class="number">1</span>;</span><br><span class="line">    De[curr].push(ptreeRoot);</span><br><span class="line">    <span class="keyword">while</span>(!De[<span class="number">0</span>].empty()||!De[<span class="number">1</span>].empty())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* Node=De[curr].top();</span><br><span class="line">        Print(Ndoe-&gt;val);</span><br><span class="line">        De[curr].pop();</span><br><span class="line">        <span class="keyword">if</span>(curr==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Ndoe-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Ndoe-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">if</span>(Ndoe-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">              <span class="keyword">if</span>(Ndoe-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(De[curr].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            print('换行');</span><br><span class="line">            curr=<span class="number">1</span>-curr;</span><br><span class="line">            next=<span class="number">1</span>-next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33、二叉搜索树的后序遍历序列"><a href="#33、二叉搜索树的后序遍历序列" class="headerlink" title="33、二叉搜索树的后序遍历序列"></a>33、二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历结果。<br>如果是则返回true，否则返回false。<br>假设输入的数组的任意两个数字互不相同。</p>
<p>输入数组{5, 7, 6, 9, 11, 10, 8}，则返回true，<br>因为这个整数序列是下面这个二叉搜索树的后序遍历结果。<br>如果输入的数组是{7, 4, 6, 5}，则由于没有<br>哪棵二叉搜索树的后序遍历结果是这个序列，因此返回false。<br>8<br>/ <br>6 10<br>/ \ / <br>5 7 9 1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isafterlist</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> root=data[length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(data[i]&gt;root);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">int</span> j=i;</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[j]&lt;root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> left=<span class="literal">true</span>;</span><br><span class="line">    left=isafterlist(data,i);</span><br><span class="line">    <span class="keyword">bool</span> right=<span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(i&lt;length<span class="number">-1</span>)</span><br><span class="line">        right=isafterlist(data+i,length-i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (left&amp;&amp;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/剑指offer/剑指offer题目二刷/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/剑指offer/剑指offer题目二刷/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>剑指Offer题目知识点（二刷）{33—–66题}</p>
<h3 id="34、二叉树中和为某一值的路径"><a href="#34、二叉树中和为某一值的路径" class="headerlink" title="34、二叉树中和为某一值的路径"></a>34、二叉树中和为某一值的路径</h3><p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>使用前序遍历，然后用栈保存路径，并统计当前路径的sum。<br>当某个节点已经不在路径内，这个节点要出栈，并从sum中减去对应的值。<br>ps:因为打印路径的时候需要遍历这个栈，所以这个栈结构最好能遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>               val;</span><br><span class="line">    BinaryTreeNode*  left;</span><br><span class="line">    BinaryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(BinaryTreeNode*root,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line">    <span class="keyword">int</span> currentSum=<span class="number">0</span>;</span><br><span class="line">    FindPath(root,sum,path,currentSum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(BinaryTreeNode*root,<span class="keyword">int</span> sum,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path,<span class="keyword">int</span> currentsum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currentSum+=root-&gt;val;</span><br><span class="line">    path.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">bool</span> isleaf=(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">if</span>(currentSum==sum&amp;&amp;isleaf)</span><br><span class="line">    &#123;</span><br><span class="line">        print(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FindPath(root-&gt;left,sum,path,currentSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FindPath(root-&gt;right,sum,path,currentSum);</span><br><span class="line">    &#125;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="35、复杂链表的复制"><a href="#35、复杂链表的复制" class="headerlink" title="35、复杂链表的复制"></a>35、复杂链表的复制</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，<br>一个指向下一个节点，另一个特殊指针指向任意一个节点或者null），<br>返回结果为复制后复杂链表的head。<br>（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  val;</span><br><span class="line">    ComplexListNode* next;</span><br><span class="line">    ComplexListNode* Sibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.第一步：根据原始链表的每个节点N创建对应的N’。把N’链接在N的后面。<br>2.第二步：设置复制出来的节点的random<br>3.第三步：把这个长链表拆分成两个链表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  val;</span><br><span class="line">    ComplexListNode* next;</span><br><span class="line">    ComplexListNode* Sibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClonNode</span><span class="params">(ComplexListNode*head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComplexListNode*node=head;</span><br><span class="line">    <span class="keyword">while</span>(node-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ComplexListNode*pClond=<span class="keyword">new</span> ComplexListNode();</span><br><span class="line">        pClond-&gt;val=node-val;</span><br><span class="line">        pClond-&gt;next=ndoe-&gt;next;</span><br><span class="line">        </span><br><span class="line">        pClond-&gt;Sibling=<span class="literal">nullptr</span>;</span><br><span class="line">        ndoe-&gt;next=pClond;</span><br><span class="line">        ndoe=pClond-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectSibling</span><span class="params">(ComplexListNode*head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connectSibling* Node=head;</span><br><span class="line">    <span class="keyword">while</span>(Node!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        connectSibling* pClond= Node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Node-&gt;Sibling!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pClond-&gt;Sibling=Node-&gt;Sibling-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node=pClond-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReconnectNode</span><span class="params">(ComplexListNode*head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComplexListNode*Node=head;</span><br><span class="line">    ComplexListNode*pClondhead=<span class="literal">nullptr</span>;</span><br><span class="line">    ComplexListNode*pClondNode=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//先设置好头结点</span></span><br><span class="line">    <span class="keyword">if</span>(Node!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pClondhead=pClondNode=Node-&gt;next;</span><br><span class="line">        Node-&gt;next=pClondNode-&gt;next;</span><br><span class="line">        Node=Node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Ndoe!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pClondNode-&gt;next=Node-&gt;next;</span><br><span class="line">        pClondNode=Ndoe-&gt;next;</span><br><span class="line">        Node-&gt;next=pClondNode-&gt;next;</span><br><span class="line">        Node=pClondNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pClondhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="36、二叉树与双向链表（-）"><a href="#36、二叉树与双向链表（-）" class="headerlink" title="36、二叉树与双向链表（*****）"></a>36、二叉树与双向链表（<strong>*****</strong>）</h3><p>使用中序遍历二叉搜索树，得到的便是整个排序的序列。<br>我们用一个节点指针 lastNodeInList 来指向已排序的链表的最后一个节点。<br>在中序遍历的时候，每遍历到一个节点，就将该节点与 lastNodeInList 双向连接，并将 lastNodeInList 置为新遍历到的这个节点。</p>
<p>一直递归到最左边的节点，然后往外回，采用的是中序遍历，这样子的节点遍历顺序刚好是排序好的了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  val;</span><br><span class="line">    BinaryTreeNode* left;</span><br><span class="line">    BinaryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">convertNode</span><span class="params">(BinaryTreeNode*proot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTreeNode*PlistInNode=<span class="literal">nullptr</span>;</span><br><span class="line">    converyNode(proot,PlistInNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">converyNode</span><span class="params">(BinaryTreeNode*pNode,BinaryTreeNode**PlistInNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BinaryTreeNode*pcurrentNode=proot;</span><br><span class="line">    <span class="keyword">if</span>(pcurrentNode-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        converyNode(pcurrentNode-&gt;left,PlistInNode);</span><br><span class="line">    &#125;</span><br><span class="line">    pcurrentNode-&gt;left=PlistInNode;</span><br><span class="line">    <span class="keyword">if</span>(PlistInNode!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (*PlistInNode)-&gt;right=pcurrentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    *PlistInNode=pcurrentNode;</span><br><span class="line">    <span class="keyword">if</span>(pcurrentNode-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        converyNode(pcurrentNode-&gt;right,PlistInNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="37、序列化二叉树"><a href="#37、序列化二叉树" class="headerlink" title="37、序列化二叉树"></a>37、序列化二叉树</h3><p> 请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>这里是二叉树的序列化的代码 及时直接前序遍历二叉树 然后如果是nullptr 则是输出的￥</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  val;</span><br><span class="line">    BinaryTreeNode* left;</span><br><span class="line">    BinaryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(BinaryTreeNode*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cont&lt;&lt;<span class="string">"$"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Serialize(root-&gt;left);</span><br><span class="line">    Serialize(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是反序列化的代码  ReadStream 这个函数主要的功能是看从字节流里面读出来的是数字还是符号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deserialize</span><span class="params">(BinaryTreeNode**root,istream&amp;stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">if</span>(ReadStream(stream,&amp;number))</span><br><span class="line">    &#123;</span><br><span class="line">        *proot=<span class="keyword">new</span> BinarytreeNode();</span><br><span class="line">        (*proot)-&gt;val=number;</span><br><span class="line">        (*proot)-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">        (*proot)-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        Deserialize(&amp;((*proot)-&gt;left),stream);</span><br><span class="line">        Deserialize(&amp;((*proot)-&gt;right),stream);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="38、字符串的排列"><a href="#38、字符串的排列" class="headerlink" title="38、字符串的排列"></a>38、字符串的排列</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>ps：输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母</p>
<p>将字符串操作分为三步进行：<br>将字符串分为两部分，第一部分是第一个字符；另外一部分是后面的字符串；每次循环将第一个字符与后面的每个字符进行交换；<br>对后一部分字符串，视为当前字符串，进行前面同样的操作；<br>子字符串操作完成后，需要恢复第一个位置的原本字符。<br>例子：如“abcd”，a和b交换后，成为“bacd”;当后面的3个字符的子字符串操作完成后，需要对‘a’和‘c’进行交换，但是当前是“bacd”；所以需要再交换回来成为“abcd”，再进行交换及后面子字符串的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Permutation(str,str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">char</span>*begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin==<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">"%s/n"</span>,str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假如这里是abcd 先是 a 和 b 进行交换，得到bacd 然后是后面的 acd 进行排序 然后</span></span><br><span class="line">         <span class="comment">//又是 ad 进行排序 最后是 a  在依次往外压出 最后还原成abcd </span></span><br><span class="line">        <span class="comment">//在进行第二轮大的排序  abcd----&gt;cbad; </span></span><br><span class="line">        <span class="comment">//                   abcd----&gt;dcbd;</span></span><br><span class="line">        <span class="comment">//这样子就可以把整个排列的情况列举出来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>* ph=begin;ph!=<span class="string">'\0'</span>;ph++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(ph,begin);</span><br><span class="line">            Permutation(str,begin+<span class="number">1</span>);</span><br><span class="line">            swap(ph,begin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *temp=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39、数组中出现次数超过一半的数字"><a href="#39、数组中出现次数超过一半的数字" class="headerlink" title="39、数组中出现次数超过一半的数字"></a>39、数组中出现次数超过一半的数字</h3><blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，说明它出现的次数比其他所有数字出现的次数和还要多。</p>
<p>那么要找的数字肯定是最后一次把数组设置为1时对应的数字，即val可能就是我们要的值<br>之所以说是可能，是因为还要验证val出现的次数是否真正超过了数组长度的一半</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MorethanHalfNumber</span><span class="params">(<span class="keyword">int</span> *number,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result=number[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> time=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(time==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result=number[i];</span><br><span class="line">            time=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result==number[i])</span><br><span class="line">        &#123;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            time--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!checknumberMoreThanHalf(number,length,result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种比较笨比的办法 这里首先会改变数组里数字的排序情况 然后时间复杂度也不是很好</p>
<p>基快排的思想去找到中间的那个数字，然后看这个数字是不是超过一半</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanNumber</span><span class="params">(<span class="keyword">int</span> *numbers,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> middle=length&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end=length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> index=Partition(numbers,start,end);</span><br><span class="line">    <span class="keyword">while</span>(index!=middle)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(index&gt;middle)</span><br><span class="line">       &#123;</span><br><span class="line">           end=index<span class="number">-1</span>;</span><br><span class="line">           Patition(numbers,start,end);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            start=index+<span class="number">1</span>;</span><br><span class="line">            Patation(numbers,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result=numbers[middle];</span><br><span class="line">    <span class="keyword">if</span>(!checknumberMoreThanHalf(number,length,result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="40、最小的K个数"><a href="#40、最小的K个数" class="headerlink" title="40、最小的K个数"></a>40、最小的K个数</h3><p>输入n个整数，找出其中最小的K个数。<br>例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。<br>ps：题目只要求最小的k个数，没有要求这k个数要排序</p>
<p>解法1：</p>
<ul>
<li>使用partition算法</li>
<li>时间复杂度为O(n)</li>
<li>空间复杂度为O(1)</li>
<li>数组会乱序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetlastNumbers</span><span class="params">(<span class="keyword">int</span> *put,<span class="keyword">int</span> length,<span class="keyword">int</span>*output,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(put==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>||k&gt;length||k&lt;=<span class="number">0</span>)\</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end=length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> index=Patition(put,start,end);</span><br><span class="line">    <span class="keyword">while</span>(index!=k<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;k<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end=index<span class="number">-1</span>;</span><br><span class="line">            Patition(put,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            start=index+<span class="number">1</span>;</span><br><span class="line">            Patition(put,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        output[i]=put[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用优先队列来做，用最大堆实现整个过程</p>
<p>==代码==</p>
<p>还可以基于红黑树做，用到STL的map 或者是 multiset</p>
<p>==代码==</p>
<h3 id="41、数据流中的中位数"><a href="#41、数据流中的中位数" class="headerlink" title="41、数据流中的中位数"></a>41、数据流中的中位数</h3><p>如何得到一个数据流中的中位数？如果从数据流中读取奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序后中间两个数的平均数</p>
<p>1.本来使用一个AVL树来实现是最佳的，但是各种语言的函数库都还没有现成的AVL树的实现，所以选择使用两个堆来完成。使用一个最大堆实现中位数左边的数据容器，使用一个最小堆实现中位数右边的数据容器。往堆中插入一个数据的时间是O(logn)，而取得最大最小数据的时间是O(1)。</p>
<blockquote>
<p>1.必须保证数据平均分配到两个堆中间，即两个堆中的数据数目之差不能超过1。为了实现数据的平均分配，可以在数据的总数目是偶数是把新数据插入到最小堆中，否则插入到最大堆中。<br>2.还必须保证最小堆中的所有数据都要大于最大堆中的数据。比如在偶数个数据时，如果要插入的数据小于最大堆的一些数据，需要把数据先插入最大堆，然后把最大堆的最大数据弹出，再插入到最小堆中。奇数个数的数据插入时也相同。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于vector的最大堆个最小堆实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//插入前 先判断现在左右整个堆奇偶性</span></span><br><span class="line">        <span class="keyword">if</span>(((min.size()+max.size())&amp;<span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max.size()&gt;&amp;&amp;num&lt;max[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                max.push_back(num);</span><br><span class="line">                push_head(max.begin(),max.end(),less&lt;T&gt;());</span><br><span class="line">                num=max[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//这里没有看懂为什么要维护两次</span></span><br><span class="line">                push_head(max.begin(),max.end(),less&lt;T&gt;());</span><br><span class="line">                max.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            min.push_back(num);</span><br><span class="line">            push_head(min.begin(),min.end(),greater&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(min.size()&gt;<span class="number">0</span>&amp;&amp;num&gt;min[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                min.push_back(num);</span><br><span class="line">                push_head(min.begin(),min.end(),greater&lt;T&gt;());</span><br><span class="line">                num=min[<span class="number">0</span>];</span><br><span class="line">                push_head(min.begin(),min.end(),greater&lt;T&gt;());</span><br><span class="line">                min.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            max.push_back(num);</span><br><span class="line">            push_head(max.begin(),max.end(),less&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetMiddleNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=min.size()+max.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> mother fucker;</span><br><span class="line">        T result;</span><br><span class="line">        <span class="keyword">if</span>(size&amp;<span class="number">1</span>==<span class="number">1</span>)</span><br><span class="line">            result=min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result=(max[<span class="number">0</span>]+min[<span class="number">0</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt;min;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt;max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42、连续子数组的最大和"><a href="#42、连续子数组的最大和" class="headerlink" title="42、连续子数组的最大和"></a>42、连续子数组的最大和</h3><p>输入一个整型数组，数组里面有正数也有负数。数组中的一个或连续多个整数组成自一个子数组，求所有子数组的和的最大值。要求时间复杂度为O(n)</p>
<p>​        </p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/空间配置器的标准接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/空间配置器的标准接口/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="空间配置器概述"><a href="#空间配置器概述" class="headerlink" title="空间配置器概述"></a>空间配置器概述</h1><p>以前在项目中运用STL一般都不会涉及到空间配置器，可是，在STL的实现中，空间配置器是重中之重，因为整个STL的操作对象都存放在容器之内，而容器一定需要配置空间以置放资料。所以，在阅读STL源码时，最先需要掌握的就是空间配置器，没了它，容器，算法怎么存在？</p>
<p>C++ STL的空间配置器将内存的配置、释放和对象的构造和析构分开，内存配置操作由alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造操作由::construct()负责，对象的析构操作由::destroy()负责。首先放一张思维导图来概述一下STL的整个空间配置器概览。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfode4zyj30qs0agq3y.jpg" alt="空间配置器"></p>
<h1 id="对象的构造和析构"><a href="#对象的构造和析构" class="headerlink" title="对象的构造和析构"></a>对象的构造和析构</h1><p>个人觉得看源码只需要图和代码注释即可，所以本篇博客图片较多！对着图来看代码效率会高很多！</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfo9n8psj30ql08z3zm.jpg" alt="构造和析构"></p>
<p>下面是源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new.h&gt;        // 需要placement new的原型</span></span></span><br><span class="line"><span class="comment">// -----------------构造函数---------------------------------//</span></span><br><span class="line"><span class="comment">// 使用placement new在已经分配的内存上构造对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(<span class="title">T1</span>* <span class="title">p</span>, <span class="title">const</span> <span class="title">T2</span>&amp; <span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">new</span> (p) T1(value);<span class="comment">//将value设定到指针p所指的空间上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------析构函数---------------------------------//</span></span><br><span class="line"><span class="comment">// -----------第一个版本：接受一个指针--------------------------//</span></span><br><span class="line"><span class="comment">// 调用成员的析构函数, 需要类型具有non-trivial destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span>* <span class="title">pointer</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    pointer-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------第二个版本：接受两个迭代器------------------------//</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __destroy(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先是两个特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">char</span>*)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">wchar_t</span>*, <span class="keyword">wchar_t</span>*)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构一组对象, 用于具有non-trivial destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span></span></span><br><span class="line"><span class="class">__<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first &lt; last; ++first)</span><br><span class="line">    destroy(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有类型non-trivial destructor, 则使用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span>, <span class="title">ForwardIterator</span>, __<span class="title">true_type</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用traits技术, 判断类型是否就有non-trivial destructor, 然后调用不同的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">T</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">  __destroy_aux(first, last, trivial_destructor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内存的配置和释放"><a href="#内存的配置和释放" class="headerlink" title="内存的配置和释放"></a>内存的配置和释放</h1><p>在内存配置方面，STL分为两级配置器，当请求的内存大于128b的时候调用第一级配置器，当请求的内存小于等于128b的时候调用第二级配置器。先来看看下面这张表，大概就能知道第一级和第二级配置器主要干了些什么，其他的一些细节如内存池是怎么工作的，下面会给出具体解释。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfoeivm3j30q3078t9m.jpg" alt="内存配置"></p>
<h2 id="第一级配置器"><a href="#第一级配置器" class="headerlink" title="第一级配置器"></a>第一级配置器</h2><p>首先我们来看第一级配置器的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//调用malloc函数不成功后调用</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用realloc函数不成功后调用 </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类似于C++的set_new_handle错误处理函数一样，如果不设置，在内存不足时，返回THROW_BAD_ALLOC</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG  </span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;  </span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:  </span><br><span class="line">	<span class="comment">//直接调用malloc来分配内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">	 <span class="keyword">void</span> *result = <span class="built_in">malloc</span>(n);  </span><br><span class="line">	 <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_malloc(n);  <span class="comment">//如果分配失败，则调用oom_malloc()</span></span><br><span class="line">	 <span class="keyword">return</span> result;  </span><br><span class="line">	&#125;  </span><br><span class="line"> 	<span class="comment">//第一级配置器直接调用free来释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* n */</span>)</span>  </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="built_in">free</span>(p); </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//直接调用reallloc来分配内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> new_sz)</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">	 <span class="keyword">void</span> * result = <span class="built_in">realloc</span>(p, new_sz);  </span><br><span class="line">	 <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_realloc(p, new_sz);  <span class="comment">//如果realloc分配不成功，调用oom_realloc()</span></span><br><span class="line">	 <span class="keyword">return</span> result;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常处理函数，即内存分配失败后的处理</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="keyword">void</span> (*f)()))</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">	 <span class="keyword">void</span> (* old)() = __malloc_alloc_oom_handler;  </span><br><span class="line">	 __malloc_alloc_oom_handler = f;  </span><br><span class="line">	 <span class="keyword">return</span>(old);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上述源码中可以看到，STL的第一级配置器仅仅是调用了malloc，free等函数，然后增加了内存分配错误下的异常处理函数，下面我们就通过源码来看看在内存分配失败后，STL是怎么处理的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是针对内存分配失败后的处理</span></span><br><span class="line"><span class="comment">//首先，将__malloc_alloc_oom_handler的默认值设为0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_malloc(<span class="keyword">size_t</span> n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">void</span> (* my_malloc_handler)();  </span><br><span class="line">	<span class="keyword">void</span> *result;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  <span class="comment">// 不断地尝试释放、再配置、再释放、再配置</span></span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;  </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;  <span class="comment">//这里是当没有设置处理函数的时候，直接抛出异常</span></span><br><span class="line">		(*my_malloc_handler)();   <span class="comment">// 调用处理例程，尝试释放内存</span></span><br><span class="line">		result = <span class="built_in">malloc</span>(n);  	  <span class="comment">// 再重新分配内存</span></span><br><span class="line">		<span class="keyword">if</span> (result) <span class="keyword">return</span>(result);  <span class="comment">// 如果分配成功则返回指针</span></span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">void</span> (* my_malloc_handler)();  </span><br><span class="line">	<span class="keyword">void</span> *result;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  <span class="comment">//不断地尝试释放、再配置、再释放、再配置</span></span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;  </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; <span class="comment">//这里是当没有设置处理函数的时候，直接抛出异常 </span></span><br><span class="line">		(*my_malloc_handler)();  <span class="comment">// 调用处理例程，尝试释放内存</span></span><br><span class="line">		result = <span class="built_in">realloc</span>(p, n);  <span class="comment">// 再重新分配内存</span></span><br><span class="line">		<span class="keyword">if</span> (result) <span class="keyword">return</span>(result);  <span class="comment">// 如果分配成功则返回指针</span></span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二级配置器"><a href="#第二级配置器" class="headerlink" title="第二级配置器"></a>第二级配置器</h2><p>当申请内存小于128b的时候，会调用第二级配置器。第二级配置器有一个内存池和一个对应的自由链表，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> obj  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">union</span> obj * free_list_link;  </span><br><span class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里有一个技巧，如果使用union的第一个成员，则指向另一个相同的union obj；而如果使用第二个成员，则指向实际的内存区域，这样一来，既实现了链表结点只用一个指针的大小空间，却能同时做索引和指向内存区域。</p>
<blockquote>
<p>这里的这个技巧我觉得有必要解释一下，首先client_data是一个常量指针，指向client_data[0]，然后client_data[0]和free_list_link共用同一段内存，我们在使用这个union的时候，先让client_data指向实际的内存区域，然后将free_list_link(也就是client_data[0])赋值为下一个结点的地址，注意这里我只是修改了client_data[0]，client_data并没有修改，而是始终指向实际内存。</p>
</blockquote>
<p>我们先来看看第二级配置器的部分源码，然后再去分析其中每个函数的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;   <span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;  <span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;   <span class="comment">//free-lists个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一参数用于多线程，这里不做讨论。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 此函数将bytes的边界上调至8的倍数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));  </span><br><span class="line">	&#125;  </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">	<span class="comment">// 此union结构体上面已经解释过了</span></span><br><span class="line">	<span class="keyword">union</span> obj  </span><br><span class="line">	&#123;  </span><br><span class="line">	<span class="keyword">union</span> obj * free_list_link;  </span><br><span class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">	&#125;;  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="comment">//16个free-lists</span></span><br><span class="line">	<span class="keyword">static</span> obj * __VOLATILE free_list[__NFREELISTS];</span><br><span class="line">	<span class="comment">// 根据待待分配的空间大小, 在free_list中选择合适的大小  </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span>  size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个大小为n的对象，并可能加入大小为n的其它区块到free-lists</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;  </span><br><span class="line">	<span class="comment">// 配置一大块空间，可容纳nobjs个大小为“size”的区块</span></span><br><span class="line">	<span class="comment">// 如果配置nobjs个区块有所不便，nobjs可能会降低，所以需要用引用传递</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span></span>;  </span><br><span class="line">	<span class="comment">// 内存池  </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *start_free;      <span class="comment">// 内存池起始点，只在chunk_alloc()中变化 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *end_free;        <span class="comment">// 内存池结束点，只在chunk_alloc()中变化 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;      <span class="comment">// 已经在堆上分配的空间大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;<span class="comment">// 空间配置函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span></span>; <span class="comment">// 空间释放函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> old_sz , <span class="keyword">size_t</span> new_sz)</span></span>; <span class="comment">//空间重新配置函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些静态成员变量的初始化</span></span><br><span class="line"><span class="comment">// 内存池起始位置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 内存池结束位置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 已经在堆上分配的空间大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 内存池容量索引数组  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj * __VOLATILE  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt; ::free_list[__NFREELISTS ] = </span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>

<p>看完上面这一堆源码，你可能早就头晕眼花，一脸懵逼了，没事，我再来用一张思维导图来帮你理一理思绪：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkfocm8q6j30ri0dl40t.jpg" alt="二级配置器1"></p>
<p>接下来又是枯燥的源码时间！相信有上面这张图，看源码的思路就比较清晰了。</p>
<h3 id="空间配置函数allocate"><a href="#空间配置函数allocate" class="headerlink" title="空间配置函数allocate()"></a>空间配置函数allocate()</h3><p>借用《STL源码剖析》里面的一张图，来说明空间配置函数的调用过程：(看图放松，放松完继续看源码！别偷懒)</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfobir1sj30mz0fw402.jpg" alt="空间配置函数"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	obj * <span class="keyword">volatile</span> * my_free_list;  </span><br><span class="line">	obj * result;  </span><br><span class="line">	<span class="comment">// 大于128就调用第一级配置器</span></span><br><span class="line">	<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;  </span><br><span class="line">	 <span class="keyword">return</span>(malloc_alloc::allocate(n));  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">// 寻找16个free_lists中适当的一个</span></span><br><span class="line">	my_free_list = free_list + FREELIST_INDEX(n);  </span><br><span class="line">	result = *my_free_list;  </span><br><span class="line">	<span class="keyword">if</span> (result == <span class="number">0</span>) &#123;  </span><br><span class="line">		<span class="comment">// 如果没有可用的free list，准备重新填充free_list</span></span><br><span class="line">		<span class="keyword">void</span> *r = refill(ROUND_UP(n));  </span><br><span class="line">		<span class="keyword">return</span> r;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调整free list</span></span><br><span class="line">	*my_free_list = result -&gt; free_list_link;  </span><br><span class="line">	<span class="keyword">return</span> (result);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="重新填充函数refill"><a href="#重新填充函数refill" class="headerlink" title="重新填充函数refill()"></a>重新填充函数refill()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">int</span> nobjs = <span class="number">20</span>;  <span class="comment">//	默认获取20个</span></span><br><span class="line">	<span class="keyword">char</span> * chunk = chunk_alloc(n, nobjs);  <span class="comment">//找内存池要空间</span></span><br><span class="line">	obj * <span class="keyword">volatile</span> * my_free_list;  </span><br><span class="line">	obj * result;  </span><br><span class="line">	obj * current_obj, * next_obj;  </span><br><span class="line">	<span class="keyword">int</span> i;  </span><br><span class="line">	<span class="comment">// 如果内存池仅仅只够分配一个对象的空间, 直接返回即可  </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);  </span><br><span class="line">	<span class="comment">// 内存池能分配更多的空间，调整free_list纳入新节点</span></span><br><span class="line">	my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在chunk的空间中建立free_list  </span></span><br><span class="line">	result = (obj *)chunk;</span><br><span class="line">	*my_free_list = next_obj = (obj *)(chunk + n); <span class="comment">//导引free_list指向新配置的空间(取自内存池)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; ; i++) &#123;	<span class="comment">//从1开始，因为第0个返回给客端</span></span><br><span class="line">		current_obj = next_obj;  </span><br><span class="line">		next_obj = (obj *)((<span class="keyword">char</span> *)next_obj + n);  </span><br><span class="line">		<span class="keyword">if</span>(nobjs - <span class="number">1</span> == i) &#123;  </span><br><span class="line">			current_obj -&gt; free_list_link = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			current_obj -&gt; free_list_link = next_obj;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span>(result);<span class="comment">//返回头指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存池函数chunk-alloc"><a href="#内存池函数chunk-alloc" class="headerlink" title="内存池函数chunk_alloc()"></a>内存池函数chunk_alloc()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span>*  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">char</span> * result;  </span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = size * nobjs;  </span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;  <span class="comment">// 计算内存池剩余容量  </span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//内存池中的剩余空间满足需求 </span></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(result);<span class="comment">//返回起始地址</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果内存池中剩余的容量不够分配, 但是能至少分配一个节点时,  </span></span><br><span class="line">    <span class="comment">// 返回所能分配的最多的节点, 返回start_free指向的内存块  </span></span><br><span class="line">    <span class="comment">// 并且重新设置内存池起始点  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bytes_left &gt;= size) &#123;</span><br><span class="line">        nobjs = bytes_left/size;  </span><br><span class="line">        total_bytes = size * nobjs;  </span><br><span class="line">        result = start_free;  </span><br><span class="line">        start_free += total_bytes;  </span><br><span class="line">        <span class="keyword">return</span>(result);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 内存池剩余内存连一个节点也不够分配  </span></span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);  </span><br><span class="line">        <span class="comment">// 将剩余的内存分配给指定的free_list[FREELIST_INDEX(bytes_left)]  </span></span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        	<span class="comment">//内存池内还有一些零头，先分给适当的free_list</span></span><br><span class="line">        	<span class="comment">//寻找适当的free_list</span></span><br><span class="line">            obj * __VOLATILE * my_free_list =  </span><br><span class="line">                   	free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line">            <span class="comment">// 调整free_list，将内存池中的残余空间编入 </span></span><br><span class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;  </span><br><span class="line">            *my_free_list = (obj *)start_free;  </span><br><span class="line">        &#125;  </span><br><span class="line">        start_free = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);  </span><br><span class="line">        <span class="comment">// 分配失败, 搜索原来已经分配的内存块, 看是否有大于等于当前请求的内存块  </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;<span class="comment">// heap里面空间不足，malloc失败</span></span><br><span class="line">            <span class="keyword">int</span> i;  </span><br><span class="line">            obj * __VOLATILE * my_free_list, *p;  </span><br><span class="line">            <span class="comment">// 试着检查检查free_list中的可用空间，即尚有未用的空间，且区块够大  </span></span><br><span class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;  </span><br><span class="line">                my_free_list = free_list + FREELIST_INDEX(i);  </span><br><span class="line">                p = *my_free_list;  </span><br><span class="line">                <span class="comment">// 找到了一个, 将其加入内存池中  </span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;  </span><br><span class="line">                    *my_free_list = p -&gt; free_list_link;  </span><br><span class="line">                    start_free = (<span class="keyword">char</span> *)p;  </span><br><span class="line">                    end_free = start_free + i;  </span><br><span class="line">                    <span class="comment">// 内存池更新完毕, 重新分配需要的内存  </span></span><br><span class="line">                    <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </span><br><span class="line">                    <span class="comment">//任何剩余零头将被编入适当的free_list以留备用 </span></span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 再次失败, 直接调用一级配置器分配, 期待异常处理函数能提供帮助  </span></span><br><span class="line">        <span class="comment">// 不过在我看来, 内存分配失败进行其它尝试已经没什么意义了,  </span></span><br><span class="line">        <span class="comment">// 最好直接log, 然后让程序崩溃  </span></span><br><span class="line">        end_free = <span class="number">0</span>;</span><br><span class="line">        	<span class="comment">//调用第一级配置器，看看out-of-memory机制能不能起点作用</span></span><br><span class="line">            start_free = (<span class="keyword">char</span> *)malloc_alloc::allocate(bytes_to_get);  </span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;  </span><br><span class="line">        end_free = start_free + bytes_to_get;  </span><br><span class="line">        <span class="comment">// 内存池更新完毕, 重新分配需要的内存  </span></span><br><span class="line">        <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存释放函数deallocate"><a href="#内存释放函数deallocate" class="headerlink" title="内存释放函数deallocate()"></a>内存释放函数deallocate()</h3><p>内存释放函数会将释放的空间交还给free_list以留备用。其过程如下图所示：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fbkfoariykj30mp0gitai.jpg" alt="空间释放函数"></p>
<p>其实就是一个简单的单链表插入的过程。其源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	obj *q = (obj *)p;  </span><br><span class="line">	obj * <span class="keyword">volatile</span> * my_free_list;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 大于128的直接交由第一级配置器释放  </span></span><br><span class="line">	<span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;  </span><br><span class="line">		malloc_alloc::deallocate(p, n);  </span><br><span class="line">		<span class="keyword">return</span>;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 寻找适当的free_list  </span></span><br><span class="line">	my_free_list = free_list + FREELIST_INDEX(n);  </span><br><span class="line">	<span class="comment">// 调整free_list，回收区块</span></span><br><span class="line">	q -&gt; free_list_link = *my_free_list;  </span><br><span class="line">	*my_free_list = q;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="配置器的使用"><a href="#配置器的使用" class="headerlink" title="配置器的使用"></a>配置器的使用</h1><p>通过以上的图和源代码，基本上将STL的两层配置器讲完了，接下来就来熟悉一下怎么使用配置器。</p>
<p>STL将上述配置器封装在类simple_alloc中，提供了四个用于内存操作的借口函数，分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::allocate(n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span>	</span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> (T*) Alloc::allocate(<span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span> </span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::deallocate(p, n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">                </span>&#123; Alloc::deallocate(p, <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就示范在vector中是怎么使用它的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;  //<span class="title">alloc</span>被默认为第二级配置器</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 专属的空间配置器，每次只分配一个元素的大小</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在释放内存的时候直接调用借口函数即可</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(...)&#123;</span><br><span class="line">			data_allocator::deallocate(start , end_of_storage - start);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/Vector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/Vector/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++内置了数组的类型，在使用数组的时候，必须指定数组的长度，一旦配置了就不能改变了，通常我们的做法是：尽量配置一个大的空间，以免不够用，这样做的缺点是比较浪费空间，预估空间不当会引起很多不便。</p>
<p>STL实现了一个Vector容器，该容器就是来改善数组的缺点。vector是一个动态空间，随着元素的加入，它的内部机制会自行扩充以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，再也不必因为害怕空间不足而一开始就配置一个大容量数组了，vector是用多少就分配多少。</p>
<p>要想实现动态分配数组，Vector内部就需要对空间控制做到有效率的掌控，这些机制要如何运作才能高效地实现动态分配呢？本篇博客就从源代码的角度带你领略一下Vector容器内部的构造艺术。</p>
<h1 id="Vector概述"><a href="#Vector概述" class="headerlink" title="Vector概述"></a>Vector概述</h1><p>大家知道，初始化一个数组的时候，需要给数组分配一块内存，数组中的数据都是按序存放的。vector也是如此，再初始化的时候给vector容器分配一块内存，用来存放容器中的数据，一旦分配的内存不足以存放新加入的数据时，就需要扩充空间。STLVector的做法是：重新开辟一段新的空间，将原空间的数据迁移过去，然后新加入的数据存放在新空间之后并释放掉原有空间。</p>
<p>在这个过程中，配置新空间-&gt;数据移动-&gt;释放旧空间会带来一定的时间成本，所以必须尽可能高效的实现，STL的Vector设计中对这一部分做了相当大的优化，使得时间成本尽可能的小。下面就一起去看看这些优秀的设计吧↓。</p>
<h1 id="Vector的数据结构"><a href="#Vector的数据结构" class="headerlink" title="Vector的数据结构"></a>Vector的数据结构</h1><p>我们从最简单的开始，Vector的数据结构相当简单，由于需要判断内存是否够用，所以要用到三个指针，分别指向头，目前使用空间的尾，目前可用空间的尾。其源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;//<span class="title">alloc</span>是<span class="title">STL</span>的空间配置器</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// 这里提供STL标准的allocator接口</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"></span><br><span class="line">  iterator start;               <span class="comment">// 内存空间起始点</span></span><br><span class="line">  iterator finish;              <span class="comment">// 当前使用的内存空间结束点</span></span><br><span class="line">  iterator end_of_storage;      <span class="comment">// 实际分配内存空间的结束点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当初始化一个vector的时候，先分配一段内存，称为目前可用空间，大小为end_of_storage - start + 1，当往vector里面加入数据的时候，finish就往后移，代表目前已使用的空间，这样做的好处是，不用频繁的扩充空间和转移数据，使得时间成本下降。</p>
<p>在上述代码中，我们看到vector采用了STL标准的空间配置其接口，关于空间配置器的知识在<a href="https://zcheng.ren/2016/08/17/STLAllocater/" target="_blank" rel="noopener">带你深入理解STL之空间配置器(思维导图+源码)</a>一文中有讲解，如有疑惑，可以跳转复习一下再来！</p>
<p>vector提供了如下函数来支持获取其数据结构中的相关参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取指向vector首元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指向vector尾元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前对象个数，即已使用空间的大小</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end() - begin()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回重新分配内存前最多能存储的对象个数，即目前可用空间的大小</span></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end_of_storage - begin()); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vector的迭代器"><a href="#Vector的迭代器" class="headerlink" title="Vector的迭代器"></a>Vector的迭代器</h1><p>既然是STL的容器，必须要满足迭代器的相关要求，如对迭代器有疑惑的，参考<a href="https://zcheng.ren/2016/08/23/STLIterator/" target="_blank" rel="noopener">带你深入理解STL之迭代器和Traits技法 </a>。</p>
<p>vector维护的是一段连续的内存空间，所以不论容器中元素的型别为何，普通指针都可以作为vector的迭代器而满足所有必要的条件。vector支持随机存取，所以vector提供的是Random Access Iterator。</p>
<p>下面来看看vector关于迭代器的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// vector内部是连续内存空间，所以迭代器采用原生指针即可</span></span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator;  								</span><br><span class="line"></span><br><span class="line">  <span class="comment">//以下为满足Traits功能定义的内嵌型别</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;                  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;                </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vector的构造函数"><a href="#vector的构造函数" class="headerlink" title="vector的构造函数"></a>vector的构造函数</h1><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>在使用vector的时候，我们通常会有如下定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>

<p>在上述定义中，调用了vector的默认构造函数，其默认不分配内存空间，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector的默认构造函数默认不分配内存空间</span></span><br><span class="line"><span class="built_in">vector</span>() : start(<span class="number">0</span>), finish(<span class="number">0</span>), end_of_storage(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带参构造函数"><a href="#带参构造函数" class="headerlink" title="带参构造函数"></a>带参构造函数</h2><p>通常，vector的初始化可以指定元素个数和初始化类型。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>,<span class="number">1</span>); <span class="comment">// 将vec初始化为10个1</span></span><br></pre></td></tr></table></figure>

<p>vector提供下面的构造函数以支持上述初始化操作：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gw1fbkg2cxastj30iu0dg0u0.jpg" alt="带参构造函数"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数，允许指定vector的元素个数和初值</span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要对象提供默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; fill_initialize(n, T()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 填充并予以初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  start = allocate_and_fill(n, value);</span><br><span class="line">  finish = start + n;                         <span class="comment">// 设置当前使用内存空间的结束点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里不过多的分配内存</span></span><br><span class="line">  end_of_storage = finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置一块大小为n的内存空间，并予以填充</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 调用STL的空间配置器配置一块大小为n的内存空间</span></span><br><span class="line">  iterator result = data_allocator::allocate(n); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用底层函数uninitialized_fill_n予以填充</span></span><br><span class="line">  uninitialized_fill_n(result, n, x);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面调用了uninitialized_fill_n函数，这个函数是STL的内存基本处理函数，存放在stl_uninitialized.h中，下面来看看它的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果copy construction和operator =等效, 并且destructor is trivial</span></span><br><span class="line"><span class="comment">// 那么就可以使用本函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> fill_n(first, n, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是POD类型使用以下函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ForwardIterator cur = first;</span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur)</span><br><span class="line">    construct(&amp;*cur, x);</span><br><span class="line">  <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用type_traits来判断是否是POD类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> __<span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">T1</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, is_POD());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用Iterator_traits来萃取出其值类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> <span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, value_type(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="vector的元素操作函数"><a href="#vector的元素操作函数" class="headerlink" title="vector的元素操作函数"></a>vector的元素操作函数</h1><h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h2><p>push_back()函数将新元素插入于vector的尾部，该函数再完成这一操作的时候，先检查是否还有备用空间，如果有直接再备用空间上构造函数；如果没有就扩充空间，通过重新配置一块大空间，移动数据，释放原空间的操作来完成push_back操作。其源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 向容器尾追加一个元素, 可能导致内存重新分配</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//                          push_back(const T&amp; x)</span></span><br><span class="line"><span class="comment">//                                   |</span></span><br><span class="line"><span class="comment">//                                   |---------------- 容量已满?</span></span><br><span class="line"><span class="comment">//                                   |</span></span><br><span class="line"><span class="comment">//               ----------------------------</span></span><br><span class="line"><span class="comment">//           No  |                          |  Yes</span></span><br><span class="line"><span class="comment">//               |                          |</span></span><br><span class="line"><span class="comment">//               ↓                          ↓</span></span><br><span class="line"><span class="comment">//      construct(finish, x);       insert_aux(end(), x);</span></span><br><span class="line"><span class="comment">//      ++finish;                           |</span></span><br><span class="line"><span class="comment">//                                          |------ 内存不足, 重新分配</span></span><br><span class="line"><span class="comment">//                                          |       大小为原来的2倍</span></span><br><span class="line"><span class="comment">//      new_finish = data_allocator::allocate(len);       &lt;stl_alloc.h&gt;</span></span><br><span class="line"><span class="comment">//      uninitialized_copy(start, position, new_start);   &lt;stl_uninitialized.h&gt;</span></span><br><span class="line"><span class="comment">//      construct(new_finish, x);                         &lt;stl_construct.h&gt;</span></span><br><span class="line"><span class="comment">//      ++new_finish;</span></span><br><span class="line"><span class="comment">//      uninitialized_copy(position, finish, new_finish); &lt;stl_uninitialized.h&gt;</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 内存满足条件则直接追加元素, 否则需要重新分配内存空间</span></span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">    construct(finish, x);</span><br><span class="line">    ++finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    insert_aux(end(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 提供插入操作</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//                 insert_aux(iterator position, const T&amp; x)</span></span><br><span class="line"><span class="comment">//                                   |</span></span><br><span class="line"><span class="comment">//                                   |---------------- 容量是否足够?</span></span><br><span class="line"><span class="comment">//                                   ↓</span></span><br><span class="line"><span class="comment">//              -----------------------------------------</span></span><br><span class="line"><span class="comment">//        Yes   |                                       | No</span></span><br><span class="line"><span class="comment">//              |                                       |</span></span><br><span class="line"><span class="comment">//              ↓                                       |</span></span><br><span class="line"><span class="comment">// 从opsition开始, 整体向后移动一个位置                     |</span></span><br><span class="line"><span class="comment">// construct(finish, *(finish - 1));                    |</span></span><br><span class="line"><span class="comment">// ++finish;                                            |</span></span><br><span class="line"><span class="comment">// T x_copy = x;                                        |</span></span><br><span class="line"><span class="comment">// copy_backward(position, finish - 2, finish - 1);     |</span></span><br><span class="line"><span class="comment">// *position = x_copy;                                  |</span></span><br><span class="line"><span class="comment">//                                                      ↓</span></span><br><span class="line"><span class="comment">//                            data_allocator::allocate(len);</span></span><br><span class="line"><span class="comment">//                            uninitialized_copy(start, position, new_start);</span></span><br><span class="line"><span class="comment">//                            construct(new_finish, x);</span></span><br><span class="line"><span class="comment">//                            ++new_finish;</span></span><br><span class="line"><span class="comment">//                            uninitialized_copy(position, finish, new_finish);</span></span><br><span class="line"><span class="comment">//                            destroy(begin(), end());</span></span><br><span class="line"><span class="comment">//                            deallocate();</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;:</span>:insert_aux(iterator position, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;       <span class="comment">// 还有剩余内存</span></span><br><span class="line">    construct(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">    ++finish;</span><br><span class="line">    T x_copy = x;</span><br><span class="line">    copy_backward(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">    *position = x_copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;        </span><br><span class="line">    <span class="comment">// 内存不足, 需要重新分配</span></span><br><span class="line">    <span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">    <span class="comment">//配置原则：如果原大小为0，就配置1个元素大小</span></span><br><span class="line">    <span class="comment">//        如果原大小不为0，就配置原大小的两倍</span></span><br><span class="line">    <span class="comment">//				前半段用来放置原数据，后半段用来放置新数据</span></span><br><span class="line">    <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">    iterator new_start = data_allocator::allocate(len);</span><br><span class="line">    iterator new_finish = new_start;</span><br><span class="line">    <span class="comment">// 将内存重新配置</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">    	<span class="comment">// 将原vector的内容拷贝到新vector</span></span><br><span class="line">      new_finish = uninitialized_copy(start, position, new_start);</span><br><span class="line">      <span class="comment">// 构造新元素并赋值为x</span></span><br><span class="line">      construct(new_finish, x);</span><br><span class="line">      <span class="comment">// 调整finish的位置</span></span><br><span class="line">      ++new_finish;</span><br><span class="line">      <span class="comment">// 将安插点的原内容也拷贝过来</span></span><br><span class="line">      new_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 分配失败则抛出异常</span></span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      destroy(new_start, new_finish);</span><br><span class="line">      data_allocator::deallocate(new_start, len);</span><br><span class="line">      <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构原容器中的对象</span></span><br><span class="line">    destroy(begin(), end());</span><br><span class="line">    <span class="comment">// 释放原容器分配的内存</span></span><br><span class="line">    deallocate();</span><br><span class="line">    <span class="comment">// 调整内存指针状态</span></span><br><span class="line">    start = new_start;</span><br><span class="line">    finish = new_finish;</span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-back-函数"><a href="#pop-back-函数" class="headerlink" title="pop_back()函数"></a>pop_back()函数</h2><p>pop_back函数弹出当前尾端元素。其源代码比较简单，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//调整finish</span></span><br><span class="line">  --finish;</span><br><span class="line">  <span class="comment">//释放调弹出的元素</span></span><br><span class="line">  destroy(finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a>erase()函数</h2><p>erase函数支持两个版本：</p>
<ul>
<li>清除某个位置上的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position + <span class="number">1</span> != end())</span><br><span class="line">    copy(position + <span class="number">1</span>, finish, position); <span class="comment">//将[position+1,finish]移到[position,finish]</span></span><br><span class="line">  --finish;</span><br><span class="line">  destroy(finish);</span><br><span class="line">  <span class="keyword">return</span> position;<span class="comment">//返回删除点的迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>清除某个区间上的所有函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  iterator i = copy(last, finish, first);<span class="comment">//关于copy函数的源码分析在以后的博文中会提到</span></span><br><span class="line">  <span class="comment">// 析构掉需要析构的元素</span></span><br><span class="line">  destroy(i, finish);</span><br><span class="line">  finish = finish - (last - first);</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里放上两张《STL源码剖析》中的图，便于理解这一过程：</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkg2eirlej30fz0c7dgm.jpg" alt="erase函数"></p>
<p>有上述erase函数，可以衍生出一个函数，用来清除迭代器中所有的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; erase(begin(), end()); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="insert-函数"><a href="#insert-函数" class="headerlink" title="insert()函数"></a>insert()函数</h2><p>insert函数实现的功能是：从position开始，插入n个元素，元素的初值均为x。其源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 在指定位置插入n个元素</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//             insert(iterator position, size_type n, const T&amp; x)</span></span><br><span class="line"><span class="comment">//                                   |</span></span><br><span class="line"><span class="comment">//                                   |---------------- 插入元素个数是否为0?</span></span><br><span class="line"><span class="comment">//                                   ↓</span></span><br><span class="line"><span class="comment">//              -----------------------------------------</span></span><br><span class="line"><span class="comment">//        No    |                                       | Yes</span></span><br><span class="line"><span class="comment">//              |                                       |</span></span><br><span class="line"><span class="comment">//              |                                       ↓</span></span><br><span class="line"><span class="comment">//              |                                    return;</span></span><br><span class="line"><span class="comment">//              |----------- 内存是否足够?</span></span><br><span class="line"><span class="comment">//              |</span></span><br><span class="line"><span class="comment">//      -------------------------------------------------</span></span><br><span class="line"><span class="comment">//  Yes |                                               | No</span></span><br><span class="line"><span class="comment">//      |                                               |</span></span><br><span class="line"><span class="comment">//      |------ (finish - position) &gt; n?                |</span></span><br><span class="line"><span class="comment">//      |       分别调整指针                              |</span></span><br><span class="line"><span class="comment">//      ↓                                               |</span></span><br><span class="line"><span class="comment">//    ----------------------------                      |</span></span><br><span class="line"><span class="comment">// No |                          | Yes                  |</span></span><br><span class="line"><span class="comment">//    |                          |                      |</span></span><br><span class="line"><span class="comment">//    ↓                          ↓                      |</span></span><br><span class="line"><span class="comment">// 插入操作, 调整指针           插入操作, 调整指针           |</span></span><br><span class="line"><span class="comment">//                                                      ↓</span></span><br><span class="line"><span class="comment">//            data_allocator::allocate(len);</span></span><br><span class="line"><span class="comment">//            new_finish = uninitialized_copy(start, position, new_start);</span></span><br><span class="line"><span class="comment">//            new_finish = uninitialized_fill_n(new_finish, n, x);</span></span><br><span class="line"><span class="comment">//            new_finish = uninitialized_copy(position, finish, new_finish);</span></span><br><span class="line"><span class="comment">//            destroy(start, finish);</span></span><br><span class="line"><span class="comment">//            deallocate();</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;:</span>:insert(iterator position, size_type n, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果n为0则不进行任何操作</span></span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size_type(end_of_storage - finish) &gt;= n) &#123;      <span class="comment">// 剩下的内存够分配</span></span><br><span class="line">      T x_copy = x;</span><br><span class="line">      <span class="keyword">const</span> size_type elems_after = finish - position; <span class="comment">// 计算插入点之后的现有元素个数</span></span><br><span class="line">      iterator old_finish = finish;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; n) &#123;  <span class="comment">// 插入点之后的现有元素个数大于新增元素个数，见下图1</span></span><br><span class="line">      	<span class="comment">// 先复制尾部n个元素到尾部</span></span><br><span class="line">        uninitialized_copy(finish - n, finish, finish);</span><br><span class="line">        finish += n; <span class="comment">// 调整新的finish</span></span><br><span class="line">        <span class="comment">// 从后往前复制剩余的旧元素</span></span><br><span class="line">        copy_backward(position, old_finish - n, old_finish);</span><br><span class="line">        <span class="comment">// 从position开始填充新元素</span></span><br><span class="line">        fill(position, position + n, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 插入点之后的现有元素个数小于新增元素个数，见下图2</span></span><br><span class="line">      	<span class="comment">// 先在尾部填充n - elems_after个新增元素</span></span><br><span class="line">        uninitialized_fill_n(finish, n - elems_after, x_copy);</span><br><span class="line">        <span class="comment">// 调整新的finish</span></span><br><span class="line">        finish += n - elems_after;</span><br><span class="line">        <span class="comment">// 复制[position,old_finish]区间的数到新的finish之后</span></span><br><span class="line">        uninitialized_copy(position, old_finish, finish);</span><br><span class="line">        <span class="comment">// 调整finish</span></span><br><span class="line">        finish += elems_after;</span><br><span class="line">        <span class="comment">// 从position开始填充新增元素</span></span><br><span class="line">        fill(position, old_finish, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// 剩下的内存不够分配, 需要重新分配</span></span><br><span class="line">      <span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">      <span class="keyword">const</span> size_type len = old_size + max(old_size, n);</span><br><span class="line">      iterator new_start = data_allocator::allocate(len);</span><br><span class="line">      iterator new_finish = new_start;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">      	<span class="comment">// 将旧的vector中插入点之前的元素复制到新空间，见下图3</span></span><br><span class="line">        new_finish = uninitialized_copy(start, position, new_start);</span><br><span class="line">        <span class="comment">// 将新增元素复制到新空间</span></span><br><span class="line">        new_finish = uninitialized_fill_n(new_finish, n, x);</span><br><span class="line">        <span class="comment">// 将插入点之后的元素复制到新空间</span></span><br><span class="line">        new_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        destroy(new_start, new_finish);</span><br><span class="line">        data_allocator::deallocate(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 清除并释放原有vector</span></span><br><span class="line">      destroy(start, finish);</span><br><span class="line">      deallocate();</span><br><span class="line">      <span class="comment">// 调整新的start和finish</span></span><br><span class="line">      start = new_start;</span><br><span class="line">      finish = new_finish;</span><br><span class="line">      end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述操作可以使插入操作达到最高的效率。配合以下图解更容易理解：</p>
<ul>
<li><p>插入点之后的现有元素个数大于新增元素个数的情况</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gw1fbkg2dn6tcj30dw0fgabf.jpg" alt="第一种情况"></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/STL函数对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/STL函数对象/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在STL中，函数对象也是比较重要的，有时候可以限定STL算法的行为，例如在前面介绍的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL</a><a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">算法剖析</a>》中，每个算法基本上都提供了两个操作版本，其中就有一个版本允许用户指定函数对象，这样可以根据用户的需要对算法进行操作。函数对象是一种具有函数特质的对象，所以可以作为算法的参数。本文介绍的函数对象比较简单，是基于一元或者二元操作结构的算术类函数对象、关系运算类函数对象、逻辑运算类函数对象。在定义函数对象时，为了使其具有函数行为，则必须重载operator()操作符。本文源码出自SGI STL中的&lt;stl_function.h&gt;文件。</p>
<h3 id="函数对象源码剖析"><a href="#函数对象源码剖析" class="headerlink" title="函数对象源码剖析"></a>函数对象源码剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">_STL_BEGIN_NAMESPACE</span><br><span class="line"><span class="comment">//一元操作结构定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>, <span class="title">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg argument_type;<span class="comment">//参数类型</span></span><br><span class="line">  <span class="keyword">typedef</span> _Result result_type;<span class="comment">//返回结果类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//二元操作结构定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>, <span class="title">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg1 first_argument_type;<span class="comment">//参数一类型</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg2 second_argument_type;<span class="comment">//参数二类型</span></span><br><span class="line">  <span class="keyword">typedef</span> _Result result_type;<span class="comment">//返回结果类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是二元操作算术函数对象，继承二元操作binary_function的结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">加法操作plus&lt;T&gt;,减法操作minus&lt;T&gt;,乘法操作multiplies&lt;T&gt;,除法操作divides&lt;T&gt;,</span></span><br><span class="line"><span class="comment">取模运算modulus&lt;T&gt;,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x + __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x - __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">multiplies</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x * __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">divides</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x / __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">modulus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x % __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一元操作，继承一元操作unary_function结构</span></span><br><span class="line"><span class="comment">//负值操作negate&lt;T&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">negate</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">  _<span class="function">Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> -__x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// identity_element (not part of the C++ standard).</span></span><br><span class="line"><span class="comment">//证同元素：</span></span><br><span class="line"><span class="comment">//以下只提供的两种证同元素</span></span><br><span class="line"><span class="comment">//加法：任何元素加上0结果都为自身</span></span><br><span class="line"><span class="comment">//乘法：任何元素乘以1结果都为自身</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt; <span class="title">inline</span> _<span class="title">Tp</span> <span class="title">identity_element</span>(<span class="title">plus</span>&lt;_Tp&gt;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> _Tp(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt; <span class="title">inline</span> _<span class="title">Tp</span> <span class="title">identity_element</span>(<span class="title">multiplies</span>&lt;_Tp&gt;) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> _Tp(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是二元操作关系函数对象，继承二元操作的结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值的类型是bool型别</span></span><br><span class="line"><span class="comment">equal_to,not_equal_to,greater,less,greater_equal,less_equal,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x == __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">not_equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x != __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &gt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater_equal</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &gt;= __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less_equal</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &lt;= __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是二元操作逻辑函数对象，继承二元操作的结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中logical_not为一元操作函数</span></span><br><span class="line"><span class="comment">logical_and,logical_or,logical_not</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_and</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &amp;&amp; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_or</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x || __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">logical_not</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !__x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// identity is an extensions: it is not part of the standard.</span></span><br><span class="line"><span class="comment">//证同函数</span></span><br><span class="line"><span class="comment">//任何数值通过此函数后，不会有任何修改。所以返回值类型为const引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Identity</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,_Tp&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> _<span class="function">Tp&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt; <span class="title">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> _Identity&lt;_Tp&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select1st and select2nd are extensions: they are not part of the standard.</span></span><br><span class="line"><span class="comment">//选择函数</span></span><br><span class="line"><span class="comment">//版本一：选择pair元素的第一个参数，忽略第二个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Select1st</span> :</span> <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::first_type&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> _Pair::<span class="function">first_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Pair&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __x.first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//版本二：选择pair元素的第二个参数，忽略第一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Select2nd</span> :</span> <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::second_type&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> _Pair::<span class="function">second_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Pair&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __x.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt; <span class="title">struct</span> <span class="title">select1st</span> :</span> <span class="keyword">public</span> _Select1st&lt;_Pair&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt; <span class="title">struct</span> <span class="title">select2nd</span> :</span> <span class="keyword">public</span> _Select2nd&lt;_Pair&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// project1st and project2nd are extensions: they are not part of the standard</span></span><br><span class="line"><span class="comment">//投射函数</span></span><br><span class="line"><span class="comment">//版本一：投射出第一个参数，忽略第二个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Project1st</span> :</span> <span class="keyword">public</span> binary_function&lt;_Arg1, _Arg2, _Arg1&gt; &#123;</span><br><span class="line">  _<span class="function">Arg1 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Arg1&amp; __x, <span class="keyword">const</span> _Arg2&amp;)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//版本二：投射出第二个参数，忽略第一个参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Project2nd</span> :</span> <span class="keyword">public</span> binary_function&lt;_Arg1, _Arg2, _Arg2&gt; &#123;</span><br><span class="line">  _<span class="function">Arg2 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Arg1&amp;, <span class="keyword">const</span> _Arg2&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">project1st</span> :</span> <span class="keyword">public</span> _Project1st&lt;_Arg1, _Arg2&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">project2nd</span> :</span> <span class="keyword">public</span> _Project2nd&lt;_Arg1, _Arg2&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/STL之迭代器和Traits技法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/STL之迭代器和Traits技法/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在开始讲迭代器之前，先列举几个例子，由浅入深的来理解一下为什么要设计迭代器。</p>
<p>针对下面两个函数，我们来谈谈这种设计的缺陷所在：</p>
<ul>
<li>遍历int数组和单链表listNode时，需要设计两份不一样的sum求和函数，对于STL这样含有大量容器的代码库，针对每一种容器都设计sum的话，过于冗杂</li>
<li>在sum函数中暴露了太多设计细节，如ListNode的节点值类型int，和指向下一个节点的指针next</li>
<li>对于int数组来说，还必须知道数组的大小，以免越界访问</li>
<li>算法的设计过多的依赖容器，容器的改动会造成大量算法函数的随之改动</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于int类的求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) &#123;</span><br><span class="line">		sum += *a++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于listNode类的求和函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	ListNode * next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(ListNode * head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	ListNode *p = head;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		sum += p-&gt;val;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如何设计才能使得算法摆脱特定容器？如何让算法和容器各自独立设计，互不影响又能统一到一起？本篇博客就带你一窥STL的迭代器设计。</p>
<h1 id="迭代器概述"><a href="#迭代器概述" class="headerlink" title="迭代器概述"></a>迭代器概述</h1><p>迭代器是一种抽象的设计概念，在设计模式中是这么定义迭代器模式的，即提供一种方法，使之能够巡访某个聚合物所含的每一个元素，而无需暴露该聚合物的内部表述方式。</p>
<p>不论是泛型思维或STL的实际运用，迭代器都扮演着重要的角色，STL的中心思想就在于：将数据容器和算法分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。</p>
<p>谈到迭代器需要遍历容器就想到指针，的确，迭代器就是一种类似指针的对象，而指针的各种行为中最常见也最重要的就是内容提领(dereference)和成员访问(member access)，因此，迭代器最重要的编程工作就是对operator*和operator-&gt;进行重载工作。</p>
<h1 id="Traits编程技法"><a href="#Traits编程技法" class="headerlink" title="Traits编程技法"></a>Traits编程技法</h1><p>在介绍STL迭代器之前，先来看看Traits编程技法，通过它你能够更好的理解迭代器设计。</p>
<h2 id="template参数推导机制"><a href="#template参数推导机制" class="headerlink" title="template参数推导机制"></a>template参数推导机制</h2><p>我们先回过头去看看sum函数，在sum函数中，我们必须知道容器的元素类型，这关系到函数返回值。既然迭代器设计中不能暴露容器的实现细节，那么我们在算法中是不可能知道容器元素的类型，因此，必须设计出一个机制，能够提取出容器中元素的类型。看看如下示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数中并不知道iter所指的元素型别，而是通过模板T来获取的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>, <span class="title">class</span> <span class="title">T1</span> ,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">sum_impl</span>(<span class="title">I</span> <span class="title">iter</span> ,<span class="title">T1</span> <span class="title">n</span> , <span class="title">T</span> <span class="title">t</span>) &#123;</span></span><br><span class="line">	T sum = <span class="number">0</span>;<span class="comment">//通过模板的特性，可以获取I所指之物的型别,此处为int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里做func应该做的工作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ;i++)&#123;</span><br><span class="line">		sum+=*iter++;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span> , <span class="title">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T1</span> <span class="title">sum</span>(<span class="title">I</span> <span class="title">iter</span> , <span class="title">T1</span> <span class="title">n</span>) &#123;</span><span class="comment">//此处暴露了template参数推导机制的缺陷，在型别用于返回值时便束手无策</span></span><br><span class="line">	<span class="keyword">return</span> sum_impl(iter , n ,*iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> sum1 = sum(a , <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中通过模板的参数推导机制推导出了iter所指之物的型别(int)，于是可以定义T sum变量。</p>
<p>然而，迭代器所指之物的型别并非只是”迭代器所指对象的型别“，最常用的迭代器型别有五种，并非任何情况下任何一种都可利用上述的template参数推导机制来获取，而且对于返回值类型，template参数推导机制也束手无策，因此，Traits技法应运而生，解决了这一难题！</p>
<h2 id="内嵌型别机制"><a href="#内嵌型别机制" class="headerlink" title="内嵌型别机制"></a>内嵌型别机制</h2><p>Traits技法采用内嵌型别来实现获取迭代器型别这一功能需求，具体怎么实现的呢？我们看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义一个简单的iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyIter</span>&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌型别声明</span></span><br><span class="line">	T* ptr;</span><br><span class="line">	MyIter(T* p =<span class="number">0</span>):ptr(p)&#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">I</span>:</span>:value_type <span class="comment">// func返回值型别</span></span><br><span class="line">func(I iter)&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MyIter&lt;<span class="keyword">int</span>&gt; iter(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;func(iter)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，func()函数的返回值型别必须加上关键词typename，因为T是一个template参数，在它被编译器具现化之前，编译器对其一无所知，关键词typename的用意在于告诉编译器这是一个型别，如此才能通过编译。</p>
<p>内嵌型别看起来不错，可以很顺利的提取出迭代器所指型别并克服了template参数推导机制不能用于函数返回值的缺陷。可是，并不是所有的迭代器都是class type，原声指针就不是！如果不是class type，那么就无法声明内嵌型别。但是STL绝对必须接受原生指针作为一个迭代器。因此，必须另行它法！</p>
<h2 id="iterator-traits萃取机"><a href="#iterator-traits萃取机" class="headerlink" title="iterator_traits萃取机"></a>iterator_traits萃取机</h2><p>针对原生指针这类特殊情况，我们很容易想到利用模板偏特化的机制来实现特殊声明，在泛化设计中提供一个特化版本。偏特化的定义是：针对任何template参数更进一步的条件限制所设计出来的一个特化版本。这里，针对上面的MyIter设计出一个适合原生指针的特化版本，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyIter</span> &lt;T*&gt;&#123;</span>   <span class="comment">//T*代表T为原生指针，这便是T为任意型别的一个更进一步的条件限制</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌型别声明</span></span><br><span class="line">	T* ptr;</span><br><span class="line">	MyIter(T* p =<span class="number">0</span>):ptr(p)&#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了上述的介绍，包括template参数推导，内嵌型别，模板偏特化等，下面STL的真正主角要登场了，STL专门设计了一个iterator_traits模板类来”萃取“迭代器的特性。其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于traits出迭代其所指对象的型别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type        value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类如何完成迭代器的型别萃取呢？我们继续往下看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt;:</span>:value_type <span class="comment">// 通过iterator_traits类萃取I的型别</span></span><br><span class="line">func(I iter)&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从表面上来看，这么做只是多了一层间接性，但是带来的好处是极大的！iterator_traits类可以拥有特化版本，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生指针特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T  value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const指针特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &lt;const T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T  value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，原生指针int*虽然不是一种class type，也可以通过traits取其value，到这里traits的思想就基本明了了！下面就来看看STL只能中”萃取机“的源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于traits出迭代其所指对象的型别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 迭代器类型, STL提供五种迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代器所指对象的型别</span></span><br><span class="line">  <span class="comment">// 如果想与STL算法兼容, 那么在类内需要提供value_type定义</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个是用于处理两个迭代器间距离的类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接指向对象的原生指针类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个是对象的引用类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 针对指针提供特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> T*                         pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对指向常对象的指针提供特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T*                   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                   reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于源码中的五种迭代器型别在下一小节中会有详细说明。</p>
<h1 id="迭代器设计"><a href="#迭代器设计" class="headerlink" title="迭代器设计"></a>迭代器设计</h1><h2 id="迭代器型别"><a href="#迭代器型别" class="headerlink" title="迭代器型别"></a>迭代器型别</h2><h3 id="value-type"><a href="#value-type" class="headerlink" title="value_type"></a>value_type</h3><p>所谓value_type，是指迭代器所指对象的型别，在之前的示例中已经介绍得很清楚了，这里就不再赘述。</p>
<h3 id="difference-type"><a href="#difference-type" class="headerlink" title="difference_type"></a>difference_type</h3><p>difference_type用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量。下面以STL里面的计数功能函数count()为例，来介绍一下difference_type的用法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt;:</span>:difference_type   <span class="comment">//返回值类型</span></span><br><span class="line">count(I first , I end , <span class="keyword">const</span> T&amp; value)&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type n = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">for</span>( ; first!=end ; ++first)&#123;</span><br><span class="line">		<span class="keyword">if</span>(*first == value) ++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对原生指针和原生的const指针，iterator_traits的difference_type为ptrdiff_t(long int)，特化版本依然可以采用iterator_traits<em>::difference_type来获取型别。</em></p>
<h3 id="reference-type"><a href="#reference-type" class="headerlink" title="reference_type"></a>reference_type</h3><p>从“迭代器所指之物的内容是否可以改变”的角度可以将迭代器分为两种：</p>
<blockquote>
<p>const迭代器：不允许改变“所指对象之内容”，例如const int* p</p>
<p>mutable迭代器：允许改变“所指对象之内容”，例如int* p</p>
</blockquote>
<p>当我们要对一个mutable迭代器进行提领(reference)操作时，获得的不应该是一个右值(右值不允许赋值操作)，而应该是一个左值，左值才允许赋值操作。</p>
<p>故： + 当p是一个mutable迭代器时，如果其value type是T，那么<em>p的型别应该为T&amp;； + 当p是一个const迭代器时，</em>p的型别为const T&amp;</p>
<h3 id="pointer-type"><a href="#pointer-type" class="headerlink" title="pointer type"></a>pointer type</h3><p>迭代器可以传回一个指针，指向迭代器所指之物。再迭代器源码中，可以找到如下关于指针和引用的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *value; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br></pre></td></tr></table></figure>

<p>在iterator_traits结构体中需要加入其型别，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//针对原生指针的特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T*                         pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//针对原生const指针的特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T*                   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                   reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="iterator-category"><a href="#iterator-category" class="headerlink" title="iterator_category"></a>iterator_category</h3><p>这一型别代表迭代器的类别，一般分为五类：</p>
<p>Input Iterator：只读(read only)</p>
<p>Output Iterator：只写(write only)</p>
<p>Forward Iterator：允许“写入型”算法在此迭代器所形成的区间上进行读写操作</p>
<p>Bidirectional Iterator：可双向移动的迭代器</p>
<p>Random Access Iterator：前四种迭代器都只供应一部分指针的算数能力(前三种支持operator++，第四种支持operator–)，第五种则涵盖所有指针的算数能力，包括p+n,p-n,p[n],p1-p2,p1&lt;p2等在STL中，这五类迭代器的继承关系如下:</p>
<p>下面我们来看看它的源代码实现：// 用于标记迭代器类型<br>struct input_iterator_tag {};<br>struct output_iterator_tag {};<br>struct forward_iterator_tag : public input_iterator_tag {};<br>struct bidirectional_iterator_tag : public forward_iterator_tag {};<br>struct random_access_iterator_tag : public bidirectional_iterator_tag {};</p>
<h3 id="迭代器的保证"><a href="#迭代器的保证" class="headerlink" title="迭代器的保证"></a>迭代器的保证</h3><p>为了符合规范，任何迭代器都应该提供五个内嵌型别，以利于Traits萃取，否则就自别与整个STL架构，可能无法与其他STL组件顺利搭配。STL提供了一份iterator class如下：//为避免挂一漏万，每个新设计的迭代器都必须继承自它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Category</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span> = <span class="title">ptrdiff_t</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Pointer</span> = <span class="title">T</span>*, <span class="title">class</span> <span class="title">Reference</span> = <span class="title">T</span>&amp;&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器源码(完整版)/**</p>
<p>迭代器源码(完整版)/**</p>
<ul>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line">- 用于标记迭代器类型</span><br><span class="line"> */</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 用于traits出迭代其所指对象的型别</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">// 迭代器类型, STL提供五种迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代器所指对象的型别</span></span><br><span class="line">  <span class="comment">// 如果想与STL算法兼容, 那么在类内需要提供value_type定义</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个是用于处理两个迭代器间距离的类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接指向对象的原生指针类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个是对象的引用类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 针对指针提供特化版本</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                         pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                         reference;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对指向常对象的指针提供特化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T*                   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                   reference;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 返回迭代器类别</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:iterator_category</span><br><span class="line">  iterator_category(<span class="keyword">const</span> Iterator&amp;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> category();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 返回表示迭代器距离的类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:difference_type*</span><br><span class="line">  distance_type(<span class="keyword">const</span> Iterator&amp;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 返回迭代器所指对象的类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:value_type*</span><br><span class="line">  value_type(<span class="keyword">const</span> Iterator&amp;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  迭代器相关函数设计distance函数distance函数用来计算两个迭代器之前的距离。针对Input Iterator，Output Iterator，Forward Iterator，Bidirectional Iterator来说，必须逐一累加计算距离针对random_access_iterator来说，支持两个迭代器相减，所以直接相减就能得到距离其具体实现如下:<span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对Input Iterator，Output Iterator，Forward Iterator，Bidirectional Iterator</span></span><br><span class="line"><span class="comment">- 这四种函数，需要逐一累加来计算距离</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">  __distance(InputIterator first, InputIterator last, input_iterator_tag)</span><br><span class="line">  &#123;</span><br><span class="line">    iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">  ++first; ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对random_access_iterator，可直接相减来计算差距</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">iterator_traits</span>&lt;RandomAccessIterator&gt;:</span>:difference_type</span><br><span class="line">  __distance(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">         random_access_iterator_tag)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> last - first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入口函数，先判断迭代器类型iterator_category，然后调用特定函数</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">  distance(InputIterator first, InputIterator last)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> __distance(first, last, category());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Advance函数Advance函数有两个参数，迭代器p和n，函数内部将p前进n次。针对不同类型的迭代器有如下实现：针对input_iterator和forward_iterator,单向，逐一前进针对bidirectional_iterator，双向，可以前进和后退，n&gt;<span class="number">0</span>和n&lt;<span class="number">0</span>针对random_access_iterator，支持p+n，可直接计算其代码实现如下：<span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对input_iterator和forward_iterator版本</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对bidirectional_iterator版本</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">BidirectionalIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">bidirectional_iterator_tag</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">while</span> (n++) --i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 针对random_access_iterator版本</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">RandomAccessIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    i += n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">- 入口函数，先判断迭代器的类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __advance(i, n, iterator_category(i));</span><br><span class="line">  &#125;</span><br><span class="line">  附加：type_traits设计iterator_traits负责萃取迭代器的特性；type_traits负责萃取型别的特性。在带你深入理解STL之空间配置器(思维导图+源码)一篇博客中，讲到需要根据对象构造函数和析构函数的trivial和non-trivial特性来采用最有效的措施，例如：如果构造函数是trivial的，那么可以直接采用如<span class="built_in">malloc</span>()和<span class="built_in">memcpy</span>()等函数，来提高效率。例如：如果拷贝一个未知类型的数组，如果其具有trivial拷贝构造函数，那么可以直接利用<span class="built_in">memcpy</span>()来拷贝，反之则要调用该类型的拷贝构造函数。type_traits的源代码实现如下：<span class="comment">/**</span></span><br><span class="line"><span class="comment">- 用来标识真/假对象,利用type_traits响应结果来进行参数推导，</span></span><br><span class="line"><span class="comment">- 而编译器只有面对class object形式的参数才会做参数推导，</span></span><br><span class="line"><span class="comment">- 这两个空白class不会带来额外负担</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">true_type</span>&#123;</span>&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">false_type</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- type_traits结构体设计</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">struct</span> __<span class="title">type_traits</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="comment">// 不要移除这个成员</span></span><br><span class="line">  <span class="comment">// 它通知能自动特化__type_traits的编译器, 现在这个__type_traits template是特化的</span></span><br><span class="line">  <span class="comment">// 这是为了确保万一编译器使用了__type_traits而与此处无任何关联的模板时</span></span><br><span class="line">  <span class="comment">// 一切也能顺利运作</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下条款应当被遵守, 因为编译器有可能自动生成类型的特化版本</span></span><br><span class="line">  <span class="comment">//   - 你可以重新安排的成员次序</span></span><br><span class="line">  <span class="comment">//   - 你可以移除你想移除的成员</span></span><br><span class="line">  <span class="comment">//   - 一定不可以修改下列成员名称, 却没有修改编译器中的相应名称</span></span><br><span class="line">  <span class="comment">//   - 新加入的成员被当作一般成员, 除非编译器提供特殊支持</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __false_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 特化类型:</span></span><br><span class="line">  <span class="comment">//         char, signed char, unsigned char,</span></span><br><span class="line">  <span class="comment">//         short, unsigned short</span></span><br><span class="line">  <span class="comment">//         int, unsigned int</span></span><br><span class="line">  <span class="comment">//         long, unsigned long</span></span><br><span class="line">  <span class="comment">//         float, double, long double</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 以下针对C++内置的基本数据类型提供特化版本, </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 使其具有trivial default constructor,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- copy constructor, assignment operator, destructor并标记其为POD类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;char&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对char的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;signed char&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对unsigned char的特化版本</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;unsigned char&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对short的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;short&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对unsigned short的特化版本</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;unsigned short&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对int的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;int&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对unsigned int的特化版本</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;unsigned int&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对long的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;long&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对unsigned long的特化版本</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;unsigned long&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对float的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;float&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对double的特化版本</span></span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;double&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//针对long double的特化版本</span></span><br><span class="line">  </span><br><span class="line">  __STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;long double&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对指针提供特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对char *, signed char *, unsigned char *提供特化</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;char*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;signed char*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;unsigned char*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/Stcak和Queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/Stcak和Queue/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇博客，<a href="https://zcheng.ren/2016/08/26/STLDeque/" target="_blank" rel="noopener">带你深入理解STL之Deque容器</a>中详细介绍了deque容器的源码实现方式。结合前面介绍的两个容器vector和list，在使用的过程中，我们确实要知道在什么情况下需要选择恰当的容器来满足需求和提升效率。一般选择的准则有如下几条：</p>
<ul>
<li>如果需要随机访问一个容器，vector比list要好</li>
<li>如果需要经常插入和删除操作的话，list比vector要好</li>
<li>如果既要随机存取，又要关心两端数据的插入和删除，则选择deque</li>
</ul>
<p>好了，复习完前面的知识后，开始介绍今天的两个容器stack和queue。由于stack和queue都是基于deque来实现的，所以相应的代码会比较简单，也是比较轻松易实现的，下面一起去看看吧。</p>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>如果把deque比作一个管道，两头都可进可出的话，stack就是一个桶！只能一头进一头出，而且，压在下面的东西你看不到，你要是想看，只能把上面的东西拿出来再去看。</p>
<p>stack是一种先进后出的数据结构，允许新增元素、移除元素和取得最顶端的元素，除了最顶端，没有任何其他方法可以存取stack中的元素，也就是说stack没有遍历行为，因此，stack是没有迭代器的！！！！！</p>
<p>以deque为底层容器来实现stack这种数据结构，简直不能再简单，基本的操作函数都已经定义好了，deque可以为它完成所有工作。与其说stack是一种容器，倒不如说它是一种配接器，一种容器适配器。</p>
<p>下面我们就来看看stack的源码，真的没骗你，超级简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">deque</span>&lt;T&gt;  // 以<span class="title">deque</span>作为缺省底层容器</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// #define __STL_NULL_TMPL_ARGS &lt;&gt;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">stack</span>&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">stack</span>&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;   <span class="comment">// 底层容器，stack全靠它来实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 以下函数直接调用底层容器的接口即可实现</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断stack是否为空</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.empty(); &#125;	</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stack中元素个数</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈顶元素, 注意这里返回的是引用!!!</span></span><br><span class="line">  <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在栈顶追加新元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; c.push_back(x); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除栈顶元素, 注意不返回元素的引用,</span></span><br><span class="line">  <span class="comment">// 很多初学者随机用此容器时经常误认为pop()操作同时会返回栈顶元素的引用</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.pop_back(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个stack是否相等, 就要测试其内部维护容器是否相等</span></span><br><span class="line"><span class="comment">// x.c == y.c会调用容器重载的operator ==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">stack</span>&lt;T, Sequence&gt;&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">stack</span>&lt;T, Sequence&gt;&amp; <span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个迭代器的大小，即比较底层容器的大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>&lt;(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">  return x.c &lt; y.c;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>你没有看错，stack的源码就只有上面几句话，全是调用底层容器的接口。下面再来看看它的同胞queue，同样很简单。</p>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>queue是一种先进先出的数据结构，上面说道，dequeu是个双向可进可出的管道，stack是一个桶，queue就是一个单向的水管，只能一端进，一端出。</p>
<p>queue允许新增元素、移除元素、从最底端插入元素，从最顶端取得元素，但是，从了最底端插入，最顶端取出之外，没有任何其他方法可以存取queue里面的元素，queue和stack一样，不允许有遍历行为，因此，queue也没有迭代器！！！！</p>
<p>queue和stack一样，也是一种容器适配器，只需要调用底层容器的接口就能实现。下面来看看它的源码吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">queue</span>&amp; x, <span class="keyword">const</span> <span class="built_in">queue</span>&amp; y);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">queue</span>&amp; x, <span class="keyword">const</span> <span class="built_in">queue</span>&amp; y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 由于queue仅支持对队头和队尾的操作, 所以不定义STL要求的</span></span><br><span class="line">  <span class="comment">// pointer, iterator, difference_type</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;   <span class="comment">// 底层容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 以下操作和stack一样</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.size(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.front(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.front(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.back(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; c.push_back(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.pop_front(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载==操作符，比较底层容器即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">queue</span>&lt;T, Sequence&gt;&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">queue</span>&lt;T, Sequence&gt;&amp; <span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>&lt;(const queue&lt;T, Sequence&gt;&amp; x, const queue&lt;T, Sequence&gt;&amp; y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">  return x.c &lt; y.c;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇博客的两个”容器“比较容易理解，因为底层都已经学过了，只需要调用接口即可。最后再啰嗦两句，stack是一个先进后出的容器，queue是一个先进先出的容器，在使用过程中，需要根据你的需求来选择。我在刷leetcode的时候，碰到遍历二叉树的问题，基本上前、中后序遍历的非递归实现中，都会用到stack，而树的层序遍历中，会采用queue，具体的做法可以参考我的这片博文，<a href="https://zcheng.ren/2016/08/01/【数据结构和算法】全面剖析树的各类遍历方法/" target="_blank" rel="noopener">全面剖析树的各类遍历方法</a>,相信看完你会对stack和queue的使用有进一步的理解！</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/sort/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于在前文的《<a href="http://blog.csdn.net/chenhanzhun/article/details/39698523" target="_blank" rel="noopener">STL算法剖析</a>》中，源码剖析非常多，不方便学习，也不方便以后复习，这里把这些算法进行归类，对他们单独的源码剖析进行讲解。本文介绍的STL算法中的sort排序算法，SGI STL中的排序算法不是简单的快速排序，而是交叉利用各种排序：堆排序、插入排序和快速排序；这样做的目的是提高效率，针对数据量比较大的采用快速排序，数据量比较小的可以采用堆排序或插入排序。本文介绍了有关排序的算法random_shuffle、partition、stable_partition、sort、stable_sort、partial_sort、partial_sort_copy、nth_element；注意：STL的sort排序算法的迭代器必须是随机访问迭代器。</p>
<h3 id="sort排序算法剖析"><a href="#sort排序算法剖析" class="headerlink" title="sort排序算法剖析"></a>sort排序算法剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a random number in the range [0, __n).  This function encapsulates</span></span><br><span class="line"><span class="comment">// whether we're using rand (part of the standard C library) or lrand48</span></span><br><span class="line"><span class="comment">// (not standard, but a much better choice whenever it's available).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">Distance</span> __<span class="title">random_number</span>(_<span class="title">Distance</span> __<span class="title">n</span>) &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_NO_DRAND48</span></span><br><span class="line">  <span class="keyword">return</span> rand() % __n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> lrand48() % __n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random_shuffle</span></span><br><span class="line"><span class="comment">//将区间[first,last)内的元素随机重排</span></span><br><span class="line"><span class="comment">//两个版本的不同是随机数的取得</span></span><br><span class="line"><span class="comment">//版本一是使用内部随机数产生器</span></span><br><span class="line"><span class="comment">//版本二是使用一个会产生随机数的仿函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last) randomly.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">generator by default (1)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void random_shuffle (RandomAccessIterator first, RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">specific generator (2)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class RandomNumberGenerator&gt;</span></span><br><span class="line"><span class="comment">	void random_shuffle (RandomAccessIterator first, RandomAccessIterator last,</span></span><br><span class="line"><span class="comment">                       RandomNumberGenerator&amp; gen);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">random_shuffle</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    iter_swap(__i, __first + __random_number((__i - __first) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">random_shuffle</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    iter_swap(__i, __first + __rand((__i - __first) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random_sample and random_sample_n (extensions, not part of the standard).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">random_sample_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">OutputIter</span> __<span class="title">out</span>, <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  _Distance __remaining = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __remaining);</span><br><span class="line">  _Distance __m = min(__n, __remaining);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__random_number(__remaining) &lt; __m) &#123;</span><br><span class="line">      *__out = *__first;</span><br><span class="line">      ++__out;</span><br><span class="line">      --__m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --__remaining;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Distance</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">random_sample_n</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">OutputIter</span> __<span class="title">out</span>, <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(_OutputIter, _OutputIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_RandomNumberGenerator, _Distance, _Distance);</span><br><span class="line">  _Distance __remaining = <span class="number">0</span>;</span><br><span class="line">  distance(__first, __last, __remaining);</span><br><span class="line">  _Distance __m = min(__n, __remaining);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__rand(__remaining) &lt; __m) &#123;</span><br><span class="line">      *__out = *__first;</span><br><span class="line">      ++__out;</span><br><span class="line">      --__m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --__remaining;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                  _<span class="title">RandomAccessIter</span> __<span class="title">out</span>,</span></span><br><span class="line"><span class="class">                                  <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Distance __m = <span class="number">0</span>;</span><br><span class="line">  _Distance <span class="keyword">__t</span> = __n;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last &amp;&amp; __m &lt; __n; ++__m, ++__first) </span><br><span class="line">    __out[__m] = *__first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    ++<span class="keyword">__t</span>;</span><br><span class="line">    _Distance __M = __random_number(<span class="keyword">__t</span>);</span><br><span class="line">    <span class="keyword">if</span> (__M &lt; __n)</span><br><span class="line">      __out[__M] = *__first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __out + __m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                  _<span class="title">RandomAccessIter</span> __<span class="title">out</span>,</span></span><br><span class="line"><span class="class">                                  _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>,</span></span><br><span class="line"><span class="class">                                  <span class="title">const</span> _<span class="title">Distance</span> __<span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_RandomNumberGenerator, _Distance, _Distance);</span><br><span class="line">  _Distance __m = <span class="number">0</span>;</span><br><span class="line">  _Distance <span class="keyword">__t</span> = __n;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last &amp;&amp; __m &lt; __n; ++__m, ++__first)</span><br><span class="line">    __out[__m] = *__first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    ++<span class="keyword">__t</span>;</span><br><span class="line">    _Distance __M = __rand(<span class="keyword">__t</span>);</span><br><span class="line">    <span class="keyword">if</span> (__M &lt; __n)</span><br><span class="line">      __out[__M] = *__first;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __out + __m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">RandomAccessIter</span> __<span class="title">out_first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">out_last</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">return</span> __random_sample(__first, __last,</span><br><span class="line">                         __out_first, __out_last - __out_first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">RandomNumberGenerator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">random_sample</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">RandomAccessIter</span> __<span class="title">out_first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">out_last</span>,</span></span><br><span class="line"><span class="class">              _<span class="title">RandomNumberGenerator</span>&amp; __<span class="title">rand</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">return</span> __random_sample(__first, __last,</span><br><span class="line">                         __out_first, __rand,</span><br><span class="line">                         __out_last - __out_first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partition, stable_partition, and their auxiliary functions</span></span><br><span class="line"><span class="comment">//若迭代器的类型为forward_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">		         _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">			 _<span class="title">Predicate</span>   __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">			 <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __first;<span class="comment">//若为空，直接退出</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__pred(*__first))<span class="comment">//若pred出first的值为true</span></span><br><span class="line">    <span class="keyword">if</span> (++__first == __last) <span class="keyword">return</span> __first;<span class="comment">//先移动迭代器first，在判断是否到达尾端last</span></span><br><span class="line"></span><br><span class="line">  _ForwardIter __next = __first;<span class="comment">//继续判断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (++__next != __last)<span class="comment">//若下一个位置依然不是尾端</span></span><br><span class="line">    <span class="keyword">if</span> (__pred(*__next)) &#123;<span class="comment">//继续pred出next的值，若为true</span></span><br><span class="line">      swap(*__first, *__next);<span class="comment">//交换值</span></span><br><span class="line">      ++__first;<span class="comment">//继续下一位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若迭代器的类型为bidirectional_iterator_tag，则调用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">BidirectionalIter</span> __<span class="title">partition</span>(_<span class="title">BidirectionalIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">BidirectionalIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">			       _<span class="title">Predicate</span> __<span class="title">pred</span>,</span></span><br><span class="line"><span class="class">			       <span class="title">bidirectional_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (__first == __last)<span class="comment">//若为空</span></span><br><span class="line">        <span class="keyword">return</span> __first;<span class="comment">//直接退出</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (__pred(*__first))<span class="comment">//first的值符合不移动条件，则不移动该值</span></span><br><span class="line">        ++__first;<span class="comment">//只移动迭代器</span></span><br><span class="line">      <span class="keyword">else</span><span class="comment">//若头指针符合移动</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">    --__last;<span class="comment">//尾指针回溯</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (__first == __last)<span class="comment">//头指针等于尾指针</span></span><br><span class="line">        <span class="keyword">return</span> __first;<span class="comment">//操作结束</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!__pred(*__last))<span class="comment">//尾指针的元素符合不移动操作</span></span><br><span class="line">        --__last;<span class="comment">//至移动迭代器，并不移动具体元素</span></span><br><span class="line">      <span class="keyword">else</span><span class="comment">//尾指针的元素符合移动操作</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">    iter_swap(__first, __last);<span class="comment">//头尾指针交换元素</span></span><br><span class="line">    ++__first;<span class="comment">//准备下一次循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将区间[first,last)的元素进行排序，被pred判断为true的放在区间的前段，判定为false的放在区间后段</span></span><br><span class="line"><span class="comment">//该算算可能会使元素的元素位置放生改变.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">算法功能：Rearranges the elements from the range [first,last), in such a way that all the elements</span></span><br><span class="line"><span class="comment">for which pred returns true precede all those for which it returns false. </span></span><br><span class="line"><span class="comment">The iterator returned points to the first element of the second group.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法原型：</span></span><br><span class="line"><span class="comment">	template &lt;class BidirectionalIterator, class UnaryPredicate&gt;</span></span><br><span class="line"><span class="comment">	BidirectionalIterator partition (BidirectionalIterator first,</span></span><br><span class="line"><span class="comment">                                   BidirectionalIterator last, UnaryPredicate pred);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">   			      _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">			      _<span class="title">Predicate</span>   __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>, </span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="comment">//首先萃取出迭代器first的类型，根据迭代器的类型调用不同的函数</span></span><br><span class="line">  <span class="keyword">return</span> __partition(__first, __last, __pred, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//partition函数举例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#include &lt;iostream&gt;     // std::cout</span></span><br><span class="line"><span class="comment">	#include &lt;algorithm&gt;    // std::partition</span></span><br><span class="line"><span class="comment">	#include &lt;vector&gt;       // std::vector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	bool IsOdd (int i) &#123; return (i%2)==1; &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int main () &#123;</span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt; myvector;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // set some values:</span></span><br><span class="line"><span class="comment">	  for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::vector&lt;int&gt;::iterator bound;</span></span><br><span class="line"><span class="comment">	  bound = std::partition (myvector.begin(), myvector.end(), IsOdd);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  // print out content:</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "odd elements:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=bound; ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; "even elements:";</span></span><br><span class="line"><span class="comment">	  for (std::vector&lt;int&gt;::iterator it=bound; it!=myvector.end(); ++it)</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; ' ' &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">	  std::cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	  return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Output:</span></span><br><span class="line"><span class="comment">	odd elements: 1 9 3 7 5</span></span><br><span class="line"><span class="comment">	even elements: 6 4 8 2</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">inplace_stable_partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                        _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                        _<span class="title">Predicate</span> __<span class="title">pred</span>, _<span class="title">Distance</span> __<span class="title">len</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> __pred(*__first) ? __last : __first;</span><br><span class="line">  _ForwardIter __middle = __first;</span><br><span class="line">  advance(__middle, __len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> rotate(__inplace_stable_partition(__first, __middle, __pred, </span><br><span class="line">                                           __len / <span class="number">2</span>),</span><br><span class="line">                __middle,</span><br><span class="line">                __inplace_stable_partition(__middle, __last, __pred,</span><br><span class="line">                                           __len - __len / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Predicate</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span> __<span class="title">stable_partition_adaptive</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Predicate</span> __<span class="title">pred</span>, _<span class="title">Distance</span> __<span class="title">len</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Distance</span> __<span class="title">buffer_size</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__len &lt;= __buffer_size) &#123;</span><br><span class="line">    _ForwardIter __result1 = __first;</span><br><span class="line">    _Pointer __result2 = __buffer;</span><br><span class="line">    <span class="keyword">for</span> ( ; __first != __last ; ++__first)</span><br><span class="line">      <span class="keyword">if</span> (__pred(*__first)) &#123;</span><br><span class="line">        *__result1 = *__first;</span><br><span class="line">        ++__result1;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__result2 = *__first;</span><br><span class="line">        ++__result2;</span><br><span class="line">      &#125;</span><br><span class="line">    copy(__buffer, __result2, __result1);</span><br><span class="line">    <span class="keyword">return</span> __result1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _ForwardIter __middle = __first;</span><br><span class="line">    advance(__middle, __len / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> rotate(__stable_partition_adaptive(</span><br><span class="line">                          __first, __middle, __pred,</span><br><span class="line">                          __len / <span class="number">2</span>, __buffer, __buffer_size),</span><br><span class="line">                    __middle,</span><br><span class="line">                    __stable_partition_adaptive(</span><br><span class="line">                          __middle, __last, __pred,</span><br><span class="line">                          __len - __len / <span class="number">2</span>, __buffer, __buffer_size));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">stable_partition_aux</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                       _<span class="title">Predicate</span> __<span class="title">pred</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Temporary_buffer&lt;_ForwardIter, _Tp&gt; __buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (__buf.size() &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __stable_partition_adaptive(__first, __last, __pred,</span><br><span class="line">                                       _Distance(__buf.requested_size()),</span><br><span class="line">                                       __buf.begin(), __buf.size());</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __inplace_stable_partition(__first, __last, __pred, </span><br><span class="line">                                      _Distance(__buf.requested_size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span> <span class="title">stable_partition</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">ForwardIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                                     _<span class="title">Predicate</span> __<span class="title">pred</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);</span><br><span class="line">  __STL_UNARY_FUNCTION_CHECK(_Predicate, <span class="keyword">bool</span>,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __stable_partition_aux(__first, __last, __pred,</span><br><span class="line">                                  __VALUE_TYPE(__first),</span><br><span class="line">                                  __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出快速排序的枢纽位置</span></span><br><span class="line"><span class="comment">//版本一采用operator&lt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">unguarded_partition</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">Tp</span> __<span class="title">pivot</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//找出枢纽轴的位置</span></span><br><span class="line">	<span class="comment">//令头端迭代器向尾端方向移动，尾端迭代器向头端移动。</span></span><br><span class="line">	<span class="comment">//当*first不小于枢纽值时，就停下来，当*last不大于枢纽值时也停下来，然后检测两个迭代器是否交错</span></span><br><span class="line">	<span class="comment">//如果first仍然在左侧而last仍然在右侧，就交换两个元素，然后各自调整位置，向中央逼近，再继续执行相同的行为.</span></span><br><span class="line">	<span class="comment">//直到first和last两个迭代器交错，此时表示已找到枢纽轴位置即first所在的位置</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*__first &lt; __pivot)</span><br><span class="line">      ++__first;<span class="comment">//first向尾端移动，直到遇到不小于枢纽值时，停止</span></span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (__pivot &lt; *__last)</span><br><span class="line">      --__last;<span class="comment">//last向头端移动，直到遇到不大于枢纽值时，停止</span></span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))<span class="comment">//检测两个迭代器是否交错</span></span><br><span class="line">      <span class="keyword">return</span> __first;<span class="comment">//交错，则此时已找到，即为first迭代器所指位置</span></span><br><span class="line">    iter_swap(__first, __last);<span class="comment">//否则交换迭代器所指的元素</span></span><br><span class="line">    ++__first;<span class="comment">//继续执行相同行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//版本一采用__comp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">unguarded_partition</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                                        _<span class="title">Tp</span> __<span class="title">pivot</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__comp(*__first, __pivot))</span><br><span class="line">      ++__first;</span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (__comp(__pivot, *__last))</span><br><span class="line">      --__last;</span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    iter_swap(__first, __last);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> __stl_threshold = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort() and its auxiliary functions. </span></span><br><span class="line"><span class="comment">//__insertion_sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span> __<span class="title">val</span>) &#123;</span></span><br><span class="line">  _RandomAccessIter __next = __last;</span><br><span class="line">  --__next;</span><br><span class="line">  <span class="comment">//__insertion_sort的内循环</span></span><br><span class="line">  <span class="comment">//注意：一旦不再出现逆转对，循环就结束</span></span><br><span class="line">  <span class="keyword">while</span> (__val &lt; *__next) &#123;<span class="comment">//存在逆转对</span></span><br><span class="line">    *__last = *__next;<span class="comment">//调整元素</span></span><br><span class="line">    __last = __next;<span class="comment">//调整迭代器</span></span><br><span class="line">    --__next;<span class="comment">//左移一个位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  *__last = __val;<span class="comment">//value的正确插入位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort版本二的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span> __<span class="title">val</span>, </span></span><br><span class="line"><span class="class">                               _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _RandomAccessIter __next = __last;</span><br><span class="line">  --__next;  </span><br><span class="line">  <span class="keyword">while</span> (__comp(__val, *__next)) &#123;</span><br><span class="line">    *__last = *__next;</span><br><span class="line">    __last = __next;</span><br><span class="line">    --__next;</span><br><span class="line">  &#125;</span><br><span class="line">  *__last = __val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  _Tp __val = *__last;<span class="comment">//记录尾元素</span></span><br><span class="line">  <span class="keyword">if</span> (__val &lt; *__first) &#123;<span class="comment">//尾元素比头元素还小</span></span><br><span class="line">	  <span class="comment">//将整个区间向右移一个位置</span></span><br><span class="line">    copy_backward(__first, __last, __last + <span class="number">1</span>);</span><br><span class="line">    *__first = __val;<span class="comment">//令头元素等于原先的尾元素</span></span><br><span class="line">	<span class="comment">//以上两行命令的功能相等于交换两个元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//尾元素不小于头元素</span></span><br><span class="line">    __unguarded_linear_insert(__last, __val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort版本二的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">linear_insert</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Tp __val = *__last;</span><br><span class="line">  <span class="keyword">if</span> (__comp(__val, *__first)) &#123;</span><br><span class="line">    copy_backward(__first, __last, __last + <span class="number">1</span>);</span><br><span class="line">    *__first = __val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __unguarded_linear_insert(__last, __val, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__insertion_sort以双层循环形式进行。外循环遍历整个序列，每次迭代决定出一个子区间；</span></span><br><span class="line"><span class="comment">//内循环遍历子区间，将子区间内的每一个“逆转对”倒转过来，如果一旦不存在“逆转对”，表示排序完毕。</span></span><br><span class="line"><span class="comment">//“逆转对”概念：指任何两个迭代器i和j，i&lt;j,而*i&gt;*j.</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>; <span class="comment">//若区间为空，则退出</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)<span class="comment">//外循环，遍历整个区间</span></span><br><span class="line">	  <span class="comment">//[first,i)形成的子空间</span></span><br><span class="line">    __linear_insert(__first, __i, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    __linear_insert(__first, __i, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_insertion_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first; __i != __last; ++__i)</span><br><span class="line">    __unguarded_linear_insert(__i, _Tp(*__i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">unguarded_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __unguarded_insertion_sort_aux(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_insertion_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                    _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first; __i != __last; ++__i)</span><br><span class="line">    __unguarded_linear_insert(__i, _Tp(*__i), __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">unguarded_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                                       _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                       _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __unguarded_insertion_sort_aux(__first, __last, __VALUE_TYPE(__first),</span><br><span class="line">                                 __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sort版本一的辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">final_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &gt; __stl_threshold) &#123;<span class="comment">//判断元素个数是否大于16</span></span><br><span class="line">	  <span class="comment">//则把区间分割成两段，一端长度为16，另一端为剩余的长度</span></span><br><span class="line">    __insertion_sort(__first, __first + __stl_threshold);</span><br><span class="line">    __unguarded_insertion_sort(__first + __stl_threshold, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//若不大于16，直接调用插入排序</span></span><br><span class="line">    __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">final_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __stl_threshold, __comp);</span><br><span class="line">    __unguarded_insertion_sort(__first + __stl_threshold, __last, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//_lg()函数是用来控制分割恶化的情况</span></span><br><span class="line"><span class="comment">//该函数找出2^k &lt;= n 的最大值k;</span></span><br><span class="line"><span class="comment">//例如：n=7,得k=2; n=20,得k=4; n=8,得k=3; </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">Size</span> __<span class="title">lg</span>(_<span class="title">Size</span> __<span class="title">n</span>) &#123;</span></span><br><span class="line">  _Size __k;</span><br><span class="line">  <span class="keyword">for</span> (__k = <span class="number">0</span>; __n != <span class="number">1</span>; __n &gt;&gt;= <span class="number">1</span>) ++__k;</span><br><span class="line">  <span class="keyword">return</span> __k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sort版本一的辅助函数</span></span><br><span class="line"><span class="comment">//参数__depth_limit表示最大的分割层数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">introsort_loop</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*,</span></span><br><span class="line"><span class="class">                      _<span class="title">Size</span> __<span class="title">depth_limit</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//__stl_threshold为全局常量，其值为16</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) &#123;<span class="comment">//若区间长度大于16</span></span><br><span class="line">    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) &#123;<span class="comment">//表示分割恶化</span></span><br><span class="line">      partial_sort(__first, __last, __last);<span class="comment">//转而调用堆排序heap_sort()</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --__depth_limit;</span><br><span class="line">	<span class="comment">//计算分割点cut，枢纽值是采用首、尾、中央三个的中间值</span></span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>))));</span><br><span class="line">	<span class="comment">//对右半部分递归地进行排序</span></span><br><span class="line">    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit);</span><br><span class="line">    __last = __cut;<span class="comment">//接下来对左半部分递归地进行排序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">introsort_loop</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*,</span></span><br><span class="line"><span class="class">                      _<span class="title">Size</span> __<span class="title">depth_limit</span>, _<span class="title">Compare</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) &#123;</span><br><span class="line">      partial_sort(__first, __last, __last, __comp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --__depth_limit;</span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>), __comp)),</span><br><span class="line">       __comp);</span><br><span class="line">    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit, __comp);</span><br><span class="line">    __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SGI STL的排序算法，迭代器参数的类型必须是随机访问迭代器_RandomAccessIter</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Sorts the elements in the range [first,last) into ascending order.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	：版本一采用默认的operator&lt;</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void sort (RandomAccessIterator first, RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	：版本二采用仿函数comp</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="comment">//_lg()函数是用来控制分割恶化的情况</span></span><br><span class="line">  <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>);</span><br><span class="line">	<span class="comment">//进行插入排序</span></span><br><span class="line">    __final_insertion_sort(__first, __last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                 _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>,</span><br><span class="line">                     __comp);</span><br><span class="line">    __final_insertion_sort(__first, __last, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stable_sort() and its auxiliary functions.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">inplace_stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">15</span>) &#123;</span><br><span class="line">    __insertion_sort(__first, __last);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _RandomAccessIter __middle = __first + (__last - __first) / <span class="number">2</span>;</span><br><span class="line">  __inplace_stable_sort(__first, __middle);</span><br><span class="line">  __inplace_stable_sort(__middle, __last);</span><br><span class="line">  __merge_without_buffer(__first, __middle, __last,</span><br><span class="line">                         __middle - __first,</span><br><span class="line">                         __last - __middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">inplace_stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                           _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">15</span>) &#123;</span><br><span class="line">    __insertion_sort(__first, __last, __comp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _RandomAccessIter __middle = __first + (__last - __first) / <span class="number">2</span>;</span><br><span class="line">  __inplace_stable_sort(__first, __middle, __comp);</span><br><span class="line">  __inplace_stable_sort(__middle, __last, __comp);</span><br><span class="line">  __merge_without_buffer(__first, __middle, __last,</span><br><span class="line">                         __middle - __first,</span><br><span class="line">                         __last - __middle,</span><br><span class="line">                         __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter1</span>, <span class="title">class</span> _<span class="title">RandomAccessIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_loop</span>(_<span class="title">RandomAccessIter1</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter1</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter2</span> __<span class="title">result</span>, _<span class="title">Distance</span> __<span class="title">step_size</span>) &#123;</span></span><br><span class="line">  _Distance __two_step = <span class="number">2</span> * __step_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __two_step) &#123;</span><br><span class="line">    __result = merge(__first, __first + __step_size,</span><br><span class="line">                     __first + __step_size, __first + __two_step,</span><br><span class="line">                     __result);</span><br><span class="line">    __first += __two_step;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __step_size = min(_Distance(__last - __first), __step_size);</span><br><span class="line">  merge(__first, __first + __step_size, __first + __step_size, __last,</span><br><span class="line">        __result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter1</span>, <span class="title">class</span> _<span class="title">RandomAccessIter2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_loop</span>(_<span class="title">RandomAccessIter1</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter1</span> __<span class="title">last</span>, </span></span><br><span class="line"><span class="class">                       _<span class="title">RandomAccessIter2</span> __<span class="title">result</span>, _<span class="title">Distance</span> __<span class="title">step_size</span>,</span></span><br><span class="line"><span class="class">                       _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __two_step = <span class="number">2</span> * __step_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __two_step) &#123;</span><br><span class="line">    __result = merge(__first, __first + __step_size,</span><br><span class="line">                     __first + __step_size, __first + __two_step,</span><br><span class="line">                     __result,</span><br><span class="line">                     __comp);</span><br><span class="line">    __first += __two_step;</span><br><span class="line">  &#125;</span><br><span class="line">  __step_size = min(_Distance(__last - __first), __step_size);</span><br><span class="line"></span><br><span class="line">  merge(__first, __first + __step_size,</span><br><span class="line">        __first + __step_size, __last,</span><br><span class="line">        __result,</span><br><span class="line">        __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> __stl_chunk_size = <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">chunk_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Distance</span> __<span class="title">chunk_size</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __chunk_size) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __chunk_size);</span><br><span class="line">    __first += __chunk_size;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">chunk_insertion_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">chunk_size</span>, _<span class="title">Compare</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt;= __chunk_size) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __chunk_size, __comp);</span><br><span class="line">    __first += __chunk_size;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_with_buffer</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">Pointer</span> __<span class="title">buffer</span>, _<span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  _Distance __len = __last - __first;</span><br><span class="line">  _Pointer __buffer_last = __buffer + __len;</span><br><span class="line"></span><br><span class="line">  _Distance __step_size = __stl_chunk_size;</span><br><span class="line">  __chunk_insertion_sort(__first, __last, __step_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__step_size &lt; __len) &#123;</span><br><span class="line">    __merge_sort_loop(__first, __last, __buffer, __step_size);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_with_buffer</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">Distance</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __len = __last - __first;</span><br><span class="line">  _Pointer __buffer_last = __buffer + __len;</span><br><span class="line"></span><br><span class="line">  _Distance __step_size = __stl_chunk_size;</span><br><span class="line">  __chunk_insertion_sort(__first, __last, __step_size, __comp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__step_size &lt; __len) &#123;</span><br><span class="line">    __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);</span><br><span class="line">    __step_size *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">stable_sort_adaptive</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  _Distance __len = (__last - __first + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  _RandomAccessIter __middle = __first + __len;</span><br><span class="line">  <span class="keyword">if</span> (__len &gt; __buffer_size) &#123;</span><br><span class="line">    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size);</span><br><span class="line">    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)<span class="number">0</span>);</span><br><span class="line">    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), </span><br><span class="line">                   _Distance(__last - __middle), __buffer, __buffer_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Pointer</span>, <span class="title">class</span> _<span class="title">Distance</span>, </span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">stable_sort_adaptive</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, </span></span><br><span class="line"><span class="class">                            _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Pointer</span> __<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                            _<span class="title">Distance</span> __<span class="title">buffer_size</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Distance __len = (__last - __first + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  _RandomAccessIter __middle = __first + __len;</span><br><span class="line">  <span class="keyword">if</span> (__len &gt; __buffer_size) &#123;</span><br><span class="line">    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, </span><br><span class="line">                           __comp);</span><br><span class="line">    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, </span><br><span class="line">                           __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)<span class="number">0</span>,</span><br><span class="line">                               __comp);</span><br><span class="line">    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)<span class="number">0</span>,</span><br><span class="line">                               __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), </span><br><span class="line">                   _Distance(__last - __middle), __buffer, __buffer_size,</span><br><span class="line">                   __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">stable_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  _Temporary_buffer&lt;_RandomAccessIter, _Tp&gt; buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __inplace_stable_sort(__first, __last);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    __stable_sort_adaptive(__first, __last, buf.begin(),</span><br><span class="line">                           _Distance(buf.size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">stable_sort_aux</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                              _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  _Temporary_buffer&lt;_RandomAccessIter, _Tp&gt; buf(__first, __last);</span><br><span class="line">  <span class="keyword">if</span> (buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __inplace_stable_sort(__first, __last, __comp);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    __stable_sort_adaptive(__first, __last, buf.begin(),</span><br><span class="line">                           _Distance(buf.size()),</span><br><span class="line">                           __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __stable_sort_aux(__first, __last,</span><br><span class="line">                    __VALUE_TYPE(__first),</span><br><span class="line">                    __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">stable_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __stable_sort_aux(__first, __last,</span><br><span class="line">                    __VALUE_TYPE(__first),</span><br><span class="line">                    __DISTANCE_TYPE(__first), </span><br><span class="line">                    __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partial_sort, partial_sort_copy, and auxiliary functions.</span></span><br><span class="line"><span class="comment">//重新安排序列[first,last)，使序列前半部分middle-first个最小元素以递增顺序排序，并将其置于[first,middle)</span></span><br><span class="line"><span class="comment">//其余last-middle个元素不指定任何排序，并将其置于[middle,last)</span></span><br><span class="line"><span class="comment">//注意：迭代器middle是在[first,last)范围之内</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last), </span></span><br><span class="line"><span class="comment">in such a way that the elements before middle are the smallest elements in the entire range </span></span><br><span class="line"><span class="comment">and are sorted in ascending order, while the remaining elements are left without any specific order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	版本一 operator&lt; </span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void partial_sort (RandomAccessIterator first, RandomAccessIterator middle,</span></span><br><span class="line"><span class="comment">                     RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">custom (2) 版本二 comp	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void partial_sort (RandomAccessIterator first, RandomAccessIterator middle,</span></span><br><span class="line"><span class="comment">                     RandomAccessIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">		<span class="comment">//利用heap的知识，在SGI STL中，是采用最大堆</span></span><br><span class="line">		<span class="comment">//将[first,middle)区间的元素创建成最大堆</span></span><br><span class="line">		<span class="comment">//再根据最大堆的性质，一个一个弹出堆，并将其保存，即堆排序</span></span><br><span class="line">  make_heap(__first, __middle);<span class="comment">//创建最大堆，定义与&lt;stl_heap.h&gt;文件</span></span><br><span class="line">  <span class="comment">//以下是在区间中[first,last)找出middle-first个最小元素</span></span><br><span class="line">  <span class="comment">//这里的是将后半部分[middle,last)的元素依次与最大堆的根节点元素(即堆的最大元素)比较</span></span><br><span class="line">  <span class="comment">//若小于堆的最大元素，则与堆的最大元素交换，并调整堆，使其依次成为最大堆</span></span><br><span class="line">  <span class="comment">//若不小于堆的最大元素，则不作任何操作</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (*__i &lt; *__first) </span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i),</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  sort_heap(__first, __middle);<span class="comment">//对最大堆进行堆排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  make_heap(__first, __middle, __comp);</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__i, *__first))</span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i), __comp,</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  sort_heap(__first, __middle, __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">partial_sort</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                         _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>, </span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//partial_sort_copy与partial_sort的实现机制是相同，只是partial_sort_copy将元素排序后放在以result起始的容器中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Distance</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                                      _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>, </span></span><br><span class="line"><span class="class">                                      _<span class="title">Distance</span>*, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__result_first == __result_last) <span class="keyword">return</span> __result_last;</span><br><span class="line">  _RandomAccessIter __result_real_last = __result_first;</span><br><span class="line">  <span class="keyword">while</span>(__first != __last &amp;&amp; __result_real_last != __result_last) &#123;</span><br><span class="line">    *__result_real_last = *__first;</span><br><span class="line">    ++__result_real_last;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  make_heap(__result_first, __result_real_last);</span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__first &lt; *__result_first) </span><br><span class="line">      __adjust_heap(__result_first, _Distance(<span class="number">0</span>),</span><br><span class="line">                    _Distance(__result_real_last - __result_first),</span><br><span class="line">                    _Tp(*__first));</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  sort_heap(__result_first, __result_real_last);</span><br><span class="line">  <span class="keyword">return</span> __result_real_last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_CONVERTIBLE(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                    <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">return</span> __partial_sort_copy(__first, __last, __result_first, __result_last, </span><br><span class="line">                             __DISTANCE_TYPE(__result_first),</span><br><span class="line">                             __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Distance</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">RandomAccessIter</span> __<span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>,</span></span><br><span class="line"><span class="class">                                         _<span class="title">Compare</span> __<span class="title">comp</span>, _<span class="title">Distance</span>*, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (__result_first == __result_last) <span class="keyword">return</span> __result_last;</span><br><span class="line">  _RandomAccessIter __result_real_last = __result_first;</span><br><span class="line">  <span class="keyword">while</span>(__first != __last &amp;&amp; __result_real_last != __result_last) &#123;</span><br><span class="line">    *__result_real_last = *__first;</span><br><span class="line">    ++__result_real_last;</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  make_heap(__result_first, __result_real_last, __comp);</span><br><span class="line">  <span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__first, *__result_first))</span><br><span class="line">      __adjust_heap(__result_first, _Distance(<span class="number">0</span>),</span><br><span class="line">                    _Distance(__result_real_last - __result_first),</span><br><span class="line">                    _Tp(*__first),</span><br><span class="line">                    __comp);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">  sort_heap(__result_first, __result_real_last, __comp);</span><br><span class="line">  <span class="keyword">return</span> __result_real_last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">RandomAccessIter</span></span></span><br><span class="line"><span class="class"><span class="title">partial_sort_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">RandomAccessIter</span> __<span class="title">result_last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_InputIter, _InputIterator);</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_CONVERTIBLE(<span class="keyword">typename</span> iterator_traits&lt;_InputIter&gt;::value_type,</span><br><span class="line">                    <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);  </span><br><span class="line">  <span class="keyword">return</span> __partial_sort_copy(__first, __last, __result_first, __result_last,</span><br><span class="line">                             __comp,</span><br><span class="line">                             __DISTANCE_TYPE(__result_first),</span><br><span class="line">                             __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// nth_element() and its auxiliary functions.  </span></span><br><span class="line"><span class="comment">//nth_element版本一辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                   _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">3</span>) &#123;<span class="comment">//区间长度大于3</span></span><br><span class="line">	  <span class="comment">//获取分割点cut</span></span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>))));</span><br><span class="line">    <span class="keyword">if</span> (__cut &lt;= __nth)<span class="comment">//若分割点小于指定位置，则nth位置在右半段</span></span><br><span class="line">      __first = __cut;<span class="comment">//再对右半段进行分割</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//否则，对左半段进行分割</span></span><br><span class="line">      __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重新排序序列[first,last)，使迭代器nth所指的元素，与“整个[first,last)序列完整排序后，同一位置的元素”同值.</span></span><br><span class="line"><span class="comment">//此外，必须保证[nth,last)内的所有元素不小于[first,nth)内的元素，但是对于序列[first,nth)和序列[nth,last)内的元素的排序顺序不能确定.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：Rearranges the elements in the range [first,last), </span></span><br><span class="line"><span class="comment">in such a way that the element at the nth position is the element that would be in that position in a sorted sequence.</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">default (1)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator&gt;</span></span><br><span class="line"><span class="comment">	void nth_element (RandomAccessIterator first, RandomAccessIterator nth,</span></span><br><span class="line"><span class="comment">                    RandomAccessIterator last);</span></span><br><span class="line"><span class="comment">custom (2)	</span></span><br><span class="line"><span class="comment">	template &lt;class RandomAccessIterator, class Compare&gt;</span></span><br><span class="line"><span class="comment">	void nth_element (RandomAccessIterator first, RandomAccessIterator nth,</span></span><br><span class="line"><span class="comment">                    RandomAccessIterator last, Compare comp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//nth_element版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __nth_element(__first, __nth, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                   _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Tp</span>*, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>), </span><br><span class="line">                                         *(__last - <span class="number">1</span>),</span><br><span class="line">                                         __comp)),</span><br><span class="line">                            __comp);</span><br><span class="line">    <span class="keyword">if</span> (__cut &lt;= __nth)</span><br><span class="line">      __first = __cut;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="title">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">nth_element</span>(_<span class="title">RandomAccessIter</span> __<span class="title">first</span>, _<span class="title">RandomAccessIter</span> __<span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">RandomAccessIter</span> __<span class="title">last</span>, _<span class="title">Compare</span> __<span class="title">comp</span>) &#123;</span></span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="keyword">bool</span>,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">     <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __nth_element(__first, __nth, __last, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is_sorted, a predicated testing whether a range is sorted in</span></span><br><span class="line"><span class="comment">// nondescending order.  This is an extension, not part of the C++</span></span><br><span class="line"><span class="comment">// standard.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">is_sorted</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _ForwardIter __next = __first;</span><br><span class="line">  <span class="keyword">for</span> (++__next; __next != __last; __first = __next, ++__next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*__next &lt; *__first)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">StrictWeakOrdering</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">is_sorted</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">               _<span class="title">StrictWeakOrdering</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __STL_REQUIRES(_ForwardIter, _ForwardIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_StrictWeakOrdering, <span class="keyword">bool</span>, </span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type,</span><br><span class="line">        <span class="keyword">typename</span> iterator_traits&lt;_ForwardIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first == __last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _ForwardIter __next = __first;</span><br><span class="line">  <span class="keyword">for</span> (++__next; __next != __last; __first = __next, ++__next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__next, *__first))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/STL/Set和Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/STL/Set和Map/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇博客中，讲到了STL中关于红黑树的实现，理解起来比较复杂，正所谓前人种树，后人乘凉，RBTree把树都种好了，接下来就该set和map这类关联式容器来“乘凉”了。</p>
<p>STL的set和map都是基于红黑树实现的，和stack和queue都是基于deque一样，它们仅仅是调用了RBTree提供的接口函数，然后进行外层封装即可。本篇博客理解起来比较轻松，set和map的源代码也不多，大家可以慢慢“品味”。另外，还会介绍multiset和multimap这两个容器，并给出它们的区别和应用等。还等什么呢？走吧，带你理解理解set和map吧！</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set是一种关联式容器，其特性如下：</p>
<ul>
<li>set以RBTree作为底层容器</li>
<li>所得元素的只有key没有value，value就是key</li>
<li>不允许出现键值重复</li>
<li>所有的元素都会被自动排序</li>
<li>不能通过迭代器来改变set的值，因为set的值就是键</li>
</ul>
<p>针对这五点来说，前四点都不用再多作说明，第五点需要做一下说明。如果set中允许修改键值的话，那么首先需要删除该键，然后调节平衡，在插入修改后的键值，再调节平衡，如此一来，严重破坏了set的结构，导致iterator失效，不知道应该指向之前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值。</p>
<h2 id="set的数据结构"><a href="#set的数据结构" class="headerlink" title="set的数据结构"></a>set的数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较器默认采用less，内部按照升序排列，配置器默认采用alloc</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//  在set中key就是value, value同时也是key</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Key value_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于比较的函数</span></span><br><span class="line">  <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">  <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 内部采用RBTree作为底层容器</span></span><br><span class="line">  <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">  rep_type t;	<span class="comment">// t为内部RBTree容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 用于提供iterator_traits&lt;I&gt;支持</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;            </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;        </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type; </span><br><span class="line">  <span class="comment">// 设置成const迭代器，set的键值不允许修改</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;          </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">  <span class="comment">// 反向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.size(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.max_size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回用于key比较的函数</span></span><br><span class="line">  <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line">  <span class="comment">// 由于set的性质, value比较和key使用同一个比较函数</span></span><br><span class="line">  <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明了两个友元函数，重载了==和&lt;操作符</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">set</span>&amp;, <span class="keyword">const</span> <span class="built_in">set</span>&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">set</span>&amp;, <span class="keyword">const</span> <span class="built_in">set</span>&amp;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set的构造函数"><a href="#set的构造函数" class="headerlink" title="set的构造函数"></a>set的构造函数</h2><p>set提供了如下几个构造函数用于初始化一个set</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：下面相关函数都在set类中定义，为了介绍方便才抽出来单独讲解</span></span><br><span class="line"><span class="comment">// 空构造函数，初始化一个空的set</span></span><br><span class="line"><span class="built_in">set</span>() : t(Compare()) &#123;&#125;</span><br><span class="line"><span class="comment">// 支持自定义比较器，如set&lt;int,greater&lt;int&gt; &gt; myset的初始化</span></span><br><span class="line">explicit set(const Compare&amp; comp) : t(comp) &#123;&#125;</span><br><span class="line"><span class="comment">// 实现诸如set&lt;int&gt; myset(anotherset.begin(),anotherset.end())这样的初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">set</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">:</span> t(Compare()) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 支持自定义比较器的初始化操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">set</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">:</span> t(comp) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 以另一个set来初始化</span></span><br><span class="line"><span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x) : t(x.t) &#123;&#125;</span><br><span class="line"><span class="comment">// 赋值运算符函数</span></span><br><span class="line"><span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">	t = x.t;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set的操作函数"><a href="#set的操作函数" class="headerlink" title="set的操作函数"></a>set的操作函数</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>插入函数，调用RBTree的插入函数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  pair&lt;iterator, <span class="keyword">bool</span>&gt; pair_iterator_bool;</span><br><span class="line"><span class="comment">// 由于set不允许键值重复，所以必须调用RBTree的insert_unique函数</span></span><br><span class="line"><span class="comment">// second表示插入操作是否成功</span></span><br><span class="line">pair&lt;iterator,<span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  pair&lt;<span class="keyword">typename</span> rep_type::iterator, <span class="keyword">bool</span>&gt; p = t.insert_unique(x);</span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(p.first, p.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position处插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span></span><br><span class="line"><span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  <span class="keyword">return</span> t.insert_unique((rep_iterator&amp;)position, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将[first，last)区间内的元素插入到set中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  t.insert_unique(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><p>擦除函数，用于擦除单个元素或者区间内的元素，直接调用RBTree的函数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 擦除指定位置的元素, 会导致内部的红黑树重新排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  t.erase((rep_iterator&amp;)position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会返回擦除元素的个数, 其实就是标识set内原来是否有指定的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.erase(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦除指定区间的元素, 会导致红黑树有较大变化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  t.erase((rep_iterator&amp;)first, (rep_iterator&amp;)last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p>清除整个set容器，直接调用RBTree的clean函数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.clear(); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找函数，RBTree也提供了，直接调用即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找指定的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>查找制定元素的个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定元素的个数, set不允许键值重复，其实就是测试元素是否在set中</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.count(x); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>set重载了==和&lt;操作符，基本上都是调用RBTree的接口函数即可，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">set</span>&lt;Key, Compare, Alloc&gt;&amp; <span class="title">x</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> <span class="title">set</span>&lt;Key, Compare, Alloc&gt;&amp; <span class="title">y</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>&lt;(const set&lt;Key, Compare, Alloc&gt;&amp; x,</span></span><br><span class="line"><span class="class">                      const set&lt;Key, Compare, Alloc&gt;&amp; y) &#123;</span></span><br><span class="line"><span class="class">  return x.t &lt; y.t;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="其他操作函数"><a href="#其他操作函数" class="headerlink" title="其他操作函数"></a>其他操作函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回小于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.lower_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回大于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.upper_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回与指定键值相等的元素区间</span></span><br><span class="line">pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> t.equal_range(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h1><p>multiset相对于set来说，区别就是multiset允许键值重复，在multiset中调用的是RBTree的insert_equal函数，其他的基本与set相同。</p>
<p>其他的就不赘述了，下面列举一下跟set不同的地方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化函数，</span></span><br><span class="line"><span class="comment">// 注意！！！！插入操作采用的是RBTree的insert_equal，而不是insert_unique</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">multiset</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  :</span> t(Compare()) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">multiset</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">  :</span> t(comp) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素, 注意, 插入的元素key允许重复</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.insert_equal(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position处插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span></span><br><span class="line"><span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">  <span class="keyword">return</span> t.insert_equal((rep_iterator&amp;)position, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map和set一样是关联式容器，它们的底层容器都是红黑树，区别就在于map的值不作为键，键和值是分开的。它的特性如下：</p>
<ul>
<li>map以RBTree作为底层容器</li>
<li>所有元素都是键+值存在</li>
<li>不允许键重复</li>
<li>所有元素是通过键进行自动排序的</li>
<li>map的键是不能修改的，但是其键对应的值是可以修改的</li>
</ul>
<p>在map中，一个键对应一个值，其中键不允许重复，不允许修改，但是键对应的值是可以修改的，原因可以看上面set中的解释。下面就一起来看看STL中的map的源代码。</p>
<h2 id="map的数据结构"><a href="#map的数据结构" class="headerlink" title="map的数据结构"></a>map的数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认比较器为less&lt;key&gt;,元素按照键的大小升序排列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;                         <span class="comment">// key类型</span></span><br><span class="line">  <span class="keyword">typedef</span> T data_type;                          <span class="comment">// value类型</span></span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;        <span class="comment">// 元素类型, 要保证key不被修改</span></span><br><span class="line">  <span class="keyword">typedef</span> Compare key_compare;                  <span class="comment">// 用于key比较的函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 内部采用RBTree作为底层容器</span></span><br><span class="line">  <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">  rep_type t; <span class="comment">// t为内部RBTree容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 用于提供iterator_traits&lt;I&gt;支持</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;            </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;        </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type; </span><br><span class="line">  <span class="comment">// 注意：这里与set不一样，map的迭代器是可以修改的</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;          </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">  <span class="comment">// 反向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常规的返回迭代器函数</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.size(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.max_size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回用于key比较的函数</span></span><br><span class="line">  <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于map的性质, value和key使用同一个比较函数, 实际上我们并不使用value比较函数</span></span><br><span class="line">  <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value_compare(t.key_comp()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意: 这里有一个常见的陷阱, 如果访问的key不存在, 会新建立一个</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> key_type&amp; k)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (*((insert(value_type(k, T()))).first)).second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重载了==和&lt;操作符，后面会有实现</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">map</span>&amp;, <span class="keyword">const</span> <span class="built_in">map</span>&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">map</span>&amp;, <span class="keyword">const</span> <span class="built_in">map</span>&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map的构造函数"><a href="#map的构造函数" class="headerlink" title="map的构造函数"></a>map的构造函数</h2><p>map提供了一下的构造函数来初始化一个map</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空构造函数，直接调用RBTree的空构造函数</span></span><br><span class="line"><span class="built_in">map</span>() : t(Compare()) &#123;&#125;</span><br><span class="line">explicit map(const Compare&amp; comp) : t(comp) &#123;&#125;</span><br><span class="line"><span class="comment">// 提供类似map&lt;int,int&gt; myMap(anotherMap.begin(),anotherMap.end())的初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">map</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  :</span> t(Compare()) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 提供类似map&lt;int,int&gt; myMap(anotherMap.begin(),anotherMap.end(),less&lt;int&gt;)初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">map</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">  :</span> t(comp) &#123; t.insert_unique(first, last); &#125;</span><br><span class="line"><span class="comment">// 提供类似map&lt;int&gt; maMap(anotherMap)的初始化</span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x) : t(x.t) &#123;&#125;</span><br><span class="line"><span class="comment">// 重载=操作符，赋值运算符</span></span><br><span class="line"><span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  t = x.t;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map的操作函数"><a href="#map的操作函数" class="headerlink" title="map的操作函数"></a>map的操作函数</h2><h3 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h3><p>同set一样，直接调用RBTree的插入函数即可，注意map不允许键值重复，所以调用的是insert_unique</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于相同的key, 只允许出现一次, bool标识</span></span><br><span class="line">pair&lt;iterator,<span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; x) &#123; <span class="keyword">return</span> t.insert_unique(x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在position处</span></span><br><span class="line">插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span><br><span class="line"><span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.insert_unique(position, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将[first，last)区间内的元素插入到map中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  t.insert_unique(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="erase-1"><a href="#erase-1" class="headerlink" title="erase"></a>erase</h3><p>同set，直接调用即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 擦除指定位置的元素, 会导致内部的红黑树重新排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; t.erase(position); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会返回擦除元素的个数, 其实就是标识map内原来是否有指定的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.erase(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123; t.erase(first, last); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="clean-1"><a href="#clean-1" class="headerlink" title="clean"></a>clean</h3><p>同set，直接调用即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.clear(); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="find-1"><a href="#find-1" class="headerlink" title="find"></a>find</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找指定key的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br><span class="line">````</span><br><span class="line">### 重载运算符</span><br><span class="line">上面介绍到<span class="built_in">map</span>重载了[],==和&lt;运算符，[]的实现已经介绍过，下面是==和&lt;的实现</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// 比较map直接是对其底层容器t的比较，直接调用RBTree的比较函数即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;class Key, class T, class Compare, class Alloc&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x,</span><br><span class="line">                       <span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>&lt;(const map&lt;Key, T, Compare, Alloc&gt;&amp; x,</span></span><br><span class="line"><span class="class">                      const map&lt;Key, T, Compare, Alloc&gt;&amp; y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">  return x.t &lt; y.t;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="其他操作函数-1"><a href="#其他操作函数-1" class="headerlink" title="其他操作函数"></a>其他操作函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回小于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.lower_bound(x); &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.lower_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回大于当前元素的第一个可插入的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.upper_bound(x); &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.upper_bound(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回与指定键值相等的元素区间</span></span><br><span class="line">pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> t.equal_range(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h1><p>multimap和map的关系就跟multiset和set的关系一样，multimap允许键的值相同，因此在插入操作的时候用到insert_equal()，除此之外，基本上与map相同。</p>
<p>下面就仅仅列出不同的地方</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multimap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// ... 其他地方与map相同</span></span><br><span class="line">  <span class="comment">// 注意下面这些函数都调用的是insert_equal，而不是insert_unique</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">multimap</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">    :</span> t(Compare()) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">multimap</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">    :</span> t(comp) &#123; t.insert_equal(first, last); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入元素, 注意, 插入的元素key允许重复</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.insert_equal(x); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在position处插入元素, 但是position仅仅是个提示, 如果给出的位置不能进行插入,</span></span><br><span class="line">  <span class="comment">// STL会进行查找, 这会导致很差的效率</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.insert_equal(position, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入一个区间内的元素</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    t.insert_equal(first, last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...其余地方和map相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，这四类容器仅仅只是在RBTree上进行了一层封装，首先，set和map的区别就在于键和值是否相同，set中将值作为键，支持STL的提供的一些交集、并集和差集等运算；map的键和值不同，每个键都有自己的值，键不能重复，但是值可以重复。</p>
<p>multimap和multiset就在map和set的基础上，使他们的键可以重复，除此之外基本等同。</p>
<p>关于map和set的用法，大家可以在其源代码中找到，这里就不在赘述，本系列博客也是基于源码的角度来分析这些容器。到此，end！</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/bolgzxy.github.io/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/bolgzxy.github.io/">1</a><span class="page-number current">2</span><a class="page-number" href="/bolgzxy.github.io/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/bolgzxy.github.io/page/5/">5</a><a class="extend next" rel="next" href="/bolgzxy.github.io/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/bolgzxy.github.io/images/user.jpg" alt="半世烟尘">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/bolgzxy.github.io/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/bolgzxy.github.io/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/bolgzxy.github.io/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/COTVZHAOYUEXING" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1998lovexs@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/bolgzxy.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
