<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/Moonstar-Z.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/Moonstar-Z.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/Moonstar-Z.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/Moonstar-Z.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/Moonstar-Z.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/Moonstar-Z.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/Moonstar-Z.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:type" content="website">
<meta property="og:title" content="し半世烟尘">
<meta property="og:url" content="https://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="し半世烟尘">
<meta name="twitter:description" content="黄沙百战穿金甲，不破楼兰誓不还。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/Moonstar-Z.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/page/5/">





  <title>し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/Moonstar-Z.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/Moonstar-Z.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/Moonstar-Z.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/Moonstar-Z.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/Moonstar-Z.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/Moonstar-Z.github.io/2019/09/14/字符串/大小写字母之间的转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Moonstar-Z.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Moonstar-Z.github.io/2019/09/14/字符串/大小写字母之间的转换/" itemprop="url">大小写字母的转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T00:00:00+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Moonstar-Z.github.io/categories/字符串/" itemprop="url" rel="index">
                    <span itemprop="name">字符串</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="大小写字母的转化"><a href="#大小写字母的转化" class="headerlink" title="大小写字母的转化"></a>大小写字母的转化</h3><p>现在聊聊经常遇到的一道题目：不使用比较转换字母大小写。<br>大写      十六进制         二进制            小写           十六进制        二进制<br>A          41                    0100 0001    a               61               0110 0001<br>B          42                    0100 0010    b               62               0110 0010<br>C          43                    0100 0011    c               63               0110 0011</p>
<p>对比发现，小写字符的ASCII的码值比大写字母大20H，同时大写字母二进制与小写字母二进制的区别在于第5为是0还是1（位数从0开始）。因此转换大小写思路有两种：<br>1、基于第一种比较的方式：首先判断是大写还是小写字母，然后加20H或者减20H<br>2 、基于就修改二进制的方式：任何一个字母将第5位置1，则转成小写，置0则是大写。</p>
<p>现在我们用思路2来实现，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toUpper</span><span class="params">( <span class="keyword">char</span> * ptr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toLower</span><span class="params">( <span class="keyword">char</span> * ptr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc , <span class="keyword">char</span> ** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                 <span class="keyword">char</span> ptr [] = <span class="string">"ABCDabcd"</span> ;</span><br><span class="line">                 toUpper (ptr );</span><br><span class="line">                 <span class="built_in">cout</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    </span><br><span class="line">                 toLower (ptr );</span><br><span class="line">                 <span class="built_in">cout</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">                 system (<span class="string">"pause"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*小写转换成大写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toUpper</span><span class="params">( <span class="keyword">char</span> * ptr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                 <span class="keyword">while</span> (* ptr != <span class="string">'\0'</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                   * ptr = (* ptr ) &amp; <span class="number">223</span> ; <span class="comment">//与运算将第5位置0,223二进制1101 1111</span></span><br><span class="line">                   ++ ptr;</span><br><span class="line">                 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*大写转小写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toLower</span><span class="params">( <span class="keyword">char</span> * ptr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                 <span class="keyword">while</span> (* ptr != <span class="string">'\0'</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                  * ptr = (* ptr )|<span class="number">32</span> ; <span class="comment">//或运算将第5位置1,32二进制0010 0000</span></span><br><span class="line">                  ++ ptr;</span><br><span class="line">                 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/Moonstar-Z.github.io/2019/09/14/设计模式/单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Moonstar-Z.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Moonstar-Z.github.io/2019/09/14/设计模式/单例模式/" itemprop="url">单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T00:00:00+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Moonstar-Z.github.io/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式也称为单件模式、单子模式，可能是使用最广泛的设计模式。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。有很多地方需要这样的功能模块，如系统的日志输出，GUI应用必须是单鼠标，MODEM的联接需要一条且只需要一条电话线，操作系统只能有一个窗口管理器，一台PC连一个键盘。<br>       单例模式有许多种实现方法，在C++中，甚至可以直接用一个全局变量做到这一点，但这样的代码显的很不优雅。 使用全局对象能够保证方便地访问实例，但是不能保证只声明一个对象——也就是说除了一个全局实例外，仍然能创建相同类的本地实例。<br>《设计模式》一书中给出了一种很不错的实现，定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。<br>       单例模式通过类本身来管理其唯一实例，这种特性提供了解决问题的方法。唯一的实例是类的一个普通对象，但设计这个类时，让它只能创建一个实例并提供对此实例的全局访问。唯一实例类Singleton在静态成员函数中隐藏创建实例的操作。习惯上把这个成员函数叫做Instance()，它的返回值是唯一实例的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyTest</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">inline</span>	<span class="keyword">static</span> CMyTest* <span class="title">GetSingleObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s_nCount &lt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s_pSingle = <span class="keyword">new</span> CMyTest();</span><br><span class="line">			s_nCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// do nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s_pSingle;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> CMyTest* s_pSingle;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_nCount;</span><br><span class="line">&#125;;</span><br><span class="line">CMyTest* CMyTest::s_pSingle = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> CMyTest::s_nCount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CMyTest* pObj = CMyTest::GetSingleObject();</span><br><span class="line">	CMyTest* pObj2 = CMyTest::GetSingleObject();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码虽然可以实现通过类直接访问静态成员函数，但是也存在缺陷，因为此时还是可以通过new产生新的对象指针。<br>$$<br>CMyTest* pObj3 = new  CMyTest();<br>$$<br>这里解决的办法很简单，将构造函数私有化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyTest</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	CMyTest()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> CMyTest* <span class="title">GetSingleObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s_nCount &lt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s_pSingle = <span class="keyword">new</span> CMyTest();</span><br><span class="line">			s_nCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// do nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s_pSingle;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> CMyTest* s_pSingle;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_nCount;</span><br><span class="line">&#125;;</span><br><span class="line">CMyTest* CMyTest::s_pSingle = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> CMyTest::s_nCount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CMyTest* pObj = CMyTest::GetSingleObject(); <span class="comment">//CMyTest类之外获取实例化对象的唯一方法</span></span><br><span class="line">	CMyTest* pObj2 = CMyTest::GetSingleObject();</span><br><span class="line">	<span class="comment">//CMyTest* pObj3 = new CMyTest(); //非法，不能这样实例化</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的单例模式改写为模板和宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_H_</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> T&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">static</span> T s_instance;</span><br><span class="line">		<span class="keyword">return</span> s_instance;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singleton();</span><br><span class="line">	Singleton(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>= (Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">	~Singleton();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T Singleton::s_instance=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//SINGLETON_H_</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_DIFINE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_DIFINE_H_</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//单例模式宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON(_CLASS_)					\</span></span><br><span class="line"><span class="keyword">public</span>:										\</span><br><span class="line">	inline static _CLASS_&amp; GetInstance()	\</span><br><span class="line">	&#123;										\</span><br><span class="line">	<span class="keyword">static</span> _CLASS_ s_instance;				\</span><br><span class="line">	<span class="keyword">return</span> s_instance;						\</span><br><span class="line">	&#125;										\</span><br><span class="line"><span class="keyword">private</span>:									\</span><br><span class="line">	_CLASS_();								\</span><br><span class="line">	_CLASS_(_CLASS_ <span class="keyword">const</span>&amp;)&#123;&#125;				\</span><br><span class="line">	_CLASS_&amp; <span class="keyword">operator</span>= (_CLASS_ <span class="keyword">const</span>&amp;)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;	\</span><br><span class="line">	~_CLASS_();								\</span><br><span class="line"> </span><br><span class="line"><span class="comment">//单例模式默认构造函数与析构函数（配合单例模式宏使用）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_C_D(_CLASS_)		\</span></span><br><span class="line">	_CLASS_::_CLASS_()&#123;&#125;			\</span><br><span class="line">	_CLASS_::~_CLASS_()&#123;&#125;			\</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//SINGLETON_DIFINE_H_</span></span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/Moonstar-Z.github.io/2019/09/12/字符串/手写字符串函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Moonstar-Z.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Moonstar-Z.github.io/2019/09/12/字符串/手写字符串函数/" itemprop="url">手写字符串的库函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T00:00:00+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Moonstar-Z.github.io/categories/字符串/" itemprop="url" rel="index">
                    <span itemprop="name">字符串</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="1、strcpy"><a href="#1、strcpy" class="headerlink" title="1、strcpy"></a>1、strcpy</h4><p><strong>函数作用：</strong>把 src 所指向的字符串复制到 dest。</p>
<p>注意：dest定义的空间应该比src大。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/Moonstar-Z.github.io/2019/09/12/字符串/手写字符串函数/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/Moonstar-Z.github.io/2019/08/16/数据结构/二叉树的遍历方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Moonstar-Z.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Moonstar-Z.github.io/2019/08/16/数据结构/二叉树的遍历方式/" itemprop="url">二叉树的遍历方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T17:27:08+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）"><a href="#二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）" class="headerlink" title="二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）"></a>二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）</h2><p>前言：</p>
<p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。</p>
<p>四种主要的遍历思想为：</p>
<p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>
<p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p>
<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>
<p>层次遍历：只需按层次遍历即可</p>
<p>例如，求下面二叉树的各种遍历</p>
<p><img src="https://img-blog.csdn.net/20150204101904649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTXlfSm9icw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>前序遍历：1  2  4  5  7  8  3  6 </p>
<p>中序遍历：4  2  7  5  8  1  3  6</p>
<p>后序遍历：4  7  8  5  2  6  3  1</p>
<p>层次遍历：1  2  3  4  5  6  7  8</p>
<h4 id="1，前序遍历（先序遍历）"><a href="#1，前序遍历（先序遍历）" class="headerlink" title="1，前序遍历（先序遍历）"></a>1，前序遍历（先序遍历）</h4><p>根据上文提到的遍历思路：根结点 —&gt; 左子树 —&gt; 右子树，很容易写出递归版本</p>
<p>一般的正常遍历的递归代码</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt; 		<span class="keyword">if</span> (root != null) &#123;</span><br><span class="line">&gt; 			System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">&gt; 			preOrderTraverse1(root.left);</span><br><span class="line">&gt; 			preOrderTraverse1(root.right);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; <span class="comment">//下面是迭代的版本</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt; 		LinkedList&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&gt; 		TreeNode pNode = root;</span><br><span class="line">&gt; 		<span class="keyword">while</span> (pNode != null || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">&gt; 			<span class="keyword">if</span> (pNode != null) &#123;</span><br><span class="line">&gt; 				System.out.print(pNode.val+<span class="string">"  "</span>);</span><br><span class="line">&gt; 				<span class="built_in">stack</span>.push(pNode);</span><br><span class="line">&gt; 				pNode = pNode.left;</span><br><span class="line">&gt; 			&#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">&gt; 				TreeNode node = <span class="built_in">stack</span>.pop();</span><br><span class="line">&gt; 				pNode = node.right;</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是Leecode 144题就是先序遍历的题目</p>
<blockquote>
<p>给定一个二叉树，返回它的 前序 遍历。</p>
<p> 示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p>
<p>输出: [1,2,3]</p>
</blockquote>
<ul>
<li><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> &gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - int val;</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - TreeNode *left;</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - TreeNode *right;</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - &#125;;</span></span><br><span class="line"><span class="comment">    &gt;   */</span></span><br><span class="line">    &gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    &gt;   <span class="keyword">public</span>:</span><br><span class="line">    &gt;   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    &gt;      <span class="comment">//递归版本，效率极其低下</span></span><br><span class="line">    &gt;       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    &gt;       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;data;</span><br><span class="line">    &gt;       <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &gt;       &#123;</span><br><span class="line">    &gt;        result.push_back(root-&gt;val);</span><br><span class="line">    &gt;        data=preorderTraversal(root-&gt;left);</span><br><span class="line">    &gt;        result.insert(result.end(),data.begin(),data.end());</span><br><span class="line">    &gt;        data=preorderTraversal(root-&gt;right);</span><br><span class="line">    &gt;        result.insert(result.end(),data.begin(),data.end());</span><br><span class="line">    &gt;       &#125;</span><br><span class="line">    &gt;        <span class="keyword">return</span> result;</span><br><span class="line">    &gt;       <span class="comment">//下面是迭代版本</span></span><br><span class="line">    &gt;        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    &gt;        <span class="built_in">stack</span>&lt;TreeNode*&gt;data;</span><br><span class="line">    &gt;        TreeNode* a1=root;</span><br><span class="line">    &gt;       <span class="keyword">if</span>(a1==<span class="literal">NULL</span>)</span><br><span class="line">    &gt;         <span class="keyword">return</span> result;</span><br><span class="line">    &gt;       <span class="keyword">while</span>(a1!=<span class="literal">NULL</span>||!data.empty())</span><br><span class="line">&gt;       &#123;</span><br><span class="line">    &gt;           <span class="keyword">while</span>(a1!=<span class="literal">NULL</span>)</span><br><span class="line">&gt;           &#123;</span><br><span class="line"> &gt;               result.push_back(a1-&gt;val);   </span><br><span class="line"> &gt;               data.push(a1);</span><br><span class="line"> &gt;               a1=a1-&gt;left;</span><br><span class="line"> &gt;           &#125;</span><br><span class="line"> &gt;           <span class="keyword">if</span>(!data.empty())&#123;</span><br><span class="line"> &gt;           a1=data.top();</span><br><span class="line"> &gt;           data.pop(); </span><br><span class="line"> &gt;           a1=a1-&gt;right;</span><br><span class="line"> &gt;           &#125;</span><br><span class="line"> &gt;       &#125;</span><br><span class="line"> &gt;       <span class="keyword">return</span> result;</span><br><span class="line"> &gt; </span><br><span class="line"> &gt;   &#125;</span><br><span class="line"> &gt;   &#125;;</span><br><span class="line"> &gt; 执行用时 :<span class="number">4</span> ms, 在所有 C++ 提交中击败了<span class="number">84.55</span>%的用户</span><br><span class="line"> &gt; 内存消耗 :<span class="number">9.2</span> MB, 在所有 C++ 提交中击败了<span class="number">43.67</span>%的用户</span><br><span class="line"> &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="2，中序遍历"><a href="#2，中序遍历" class="headerlink" title="2，中序遍历"></a>2，中序遍历</h4><p>根据上文提到的遍历思路：左子树 —&gt; 根结点 —&gt; 右子树，很容易写出递归版本：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt; 		<span class="keyword">if</span> (root != null) &#123;</span><br><span class="line">&gt; 			inOrderTraverse1(root.left);</span><br><span class="line">&gt; 			System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">&gt; 			inOrderTraverse1(root.right);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;                                        </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt; 		LinkedList&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&gt; 		TreeNode pNode = root;</span><br><span class="line">&gt; 		<span class="keyword">while</span> (pNode != null || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">&gt; 			<span class="keyword">if</span> (pNode != null) &#123;</span><br><span class="line">&gt; 				<span class="built_in">stack</span>.push(pNode);</span><br><span class="line">&gt; 				pNode = pNode.left;</span><br><span class="line">&gt; 			&#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">&gt; 				TreeNode node = <span class="built_in">stack</span>.pop();</span><br><span class="line">&gt; 				System.out.print(node.val+<span class="string">"  "</span>);</span><br><span class="line">&gt; 				pNode = node.right;</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Leecode94题就是二叉树的中序遍历</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">    - struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    - int val;</span></span><br><span class="line"><span class="comment">    - TreeNode *left;</span></span><br><span class="line"><span class="comment">    - TreeNode *right;</span></span><br><span class="line"><span class="comment">    - TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">    - &#125;;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">/* 递归</span></span><br><span class="line"><span class="comment">          vector&lt;int&gt;result;</span></span><br><span class="line"><span class="comment">          vector&lt;int&gt;data;</span></span><br><span class="line"><span class="comment">          if(root!=NULL)</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">           data=inorderTraversal(root-&gt;left);</span></span><br><span class="line"><span class="comment">           result.insert(result.end(),data.begin(),data.end());</span></span><br><span class="line"><span class="comment">           result.push_back(root-&gt;val);</span></span><br><span class="line"><span class="comment">           data=inorderTraversal(root-&gt;right);</span></span><br><span class="line"><span class="comment">           result.insert(result.end(),data.begin(),data.end());</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">           return result;*/</span></span><br><span class="line">          <span class="comment">//迭代 用栈</span></span><br><span class="line">          <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">          <span class="built_in">stack</span>&lt;TreeNode*&gt;data;</span><br><span class="line">          TreeNode* a=root;</span><br><span class="line">          <span class="keyword">while</span>(a||!data.empty())</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">while</span>(a!=<span class="literal">NULL</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                 data.push(a);</span><br><span class="line">              a=a-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           a=data.top();</span><br><span class="line">           data.pop();</span><br><span class="line">           result.push_back(a-&gt;val);</span><br><span class="line">           a=a-&gt;right;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h4 id="3，后序遍历"><a href="#3，后序遍历" class="headerlink" title="3，后序遍历"></a>3，后序遍历</h4><p>根据上文提到的遍历思路：左子树 —&gt; 右子树 —&gt; 根结点，很容易写出递归版本：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt; 		<span class="keyword">if</span> (root != null) &#123;</span><br><span class="line">&gt; 			postOrderTraverse1(root.left);</span><br><span class="line">&gt; 			postOrderTraverse1(root.right);</span><br><span class="line">&gt; 			System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Leecode145后序遍历二叉树</p>
<ul>
<li><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> &gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">    &gt; - struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    &gt; - int val;</span></span><br><span class="line"><span class="comment">    &gt; - TreeNode *left;</span></span><br><span class="line"><span class="comment">    &gt; - TreeNode *right;</span></span><br><span class="line"><span class="comment">    &gt; - TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">    &gt; - &#125;;</span></span><br><span class="line"><span class="comment">    &gt;   */</span></span><br><span class="line">    &gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    &gt;   <span class="keyword">public</span>:</span><br><span class="line">    &gt;   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    &gt;       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    &gt;       <span class="built_in">stack</span>&lt;TreeNode*&gt;data;<span class="comment">//存放已经遍历的节点</span></span><br><span class="line">    &gt;       TreeNode* a=root; <span class="comment">//这个节点用于遍历整个二叉树</span></span><br><span class="line">    &gt;       TreeNode* last=root; <span class="comment">//设置的最后一次访问的节点      </span></span><br><span class="line">    &gt;       <span class="keyword">while</span>(a!=<span class="literal">NULL</span>||!data.empty())</span><br><span class="line">    &gt;       &#123;</span><br><span class="line">    &gt;           <span class="keyword">while</span>(a!=<span class="literal">NULL</span>)</span><br><span class="line">    &gt;           &#123;</span><br><span class="line">    &gt;               data.push(a);</span><br><span class="line">    &gt;               a=a-&gt;left;</span><br><span class="line">    &gt;           &#125;</span><br><span class="line">    &gt;               a=data.top();<span class="comment">//这一步是关键，因为不断的从占中获取最上面的元素。</span></span><br><span class="line">    &gt;               <span class="keyword">if</span>(a-&gt;right==<span class="literal">NULL</span>||a-&gt;right==last)</span><br><span class="line">    &gt;               &#123;</span><br><span class="line">    &gt;               result.push_back(a-&gt;val);</span><br><span class="line">    &gt;               data.pop();</span><br><span class="line">    &gt;               last=a;</span><br><span class="line">&gt;               a=<span class="literal">NULL</span>;              </span><br><span class="line"> &gt;                &#125;</span><br><span class="line"> &gt;           <span class="keyword">else</span></span><br><span class="line"> &gt;           &#123;</span><br><span class="line"> &gt;           a=a-&gt;right;</span><br><span class="line"> &gt;           &#125;</span><br><span class="line"> &gt;       &#125;</span><br><span class="line"> &gt;       <span class="keyword">return</span> result;</span><br><span class="line"> &gt;   &#125;</span><br><span class="line"> &gt;   &#125;;</span><br><span class="line"> &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="4，层序遍历"><a href="#4，层序遍历" class="headerlink" title="4，层序遍历"></a>4，层序遍历</h4><p>层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt; <span class="keyword">public</span>:</span><br><span class="line">&gt;     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelOrder(TreeNode* root) </span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">&gt;         <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">&gt;         <span class="keyword">if</span>(root)</span><br><span class="line">&gt;             q.push(root);</span><br><span class="line">&gt;         <span class="keyword">while</span>(!q.empty())</span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             TreeNode* temp = q.front();</span><br><span class="line">&gt;             ret.push_back(temp-&gt;val);</span><br><span class="line">&gt;             q.pop();</span><br><span class="line">&gt;             <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">&gt;                 q.push(temp-&gt;left);</span><br><span class="line">&gt;             <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">&gt;                 q.push(temp-&gt;right);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> ret;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Leecode 102题二叉树的层序遍历</p>
<ul>
<li><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">&gt; - struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">&gt; - int val;</span></span><br><span class="line"><span class="comment">&gt; - TreeNode *left;</span></span><br><span class="line"><span class="comment">&gt; - TreeNode *right;</span></span><br><span class="line"><span class="comment">&gt; - TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&gt; - &#125;;</span></span><br><span class="line"><span class="comment">&gt;   */</span></span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt;   <span class="keyword">public</span>:</span><br><span class="line">&gt;    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">&gt;       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">&gt;         pre(root,<span class="number">0</span>,result);</span><br><span class="line">&gt;        <span class="keyword">return</span> result;</span><br><span class="line">&gt;        </span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(TreeNode* root,<span class="keyword">int</span> i,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;result)</span></span></span><br><span class="line">&gt;    &#123;</span><br><span class="line">&gt;        <span class="keyword">if</span>(!root)</span><br><span class="line">&gt;            <span class="keyword">return</span>;</span><br><span class="line">&gt;        <span class="keyword">if</span>(i&gt;=result.size())</span><br><span class="line">&gt;        &#123;</span><br><span class="line">&gt;            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;&#125;);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        result[i].push_back(root-&gt;val);</span><br><span class="line">&gt;        pre(root-&gt;left,i+<span class="number">1</span>,result);</span><br><span class="line">&gt;        pre(root-&gt;right,i+<span class="number">1</span>,result);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>Leecode 107 二叉树的层序遍历II </p>
<ul>
<li><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - int val;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - TreeNode *left;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - TreeNode *right;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - &#125;;</span></span><br><span class="line"><span class="comment">&gt;   */</span></span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt;   <span class="keyword">public</span>:</span><br><span class="line">&gt;    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">&gt;       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   ```</span><br><span class="line">&gt;     pre(root,<span class="number">0</span>,result);</span><br><span class="line">&gt;     <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result1(result.size());</span><br><span class="line">&gt;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.size();i++)</span><br><span class="line">&gt;    &#123;</span><br><span class="line">&gt;      result1[i]=result[result.size()<span class="number">-1</span>-i];  </span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">return</span> result1;</span><br><span class="line">&gt;   ```</span><br><span class="line">&gt; </span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(TreeNode* root,<span class="keyword">int</span> i,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;result)</span></span></span><br><span class="line">&gt;    &#123;</span><br><span class="line">&gt;        <span class="keyword">if</span>(!root)</span><br><span class="line">&gt;            <span class="keyword">return</span>;</span><br><span class="line">&gt;        <span class="keyword">if</span>(i&gt;=result.size())</span><br><span class="line">&gt;        &#123;</span><br><span class="line">&gt;            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;&#125;);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   ```</span><br><span class="line">&gt;    pre(root-&gt;left,i+<span class="number">1</span>,result);</span><br><span class="line">&gt;    pre(root-&gt;right,i+<span class="number">1</span>,result);</span><br><span class="line">&gt;    result[i].push_back(root-&gt;val);</span><br><span class="line">&gt;   ```</span><br><span class="line">&gt; </span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/Moonstar-Z.github.io/2019/08/13/C++基础知识/递归的详细理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Moonstar-Z.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Moonstar-Z.github.io/2019/08/13/C++基础知识/递归的详细理解/" itemprop="url">递归的详细理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-13T16:44:58+08:00">
                2019-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、什么是递归"><a href="#一、什么是递归" class="headerlink" title="一、什么是递归"></a>一、什么是递归</h2><p>函数直接或间接调用自身的过程称为递归，相应的函数称为递归函数。使用递归算法，可以很容易地解决某些问题。此类问题的示例包括河内塔TOH，订单/预订/后序树遍历，图表DFS等。</p>
<h5 id="2-1递归时间复杂度"><a href="#2-1递归时间复杂度" class="headerlink" title="2.1递归时间复杂度"></a><strong><em>2.1递归时间复杂度</em></strong></h5><p>给出一个递归算法，其时间复杂度 O(T)通常是<strong>递归调用的数量</strong>（记作 {<em>R</em>） 和计算的时间复杂度的乘积（表示为 O(S)的乘积：<br>$$<br>O(T)=R∗O(s<br>)<br>$$</p>
<h5 id="2-1递归空间复杂度"><a href="#2-1递归空间复杂度" class="headerlink" title="2.1递归空间复杂度"></a><strong><em>2.1递归空间复杂度</em></strong></h5><h2 id="二、正常递归算法"><a href="#二、正常递归算法" class="headerlink" title="二、正常递归算法"></a>二、正常递归算法</h2><p>在递归程序中，提供了对基本情况的解决方案，并且用较小的问题表达了较大问题的解决方案。、</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; = <span class="number">1</span>) <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么在递归中发生堆栈溢出错误？</strong></p>
<p>在递归调用的过程中发生了不可能到达的情况，就可能会发生栈的溢出。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> (n = = <span class="number">100</span>) <span class="comment">// base case</span></span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;     <span class="keyword">else</span>    </span><br><span class="line">&gt;         <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);    </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在上面如果直接用fact(10);</p>
<h2 id="三、尾递归"><a href="#三、尾递归" class="headerlink" title="三、尾递归"></a>三、尾递归</h2><p><strong>尾递归和非尾递归有什么区别？</strong></p>
<p>当递归调用是函数执行的最后一件事时，递归函数是尾递归的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>&lt;&lt; n; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The last executed statement is recursive call </span></span><br><span class="line">    print(n<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑以下函数来计算n的阶乘。它是一种非尾递归函数。虽然看起来像尾巴递归。如果我们仔细看一下，我们可以看到事实（n-1）返回的值在事实（n）中使用，所以对事实（n-1）的调用不是事实（n）所做的最后一件事。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span>` `<span class="keyword">namespace</span>` `<span class="built_in">std</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// A NON-tail-recursive function.  The function is not tail </span></span><br><span class="line"><span class="comment">// recursive because the value returned by fact(n-1) is used in </span></span><br><span class="line"><span class="comment">// fact(n) and call to fact(n-1) is not the last thing done by fact(n) </span></span><br><span class="line"><span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `fact(<span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `n) </span><br><span class="line">&#123; </span><br><span class="line">    ``<span class="keyword">if</span>` `(n == <span class="number">0</span>) ``<span class="keyword">return</span>` `<span class="number">1</span>; </span><br><span class="line"> </span><br><span class="line">    ``<span class="keyword">return</span>` `n*fact(n<span class="number">-1</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// Driver program to test above function </span></span><br><span class="line"><span class="keyword">int</span>` `main() </span><br><span class="line">&#123; </span><br><span class="line">    ``<span class="built_in">cout</span> &lt;&lt; fact(<span class="number">5</span>); </span><br><span class="line">    ``<span class="keyword">return</span>` `<span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把上面的函数写成尾递归的样子，直接在函数最后调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span>` `<span class="keyword">namespace</span>` `<span class="built_in">std</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// A tail recursive function to calculate factorial </span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">factTR</span><span class="params">(<span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `n, <span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `a)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ``<span class="keyword">if</span>` `(n == <span class="number">0</span>)  ``<span class="keyword">return</span>` `a; </span><br><span class="line"> </span><br><span class="line">    ``<span class="keyword">return</span>` `factTR(n<span class="number">-1</span>, n*a); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// A wrapper over factTR </span></span><br><span class="line"><span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `fact(<span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `n) </span><br><span class="line">&#123; </span><br><span class="line">   ``<span class="keyword">return</span>` `factTR(n, <span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// Driver program to test above function </span></span><br><span class="line"><span class="keyword">int</span>` `main() </span><br><span class="line">&#123; </span><br><span class="line">    ``<span class="built_in">cout</span> &lt;&lt; fact(<span class="number">5</span>); </span><br><span class="line">    ``<span class="keyword">return</span>` `<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-Fibonacci尾部调用优化"><a href="#3-1-Fibonacci尾部调用优化" class="headerlink" title="3.1 Fibonacci尾部调用优化"></a><strong><em>3.1 Fibonacci尾部调用优化</em></strong></h5><p>关于如何使用外部空间直接保存数据，但是可以优化程序的堆栈的数量。</p>
<p>正常的调用递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciRecursive</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">if</span>( n &lt; <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span>         <span class="keyword">return</span> n;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">return</span> (FibonacciRecursive(n<span class="number">-1</span>)+FibonacciRecursive(n<span class="number">-2</span>));</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>

<p>下面是当n=5的递归的情况</p>
<p><img src="https://images0.cnblogs.com/blog/305504/201303/04214621-bde3e339931444a1a56ce66dd73d1f9b.png" alt="img"></p>
<p>尾递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciTailRecursive</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> ret1,<span class="keyword">int</span> ret2)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span>    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line"><span class="number">4</span>       <span class="keyword">return</span> ret1;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">return</span> FibonacciTailRecursive(n<span class="number">-1</span>,ret2,ret1+ret2);</span><br><span class="line"><span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images0.cnblogs.com/blog/305504/201303/04221026-166e3bca62d14ea7bb37eee0e6390d2d.png" alt="img"></p>
<h5 id="3-2Quicksort尾部调用优化（将最坏情况空间减少到Log-n）"><a href="#3-2Quicksort尾部调用优化（将最坏情况空间减少到Log-n）" class="headerlink" title="3.2Quicksort尾部调用优化（将最坏情况空间减少到Log n）"></a>3.2<strong><em>Quicksort尾部调用优化（将最坏情况空间减少到Log n）</em></strong></h5><p>在一般的快排中，调用的不是尾递归。Quicksort的一个简单实现会对自身进行两次调用，最坏的情况是在函数调用堆栈上需要O（n）空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>` `quickSort(``<span class="keyword">int</span>` `arr[], ``<span class="keyword">int</span>` `low, ``<span class="keyword">int</span>` `high) </span><br><span class="line">&#123; </span><br><span class="line">    ``<span class="keyword">if</span>` `(low &lt; high) </span><br><span class="line">    ``&#123; </span><br><span class="line">        ``<span class="comment">/* pi is partitioning index, arr[p] is now </span></span><br><span class="line"><span class="comment">           ``at right place */</span></span><br><span class="line">        ``<span class="keyword">int</span>` `pi = partition(arr, low, high); </span><br><span class="line">  </span><br><span class="line">        ``<span class="comment">// Separately sort elements before </span></span><br><span class="line">        ``<span class="comment">// partition and after partition </span></span><br><span class="line">        ``quickSort(arr, low, pi - <span class="number">1</span>); </span><br><span class="line">        ``quickSort(arr, pi + <span class="number">1</span>, high); </span><br><span class="line">    ``&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是用尾递归优化的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>` `quickSort(``<span class="keyword">int</span>` `arr[], ``<span class="keyword">int</span>` `low, ``<span class="keyword">int</span>` `high) </span><br><span class="line">&#123; </span><br><span class="line">    ``<span class="keyword">while</span>` `(low &lt; high) </span><br><span class="line">    ``&#123; </span><br><span class="line">        ``<span class="keyword">int</span>` `pi = partition(arr, low, high); </span><br><span class="line">        ``<span class="keyword">if</span>` `(pi - low &lt; high - pi) </span><br><span class="line">        ``&#123; </span><br><span class="line">            ``quickSort(arr, low, pi - <span class="number">1</span>); </span><br><span class="line">            ``low = pi + <span class="number">1</span>; </span><br><span class="line">        ``&#125; </span><br><span class="line">        ``<span class="keyword">else</span></span><br><span class="line">        ``&#123; </span><br><span class="line">            ``quickSort(arr, pi + <span class="number">1</span>, high); </span><br><span class="line">            ``high = pi - <span class="number">1</span>; </span><br><span class="line">        ``&#125; </span><br><span class="line">    ``&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：Partition函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剑指offer书上的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> throws Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data==null||data.length&lt;=<span class="number">0</span>||start&lt;<span class="number">0</span>||end&gt;=data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Invalid Parameters"</span>);</span><br><span class="line">        <span class="keyword">int</span> index=RandomInRange(start,end);  <span class="comment">// 随机取一个标准元素</span></span><br><span class="line">        Swap(data,index,end);  <span class="comment">// 交换元素</span></span><br><span class="line">        <span class="keyword">int</span> small=start<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&lt;data[end]) &#123;</span><br><span class="line">                ++small;</span><br><span class="line">                <span class="keyword">if</span>(small!=i)</span><br><span class="line">                    Swap(data,i,small);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++small;</span><br><span class="line">        Swap(data,small,end);</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般数据结构书上的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> throws Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data==null||data.length&lt;=<span class="number">0</span>||start&lt;<span class="number">0</span>||end&gt;=data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Invalid Parameters"</span>);</span><br><span class="line">        <span class="keyword">int</span> index=RandomInRange(start,end);  <span class="comment">// 随机取一个标准元素</span></span><br><span class="line">        Swap(data,index,start);  <span class="comment">// 交换元素</span></span><br><span class="line">        <span class="keyword">int</span> temp=data[start];  <span class="comment">// 保存标准元素</span></span><br><span class="line">        <span class="keyword">int</span> i=start,j=end;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;data[i]&lt;=temp) j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                data[j]=data[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;temp&lt;=data[j]) i++;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                data[i]=data[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[i]=temp;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/Moonstar-Z.github.io/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/Moonstar-Z.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/Moonstar-Z.github.io/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/Moonstar-Z.github.io/images/user.jpg" alt="半世烟尘">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/Moonstar-Z.github.io/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/Moonstar-Z.github.io/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/Moonstar-Z.github.io/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/COTVZHAOYUEXING" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1998lovexs@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/Moonstar-Z.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/Moonstar-Z.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/Moonstar-Z.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/Moonstar-Z.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
