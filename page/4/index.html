<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/bolgzxy.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/bolgzxy.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/bolgzxy.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/bolgzxy.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/bolgzxy.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/bolgzxy.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:type" content="website">
<meta property="og:title" content="し半世烟尘">
<meta property="og:url" content="https://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="し半世烟尘">
<meta name="twitter:description" content="黄沙百战穿金甲，不破楼兰誓不还。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/bolgzxy.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/page/4/">





  <title>し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/bolgzxy.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/bolgzxy.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/bolgzxy.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/bolgzxy.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/bolgzxy.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/05/OSI7层协议详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/05/OSI7层协议详解/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-05T22:57:47+08:00">
                2019-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、OSI7层模型"><a href="#一、OSI7层模型" class="headerlink" title="一、OSI7层模型"></a>一、OSI7层模型</h2><p><img src="http://hi.csdn.net/attachment/201201/5/0_1325744597WM32.gif" alt="img"></p>
<p>OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，<span style="color:red">因此其最主要的功能就是帮助不同类型的主机实现数据传输 。</span></p>
<p>完成中继功能的节点通常称为中继系统。在OSI七层模型中，处于不同层的中继系统具有不同的名称。   </p>
<p>一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。<br>具体说:<br>物理层：网卡，网线，集线器，中继器，调制解调器</p>
<p>数据链路层：网桥，交换机</p>
<p>网络层：路由器</p>
<p>网关工作在第四层传输层及其以上</p>
<p>集线器是物理层设备,采用广播的形式来传输信息。</p>
<p>交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文.。</p>
<p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。 </p>
<p><strong>交换机和路由器的区别</strong></p>
<p>交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在则广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部MAC地址表中。<br>使用交换机也可以把网络“分段”，通过对照MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。<br>交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。假使这里使用的是10Mbps的以太网交换机，那么该交换机这时的总流通量就等于2×10Mbps＝20Mbps，而使用10Mbps的共享式HUB时，一个HUB的总流通量也不会超出10Mbps。<br>总之，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。</p>
<p>从过滤网络流量的角度来看，路由器的作用与交换机和网桥非常相似。但是与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。因此，使用路由器转发和过滤数据的速度往往要比只查看数据包物理地址的交换机慢。但是，对于那些结构复杂的网络，使用路由器可以提高网络的整体效率。路由器的另外一个明显优势就是可以自动过滤网络广播。</p>
<p>集线器与路由器在功能上有什么不同? </p>
<p>首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。这样在机器很多或数据量很大时，两者将会有比较明显的。而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，不是完全独立的两种设备。路由器主要克服了交换机不能路由转发数据包的不足。 </p>
<p>总的来说，路由器与交换机的主要区别体现在以下几个方面： </p>
<p>（1）工作层次不同<br>最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 </p>
<p>（2）数据转发所依据的对象不同<br>交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。 </p>
<p>（3）传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域<br>由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 </p>
<p>（4）路由器提供了防火墙的服务<br>路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</p>
<h4 id="1、物理层"><a href="#1、物理层" class="headerlink" title="1、物理层"></a><strong>1、物理层</strong></h4><p>在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。<br>物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-343093645638ea0839b71db5eba1f7c0_hd.jpg" alt="img"></p>
<p>看着高大上，其实是将数据的0、1转换成电信号或者光信号。通过光纤、双绞线甚至是无限电波等介质传输到指定的地址。而传输过程中的集线器、中继器、调制解调器等，也属于物理层的传输介质。物理层是 <code>OSI</code> 七层模型的物理基础，没有它就谈不上数据传输了。</p>
<h4 id="2、数据链路层"><a href="#2、数据链路层" class="headerlink" title="2、数据链路层"></a><strong>2、数据链路层</strong></h4><p>数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。</p>
<p><strong><em>该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</em></strong></p>
<p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。<br>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p>
<p><strong>MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；</strong></p>
<p><strong>LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。</strong></p>
<p>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；<strong>并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</strong></p>
<p><strong><img src="https://pic1.zhimg.com/80/v2-fb8534d86e40986e43449de6c35ebd14_hd.jpg" alt="img"></strong></p>
<p><strong>数据链路层会将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）</strong>。举个例子可能会更好理解，暂且把需要传输的数据看作为不同来源的水，如果直接倒入池子中时，是无法重新分辨出不同来源的水的。但如果将不同来源的灌入瓶子中并打上记号，那就能区分出不同来源的水。这也就是为什么要划分为具有意义的数据帧传送给对端。同时要注意的是，数据链路层只负责将数据运送给物理相连的两端，并不负责直接发送到最终地址。</p>
<p>数据链路层可以看作是快递公司的司机，他们驾驶着汽车，将打包好的货物（数据帧）从一个城市（物理节点）运输到另一个城市</p>
<h4 id="3、网络层"><a href="#3、网络层" class="headerlink" title="3、网络层"></a><strong>3、网络层</strong></h4><p>网络层（Network Layer）是OSI模型的第三层，<strong>它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。</strong>它在下两层的基础上向资源子网提供服务。<strong>其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接</strong>。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。<br>一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 </p>
<p>在实现网络层功能时，需要解决的主要问题如下：<br> <strong>寻址</strong>：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是<strong>逻辑地址（如IP地址）</strong>。<br> <strong>交换</strong>：规定不同的信息交换方式。常见的交换技术有：<strong>线路交换技术和存储转发技术</strong>，后者又包括<strong>报文交换技术和分组交换技术</strong>。<br> <strong>路由算法</strong>：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。<br> <strong>连接服务</strong>：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。</p>
<p><img src="https://pic4.zhimg.com/80/v2-991572825990575d273f653a78bcc5e7_hd.jpg" alt="img"></p>
<p>​        网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。主要由 <code>IP</code>、<code>ICMP</code> 两个协议组成</p>
<p>​        网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是IP地址。IP地址和我们的住址有点相似，我们的住址可以从省到市再到街逐步缩小范围，直至我们住址。IP地址也有这样的能力，通过不断转发到更近的IP地址，最终可以到达目标地址。如何选择这条路，就看网络层了。</p>
<h4 id="4、传输层"><a href="#4、传输层" class="headerlink" title="4、传输层"></a><strong>4、传输层</strong></h4><p>OSI下3层的主要任务是<strong>数据通信</strong>，上3层的任务是<strong>数据处理</strong>。而传输层（Transport Layer）是OSI模型的第4层。因此该层<strong>是通信子网和资源子网的接口和桥梁，起到承上启下的作用</strong>。<br>该层的主要任务是：<strong>向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。</strong><br>传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：<br><strong>传输连接管理</strong>：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提<strong>供“面向连接”和“面向无接连”</strong>的两种服务。<br><strong>处理传输差错</strong>：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。<br><strong>监控服务质量。</strong></p>
<p><strong><img src="https://pic2.zhimg.com/80/v2-31bff54e0720487afe37e5f3f282d231_hd.jpg" alt="img"></strong></p>
<p><strong>传输层起着可靠传输的作用。只在通信双方节点进行处理，而不需在路由器上处理。此层有两个具有代表性的协议： <code>TCP</code> 与 <code>UDP</code>。</strong></p>
<p><code>TCP</code> 协议提供可靠的通信传输，简单说就是确认目标能通信的情况下才会传输数据（因此需要三次握手），传输过程如果丢了数据，也会重发。而 <code>UDP</code> 协议则不然，不会确认目标能否通信，只会根据协议发到对方地址的端口。至于对方收不收到，丢不丢包，一概不管。</p>
<p>传输层有一个重要作用，就是指定通信端口。以请求服务器数据为例，服务器有处理多种协议的能力，如之前应用层所说的<code>HTTP</code>，<code>FTP</code>，<code>TELNET</code> 等，但到底你是用什么协议呢？服务器并不知道。但如果你指定了端口，如 <code>80</code>，服务器就会知道你是想用 <code>HTTP</code> 协议的，自然会转给对应协议的处理程序进行处理。</p>
<p>作比喻的话，可以将传输层看作是快递公司的跟单员。负责任的跟单员（使用 <code>TCP</code> 协议）会保证快递送到客户手上，如果送不到就让公司再发一次。不负责任的跟单员（使用 <code>UDP</code> 协议）层只管将快递送到客户指定的地方，不管快递是否送到客户手上。</p>
<h4 id="5、会话层"><a href="#5、会话层" class="headerlink" title="5、会话层"></a><strong>5、会话层</strong></h4><p>会话层（Session Layer）是OSI模型的第5层，<strong>是用户应用程序和网络之间的接口</strong>，主要任务是：<strong>向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。</strong><br>用户可以按照<strong>半双工、单工和全双工</strong>的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。<strong>域名（DN）</strong>就是一种网络上使用的远程地址例如：<a href="http://www.3721.com就是一个域名。会话层的具体功能如下：" target="_blank" rel="noopener">www.3721.com就是一个域名。会话层的具体功能如下：</a><br><strong>会话管理</strong>：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。<br> <strong>会话流量控制</strong>：提供会话流量控制和交叉会话功能。<br><strong>寻址</strong>：使用远程地址建立会话连接。l<br><strong>出错控制</strong>：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。</p>
<p>会话层作用是负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。常见的协议有 <code>ADSP</code>、<code>RPC</code> 等。</p>
<h4 id="6、表示层"><a href="#6、表示层" class="headerlink" title="6、表示层"></a><strong>6、表示层</strong></h4><p>表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。表示层的具体功能如下：<br><strong>数据格式处理</strong>：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。<br><strong>数据的编码</strong>：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。<br><strong>压缩和解压缩</strong>：为了减少数据的传输量，这一层还负责数据的压缩与恢复。<br><strong>数据的加密和解密</strong>：可以提高网络的安全性。</p>
<p>表示层的作用是将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有 <code>ASCII</code>、<code>SSL/TLS</code> 等。</p>
<p>作用看起来可能比较绕，但其实是挺好理解的。我只会说中文，而日本友人只会说日文，那么我们两个是无法交流的。但如果我们都会说英文，交流时我先在心里想好要说的话是什么，再用英语说出来，日本友人听到英文，在心里转换为日语，他就能弄懂我的意思，此时表示层就是各自在心里转化语言。而浏览器请求回一堆数据，是解析成文本还是图片，就由表示层决定。数据的压缩、加密、打包等功能也都在这层完成。</p>
<p>这一层相当于快递公司的打包员。如果快递（数据）太臃肿，他会在不破坏快递的情况下压扁（压缩）它。如果客户注重安全线，全能的快递公司还能用密码箱（ <code>SSL/TLS</code>）打包快递再快送。当然，打包员会确定，目的地快递站的拆包员，能无损地拆开包裹，将快递交给用户。</p>
<h4 id="7、应用层"><a href="#7、应用层" class="headerlink" title="7、应用层"></a><strong>7、应用层</strong></h4><p>应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，<strong>其功能是直接向用户提供服务</strong>，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。<br>应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。应用层的主要功能如下：<br>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。<br>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</p>
<p><img src="https://pic2.zhimg.com/80/v2-741e4cd7f95897d6a61bd219e208f1c1_hd.jpg" alt="img"></p>
<p>作为前端，应用层肯定是最熟悉的。它的作用是为应用程序提供服务并规定应用程序中通讯相关的细节，也就是为应用提供服务。常见的协议有 <code>HTTP</code>，<code>FTP</code>，<code>TELNET</code>、<code>SMTP</code> 等。</p>
<p>我们日常开发中，接触的协议主要以 <code>HTTP</code> 为主，那么把浏览器看作一个应用，当用户发起请求时，通过 <code>HTTP协议</code>获得数据以供浏览器使用，这就是应用层的用途。而请求时发生错误，对错误进行处理，也是应用层需要负责的</p>
<p> <strong>OSI7层模型的小结</strong><br>由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。<br>在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。<strong>简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。</strong></p>
<h2 id="二-、TCP-IP分层模型"><a href="#二-、TCP-IP分层模型" class="headerlink" title="二 、TCP/IP分层模型"></a><strong>二 、TCP/IP分层模型</strong></h2><p>​        ┌────——────┐┌─┬─┬─-┬─┬─-┬─┬─-┬─┬─-┬─┬─-┐<br>　　│　　　　　　　　││Ｄ│Ｆ│Ｗ│Ｆ│Ｈ│Ｇ│Ｔ│Ｉ│Ｓ│Ｕ│　│<br>　　│　　　　　　　　││Ｎ│Ｉ│Ｈ│Ｔ│Ｔ│Ｏ│Ｅ│Ｒ│Ｍ│Ｓ│其│<br>　　│第四层，应用层　││Ｓ│Ｎ│Ｏ│Ｐ│Ｔ│Ｐ│Ｌ│Ｃ│Ｔ│Ｅ│　│<br>　　│　　　　　　　　││　│Ｇ│Ｉ│　│Ｐ│Ｈ│Ｎ│　│Ｐ│Ｎ│　│<br>　　│　　　　　　　　││　│Ｅ│Ｓ│　│　│Ｅ│Ｅ│　│　│Ｅ│它│<br>　　│　　　　　　　　││　│Ｒ│　│　│　│Ｒ│Ｔ│　│　│Ｔ│　│<br>　　└───────——─┘└─┴─┴─-┴─┴─-┴─┴─-┴─┴─-┴─┴-─┘<br>　　┌───────—–─┐┌─────────——-┬──——–─────────┐<br>　　│第三层，传输层　││　　　ＴＣＰ　　　│　　　　ＵＤＰ　　　　│<br>　　└───────—–─┘└────────——-─┴──────────——–─┘<br>　　┌───────—–─┐┌───—-──┬───—─┬────────——-──┐<br>　　│　　　　　　　　││　　　　　│ＩＣＭＰ│　　　　　　　　　　│<br>　　│第二层，网间层　││　　　　　└──—──┘　　　　　　　　　　│<br>　　│　　　　　　　　││　　　　　　　ＩＰ　　　　　　　　　　　 │<br>　　└────────—–┘└────────────────────————-─-┘<br>　　┌────────—–┐┌─────────——-┬──────——–─────┐<br>　　│第一层，网络接口││ＡＲＰ／ＲＡＲＰ　│　　　　其它　　　　　│<br>　　└────────——┘└─────────——┴─────——–──────┘<br>　　　　　　 TCP/IP四层参考模型</p>
<p>　　包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。<strong>TCP/IP协议簇</strong>是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。</p>
<p>​          TCP/IP协议被组织成四个概念层<strong>，其中有三层对应于ISO参考模型中的相应层</strong>。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。<br>　　TCP/IP分层模型的四个协议层分别完成以下的功能：</p>
<h4 id="第一层-网络接口层"><a href="#第一层-网络接口层" class="headerlink" title="第一层:网络接口层"></a>第一层:网络接口层</h4><p>　　包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。</p>
<p>​       网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，</p>
<p>　　然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。<br>　　实际上TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。</p>
<h4 id="第二层-网间层"><a href="#第二层-网间层" class="headerlink" title="第二层:网间层"></a>第二层:网间层</h4><p>　　对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。</p>
<p>网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。　　<br>　　网络互连层定义了分组格式和协议，即IP协议（Internet Protocol）。　　<br>　　网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。</p>
<h4 id="第三层-传输层"><a href="#第三层-传输层" class="headerlink" title="第三层:传输层"></a>第三层:传输层</h4><p>　　对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。</p>
<p>​        在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。　　<br>　　TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。</p>
<p>　　在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。　　<br>　　UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。</p>
<h4 id="第四层-应用层"><a href="#第四层-应用层" class="headerlink" title="第四层:应用层"></a>第四层:应用层</h4><p>TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。　　<br>　　应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于TCP协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本链接协议（Hyper Text Transfer Protocol，HTTP），也有基于UDP协议的。</p>
<p><img src="https://img-my.csdn.net/uploads/201302/25/1361801670_1367.png" alt="è¿éåå¾çæè¿°"></p>
<h2 id="三、-数据的封装与分用"><a href="#三、-数据的封装与分用" class="headerlink" title="三、 数据的封装与分用"></a>三、 数据的封装与分用</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><img src="https://img-my.csdn.net/uploads/201302/25/1361802159_1221.png" alt="è¿éåå¾çæè¿°"></p>
<p><strong>当应用程序用TCP传送数据时</strong>，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。</p>
<p>TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP segment）；UDP数据与TCP数据基本一致。唯一的不同是UDP传给IP的信息单元称作U D P数据报（UDP datagram），而且UDP的首部长为8字节。IP传给网络接口层的数据单元称作IP数据报(IP datagram)。<strong>通过以太网传输的比特流称作帧(Frame )</strong>。</p>
<h4 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h4><p><img src="https://img-my.csdn.net/uploads/201302/25/1361802639_2204.png" alt="è¿éåå¾çæè¿°"></p>
<p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。<strong>协议是通过目的端口号、源I P地址和源端口号进行解包的。</strong></p>
<h2 id="四、TCP-IP协议简述"><a href="#四、TCP-IP协议简述" class="headerlink" title="四、TCP/IP协议简述"></a>四、TCP/IP协议简述</h2><h4 id="1、什么是TCP-IP"><a href="#1、什么是TCP-IP" class="headerlink" title="1、什么是TCP/IP"></a><strong>1、什么是TCP/IP</strong></h4><p>如果要了解一个人，可以从他归属的集体聊起来。我们的HTTP协议就属于TCP/IP协议家族中的一员，了解HTTP协议再整个网络流程中的地位，也能更加充分的理解HTTP协议。</p>
<p>​      要想了解什么是TCP/IP协议，就要知道为什么有这个协议。中国人和中国人说话，要遵循汉语的的语法结构，使用汉语的发音。当我们和外国人交流时，就要适用外国的语言了，遵循外国的语法机构和发音。其实这就是一种协议，只不过我们称之为语言。计算机再这方面体现的更为直观，两台机器之间该如何通信呢，就需要制定各种各样的协议了。例如：文件传输适用TCP协议。域名系统适用DNS协议。有了些协议的存在，各种数据流按照规则传输，计算机之间得意通信。</p>
<p>​       TCP/IP协议是一个协议集合。大家叫的时候方便说，所以统称为TCP/IP。TCP/IP协议族中有一个重要的概念是分层，TCP/IP协议按照层次分为以下四层。<strong>应用层、传输层、网络层、数据链路层</strong>。为什么要分层？这就如同邓小平1978年的大包干，责任到人。一个层只负责一个层次的问题，如果出问题了，和其他的层次无关，只要维护这个层次也就好了。其实编程语言里也能体现这个分层理论，即封转性、隔离。这里不再延伸细谈。下面我是制作的一个简图。</p>
<p>下面是从网络上找到的TCP/IP通信数据流</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201223112616-1937529463.jpg" alt="img"></p>
<h4 id="2、HTTP-关系密切的协议-IP、TCP-和-DNS"><a href="#2、HTTP-关系密切的协议-IP、TCP-和-DNS" class="headerlink" title="2、HTTP 关系密切的协议 : IP、TCP 和 DNS"></a><strong>2、HTTP 关系密切的协议 : IP、TCP 和 DNS</strong></h4><p>  <strong>IP协议：</strong>IP(Internet protocol),这里的IP不是值得我们通常所说的192.168.1.1.这个IP指的是一种协议，而后面的数字值得是IP地址。IP协议的作用在于把各种数据包准确无误的传递给对方，其中两个重要的条件是IP地址，和MAC地址（Media Access Control Address）。由于IP地址是稀有资源，不可能每个人都拥有一个IP地址，所以我们通常的IP地址是路由器给我们生成的IP地址，路由器里面会记录我们的MAC地址。而MAC地址是全球唯一的，除去人为因素外不可能重复。举一个现实生活中的例子，IP地址就如同是我们居住小区的地址，而MAC地址就是我们住的那栋楼那个房间那个人</p>
<p>==IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址==</p>
<p>你向另外一台电脑发送一条信息，怎么再茫茫人海中瞬间找到对方，以下是图示</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201231521929-1635094019.png" alt="img"></p>
<p><strong>TCP协议：</strong>如果说IP协议是找到对方的详细地址。那么TCP协议就是把安全的把东西带给对方。各有分工，互不冲突。</p>
<p>​         按层次分，TCP属于传输层，提供可靠的字节流服务。什么叫字节流服务呢？这个名字听起来让人不知所以然，下面听下我通俗的解释。所谓的<strong>字节流</strong>，其实就类似于信息切割。比如你是一个卖自行车的，你要去送货。安装好的自行车，太过庞大，又不稳定，容易损伤。不如直接把自行车拆开来，每个零件上都贴上收货人的姓名。最后送到后按照把属于同一个人的自行车再组装起来，这个拆解、运输、拼装的过程其实就是TCP字节流的过程。</p>
<p> <u>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</u></p>
<p> 为了确保信息能够确保准确无误的到达，TCP采用了著名的三次握手策略</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201234441944-1271451860.png" alt="img"></p>
<p><strong>DNS：</strong>DNS(Domain names System) 和HTTP协议一样是处于应用层的服务，提供域名到IP地址之间的解析服务。</p>
<p>互联网之间是通过IP地址通信的，但是IP地址并不符合认得记忆习惯，人喜欢记忆有意义的字词。所以DNS服务就为了解决这个问题而生了。其实很好理解，形如我们电脑中host文件。</p>
<p>192.168.1.11       roverliang.com  </p>
<p>当我们访问roverliang.com 的时候，电脑便不会去外网服务器上查询了，直接去访问192.168.1.111。这是一个简单的域名劫持，足以说明DNS的涵义了。</p>
<p>下面是我们访问一个网页，各种协议在里面起的作用。</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201235309225-1640442692.jpg" alt="img"></p>
<h4 id="3、正常的TCP的三次握手和四次挥手过程"><a href="#3、正常的TCP的三次握手和四次挥手过程" class="headerlink" title="3、正常的TCP的三次握手和四次挥手过程"></a>3、正常的TCP的三次握手和四次挥手过程</h4><p>通过上一篇中网络模型中的IP层的介绍，我们知道网络层，可以实现两个主机之间的通信。但是这并不具体，因为，真正进行通信的实体是在主机中的进程，<strong>是一个主机中的一个进程与另外一个主机中的一个进程在交换数据</strong>。IP协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程<strong>。而端到端的通信才应该是应用进程之间的通信。</strong></p>
<p>UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p>
<p>TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p>
<p><strong>常用的熟知端口号</strong></p>
<p><img src="/bolgzxy.github.io/.com//C:%5CUsers%5CCCTVZYX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567738933945.png" alt="1567738933945"></p>
<p><strong>TCP的概述</strong></p>
<p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</p>
<p><strong>TCP报文首部</strong></p>
<p><strong>1 源端口和目的端口</strong>，各占2个字节，分别写入源端口和目的端口；<br><strong>2 序号</strong>，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；<br><strong>3 确认号</strong>，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；<br><strong>4 数据偏移</strong>，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；<br><strong>5 保留</strong>，占6位，保留今后使用，但目前应都位0；<br><strong>6 紧急URG</strong>，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；<br><strong>7 确认ACK</strong>，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；<br><strong>8 推送PSH</strong>，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；<br><strong>9 复位RST</strong>，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；<br><strong>10 同步SYN</strong>，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；<br><strong>11 终止FIN</strong>，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；<br><strong>12 窗口</strong>，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；<br><strong>13 检验和</strong>，占2字节，校验首部和数据这两部分；<br><strong>14 紧急指针</strong>，占2字节，指出本报文段中的紧急数据的字节数；<br><strong>15 选项</strong>，长度可变，定义一些其他的可选的参数。</p>
<h5 id="TCP连接的建立（三次握手）"><a href="#TCP连接的建立（三次握手）" class="headerlink" title="TCP连接的建立（三次握手）"></a><strong>TCP连接的建立（三次握手）</strong></h5><p><img src="https://img-blog.csdn.net/20170607205709367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
<p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p>
<p>1 <strong>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</strong></p>
<p>2 <strong>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong></p>
<p>3 <strong>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</strong></p>
<p>4 <strong>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong></p>
<p>5 <strong>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</strong></p>
<p><img src="https://img-blog.csdn.net/20170605110405666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ä¸æ¬¡æ¡æ"></p>
<h5 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h5><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h5 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h5><p>1  <strong>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong></p>
<p>2  <strong>服务器收到连接释放报文，发出确认报文，<span style="color:red">ACK=1，ack=u+1，并且带上自己的序列号seq=v，</span>此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，<span style="color:red">即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。</span>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</strong></p>
<p>3  <strong>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</strong></p>
<p>4  <strong>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<span style="color:red">FIN=1，ack=u+1，</span>由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的<span style="color:red">序列号为seq=w，</span>此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</strong></p>
<p>5  <strong>客户端收到服务器的连接释放报文后，必须发出确认，<span style="color:red">ACK=1，ack=w+1，而自己的序列号是seq=u+1，</span>此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</strong></p>
<p>6  <strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</strong></p>
<p><img src="https://img-blog.csdn.net/20170606084851272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="åæ¬¡æ¥æ"></p>
<h5 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h5><p> MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h5 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h5><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<h5 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h5><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/09/01/剑指Offer题目解释和对应代码的手写/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/09/01/剑指Offer题目解释和对应代码的手写/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T14:45:16+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>剑指Offer题目知识点（二刷）{1—–33题}</p>
<h3 id="1、赋值运算符"><a href="#1、赋值运算符" class="headerlink" title="1、赋值运算符"></a>1、赋值运算符</h3><blockquote>
<p>题目：为下面的类添加一个赋值运算符</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       CMyString(<span class="keyword">char</span>*Pdata=<span class="literal">nullptr</span>);</span><br><span class="line">       CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">       ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">char</span>* m_pData;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意的地方</strong></p>
<p>1 返回值的类型声明是不是该类型的引用，并在最后返回实例的*this，只有返回一个应用才能连续赋值。</p>
<p>2传入的参数的类型是不是 常量的引用 如果是按值传递会增加额外的开销 </p>
<p>3 释放自身已有的内存，否则会出现程序崩溃的情况</p>
<p>4 判断传入的是不是同一个实例 即是自己给自己赋值 这样子会出错</p>
<p><strong>常规解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMyString &amp;CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[]m_pData;</span><br><span class="line">    m_pData=<span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    m_pData=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData)+<span class="number">1</span>];</span><br><span class="line">    strcopy(m_pData,str.m_pData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 但是上面的代码在安全性上面会有一定的问题，在new新内存的时候假如没有足够的内存，m_pData会是一个空指针，程序会出现问题。</p>
<p><strong>考虑安全性的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       CMyString(<span class="keyword">char</span>*Pdata=<span class="literal">nullptr</span>);</span><br><span class="line">       CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">       ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">       CMyString&amp;CMyString::<span class="keyword">operator</span>(<span class="keyword">const</span> CMyString&amp;str);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">char</span>* m_pData;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> CMyString&amp;CMyString::<span class="keyword">operator</span>(<span class="keyword">const</span> CMyString&amp;str)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(*<span class="keyword">this</span>!=&amp;str)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="function">CMyString <span class="title">strTemp</span><span class="params">(str)</span></span>;<span class="comment">//内存不足的情况会出现在这里，但是这里你没有更改原来的实例。</span></span><br><span class="line">         </span><br><span class="line">         <span class="keyword">char</span> *pTemp=strTemp.m_pData;</span><br><span class="line">         strTemp.m_pData=m_pData;</span><br><span class="line">         m_pData=pTemp;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、数组中的重复数字"><a href="#2、数组中的重复数字" class="headerlink" title="2、数组中的重复数字"></a>2、数组中的重复数字</h3><blockquote>
<p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<p>解决的办法：</p>
<p>1 直接将整个数组排序，然后重头到尾扫描数组，此时的时间复杂度为<code>O（nlogn）</code> </p>
<p>2 用哈希表解决这个问题</p>
<p>3 在原来数组重排这个数组，第三种方法，把每个数字放回对应位置的方法。如果出现一个数字无法放回（所在位置已经是对应数字了），那么说明该数字重复。</p>
<p><strong>哈希解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *resu = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">    duplicate(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>), resu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *resu &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *hashTable = <span class="keyword">new</span> <span class="keyword">int</span>[length]();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashTable[numbers[i]]) &#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hashTable[numbers[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交换元素的解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *item1, <span class="keyword">int</span> *item2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *resu = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">    duplicate(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>), resu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *resu &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == i) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numbers[numbers[i]] != numbers[i]) &#123;</span><br><span class="line">            swap(&amp;numbers[numbers[i]], &amp;numbers[i]);<span class="comment">//外部写一个交换的函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            *duplication = numbers[i];<span class="comment">//numbers[numbers[i]] != numbers[i] 这一句检查是否                                         有重复的数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *item1, <span class="keyword">int</span> *item2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *item1;</span><br><span class="line">    *item1 = *item2;</span><br><span class="line">    *item2 = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1扩展的问题"><a href="#2-1扩展的问题" class="headerlink" title="2.1扩展的问题"></a>2.1扩展的问题</h4><blockquote>
<p>不修改数组找出重复的数字</p>
<p>在一个长度为n+1的数组里的所有数字都在1~n范围内。所以数组中至少有一个数是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，输入长度为8的数组{2，3，5，4，3，2，6，7}，那么对应的输出是重复的数字2或者3。</p>
</blockquote>
<p>1.这个题目可以依照题目一的思路来，不过由于不能修改输入数组，所以可以构建一个n+1大小的辅助数组，构建了辅助数组之后可以<strong>使用hash</strong>表也，可以<strong>使用换位置</strong>的思路来做 。<br>2.使用二分的思想来做，二分基数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *numbers, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>, end = length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> lowCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);<span class="comment">//中间的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &lt;= mid &amp;&amp; numbers[i] &gt;= start) &#123;</span><br><span class="line">                lowCnt++;</span><br><span class="line">                         &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">        <span class="keyword">if</span> (lowCnt &gt; (mid - start + <span class="number">1</span>)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">                                     &#125;</span><br><span class="line">        <span class="keyword">else</span>  &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3，二维数组中的查找"><a href="#3，二维数组中的查找" class="headerlink" title="3，二维数组中的查找"></a>3，二维数组中的查找</h3><blockquote>
<p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下的递增的顺序排序，请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。。</p>
</blockquote>
<p>1.目标数为T，从二维数组的最右上角开始查找，如果T比该数字小，说明T比该数字所在列都小，故剔除列，如果  T比该数字大，说明T比该数字所在行都大，故剔除行，直到最后找到为止。<br>2.也可以从最左下角开始，但是不能从另外两个角开始。(为什么？)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows=<span class="built_in">array</span>.size();</span><br><span class="line">    <span class="keyword">int</span> clos=<span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(rows==<span class="number">0</span>||clos==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=clos<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i!=rows&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]==target)/ </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]&gt;target)&#123;</span><br><span class="line">        j--;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i++;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不能从另外两个角开始，因为假如第一个数字是1，但是目标是7，此时7可能会在这一行的右边，也可能在这一行的下面，所以我们没有办法确定怎么进行下一步。</p>
<h3 id="4、替换空格"><a href="#4、替换空格" class="headerlink" title="4、替换空格"></a>4、替换空格</h3><blockquote>
<p>题目：请实现一个函数，把字符串中的每个空格替换成“%20”，例如，输入”We are happy.”,则输出”We%20are%20happy.”</p>
</blockquote>
<p>一般像这种需要向后扩充容量重新整理内存的，最好能够考虑到从尾部开始整理的方法<br>1.指针都可以当作数组使用，但是指针本身不检查是否超出数组范围。<br>2.对字符串的处理都应该考虑最后的空字符’\0’。<br>3.应该一个一个的处理字符串中的字符，不要向一蹴而就。<br>4<strong>.扩充字符串可以考虑从尾部开始</strong>。<br>5.应该警惕内存覆盖，如果改变字符串会导致字符串变长，那应该考虑内存的问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span>*str,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//先计算出整个字符串里面空格的数量</span></span><br><span class="line">   <span class="keyword">int</span> numsofspace=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> originallength=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span> * str1=str;<span class="comment">//复制一份原来的字符串</span></span><br><span class="line">    <span class="keyword">while</span>(*str1!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*str1=='')</span><br><span class="line">            numsofspace++;</span><br><span class="line">        str1++;</span><br><span class="line">        originallength++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//替换成%20整个字符串长度的变化</span></span><br><span class="line">    <span class="keyword">int</span> newlength=originallength+<span class="number">2</span>*numsofspace;</span><br><span class="line">    <span class="keyword">if</span>(newlength&gt;length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//下面开始直接替换字符串</span></span><br><span class="line">    <span class="keyword">int</span> indexoriginal=originallength;</span><br><span class="line">    <span class="keyword">int</span> indexnewlength=newlength;</span><br><span class="line">   <span class="comment">//下面是第一个版本用while循环写</span></span><br><span class="line">    <span class="keyword">while</span>(indexoriginal&gt;<span class="number">0</span>&amp;&amp;indexnewlength&gt;indexoriginal）<span class="comment">//这里的条件是 原来的 指针应该大于                                                    0，新的指针应该一直大于等于旧的指针</span></span><br><span class="line">          &#123;</span><br><span class="line">              if(str[indexoriginal]=='')</span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'0'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'2'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'%'</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=str[indexoriginal--];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    <span class="comment">//下面是第二个版本是用for循环写的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=indexoriginal<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              if(str[i]!='')</span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=str[i];</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'0'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'2'</span>;</span><br><span class="line">                  str[indexnewlength--]=<span class="string">'%'</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、从尾到头打印链表"><a href="#5、从尾到头打印链表" class="headerlink" title="5、从尾到头打印链表"></a>5、从尾到头打印链表</h3><blockquote>
<p>题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">       ListNode(<span class="keyword">int</span> x) :</span><br><span class="line">              val(x), next(<span class="literal">NULL</span>) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.注意传入函数的是指向链表头的指针，在函数中不应该直接使用这个指针，而是应该用一个指针的临时变量来遍历链表。<br>2.方法一：使用栈来实现（用栈更好）。<br>3.方法二：递归在本质上就是一个栈结构，所以也可以用递归来实现。</p>
<p><strong>用栈实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//先定义一个结构体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;printstack(ListNode*head)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">  <span class="built_in">stack</span>&lt;ListNode*&gt;Node;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      Node.push(head);</span><br><span class="line">      <span class="comment">//还有一种写法，直接在栈里面保存的是节点的值</span></span><br><span class="line">      head=head-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">while</span>(Node!=empty())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> nodeval=Node.top();</span><br><span class="line">      Node.pop();</span><br><span class="line">      result.push_back(nodeval);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用递归实现,但是实际上时间比上面的堆栈更加长</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;printstack(ListNode*head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">//下面开始递归的写法</span></span><br><span class="line">    result=printstack(head-&gt;next);</span><br><span class="line">    result.pusn_back(head-val);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、重建二叉树"><a href="#6、重建二叉树" class="headerlink" title="6、重建二叉树"></a>6、重建二叉树</h3><blockquote>
<p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树（假设没有重复数字）。树节点定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.前序遍历的第一个数字总是树的根节点的值。但在中序遍历中，根节点的值在序列的中间，其中左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。要扫描中序遍历序列，才能找到根节点的值。<br>2.又因为前序遍历总是在根节点后先遍历完左子树，才会遍历右子树，所以由后续遍历推断出左子树中节点的数目之后，前序遍历中根节点之后的相同数目的值都是左子树的节点的值。剩下的就是右子树的值。这样就分别找到了左右子树序列。<br>3.<strong>分别确定了根节点和左右子树的前序、中序遍历，我们可以用同样的方法构建左右子树，剩下的可以用递归来完成。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//数学公式的头文件吧</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode*<span class="title">rebulidTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;prologue,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Mediumorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(prologue.size()==<span class="number">0</span>||Mediumorder.size()!=prologue.size())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//应该新建立一个二叉树</span></span><br><span class="line">    TreeNode* newtree=<span class="keyword">new</span> TreeNode(prologue[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(prologue.size()==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> newtree;</span><br><span class="line">    <span class="comment">//检查错误吧这里是</span></span><br><span class="line">    <span class="keyword">auto</span> position=find(Mediumorder.begin(),Mediumorder.end(),prologue[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(position==Mediumorder.end())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSize = position - Mediumorder.begin();</span><br><span class="line">    <span class="keyword">int</span> rightSize = Mediumorder.end() - position - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  newtree-&gt;left=rebulidTree<span class="comment">//向左边递归求解</span></span><br><span class="line">  (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(prologue.begin()+<span class="number">1</span>,prologue.begin()+<span class="number">1</span>+leftSize),</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(Mediumorder.begin(),Mediumorder.begin()+leftSize));</span><br><span class="line">  </span><br><span class="line">  newtree-&gt;right=rebulidTree<span class="comment">//向右边递归求解</span></span><br><span class="line">  (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(prologue.begin()+<span class="number">1</span>+leftSize,prologue.end()),</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(Mediumorder.begin()+leftSize,Mediumorder.end()));、</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">return</span> newtree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是另外的一个解法</span></span><br></pre></td></tr></table></figure>

<h3 id="7、二叉树的下一个节点"><a href="#7、二叉树的下一个节点" class="headerlink" title="7、二叉树的下一个节点"></a>7、二叉树的下一个节点</h3><blockquote>
<p>给定一颗二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了指向左右子树的指针，还有一个指向父节点的指针。树节点定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">next</span>;</span><span class="comment">//还有一个指向父节点的指针</span></span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.如果该节点有右子树，则它的下一个节点就是其右子树的最左子节点。<br>2.如果该节点没有右子树，但是它本身是其父节点的左子节点，那么它的下一个节点就是其父节点。<br>3.如果该节点没有右子树，并且是其父节点的右子节点，那么它的下一个节点就需要向上不断找父节点，直到找到一个节点是其父节点的左子节点，那么该节点的父节点就要我们要找的下一个节点。<br>4.如果上面的方法都没有找到下一个节点，说明该节点不存在下一个节点，返回nullptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeLinkNode*<span class="title">getNextNode</span><span class="params">(TreeLinkNode*pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeLinkNode*nextNode=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//如果存在右子树</span></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       TreeLinkNode* temporary=pNode-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(temporary-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temporary=temporary-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">       nextNode=temporary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不存在右子树的时候</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       TreeLinkNode* temporary=pNode; </span><br><span class="line">     <span class="comment">//这里是如果该节点没有右子树，但是它本身是其父节点的左子节点，那么它的下一个节点就是其父节点</span></span><br><span class="line">        <span class="keyword">if</span>(temporary==temporary-&gt;next-&gt;left)</span><br><span class="line">            nextNode=temporary-&gt;next;</span><br><span class="line">     <span class="comment">//这里是第三种情况，需要一直上溯到一个节点是其父节点的左子节点，那么该节点的父节点就要我们要找的下一个节点。</span></span><br><span class="line">        <span class="keyword">while</span>(temporary-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temporary==temporary-&gt;next-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                nextNode=temporary-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temporary=temporary-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、用两个栈实现队列"><a href="#8、用两个栈实现队列" class="headerlink" title="8、用两个栈实现队列"></a>8、用两个栈实现队列</h3><blockquote>
<p>题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个成员函数，分别完成在队列尾部插入节点和在队列的头部删除节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>固定一个栈用于入队操作，另一个栈用于出队操作：<br>1.入队列操作，不管stack1和stack2是什么状态，直接向stack1入栈即可。<br>2.出队列操作，如果stack2为空，那么把stack1的元素一个一个弹出并压入到stack2中，完成之后，对stack2进行出栈操作，此元素就是最先入队的元素。<br>3.出队列操作，如果stack2不为空，那么直接从stack2出栈，此元素是当前所有元素中最先入队的那个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> solution::push(<span class="keyword">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> solution::pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2!=empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temporary=stack1.top();</span><br><span class="line">        stack1.pop();</span><br><span class="line">        <span class="keyword">return</span> temporary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1!=empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temporary=stack1.top();</span><br><span class="line">            stack2.push(temporary);</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temporary=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> temporary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1两个队列实现一个栈"><a href="#8-1两个队列实现一个栈" class="headerlink" title="8.1两个队列实现一个栈"></a>8.1两个队列实现一个栈</h4><p>两个栈实现一个队列：使用栈1来入队，栈2来出队，角色是固定了的<br><strong>两个队列实现一个栈：使用非空队列来入栈，使用空队列来出栈，角色会转换：</strong><br>1.入栈操作：哪个队列非空，就把元素插入哪个队列的队尾，如果两个队列都为空，那么就随便使用一个队列。<br>2.出栈操作：把非空队列的元素出队并且按顺序一个一个压入另一个队列，直到剩下一个元素，这个元素就是要出栈的元素。输出该元素即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; deueu1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; deueu2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9、斐波那契数列"><a href="#9、斐波那契数列" class="headerlink" title="9、斐波那契数列"></a>9、斐波那契数列</h3><blockquote>
<p>求斐波那契数列的第n项。斐波那契数列的定义如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">f(n) = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>); n &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>1.使用递归的方法是最简单的，但是效率成问题，有很多重复的计算。其实就是一种自顶向下的思想。 但是可以考虑用尾递归，会减少很多不必要的计算。</p>
<p>2.也可以考虑使用循环做，这样的也可以减少很多不必要的计算。</p>
<p>3.使用自底向上的思想，从n=2开始计算，并且每次保存前面两次计算的结果，以此进行下一次计算，这样就不会有重复的计算。复杂度为O(n)。<br>4.注意一旦n过大，就会超出long long的范围变成一个大数问题。</p>
<p><strong>循环的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre=<span class="number">0</span>,pre1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result=pre+per1;</span><br><span class="line">        pre=pre1;</span><br><span class="line">        pre2=result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归的解法  时间复杂度最高的一种解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>尾递归的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> pre=<span class="number">0</span>,pre1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> FibonacciTailRecursive(n,pre,pre1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> FibonacciTailRecursive(<span class="keyword">int</span> n,<span class="keyword">int</span> ret1,<span class="keyword">int</span> ret2)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> ret1;</span><br><span class="line">     <span class="keyword">return</span> FibonacciTailRecursive(n<span class="number">-1</span>,ret2,ret1+ret2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、旋转数组的最小数字"><a href="#10、旋转数组的最小数字" class="headerlink" title="10、旋转数组的最小数字"></a>10、旋转数组的最小数字</h3><blockquote>
<p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p>
<p>比如{3，4，5，1,2}和{1,2,3,4,5}</p>
</blockquote>
<p>1.旋转之后的数组实际上可以划分为两个排序的子数组，前面子数组的元素都大于或者等于后面子数组的元素，最小的元素恰好是两个子数组的分界线 </p>
<p>2.找中位数 mid mid，如果中位数大于数组首元素 start start，说明该中位数位于前半段数组，如果该中位数小于数组尾元素 end end，说明该中位数位于后半段数组。</p>
<p>3.不管移动 start start还是 end end的位置，都把它移动到 mid mid上面，保证 start start一直在前半段数组， end end一直在后半段数组 </p>
<p>4.end end的最后值就是最小元素的位置，而终结条件是 start start和 end end的距离为1 </p>
<p>5.旋转零个元素也是一个旋转数组，应该考虑到，即 data[start]&lt;data[end] data[start]&lt;data[end]的情况，这个时候最小元素直接就是第一个元素 </p>
<p>6.考虑到首元素等于尾元素等于中间元素的情况，这种情况下无法判断中间元素属于哪个子数组，所以只能采用顺序查找法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNumberOfarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;rotateArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size=rotateArray.size();</span><br><span class="line">    <span class="keyword">if</span>(size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//整个数组本来就已经是排序好成升序的数组</span></span><br><span class="line">    <span class="keyword">if</span>(rotateArray[<span class="number">0</span>]&lt;rotateArray[size<span class="number">-1</span>]||size==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> befor=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> after=size<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(after-befor&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle=(befor+after)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果第一个元素等于最后一个元素 等于中间的一个元素 那就只能强制进行一一检查</span></span><br><span class="line">        <span class="keyword">if</span>(rotateArray[befor]==rotateArray[middle]==rotateArray[after])</span><br><span class="line">            <span class="keyword">return</span> sortArray(rotateArray);</span><br><span class="line">        <span class="comment">//如果中间的元素小于等于最后的那个元素 &#123;45123&#125; 1&lt;3</span></span><br><span class="line">        <span class="keyword">if</span>(rotateArray[middle]&lt;=rotateArray[after])</span><br><span class="line">            after=middle;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            befor=middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateArray[after];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;rotateArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;itreator::it;</span><br><span class="line">    <span class="keyword">int</span> temp=rotateArray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> it=rotateArray.begin()+<span class="number">1</span>;it!=rotateArray.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;*it)</span><br><span class="line">            temp=*it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11、矩阵中的路径"><a href="#11、矩阵中的路径" class="headerlink" title="11、矩阵中的路径"></a>11、矩阵中的路径</h3><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br>例如在下面的3*4矩阵 </p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">t</th>
<th align="center">g</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c</td>
<td align="center">f</td>
<td align="center">c</td>
<td align="center">s</td>
</tr>
<tr>
<td align="center">j</td>
<td align="center">d</td>
<td align="center">e</td>
<td align="center">h</td>
</tr>
</tbody></table>
<p>矩阵中包含一条字符串”bfce”的路径，但是矩阵中不包含”abfb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><strong>可以用回溯法来解决的典型问题。</strong></p>
<p>回溯法可以看成蛮力法的升级版，它从解决问题的每一步的所有可能选项里系统地选择一个可行的解决方案。回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。就这样重复选择，直到到达最终的状态。<br>用回溯法解决的问题的所有选项可以形象的用树状结构表示。在某一步有n个可能的选项，那么该步骤可以看做是树状结构中的一个节点，每个选项看成树中节点连接线，经过这些连接线到达该节点的n个子节点。树的叶子节点对应着终结状态。如果树的叶节点满足题目的约束条件，那么我们就找到了一个可行的解决方案。<br>如果叶节点的状态不满足约束条件，那么只好回溯到它的上一个节点再尝试其他的选项。如果上一个节点的所有可能选项都已经试过了，并且不能到达满足约束条件的终结状态。则再次回溯到上一个节点。</p>
<p><span style="color:red">首先在矩阵中任意选取一个格子作为起点。假设矩阵中某个格子的字符为ch，并且这个格子对应于路径上的第i个字符。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径的第i个位置上。如果路径的第i个字符恰好是ch，那么到相邻的格子上寻找第i+1个字符。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。由于回溯法的递归特性，路径可以被看做一个栈。</span></p>
<p><strong>1.应该有一个布尔值矩阵来记录矩阵的哪些格子已经被使用过了</strong><br><strong>2.使用递归的方式求解。在使用递归的时候应该注意，在退出递归的时候需要根据需求对计数或者标志进行回退或者清除等操作。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;                </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;                 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>*matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">char</span>*str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断初始条件</span></span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="literal">nullptr</span>||rows&lt;=<span class="number">0</span>||clos&lt;=<span class="number">0</span>||str==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">//建立一个数组访问的visit</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;visit(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(clos,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;<span class="comment">//这个长度应该是整个str判断值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=clos;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasPath(matrix,rows,clos,i,j,str,length,visit))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> length,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;visit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[length]==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> isinpath=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=rows&amp;&amp;j&lt;=clos&amp;&amp;i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>&amp;&amp;matrix(i*clos+j)==str[length]&amp;&amp;!visit[i][j])</span><br><span class="line">    &#123;</span><br><span class="line">        length++;</span><br><span class="line">        visit[i][j]=<span class="literal">true</span>;</span><br><span class="line">        isinpath=hasPath(matrix,rows,clos,i<span class="number">-1</span>,j,str,length,visit)||</span><br><span class="line">                 hasPath(matrix,rows,clos,i+<span class="number">1</span>,j,str,length,visit)||</span><br><span class="line">                 hasPath(matrix,rows,clos,i,j<span class="number">-1</span>,str,length,visit)||</span><br><span class="line">                 hasPath(matrix,rows,clos,i,j+<span class="number">1</span>,str,length,visit);</span><br><span class="line">        <span class="comment">//这里就是回溯的哪一步 </span></span><br><span class="line">        <span class="keyword">if</span>(!isinpath)</span><br><span class="line">        &#123;</span><br><span class="line">            length--;</span><br><span class="line">            visit[i][j]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12、机器人的运动范围"><a href="#12、机器人的运动范围" class="headerlink" title="12、机器人的运动范围"></a>12、机器人的运动范围</h3><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p><strong>1.使用递归</strong><br><strong>2.仍然使用布尔值矩阵记录是否进入过</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoveConut</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;threshould,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span>||threshould.size()&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rows=threshould.size();</span><br><span class="line">    <span class="keyword">int</span> clos=threshould[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;visit(rows,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(clos,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">int</span> count=movingconut(threshould,rows,clos,<span class="number">0</span>,<span class="number">0</span>,visit,k);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是整个代码的核心 判断机器人可不可以进入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingcount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;threshould,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">int</span> i,                                 <span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visit,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//检查这个i j 机器人可否进入</span></span><br><span class="line">    <span class="keyword">if</span>(checkinto(threshould,rows,clos,i,j,visit,k))</span><br><span class="line">    &#123;</span><br><span class="line">        count=<span class="number">1</span>+movingcount(threshould,rows,clos,i<span class="number">-1</span>,j,visit,k)||</span><br><span class="line">                movingcount(threshould,rows,clos,i,j<span class="number">-1</span>,visit,k)||</span><br><span class="line">                movingcount(threshould,rows,clos,i+<span class="number">1</span>,j,visit,k)||</span><br><span class="line">                movingcount(threshould,rows,clos,i,j+<span class="number">1</span>,visit,k)||</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkinto</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;threshould,<span class="keyword">int</span> rows,<span class="keyword">int</span> clos,<span class="keyword">int</span> i,                                 <span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visit,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>&amp;&amp;i&lt;=rows&amp;&amp;j&lt;=clos&amp;&amp;getcountofnumber(i,j)&lt;k&amp;&amp;!visit[i][j])</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcountofnumber</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=i%<span class="number">10</span>;</span><br><span class="line">        i/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">while</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=j%<span class="number">10</span>;</span><br><span class="line">        j/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13、剪绳子（动态规划）"><a href="#13、剪绳子（动态规划）" class="headerlink" title="13、剪绳子（动态规划）"></a>13、剪绳子<span style="color:red">（动态规划）</span></h3><p>给一段长度为n的绳子，把绳子剪成m段（m，n都是整数且n&gt;1,m&gt;1，即至少要剪一次），问每段绳子长度的乘积最大是多少？</p>
<p>1.使用动态规划求解：<br>2.确定子问题:例如绳子的长度为8，那么可以剪成1，7两段，那么此时又要求解长度为7的绳子怎么剪最好。依次类推。<br>3.确定转移方程，设方程f(i)f(i)表示长度为ii的绳子剪成mm段之后的最大的乘积。则<br>$$<br>f(i)=max(f(j)×f(i−j)),0&lt;j&lt;i<br>$$<br>4.为了避免重复计算子问题，我们采用自下而上、从小到大的方式来求解，把先求到的子问题的解储存起来，之后要用到的时候直接进行查表。<br>5.注意边界条件：虽然有f(0)=f(1)=0;f(2)=1;f(3)=2;f(0)=f(1)=0;f(2)=1;f(3)=2;但是在表中存下来却不是这个值，而应该是:p(0)=0;p(1)=1;p(2)=2;p(3)=3;p(0)=0;p(1)=1;p(2)=2;p(3)=3;即在起始条件的时候小问题的最优解并不是我们求解大问题时使用的那个值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Maxlength</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;=<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">3</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(i/<span class="number">2</span>);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=dp[j]*dp[i-j];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;temp)</span><br><span class="line">                max=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        dp.pusn_back(max);</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14、二进制中1的个数"><a href="#14、二进制中1的个数" class="headerlink" title="14、二进制中1的个数"></a>14、二进制中1的个数</h3><blockquote>
<p>请实现一个函数，输入是一个整数，输出该数二进制表示中1的个数。例如，把9表示成二进制是1001，有2位是1。因此，如果输入9，则该函数输出为2。</p>
</blockquote>
<p>1.不对数据进行移位，而是移位和数据进行与操作的1。因为移位数据可能会因为符号位而造成死循环<br>2.O(1)的解法。使用公式 </p>
<p>​                                                  n=(n-1)&amp;n</p>
<p>n减去1再和自身进行与操作（&amp;）可以消除一个1。例如10表示成二进制是1010，10减1等于9表示成二进制是1001，两者想与得到1000，和1010比起来正好消去了最低位的1。在把消除为0的过程中这种操作的次数即是1个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Numberfone</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; NumberOf1(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15、数值的整数次方"><a href="#15、数值的整数次方" class="headerlink" title="15、数值的整数次方"></a>15、数值的整数次方</h3><p>实现函数double Power(double base,int exponent),求base的exponent次方。不需要考虑大数问题</p>
<p><strong>1.这个题目看起来很简单，但其实考察的是考虑到边界问题和错误输入</strong><br><strong>2.应该分别分析底数和指数大于0、等于0、小于0的情况</strong></p>
<blockquote>
<p>两种最特殊的情况：<br>1.当底数为0而指数为负数的时候，是错误输入。<br>2.当指数为负数的时候，需要求倒数。</p>
</blockquote>
<p><strong>常规解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断底数是否为0 但是这里的底数是一个double类型的输入 所以不能直接用==判断 需要用其他的技巧</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isZero</span><span class="params">(<span class="keyword">double</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-0.0</span>&lt;<span class="number">0.000000001</span>&amp;&amp;n<span class="number">-0.0</span>&gt;<span class="number">0.000000001</span>)<span class="comment">//小数点后面9位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isZero(base)&amp;&amp;exponent&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//指数小于0的情况是什么养子的</span></span><br><span class="line">    <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        base=<span class="number">1.</span>/base;</span><br><span class="line">        exponen=-exponent;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里是直接相乘的情况</span></span><br><span class="line">    <span class="keyword">while</span>(exponent)</span><br><span class="line">    &#123;</span><br><span class="line">        result*=base;</span><br><span class="line">        exponent--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更加高效的解法</strong></p>
<p><strong>更高效率的方法，即乘法的次数为指数的次数的一半即可，exponent/2</strong> </p>
<p><strong>例如求a的n次方，当n为偶数的时候，</strong><br>$$<br>an=an/2×an/2<br>$$<br><strong>当n为奇数的时候，</strong><br>$$<br>an=a(n−1)/2×a(n−1)/2×a<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;              </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isZero</span><span class="params">(<span class="keyword">double</span> base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((base - <span class="number">0.0</span> &lt; <span class="number">0.000000001</span>) &amp;&amp; (<span class="number">0.0</span> - base &lt; <span class="number">0.000000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isZero(base) &amp;&amp; exponent &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        base = <span class="number">1.</span>/base;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> resu = recursivePower(base,exponent);</span><br><span class="line">    <span class="keyword">return</span> resu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">recursivePower</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>)<span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">double</span> temp=recursivePower(base,exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">double</span> result=temp*temp;</span><br><span class="line">    <span class="keyword">if</span>(exponent&amp;<span class="number">0x01</span>)</span><br><span class="line">        result*=base;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16、打印从1到最大的n位数（有问题）"><a href="#16、打印从1到最大的n位数（有问题）" class="headerlink" title="16、打印从1到最大的n位数（有问题）"></a>16、打印从1到最大的n位数（有问题）</h3><p>输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999</p>
<p><strong>解法1</strong><br>例如输入数字3<br>可以当成排列如下数字：<br>000<br>001<br>002<br>…<br>997<br>998<br>999<br>即打印出数字的全排列。<br>所以可以递归求解</p>
<p><strong>常规解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrinttoMax</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span> * number=<span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number,<span class="string">'0'</span>,n);</span><br><span class="line">    number[n]='/0';</span><br><span class="line">    <span class="keyword">while</span>(!increament(number))</span><br><span class="line">    &#123;</span><br><span class="line">        print(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increament</span><span class="params">(<span class="keyword">char</span> *number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isOverflow=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> nTK=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nlenth=<span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nlength<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17、删除链表的节点"><a href="#17、删除链表的节点" class="headerlink" title="17、删除链表的节点"></a>17、删除链表的节点</h3><p>题目1 ：在O（1）时间内删除链表节点，单向链表，只给一个头结点和一个需要被删除的节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode**head,ListNode*pBedelete)</span></span>;</span><br></pre></td></tr></table></figure>

<p>1 如果按照正常的思路来说，需要遍历一次整个链表，那么这个时候时间复杂度会是O（n），达不到题目需要的要求。</p>
<p>2 我们可以吧需要删除节点的下一个节点的值赋值给当前需要删除的节点，然后需要把需要删除的节点指向下一个节点的下一个节点，最后删除下一个节点，效果等同与删除当前节点。</p>
<p>3 但是，如果需要删除的节点位于链表的最后位置，我们还是需要遍历整个链表。</p>
<p>4 如果删除的节点链表唯一的一个节点，那么我们还需要把整个链表置为nullptr.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode**head,ListNode*pBedelete)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//常规进行非空判断</span></span><br><span class="line">    <span class="keyword">if</span>(!head||!pBedelete)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//正常的删除，非为节点</span></span><br><span class="line">    <span class="keyword">if</span>(pBedelete-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode*pnext=pBedelete-&gt;next;</span><br><span class="line">        pBedelete-&gt;m_nValue=pnext-&gt;m_nValue;</span><br><span class="line">        pBedelete-&gt;next=pnext-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pnext;</span><br><span class="line">        pnext=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表只有一个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*head==pBedelete)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pBedelete;</span><br><span class="line">        pBedelete=<span class="literal">nullptr</span>;</span><br><span class="line">        *head=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       ListNode* pNode=*head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next!=pBedelete)</span><br><span class="line">            &#123;</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head-&gt;next=pBedelete-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> pBedelete;</span><br><span class="line">            pBedelete=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-1删除链表中重复的节点"><a href="#17-1删除链表中重复的节点" class="headerlink" title="17.1删除链表中重复的节点"></a>17.1删除链表中重复的节点</h4><p>在一个排序的链表中，如何删除重复的节点。</p>
<p>1.用tmpNode和current指向头结点，用一个flag标志遇到连续的重复值<br>2.current用来遍历整个链表，在遍历时，每当遇到一个新的值的节点，就用tmpNode指向整个节点<br>3.直到遇到下一个新的值前，current遍历链表，若有相同的值，flag置为false<br>4.遇到下一个新的值时，若flag为true，则tmpNode没有重复；若flag为false，则tmpNode重复了<br>5.遍历结束后还要在判断一次</p>
<p>例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br>1.tmpNode和current指向1<br>2.current遍历到2，flag为true，1则加入新的链表中，tmpNode指向2<br>3.current遍历到3，flag为true，2则加入新的链表中，tmpNode指向3<br>4.current遍历到第二个3，遇到重复值，flag置为false<br>5.current遍历到4，flag为false，3这个节点就不管了，flag重新置为true，tmpNode指向4<br>6.current遍历到第二个4，遇到重复值，flag置为false<br>7.current遍历到5，flag为false，4这个节点就不管了，flag重新置为true，tmpNode指向5<br>8.遍历结束，做最后一次判断，flag为true则将5加入新的链表中（若为false则把最后一个节点的next指向null</p>
<p>​      </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;              </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteDulplication</span><span class="params">(ListNode**phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*phead==<span class="literal">nullptr</span>||head==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ListNode* preNode=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pnextNode=*phead;</span><br><span class="line">    <span class="comment">//进入整个链表的循环</span></span><br><span class="line">    <span class="keyword">while</span>(pnextNode!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* Pnext=pnextNode-&gt;next;<span class="comment">//当前节点的下一个节点</span></span><br><span class="line">        <span class="keyword">bool</span> isDulication=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pnext!=<span class="literal">nullptr</span>&amp;&amp;pnext-&gt;m_nValue==pnextNode-&gt;m_nValue)<span class="comment">//接下来两个节点的值相等？</span></span><br><span class="line">        &#123;</span><br><span class="line">            isDulication=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果接下来的链表的节点不是相同的</span></span><br><span class="line">        <span class="keyword">if</span>(!isDulication)</span><br><span class="line">        &#123;</span><br><span class="line">            preNode=pnextNode;</span><br><span class="line">            pnextNode=pnextNode-&gt;next;<span class="comment">//指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果接下来链表节点是相同的</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> value=pnextNode-&gt;m_nValue;</span><br><span class="line">            ListNode* Bedelete=pnextNode;</span><br><span class="line">            <span class="keyword">while</span>(!Bedelete=<span class="literal">nullptr</span>&amp;&amp;Bedelete-&gt;m_nValue==value)</span><br><span class="line">            &#123;</span><br><span class="line">                Pnext=Bedelete-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> Bedelete;</span><br><span class="line">                Bedelete=<span class="literal">nullptr</span>;</span><br><span class="line">                Bedelete=Pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(preNode==<span class="literal">nullptr</span>)</span><br><span class="line">                *head=Pnext;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                preNode-&gt;next=Pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            pnextNode=Pnext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18、-正则表达式匹配"><a href="#18、-正则表达式匹配" class="headerlink" title="18、 正则表达式匹配"></a>18、 正则表达式匹配</h3><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符（指紧挨着的字符）可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>1、考虑特殊情况，当str和pattern都是空字符串时，匹配，返回true</p>
<p>​       当str不为空并且<em>pattern</em>为空时，一定不匹配，返回false（str为空，pattern不为空，有可能匹配）</p>
<p>2、考虑每次递归时的第二个字符是否是‘*’</p>
<p>​             当<em>（pattern+1）！=‘*’</em>‘’时，如果当前字符与模式字符相等(包括’.’），那么接着往下判断</p>
<p>​                                                            如果当前字符与模式字符不相等，直接不匹配，返回false</p>
<p>​             当<em>（pattern+1）==‘*’</em>‘’时，  如果当前字符与模式字符相等，那么考虑两种情况</p>
<p>​                                                             情况一：abc和模式ab*bc,当前字符匹配，模式的后面的字符还与其匹配</p>
<p>​                                                             情况二：abbc和模式ab*c，当前匹配，字符串的下一个字符还与其匹配</p>
<p>​                                                             如果当前字符与模式字符，字符串位置不变，模式后移两位，继续判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>*str,<span class="keyword">char</span>*pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(*str!=<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>)!=<span class="string">'*'</span>)<span class="comment">//如果下一个字符不是'*'</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str==*pattern||*str!=<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>,pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>)==<span class="string">'*'</span>)<span class="comment">//如果下一个是'*'</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str==*pattern||*str!=<span class="string">'\0'</span>&amp;&amp;*pattern==<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">return</span> match(str,pattern+<span class="number">2</span>)||match(str+<span class="number">1</span>, pattern);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> match(str,pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="20、表示数值的字符串"><a href="#20、表示数值的字符串" class="headerlink" title="20、表示数值的字符串"></a>20、表示数值的字符串</h3><h3 id="21、调整数组顺序使得奇数位于偶数前"><a href="#21、调整数组顺序使得奇数位于偶数前" class="headerlink" title="21、调整数组顺序使得奇数位于偶数前"></a>21、调整数组顺序使得奇数位于偶数前</h3><blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<p>  思路：</p>
<p>感觉这道题并没有比较完美的解法，要么时间复杂度高，要么空间复杂度高</p>
<ul>
<li><p>解法1：</p>
<p>遍历数组，将所有奇数前移，将所有偶数保存在队列里，并统计奇数个数</p>
<p>将队列里的偶数再放到数组中</p>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
</li>
<li><p>解法2：</p>
</li>
</ul>
<p>​        用i表示第一个偶数的下标，j表示i后面第一个奇数的下标（i，j初始化都为-1）</p>
<p>​        当找到符合的i,j时，将下标为[i,j)的值向后移一位（这个范围内都是偶数），</p>
<p>​       将原本下标为i的偶数替换为原本下标为j的奇数</p>
<p>​       最坏时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>*<em>使用解法1  *</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deueu&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven</span><span class="params">(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    deueu&lt;<span class="keyword">int</span>&gt;de;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pData[i]&amp;<span class="number">0x01</span>)==<span class="number">1</span>)</span><br><span class="line">            PData[index]=pData[i]</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             de.push_back(pData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index!=length&amp;&amp;!de.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pData[index++]=de.top();</span><br><span class="line">        de.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用解法2  维护两个指针 一前一后</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven</span><span class="params">(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> *begin=pData;</span><br><span class="line">    <span class="keyword">int</span> *end=pData+length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;(*begin&amp;<span class="number">0x1</span>)!=<span class="number">0</span>)</span><br><span class="line">            begin+;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;(*begin&amp;<span class="number">0x1</span>)==<span class="number">0</span>)</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=*end;</span><br><span class="line">            *begin=*end;</span><br><span class="line">            *end=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以扩展写法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reorder</span><span class="params">(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length,<span class="keyword">bool</span>(*fun)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(pData==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> *begin=pData;</span><br><span class="line">    <span class="keyword">int</span> *end=pData+length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;!func(*begin))</span><br><span class="line">            begin+;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end&amp;&amp;func(*end)</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=*end;</span><br><span class="line">            *begin=*end;</span><br><span class="line">            *end=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line"><span class="keyword">bool</span> isEven(<span class="keyword">int</span> n)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> (n&amp;<span class="number">1</span>)==<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">void</span> ReorderOddEven(<span class="keyword">int</span> *pData,<span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    Reorder(Pdata,length,isEven)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22、链表中的倒数第k个节点"><a href="#22、链表中的倒数第k个节点" class="headerlink" title="22、链表中的倒数第k个节点"></a>22、链表中的倒数第k个节点</h3><p>输入一个链表，输出该链表中倒数第k个节点。<br>为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。<br>例如，一个链表有6个节点，从头结点开始，它们的值以此是1、2、3、4、5、6。<br>这个链表的倒数第3个节点是值为4的节点。</p>
<p>方法1</p>
<p>定义两个节点node1，node2<br>让node1一开始指向第k个节点，node2指向第1个节点<br>此时node1和node2同时前进，[node1, node2]区间一共有k个节点<br>当node1指向最后一个节点时，node2即指向倒数第k个节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode * next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode*<span class="title">FindToNode</span><span class="params">(ListNode*phead,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||k&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* node1=phead;</span><br><span class="line">    ListNode* node2=phead;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node1=node1-&gt;next;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(node1==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node1!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node1=node1-&gt;next;</span><br><span class="line">        node2=node2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23、链表中环的入口节点（难点）"><a href="#23、链表中环的入口节点（难点）" class="headerlink" title="23、链表中环的入口节点（难点）"></a>23、链表中环的入口节点（难点）</h3><p>一个链表中包含环，请找出该链表的环的入口节点。</p>
<p>1.判断整个链表中有没有环的存在？</p>
<p>​    这里可以用一个快指针和一个满指针完成，如果到最后慢指针追上了快指针就表示有环的存在</p>
<p>2.怎么找到环的入口？</p>
<p>   这里还是用一个快指针和一个慢指针完成，假设这个环中有n个节点，让快指针前进n步，然后让慢指针往和快指针一起前进，一直到他们相遇，此时相遇的节点就是环的入口了。</p>
<p>3，怎么确定链表中有多少个环？</p>
<p>  假如在第一步中，快指针和慢指针相遇，那么肯定是在环里面相遇的，然后在让快慢指针一边向前走，一边计数，当指针回到原点，就可以得到环中的节点数了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">MeetNode</span><span class="params">(ListNode*phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==null)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode*slow=phead-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(slow==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     ListNode*Fast=slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span>&amp;&amp;Fast!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(slow==Fast)</span><br><span class="line">            <span class="keyword">return</span> Fast;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        Fast=slow-&gt;next;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode*<span class="title">EntryNodeOfLoop</span><span class="params">(ListNode*phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到相遇的节点</span></span><br><span class="line">    ListNode* meetNdoe=MeetNode(phead);</span><br><span class="line">    <span class="keyword">if</span>(meetNdoe==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">   <span class="comment">//找出环的个数</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    ListNode* tempNode=meetNdoe</span><br><span class="line">    <span class="keyword">while</span>(tempNode-&gt;next!=meetNdoe)</span><br><span class="line">    &#123;</span><br><span class="line">        tempNode=tempNode-&gt;next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找出了环的个数后 先移动快指针k步</span></span><br><span class="line">    ListNode*Fast=phead;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Fast=Fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">     ListNode*slow=phead;</span><br><span class="line">    <span class="comment">//快指针和慢指针一起向前移动</span></span><br><span class="line">    <span class="keyword">while</span>(slow!=Fast)</span><br><span class="line">    &#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        Fast=Fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24、反转链表"><a href="#24、反转链表" class="headerlink" title="24、反转链表"></a>24、反转链表</h3><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p>
<p>1.输入的链表头指针为null<br>2.输入的链表只有一个节点<br>3.输入的链表有多个节点（正常情况）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode*<span class="title">ReverseList</span><span class="params">(ListNode*phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(phead-&gt;next==null)</span><br><span class="line">        <span class="keyword">return</span> phead;</span><br><span class="line">    ListNdoe*Preversehead=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNdoe*pNode=phead;</span><br><span class="line">    ListNdoe*preNode=<span class="literal">nullptr</span>;</span><br><span class="line">   <span class="keyword">while</span>(pNode!=<span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       ListNode*Next=pNode-&gt;next;</span><br><span class="line">       <span class="keyword">if</span>(Next==<span class="literal">nullptr</span>)</span><br><span class="line">           Preversehead=pNode;</span><br><span class="line">       pNode-&gt;next=preNode;</span><br><span class="line">       preNode=pNode;</span><br><span class="line">       pNode=Next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用递归实现反转链表</p>
<h3 id="25、合并两个排序的链表"><a href="#25、合并两个排序的链表" class="headerlink" title="25、合并两个排序的链表"></a>25、合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。<br>例如：<br>链表1：1-&gt;3-&gt;5-&gt;7<br>链表2：2-&gt;4-&gt;6-&gt;8<br>合并后：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</p>
<p>很简单 注意边界问题就好了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode*next;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function">ListNode*<span class="title">Merge</span><span class="params">(ListNode* phead1,ListNode*phead2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(phead1==<span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span> phead2;</span><br><span class="line">     <span class="keyword">if</span>(phead2==<span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span> phead1;</span><br><span class="line">     ListNode*MergeHead=<span class="literal">nullptr</span>;</span><br><span class="line">     <span class="keyword">if</span>(phead1-&gt;val&lt;phead2-&gt;val)</span><br><span class="line">     &#123;</span><br><span class="line">         MergeHead=head1;</span><br><span class="line">         MergeHead-&gt;next=Merge(phead1-&gt;next,phead2);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         MergeHead=head2;</span><br><span class="line">         MergeHead-&gt;next=Merge(phead1,phead2-&gt;next);       </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> MergeHead;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>扩展 vector&lt;ListNode*&gt;vec;里面有n个链表，并且已经排好序，请将这里的链表完全排序</p>
<h3 id="26、树的子结构"><a href="#26、树的子结构" class="headerlink" title="26、树的子结构"></a>26、树的子结构</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。<br>（ps：我们约定空树不是任意一个树的子结构）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 直接递归的版本 */</span></span><br><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSubtree</span><span class="params">(BinaryTreeNode*root1,BinaryTreeNode*root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root1=<span class="literal">nullptr</span>&amp;&amp;!root2=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Equal(root1-&gt;val,root2-&gt;val))</span><br><span class="line">        &#123;</span><br><span class="line">            result=DoesSimTree(root1,root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">            result=hasSubtree(root1-&gt;left,root2);</span><br><span class="line">        <span class="keyword">if</span>(!resuklt)</span><br><span class="line">            result=hasSubtree(root1,root2-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Equal</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a-b&gt;<span class="number">0.00000001</span>)&amp;&amp;(a-b&lt;<span class="number">0.00000001</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DoesSimTree</span><span class="params">(BinaryTreeNode*root1,BinaryTreeNode*root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root1==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!Equal(root1-&gt;val,root2-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> DoesSimTree(root1-&gt;left,root2-&gt;left)&amp;&amp;DoesSimTree(root1-&gt;right,root2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27、二叉树的镜像"><a href="#27、二叉树的镜像" class="headerlink" title="27、二叉树的镜像"></a>27、二叉树的镜像</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>求一棵树的镜像的过程：先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当交换完所有的左右子节点之后，就得到了树的镜像。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BianryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BianryTreeNode* left;</span><br><span class="line">    BianryTreeNode* right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BianryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BianryTreeNode* left;</span><br><span class="line">    BianryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MirrorRecursively</span><span class="params">(BianryTreeNode * proot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;left==<span class="literal">nullptr</span>&amp;&amp;proot-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BianryTreeNode* temp=proot-&gt;left;</span><br><span class="line">    proot-&gt;left=proot-&gt;right;</span><br><span class="line">    proot-&gt;right=temp;</span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MirrorRecursively(proot-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MirrorRecursively(proot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28、对称的二叉树"><a href="#28、对称的二叉树" class="headerlink" title="28、对称的二叉树"></a>28、对称的二叉树</h3><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>从根节点的左右两个子节点出发</p>
<ul>
<li>左子节点采用 根左右 的方式遍历</li>
<li>右子节点采用 左根右 的方式遍历</li>
<li>每遍历一次就进行比较，一旦出现不同的值就表示不是对称的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BianryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BianryTreeNode* left;</span><br><span class="line">    BianryTreeNode* right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">issymmetrytree</span><span class="params">(BianryTreeNode* proot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> issymmetrytree(proot,proot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">issymmetrytree</span><span class="params">(BianryTreeNode* proot1,BianryTreeNode* proot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot1==<span class="literal">nullptr</span>&amp;&amp;proot2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(proot1==<span class="literal">nullptr</span>||proot2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(proot1-&gt;val!=proot2-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> issymmetrytree(proot1-&gt;left,proot2-&gt;right)&amp;&amp; issymmetrytree(proot2&gt;left,proot1&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29、顺时针打印矩阵"><a href="#29、顺时针打印矩阵" class="headerlink" title="29、顺时针打印矩阵"></a>29、顺时针打印矩阵</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，<br>例如，如果输入如下矩阵：<br>1 2 3 4<br>5 6 7 8<br>9 10 11 12<br>13 14 15 16<br>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>从外到里 一次打印 但是要注意到边界条件 防止打印的时候越界了 第一次打印的起来是（0.0）第二次打印的起点是（1,1） 选取起点坐标作为分析的依据</p>
<p>得出一个循环的条件<br>$$<br>columns&gt;startX * 2  并且rows&gt;startY * 2<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printarray</span><span class="params">(<span class="keyword">int</span> **number,<span class="keyword">int</span> columns,<span class="keyword">int</span> rows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="literal">nullptr</span>||columns&lt;=<span class="number">0</span>||rows&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(columns&gt;start*<span class="number">2</span>&amp;&amp;rows&gt;start*<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Printarray(number,columns,rows,start);</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printarray</span><span class="params">(<span class="keyword">int</span> **number,<span class="keyword">int</span> columns,<span class="keyword">int</span> rows,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endX=columns<span class="number">-1</span>-start;</span><br><span class="line">    <span class="keyword">int</span> endY=rows<span class="number">-1</span>-start;</span><br><span class="line">    <span class="comment">//从左往右打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=endX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Print(number[start][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从上到下打印一列</span></span><br><span class="line">   <span class="keyword">if</span>(start&lt;endY)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=endY;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           Print(number[i][endY])</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;endX&amp;&amp;start&lt;endX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="30、包含min函数的栈"><a href="#30、包含min函数的栈" class="headerlink" title="30、包含min函数的栈"></a>30、包含min函数的栈</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<p>定义两个栈，一个栈保存数据，另一个保存新数据入栈后的最小数<br>pop时，两个栈都要pop;<br>则minstack()的栈顶即为最小元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sulotion</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;minstack;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;mystack;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mystack.push(value);</span><br><span class="line">        <span class="keyword">if</span>(!minstack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">          minstack.push(<span class="built_in">std</span>::min(minstack.top(),value));  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          minstack.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        minstack.pop();</span><br><span class="line">        mystack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mystack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用两个vector实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        mystack.push_back(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minstack.empty())</span><br><span class="line">            minstack.push_back(value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value&lt;minstack.back())</span><br><span class="line">            minstack.push_back(value);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            minstack.push_back(minstack.back());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mystack.pop_back();</span><br><span class="line">        minstack.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mystack.back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minstack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="31、栈的压入、弹出序列-没看"><a href="#31、栈的压入、弹出序列-没看" class="headerlink" title="31、栈的压入、弹出序列(没看)"></a>31、栈的压入、弹出序列(没看)</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>这道题思路还是挺简单的<br>用一个辅助栈来解决，把压入序列的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。</p>
<p>例：<br>压入序列：1,2,3,4,5<br>弹出序列：4,5,3,2,1<br>将压入序列的元素依次压入辅助栈，直到栈顶为弹出序列的首个元素，即：<br>压入1，1不等于4（弹出序列首个元素）；<br>继续压入2，2不等于4；<br>继续压入3，3不等于4；<br>继续压入4；<br>此时4等于弹出序列的首个元素，将4弹出。<br>此时栈顶3不等于5（弹出序列的第二个元素），继续压入5；<br>此时5等于弹出序列的第二个元素，将5弹出。<br>此时3等于弹出序列的第三个元素，将3弹出。<br>此时2等于弹出序列的第四个元素，将2弹出。<br>此时1等于弹出序列的第五个元素，将1弹出。<br>此时压入序列遍历完毕，弹出序列也遍历完毕，栈为空，所以该弹出序列和该压入序列是匹配的。<br>————————————————</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">const</span> *<span class="keyword">int</span> Ppush,<span class="keyword">const</span> *<span class="keyword">int</span> pPop,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bossible=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(Ppush!=<span class="literal">nullptr</span>&amp;&amp;pPop!=<span class="literal">nullptr</span>&amp;&amp;length&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>*pNextPush=Ppush;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>*pNextPop=pPop;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;data;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="32、从上往下不分行打印二叉树"><a href="#32、从上往下不分行打印二叉树" class="headerlink" title="32、从上往下不分行打印二叉树"></a>32、从上往下不分行打印二叉树</h3><h4 id="1-从上往下打印出二叉树的每个节点，同层节点从左至右打印"><a href="#1-从上往下打印出二叉树的每个节点，同层节点从左至右打印" class="headerlink" title="1.从上往下打印出二叉树的每个节点，同层节点从左至右打印"></a>1.从上往下打印出二叉树的每个节点，同层节点从左至右打印</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printtreeone</span><span class="params">(BinaryTreeNode*ptreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptreeRoot==null)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>:<span class="built_in">deque</span>&lt;BinaryTreeNode*&gt;De;</span><br><span class="line">    De.push_back(BinaryTreeNode*ptreeRoot);</span><br><span class="line">    <span class="keyword">while</span>(De.size())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* Node=De.front();</span><br><span class="line">        De.pop_front();</span><br><span class="line">        print(Node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;left)</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;right)</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-分行从上到下打印二叉树-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行"><a href="#2-分行从上到下打印二叉树-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行" class="headerlink" title="2 分行从上到下打印二叉树 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行"></a>2 分行从上到下打印二叉树 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printtreetwo</span><span class="params">(BinaryTreeNode*ptreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptreeRoot==null)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>:<span class="built_in">deque</span>&lt;BinaryTreeNode*&gt;De;</span><br><span class="line">    <span class="keyword">int</span> TobePrint=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextNode=<span class="number">0</span>;</span><br><span class="line">    De.push_back(BinaryTreeNode*ptreeRoot);</span><br><span class="line">    <span class="keyword">while</span>(De.size())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* Node=De.front();</span><br><span class="line">        De.pop_front();</span><br><span class="line">        print(Node-&gt;val);</span><br><span class="line">        TobePrint--;</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;left);</span><br><span class="line">            nextNode++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ptreeRoot-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            Printtreeone(ptreeRoot-&gt;right!=<span class="literal">nullptr</span>);</span><br><span class="line">            nextNode++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(TobePrint==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(‘换行’);</span><br><span class="line">            TobePrint=nextNode;</span><br><span class="line">            nextNode=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、之字形打印二叉树"><a href="#3、之字形打印二叉树" class="headerlink" title="3、之字形打印二叉树"></a>3、之字形打印二叉树</h3><h4 id="3-请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推"><a href="#3-请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推" class="headerlink" title="3 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推"></a>3 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推</h4><p> 两个栈保存，交替打印</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    BinaryTreeNode*left;</span><br><span class="line">    BinaryTreeNode*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printtreethree</span><span class="params">(BinaryTreeNode*ptreeRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(ptreeRoot==<span class="literal">nullptr</span>)</span><br><span class="line">       <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">deque</span>&lt;BinaryTreeNode*&gt;De[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> curr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next=<span class="number">1</span>;</span><br><span class="line">    De[curr].push(ptreeRoot);</span><br><span class="line">    <span class="keyword">while</span>(!De[<span class="number">0</span>].empty()||!De[<span class="number">1</span>].empty())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* Node=De[curr].top();</span><br><span class="line">        Print(Ndoe-&gt;val);</span><br><span class="line">        De[curr].pop();</span><br><span class="line">        <span class="keyword">if</span>(curr==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Ndoe-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Ndoe-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">if</span>(Ndoe-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">              <span class="keyword">if</span>(Ndoe-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                De[next].push(Ndoe-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(De[curr].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            print('换行');</span><br><span class="line">            curr=<span class="number">1</span>-curr;</span><br><span class="line">            next=<span class="number">1</span>-next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33、二叉搜索树的后序遍历序列"><a href="#33、二叉搜索树的后序遍历序列" class="headerlink" title="33、二叉搜索树的后序遍历序列"></a>33、二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历结果。<br>如果是则返回true，否则返回false。<br>假设输入的数组的任意两个数字互不相同。</p>
<p>输入数组{5, 7, 6, 9, 11, 10, 8}，则返回true，<br>因为这个整数序列是下面这个二叉搜索树的后序遍历结果。<br>如果输入的数组是{7, 4, 6, 5}，则由于没有<br>哪棵二叉搜索树的后序遍历结果是这个序列，因此返回false。<br>8<br>/ <br>6 10<br>/ \ / <br>5 7 9 1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isafterlist</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> root=data[length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(data[i]&gt;root);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">int</span> j=i;</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[j]&lt;root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> left=<span class="literal">true</span>;</span><br><span class="line">    left=isafterlist(data,i);</span><br><span class="line">    <span class="keyword">bool</span> right=<span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(i&lt;length<span class="number">-1</span>)</span><br><span class="line">        right=isafterlist(data+i,length-i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (left&amp;&amp;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/08/19/C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/08/19/C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T17:39:20+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>就是一种传承，可以把父类型中的数据传承到子类中，子类除了传承了父类的数据之外，还可以对父类型进行扩展；</strong></p>
<ol>
<li><strong>公开继承  public</strong></li>
<li><strong>保护继承  protected</strong></li>
<li><strong>私有继承  private</strong></li>
<li><strong>保护成员：在子类和本类中可以访问，其他不行；</strong></li>
</ol>
<p>1、公开继承：在公开继承下，父类型中的数据是公开的到子类型中权限是公开的；父类型中保护权限的数据到子类中是保护的；父类中私有的数据到子类中会隐藏掉（就是说看不见权限，但是实际上式在子类中的）；</p>
<p>2、私有继承：在私有继承下，父类中的公开数据到子类中变成私有的，父类中的保护数据到子类中称为私有的，父类中的私有数据到子类中隐藏；</p>
<p>3、保护继承：保护继承下，父类中的公开数据和保护数据到了子类中都成为保护权限，父类中私有的数据到了子类中就变成了隐藏的；<br>4、注意：不管何种类型的继承关系，父类私有成员到子类中都成为了隐藏掉。</p>
<h5 id="1-公开继承下的public成员和protected成员的权限变化："><a href="#1-公开继承下的public成员和protected成员的权限变化：" class="headerlink" title="1.公开继承下的public成员和protected成员的权限变化："></a><strong>1.公开继承下的public成员和protected成员的权限变化：</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">geta</span><span class="params">()</span></span>&#123;</span><br><span class="line">		a = <span class="number">300</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*保护类型成员在本类和子类中可以访问*/</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="comment">//int x;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getb</span><span class="params">()</span></span>&#123;</span><br><span class="line">		b = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showa</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt; a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/*关键在于如何设置接口，成功合理的访问到各种类型的数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B pex;</span><br><span class="line">	<span class="comment">/*公开继承public成员依旧是public，所以可以类外访问*/</span></span><br><span class="line">	pex.a = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">/*b是保护类型成员，可以通过设置public接口来访问*/</span></span><br><span class="line">	pex.getb();</span><br><span class="line">	pex.show();</span><br><span class="line">	<span class="comment">/*隐藏成员的问题，怎么访问到隐藏的成员*/</span></span><br><span class="line">	pex.geta();</span><br><span class="line">	pex.showa();</span><br><span class="line">	<span class="comment">//A a = pex;//子类类型赋给了父类类型</span></span><br><span class="line">	<span class="comment">//a.geta();</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a.a &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-私有继承下的成员的权限变化关系，"><a href="#2-私有继承下的成员的权限变化关系，" class="headerlink" title="2.私有继承下的成员的权限变化关系，"></a>2.私有继承下的成员的权限变化关系，</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*私有继承下的权限变化，关键是设置合理的接口访问</span></span><br><span class="line"><span class="comment">父类中的各种类型的数据成员*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showa</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is showa()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showb</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is showb"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is showc"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">geta</span><span class="params">()</span></span>&#123;<span class="comment">//设置合理的接口访问A中的私有数据</span></span><br><span class="line">		showa();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">private</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		showc();</span><br><span class="line">		showb();</span><br><span class="line">		geta();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="comment">//A a = b;对比公开继承，对比一下</span></span><br><span class="line">	b.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。"><a href="#3-突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。" class="headerlink" title="3.突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。"></a>3.突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*友元类*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():x(<span class="number">10</span>),y(<span class="number">123</span>)&#123;&#125;</span><br><span class="line">	<span class="comment">/*B,C声明为A的友元类之后，可以访问到父类的所有类型成员*/</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"---"</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;a.x&lt;&lt; <span class="string">"---"</span> &lt;&lt; a.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.show();</span><br><span class="line">	C c;</span><br><span class="line">	c.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数"><a href="#4-继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数" class="headerlink" title="4.继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数"></a>4.继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数</h5><p><span style="color:red"><strong>构造函数和析构函数是不能被继承的，但是可以被调用。并且子类一定会调用父类的构造函数；</strong></span></p>
<p><strong>子类默认调用父类的无参构造，也可以制定调用构造函数；</strong></p>
<p><strong>析构函数的调用和构造函数的调用顺序相反；</strong></p>
<p><strong>拷贝构造函数和赋值运算符函数也不能被继承：在子类不提供拷贝构造和赋值运算符时，子类默认调用父类的赋值运算符和拷贝构造函数。但子类一旦提供拷贝构造和赋值运算符函数则不再调用父类拷贝构造和赋值运算符函数。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*继承中构造函数和析构函数的调用：构造函数和析构函数不可以</span></span><br><span class="line"><span class="comment">被继承，但是可以被调用，而且子类肯定会调用父类的构造函数</span></span><br><span class="line"><span class="comment">和析构函数。这种机制可以很自然的用于访问父类的私有成员*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//A()&#123;cout &lt;&lt; "A()" &lt;&lt; endl;&#125;</span></span><br><span class="line">	A(<span class="keyword">int</span> x = <span class="number">0</span>):x(x)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"A()构造"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="keyword">int</span> _get()&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*在初始化参数列表中可以指定调用父类的构造函数,指定调用构造函数并且给</span></span><br><span class="line"><span class="comment">	父类中的私有成员赋值*/</span></span><br><span class="line">	<span class="comment">/*注意：子类默认调用父类的无参构造，如果下面的代码没有：A(100),则会调用无参构造，但是父类无参构造</span></span><br><span class="line"><span class="comment">	被注释掉，所以会出错*/</span></span><br><span class="line">	B():A(<span class="number">100</span>)&#123;</span><br><span class="line">		<span class="comment">//x = 200;</span></span><br><span class="line">		<span class="comment">//A(100);</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//访问有参构造的方式,理解这种方式的作用</span></span><br><span class="line">	<span class="comment">/*注意，这种机制下的构造函数所赋的值是赋到了子类中的数据x中，</span></span><br><span class="line"><span class="comment">	而父类中的x仍然为0*/</span></span><br><span class="line">	~B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getbx</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _get();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;<span class="comment">//构建A对象，此时A类构造被调用，并打印出了值</span></span><br><span class="line"> </span><br><span class="line">	B b;<span class="comment">//B类为无参构造，首先调用了A的构造，在调用B的构造</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//打印a对象中的x成员</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;a._get()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a对象中的x为0</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//打印b对象中的x</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.getbx()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//是100</span></span><br><span class="line">	<span class="comment">/*一层一层的退，先调用b的析构，在调用a的析构*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-拷贝构造和赋值运算符的问题"><a href="#5-拷贝构造和赋值运算符的问题" class="headerlink" title="5.拷贝构造和赋值运算符的问题"></a>5.拷贝构造和赋值运算符的问题</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*系统一旦提供构造函数，系统默认的构造函数将被回收</span></span><br><span class="line"><span class="comment">记住，拷贝构造也是构造函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A()&#123;&#125;</span><br><span class="line">	<span class="comment">//A(int x = 0):arr(x)&#123;&#125;</span></span><br><span class="line">	A(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"父类拷贝构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"父类赋值运算符函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*有指针类型的成员时，采用默认机制就麻烦了*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="comment">//int * pi;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B()&#123;&#125;</span><br><span class="line">	B(<span class="keyword">const</span> B&amp; b):A(b)&#123;                      </span><br><span class="line">		<span class="comment">//子类中提供了拷贝构造函数将不再调用父类的拷贝构造</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"子类拷贝构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> B&amp; b)&#123;</span><br><span class="line">		A::<span class="keyword">operator</span>=(b);         <span class="comment">//调用父类的拷贝构造函数的机制</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"子类赋值运算符函数"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B a;</span><br><span class="line">	B b = a;</span><br><span class="line">	B c;</span><br><span class="line">	c = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-名字隐藏"><a href="#6-名字隐藏" class="headerlink" title="6.名字隐藏"></a>6.名字隐藏</h5><p><strong>名字隐藏机制：子类中如果定义了和父类中同名的数据，这些数据包括成员变量和成员函数。则会把父类中的数据隐藏掉。</strong></p>
<p>注意：只要名字相同，计算返回值或者形参列表不同，也会被隐藏。隐藏不代表就没有了，可以通过类名作用域::访问到被隐藏的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"show A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A()&#123;x=<span class="number">20</span>;&#125;</span><br><span class="line">	A(<span class="keyword">int</span> x):x(x)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"show A(int x)"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shouu</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"shouu()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"show B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		A::show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.shouu();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.A::x &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//突破名字隐藏机制</span></span><br><span class="line">	<span class="keyword">int</span> c = b.show();被隐藏，无法访问</span><br><span class="line">	b.A::show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-多继承和函数重写"><a href="#7-多继承和函数重写" class="headerlink" title="7.多继承和函数重写"></a>7.多继承和函数重写</h5><p><strong>多继承是c++特有的语法机制，表现为一个子类有多个直接的父类。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//phone();</span></span><br><span class="line">	phone(<span class="keyword">double</span> price = <span class="number">15</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~phone()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use calling"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MP3(<span class="keyword">double</span> price = <span class="number">20</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~MP3()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use to listening music"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vedio</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vedio(<span class="keyword">double</span> price = <span class="number">0</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~vedio()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">vcd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"watch vedio"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*多继承*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iphone</span>:</span><span class="keyword">public</span> phone,<span class="keyword">public</span> MP3,<span class="keyword">public</span> vedio&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> phone::getprice() + MP3::getprice() + vedio::getprice();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	iphone iphone6;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(iphone) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.MP3::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.phone::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.getprice() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//用名字隐藏机制解决多分数据同名冲突的问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:green">多继承遇到的问题：上面的代码用sizeof就可以看到，子类在多继承的时候会多次复制顶层数据，而我们期望的是price这个成员只需要复制一份就可以了，因为多余的复制是无意义的。首先采用顶层抽象的方式，将三个父类抽象到更高的层面上。</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*抽象到更高层的类中*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">product</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	product(<span class="keyword">double</span> price = <span class="number">0</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt;<span class="string">"product"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span>:</span><span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//phone();</span></span><br><span class="line">	phone(<span class="keyword">double</span> price = <span class="number">15</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~phone()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use calling"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3</span>:</span><span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MP3(<span class="keyword">double</span> price = <span class="number">20</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~MP3()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use to listening music"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vedio</span>:</span><span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vedio(<span class="keyword">double</span> price = <span class="number">0</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~vedio()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">vcd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"watch vedio"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iphone</span>:</span><span class="keyword">public</span> phone,<span class="keyword">public</span> MP3,<span class="keyword">public</span> vedio&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> phone::getprice() + MP3::getprice() + vedio::getprice();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	iphone iphone6;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;同样会产生冲突的问题</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; sizeof(iphone) &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.MP3::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.phone::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;//直接调用产生冲突问题，编译器不知道该调用哪一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，product的构造函数 被调用了三次，因为这种继承是一级一级的来的，构造子类的时候找父类，发现父类还有父类，就去调用爷爷类的构造函数，三次继承，三次调用。</p>
<p>这种继承方式构成了一种菱形或者钻石型的继承，叫做菱形继承或者钻石继承，但钻石继承并没有实际解决数据多次复制的问题，为了解决菱形继承，c++提出了虚继承。虚继承就是在继承的时候加上virtual关键字修饰即可。</p>
<p><span style="color:green">虚继承对于共同的成员父亲类从爷爷类那里继承来的，这里为double price，子类直接越级访问，直接从爷爷类那里继承price。</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*类中也会有对齐和补齐*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*抽象到更高层的类中*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">product</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span>  <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	product(<span class="keyword">double</span> price = <span class="number">0</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"product"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//phone();</span></span><br><span class="line">	phone(<span class="keyword">double</span> price = <span class="number">15</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~phone()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use calling"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MP3(<span class="keyword">double</span> price = <span class="number">20</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~MP3()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use to listening music"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vedio</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vedio(<span class="keyword">double</span> price = <span class="number">0</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~vedio()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">vcd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"watch vedio"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iphone</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> phone,<span class="keyword">virtual</span> <span class="keyword">public</span> MP3,<span class="keyword">virtual</span> <span class="keyword">public</span> vedio&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	iphone(<span class="keyword">int</span> m = <span class="number">0</span>,<span class="keyword">int</span> v = <span class="number">0</span>,<span class="keyword">int</span> p = <span class="number">0</span>):product(m + p + v)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*虚函数之后，product的构造函数只被调用了一次，孙子类直接越级访问</span></span><br><span class="line"><span class="comment">了product类*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">iphone <span class="title">iphone6</span><span class="params">(<span class="number">1000</span>,<span class="number">2041</span>,<span class="number">3201</span>)</span></span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;同样会产生冲突的问题</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; sizeof(iphone) &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.MP3::getprice() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.phone::getprice() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;直接调用产生冲突问题，编译器不知道该调用哪一个</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(iphone) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码中product的构造函数只调用了一次，说明子类直接越级访问了爷爷类的数据。而对于父类特有的子类照常继承，只是没有通过父类去继承爷爷类的数据成员，所以product的构造函数只被调用了一次。</p>
<p>虚函数：在函数前面加上virtual关键字修饰过的就是虚函数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showa</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚函数的主要表现为会占用四个字节的空间，只要成员中出现虚函数，不管有多少个虚函数，都只用四个字节来维护这个虚关系。虚函数会影响对象的大小。维护虚关系使用一个指针来维护的，所以是四个字节。</p>
<p><strong>函数重写：</strong></p>
<p><strong>在父类中出现一个虚函数，如果在子类中提供和父类同名的函数（注意区分名字隐藏），这就加函数重写。</strong></p>
<p><strong>函数重写要求必须有相同函数名，相同的参数列表，相同的返回值。</strong></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li>
<li>多态是以封装和继承为基础的。</li>
<li>C++ 多态分类及实现：<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ul>
<p>当人们谈论C ++中的多态时，他们通常意味着通过基类指针或引用使用派生类，这称为<strong>子类型多态</strong>。但是他们经常忘记C ++中存在各种其他多态性，例如<strong>参数多态性</strong>，<strong>ad-hoc多态性</strong>和<strong>强制多态性</strong>。</p>
<ul>
<li>子类型多态性也称为<strong>运行时多态性</strong>。</li>
<li>参数多态也称为<strong>编译时多态</strong>。</li>
<li>Ad-hoc多态性也称为<strong>重载</strong>。</li>
<li>强制也称为（隐式或显式）<strong>铸造</strong>。</li>
</ul>
<p>在本文中，我将通过C ++语言中的示例来说明所有多态性，并且还可以深入了解它们具有各种其他名称的原因。</p>
<h4 id="1-子类型多态性（运行时多态性）"><a href="#1-子类型多态性（运行时多态性）" class="headerlink" title="1.子类型多态性（运行时多态性）"></a>1.子类型多态性（运行时多态性）</h4><p>子类型多态性是每个人在C ++中说“多态”时都能理解的。它是通过基类指针和引用使用派生类的能力</p>
<p>这是一个例子。假设你有像这些猫科动物的各种猫，</p>
<p><img src="https://catonmat.net/images/polymorphic-cats.gif" alt="å¤æç«"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cats.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> meow（）= <span class="number">0</span>; </span><br><span class="line">&#125;;<span class="comment">//纯虚函数 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>：<span class="title">public</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">void</span> meow（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt;“Meowing like a regular cat！meow！\ n”; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span>：<span class="title">public</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">void</span> meow（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt;“Meowing like a tiger！MREOWWW！\ n”; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ocelot</span>：<span class="title">public</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">void</span> meow（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt;“Meowing like a ocelot！mews！\ n”; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_meowing</span><span class="params">(Felid *cat)</span> </span>&#123;</span><br><span class="line"> cat-&gt;meow();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Cat cat;</span><br><span class="line"> Tiger tiger;</span><br><span class="line"> Ocelot ocelot;</span><br><span class="line"></span><br><span class="line"> do_meowing(&amp;cat);</span><br><span class="line"> do_meowing(&amp;tiger);</span><br><span class="line"> do_meowing(&amp;ocelot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的主要程序传递指针<code>cat</code>，<code>tiger</code>并<code>ocelot</code>以<code>do_meowing</code>一个期望的指针功能<code>Felid</code>。由于它们都是<code>Felid</code>s，程序<code>meow</code>为每个felid 调用正确的函数，输出为：</p>
<p>子类型多态性也称为运行时多态，这是有充分理由的。多态函数调用的解析在运行时通过虚拟表的间接发生。解释这一点的另一种方法是编译器没有在编译时定位要调用的函数的地址，而是在程序运行时，通过解除引用虚拟表中的右指针来调用该函数。在类型理论中，它也被称为包含多态性</p>
<h4 id="2-参数多态性（编译时多态性）"><a href="#2-参数多态性（编译时多态性）" class="headerlink" title="2.参数多态性（编译时多态性）"></a>2.参数多态性（编译时多态性）</h4><p>参数多态提供了为任何类型执行相同代码的方法。在C ++中，参数多态通过模板实现。</p>
<p>最简单的例子之一是泛型<code>max</code>函数，它最多找到两个参数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">max</span>（<span class="title">T</span> <span class="title">a</span>，<span class="title">T</span> <span class="title">b</span>）&#123;</span> </span><br><span class="line"> <span class="keyword">return</span> a&gt; b？a：b; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main（）&#123; </span><br><span class="line"> <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; :: max（<span class="number">9</span>,<span class="number">5</span>）&lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>; <span class="comment">// 9 </span></span><br><span class="line"> <span class="built_in">std</span> :: <span class="built_in">string</span> foo（“foo”），bar（“bar”）; </span><br><span class="line"> <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; :: max（foo，bar）&lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>; <span class="comment">//“foo” </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>max</code>函数是类型的多态<code>T</code>。但请注意，它不适用于指针类型，因为比较指针会比较内存位置而不是内容。为了使它适用于指针，你必须专门化指针类型的模板，这将不再是参数多态，而是ad-hoc多态。</p>
<p>由于参数多态在编译时发生，因此它也称为<strong>编译时多态</strong>。</p>
<h4 id="3-Ad-hoc多态（重载）"><a href="#3-Ad-hoc多态（重载）" class="headerlink" title="3.Ad-hoc多态（重载）"></a>3.Ad-hoc多态（重载）</h4><p>Ad-hoc多态性允许具有相同名称的函数对每种类型采取不同的行为。例如，给定两个<code>int</code>s和<code>+</code>运算符，它将它们加在一起。给定两个，<code>std::string</code>它将它们连接在一起。这称为<strong>重载</strong>。</p>
<p>这是实现功能的具体例子<code>add</code>为<code>int</code> 和<code>string</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">result</span><span class="params">(a)</span></span>;</span><br><span class="line"> result += b;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">5</span>, <span class="number">9</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//14</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="string">"hello "</span>, <span class="string">"world"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您专门化模板，Ad-hoc多态也会出现在C ++中。回到上一个关于<code>max</code>函数的例子，这里是你如何写一个最大值为2 <code>char *</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * max（<span class="keyword">const</span> <span class="keyword">char</span> * a，<span class="keyword">const</span> <span class="keyword">char</span> * b）&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">strcmp</span>（a，b）&gt; <span class="number">0</span>？a：b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-强制多态（铸造）"><a href="#4-强制多态（铸造）" class="headerlink" title="4.强制多态（铸造）"></a>4.强制多态（铸造）</h4><p>当对象或基元被转换为另一种对象类型或基本类型时，就会发生强制。例如，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> b = <span class="number">6</span>; <span class="comment">// int被提升（强制转换）为隐式浮动</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">9.99</span> <span class="comment">// float隐式降级为int</span></span><br></pre></td></tr></table></figure>

<p>当你用C的类型转换的表达式，如明确铸造发生<code>(unsigned int *)</code>或<code>(int)</code>或C ++的<code>static_cast</code>，<code>const_cast</code>，<code>reinterpret_cast</code>，或<code>dynamic_cast</code>。</p>
<p><code>explicit</code>例如，如果类的构造函数不是，则也会发生强制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"> <span class="keyword">int</span> foo; </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> A（<span class="keyword">int</span> foo）：foo（foo）&#123;&#125; </span><br><span class="line"> <span class="keyword">void</span> giggidy（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; foo &lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> moo（A a）&#123; </span><br><span class="line"> a.giggidy（）; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main（）&#123; </span><br><span class="line"> moo（<span class="number">55</span>）; <span class="comment">//打印55 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你创建了A的构造函数<code>explicit</code>，那就不可能了。让构造函数明确以避免意外转换始终是个好主意。</p>
<p>此外，如果类为类型定义转换运算符<code>T</code>，则可以在<code>T</code>期望类型的任何位置使用它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrazyInt</span> &#123;</span> </span><br><span class="line"> <span class="keyword">int</span> v; </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> CrazyInt（<span class="keyword">int</span> i）：v（i）&#123;&#125; </span><br><span class="line"> <span class="keyword">operator</span> <span class="keyword">int</span>（）<span class="keyword">const</span> &#123;<span class="keyword">return</span> v; &#125; <span class="comment">//从CrazyInt转换为int </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="C-中的虚函数-表-实现机制以及用C语言对其进行的模拟实现"><a href="#C-中的虚函数-表-实现机制以及用C语言对其进行的模拟实现" class="headerlink" title="C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现"></a>C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都应该知道C++的精髓是虚函数吧? 虚函数带来的好处就是: 可以定义一个基类的指针, 其指向一个继承类, 当通过基类的指针去调用函数时, 可以在运行时决定该调用基类的函数还是继承类的函数. 虚函数是实现多态(动态绑定)/接口函数的基础. 可以说: 没有虚函数, C++将变得一无是处!</p>
<p>既然是C++的精髓, 那么我们有必要了解一下她的实现方式吗? 有必要! 既然C++是从C语言的基础上发展而来的, 那么我们可以尝试用C语言来模拟实现吗? 有可能! 接下来, 就是我一步一步地来解析C++的虚函数的实现方式, 以及用C语言对其进行的模拟.</p>
<h2 id="C-对象的内存布局"><a href="#C-对象的内存布局" class="headerlink" title="C++对象的内存布局"></a>C++对象的内存布局</h2><p>要想知道C++对象的内存布局, 可以有多种方式, 比如:</p>
<ol>
<li><p>输出成员变量的偏移, 通过offsetof宏来得到</p>
</li>
<li><p>通过调试器查看, 比如常用的VS</p>
</li>
<li><h3 id="只有数据成员的对象"><a href="#只有数据成员的对象" class="headerlink" title="只有数据成员的对象"></a>只有数据成员的对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象大小及偏移:</p>
<table>
<thead>
<tr>
<th align="center">sizeof(Base1)</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">offsetof(Base1, base1_1)</td>
<td>0</td>
</tr>
<tr>
<td align="center">offsetof(Base1, base1_2)</td>
<td>4</td>
</tr>
</tbody></table>
<p>可知对象布局:</p>
<p><img src="/bolgzxy.github.io/.com//C:%5CUsers%5CCCTVZYX%5CDesktop%5C1-1.png" alt="1-1"></p>
<p>可以看到, 成员变量是按照定义的顺序来保存的, 最先声明的在最上边, 然后依次保存!<br>类对象的大小就是所有成员变量大小之和.</p>
</li>
<li><h3 id="没有虚函数的对象"><a href="#没有虚函数的对象" class="headerlink" title="没有虚函数的对象"></a>没有虚函数的对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>4</td>
</tr>
</tbody></table>
<p>和前面的结果是一样的? 不需要有什么疑问对吧?<br>因为如果一个函数不是虚函数,那么他就不可能会发生动态绑定,也就不会对对象的布局造成任何影响.<br>当调用一个非虚函数时, 那么调用的一定就是当前指针类型拥有的那个成员函数. 这种调用机制在编译时期就确定下来了.</p>
</li>
<li><h3 id="拥有仅一个虚函数的类对象"><a href="#拥有仅一个虚函数的类对象" class="headerlink" title="拥有仅一个虚函数的类对象"></a>拥有仅一个虚函数的类对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>4</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>8</td>
</tr>
</tbody></table>
<p>咦? 多了4个字节? 且 base1_1 和 base1_2 的偏移都各自向后多了4个字节!<br>说明类对象的最前面被多加了4个字节的”东东”, what’s it?<br>现在, 我们通过VS2013来瞧瞧类Base1的变量b1的内存布局情况:<br>(由于我没有写构造函数, 所以变量的数据没有根据, 但虚函数是编译器为我们构造的, 数据正确!)<br>(Debug模式下, 未初始化的变量值为<code>0xCCCCCCCC</code>, 即:<code>-858983460</code>)</p>
<p><img src="/bolgzxy.github.io/.com//C:%5CUsers%5CCCTVZYX%5CDesktop%5C3-1.png" alt="3-1"></p>
<p>看到没? base1_1前面多了一个变量 __vfptr(常说的虚函数表vtable指针), 其类型为void<strong>, 这说明它是一个void*指针(</strong>注意:**不是数组).</p>
<p>再看看[0]元素, 其类型为void*, 其值为 ConsoleApplication2.exe!Base1::base1_fun1(void), 这是什么意思呢? 如果对WinDbg比较熟悉, 那么应该知道这是一种惯用表示手法, 她就是指 Base1::base1_fun1() 函数的地址.</p>
<p>可得, __vfptr的定义伪代码大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>*   __fun[<span class="number">1</span>] = &#123; &amp;Base1::base1_fun1 &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>**  __vfptr = &amp;__fun[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>值得注意的是:</p>
<ol>
<li><p>上面只是一种伪代码方式, 语法不一定能通过</p>
</li>
<li><p>该类的对象大小为12个字节, 大小及偏移信息如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(__vfptr)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(base1_1)</td>
<td>4</td>
</tr>
<tr>
<td>offsetof(base1_2)</td>
<td>8</td>
</tr>
</tbody></table>
</li>
<li><p>大家有没有留意这个__vfptr? 为什么它被定义成一个指向指针数组的指针, 而不是直接定义成一个指针数组呢?</p>
<p>我为什么要提这样一个问题? 因为如果仅是一个指针的情况, 您就无法轻易地修改那个数组里面的内容, 因为她并不属于类对象的一部分.<br>属于类对象的, 仅是一个指向<strong>虚函数表的一个指针__vfptr</strong>而已, 下一节我们将继续讨论这个问题.</p>
</li>
<li><p>注意到<strong>vfptr前面的const修饰. 她修饰的是那个虚函数表, 而不是</strong>vfptr.</p>
</li>
</ol>
<p>现在的对象布局如下:</p>
<p><img src="https://blog.twofei.com/496/3-2.png" alt="img"></p>
<p>虚函数指针__vfptr位于所有的成员变量之前定义.</p>
<p>注意到: 我并未在此说明__vfptr的具体指向, 只是说明了现在类对象的布局情况.<br>接下来看一个稍微复杂一点的情况, 我将清楚地描述虚函数表的构成.</p>
</li>
<li><h3 id="拥有多个虚函数的类对象"><a href="#拥有多个虚函数的类对象" class="headerlink" title="拥有多个虚函数的类对象"></a>拥有多个虚函数的类对象</h3><p>和前面一个例子差不多, 只是再加了一个虚函数. 定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大小以及偏移信息如下:</p>
<p><img src="https://blog.twofei.com/496/4-1.png" alt="img"></p>
<p>有情况!? 多了一个虚函数, 类对象大小却依然是12个字节!</p>
<p>再来看看VS形象的表现:</p>
<p><img src="https://blog.twofei.com/496/4-2.png" alt="img"></p>
<p>呀, __vfptr所指向的函数指针数组中出现了第2个元素, 其值为Base1类的第2个虚函数base1_fun2()的函数地址.</p>
<p>现在, 虚函数指针以及虚函数表的伪定义大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* __fun[] = &#123; &amp;Base1::base1_fun1, &amp;Base1::base1_fun2 &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>** __vfptr = &amp;__fun[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>通过上面两张图表, 我们可以得到如下结论:</p>
<ol>
<li>更加肯定前面我们所描述的: __vfptr只是一个指针, 她指向一个函数指针数组(即: 虚函数表)</li>
<li>增加一个虚函数, 只是简单地向该类对应的虚函数表中增加一项而已, 并不会影响到类对象的大小以及布局情况</li>
</ol>
<p>前面已经提到过: <strong>vfptr只是一个指针, 她指向一个数组, 并且: 这个数组没有包含到类定义内部, 那么她们之间是怎样一个关系呢?<br>不妨, 我们再定义一个类的变量b2, 现在再来看看</strong>vfptr的指向:</p>
<p><img src="https://blog.twofei.com/496/4-3.png" alt="img"></p>
<p>通过Watch 1窗口我们看到:</p>
<ol>
<li>b1和b2是类的两个变量, 理所当然, 她们的地址是不同的(见 &amp;b1 和 &amp;b2)</li>
<li>虽然b1和b2是类的两个变量, 但是: 她们的__vfptr的指向却是同一个虚函数表</li>
</ol>
<p>由此我们可以总结出:</p>
<p>同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void**类型)指向该虚函数表.</p>
<p>是时候该展示一下类对象的内存布局情况了:</p>
<p><img src="https://blog.twofei.com/496/4-4.png" alt="img"></p>
<p>不出意外, 很清晰明了地展示出来了吧? :-) hoho~~</p>
<p>那么问题就来了! 这个虚函数表保存在哪里呢? 其实, 我们无需过分追究她位于哪里, 重点是:</p>
<ol>
<li>她是编译器在<strong>编译时期</strong>为我们创建好的, 只存在一份</li>
<li>定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表</li>
</ol>
</li>
<li><h3 id="单继承且本身不存在虚函数的继承类的内存布局"><a href="#单继承且本身不存在虚函数的继承类的内存布局" class="headerlink" title="单继承且本身不存在虚函数的继承类的内存布局"></a>单继承且本身不存在虚函数的继承类的内存布局</h3><p>前面研究了那么多啦, 终于该到研究继承类了! 先研究单继承!</p>
<p>依然, 简单地定义一个继承类, 如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们再来看看现在的内存布局(定义为Derive1 d1):</p>
<p><img src="https://blog.twofei.com/496/5-1.png" alt="img"></p>
<p>没错! 基类在上边, 继承类的成员在下边依次定义! 展开来看看:</p>
<p><img src="https://blog.twofei.com/496/5-2.png" alt="img"></p>
<p>经展开后来看, 前面部分完全就是Base1的东西: 虚函数表指针+成员变量定义.<br>并且, Base1的虚函数表的[0][1]两项还是其本身就拥有的函数: base1_fun1() 和 base1_fun2().</p>
<p>现在类的布局情况应该是下面这样:</p>
<p><img src="https://blog.twofei.com/496/5-3.png" alt="img"></p>
</li>
<li><h3 id="本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局"><a href="#本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局" class="headerlink" title="本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局"></a>本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局</h3><p>标题<code>本身不存在虚函数</code>的说法有些不严谨, 我的意思是说: 除经过继承而得来的基类虚函数以外, 自身没有再定义其它的虚函数.</p>
<p>Ok, 既然存在基类虚函数覆盖, 那么来看看接下来的代码会产生何种影响:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖基类函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到, Derive1类 重写了Base1类的base1_fun1()函数, 也就是常说的虚函数覆盖. 现在是怎样布局的呢?</p>
<p><img src="https://blog.twofei.com/496/6-1.png" alt="img"></p>
<p>特别注意我高亮的那一行: 原本是Base1::base1_fun1(), 但由于<strong>继承类重写</strong>了基类Base1的此方法, 所以现在变成了Derive1::base1_fun1()!</p>
<p>那么, 无论是通过Derive1的指针还是Base1的指针来调用此方法, 调用的都将是被继承类重写后的那个方法(函数), 多态发生鸟!!!</p>
<p>那么新的布局图:</p>
<p><img src="https://blog.twofei.com/496/6-2.png" alt="img"></p>
</li>
<li><h3 id="定义了基类没有的虚函数的单继承的类对象布局"><a href="#定义了基类没有的虚函数的单继承的类对象布局" class="headerlink" title="定义了基类没有的虚函数的单继承的类对象布局"></a>定义了基类没有的虚函数的单继承的类对象布局</h3><p>说明一下: 由于前面一种情况只会造成覆盖基类虚函数表的指针, 所以接下来我不再同时讨论虚函数覆盖的情况.</p>
<p>继续贴代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和第5类不同的是多了一个自身定义的虚函数. 和第6类不同的是没有基类虚函数的覆盖.</p>
<p><img src="https://blog.twofei.com/496/7-1.png" alt="img"></p>
<p>咦, 有没有发现问题? 表面上看来几乎和第5种情况完全一样? 为嘛呢?<br>现在继承类明明定义了自身的虚函数, 但不见了??<br>那么, 来看看类对象的大小, 以及成员偏移情况吧:</p>
<p><img src="https://blog.twofei.com/496/7-2.png" alt="img"></p>
<p>居然没有变化!!! 前面12个字节是Base1的, 有没有觉得很奇怪?</p>
<p>好吧, 既然表面上没办法了, 我们就只能从汇编入手了, 来看看调用derive1_fun1()时的代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun1();</span><br></pre></td></tr></table></figure>

<p>要注意: 我为什么使用指针的方式调用? 说明一下: 因为如果不使用指针调用, 虚函数调用是不会发生动态绑定的哦! 你若直接 <code>d1.derive1_fun1();</code> , 是不可能会发生动态绑定的, 但如果使用指针: <code>pd1-&gt;derive1_fun1();</code> , 那么 pd1就无从知道她所指向的对象到底是Derive1 还是继承于Derive1的对象, 虽然这里我们并没有对象继承于Derive1, 但是她不得不这样做, 毕竟继承类不管你如何继承, 都不会影响到基类, 对吧?</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun1();</span></span><br><span class="line"><span class="number">00825466</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00825469</span>  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">0082546B  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line"><span class="number">0082546D</span>  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00825470</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">8</span>]  </span><br><span class="line"><span class="number">00825473</span>  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>汇编代码解释:</p>
<p>第2行: 由于pd1是指向d1的指针, 所以执行此句后 eax 就是<strong>d1的地址</strong><br>第3行: 又因为Base1::<strong>vfptr是Base1的第1个成员, 同时也是Derive1的第1个成员, 那么: &amp;</strong>vfptr == &amp;d1, clear? 所以当执行完 <code>mov edx, dword ptr[eax]</code> 后, edx就得到了<strong>vfptr的值, 也就是<strong>虚函数表的地址</strong>.<br>第5行: 由于是</strong>thiscall调用, 所以把this保存到ecx中.<br>第6行: 一定要注意到那个 edx+8, 由于edx是虚函数表的地址, 那么 edx+8将是虚函数表的第3个元素, 也就是__vftable[2]!!!<br>第7行: 调用虚函数.</p>
<p>结果:</p>
<ol>
<li>现在我们应该知道内幕了! 继承类Derive1的虚函数表被加在基类的后面! 事实的确就是这样!</li>
<li>由于Base1只知道自己的两个虚函数索引[0][1], 所以就算在后面加上了[2], Base1根本不知情, 不会对她造成任何影响.</li>
<li>如果<strong>基类没有虚函数</strong>呢? 这个问题我们留到第9小节再来讨论!</li>
</ol>
<p>最新的类对象布局表示:</p>
<p><img src="https://blog.twofei.com/496/7-3.png" alt="img"></p>
</li>
<li><h3 id="多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"><a href="#多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局" class="headerlink" title="多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"></a>多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局</h3><p>真快, 该看看多继承了, 多继承很常见, 特别是接口类中!</p>
<p>依然写点小类玩玩:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类虚函数覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码变得越来越长啦! 为了代码结构清晰, 我尽量简化定义.</p>
<p>初步了解一下对象大小及偏移信息:</p>
<p><img src="https://blog.twofei.com/496/8-1.png" alt="img"></p>
<p>貌似, 若有所思? 不管, 来看看VS再想:</p>
<p><img src="https://blog.twofei.com/496/8-2.png" alt="img"></p>
<p>哇, 不摆了! 一丝不挂啊! :-)</p>
<p>结论:</p>
<ol>
<li>按照基类的声明顺序, 基类的成员依次分布在继承中.</li>
<li>注意被我高亮的那两行, 已经发生了虚函数覆盖!</li>
<li>我们自己定义的虚函数呢? 怎么还是看不见?!</li>
</ol>
<p>好吧, 继承反汇编, 这次的调用代码如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun2();</span><br></pre></td></tr></table></figure>

<p>反汇编代码如下:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun2();</span></span><br><span class="line"><span class="number">00995306</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00995309</span>  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">0099530B  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line"><span class="number">0099530D</span>  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00995310</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">0Ch</span>]  </span><br><span class="line"><span class="number">00995313</span>  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>解释下, 其实差不多:</p>
<p>第2行: 取d1的地址<br>第3行: 取Base1::__vfptr的值!!<br>第6行: 0x0C, 也就是第4个元素(下标为[3])</p>
<p>结论:</p>
<p>Derive1的虚函数表依然是保存到第1个拥有虚函数表的那个基类的后面的.</p>
<p>看看现在的类对象布局图:</p>
<p>（注：图中有点错误，右上角应该是 <code>void* __vftable[4]</code>，多谢 shadow3002 的提醒）</p>
<p>（注：图中有点错误，Derive1是存在虚函数覆盖的。源图丢失，请读者注意不要被误导。<a href="https://blog.twofei.com/496/#comment-577" target="_blank" rel="noopener">多谢 Oyster 的提醒</a>）</p>
<p><img src="https://blog.twofei.com/496/8-3.png" alt="img"></p>
<p>如果第1个基类没有虚函数表呢? 进入第9节!</p>
</li>
<li><h3 id="如果第1个直接基类没有虚函数-表"><a href="#如果第1个直接基类没有虚函数-表" class="headerlink" title="如果第1个直接基类没有虚函数(表)"></a>如果第1个直接基类没有虚函数(表)</h3><p>这次的代码应该比上一个要稍微简单一些, 因为把第1个类的虚函数给去掉鸟!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来看看VS的布局:</p>
<p><img src="https://blog.twofei.com/496/9-1.png" alt="img"></p>
<p>这次相对前面一次的图来说还要简单啦! Base1已经没有虚函数表了! (真实情况并非完全这样, 请继续往下看!)</p>
<p>现在的大小及偏移情况: 注意: <code>sizeof(Base1) == 8;</code></p>
<p><img src="https://blog.twofei.com/496/9-2.png" alt="img"></p>
<p>重点是看虚函数的位置, 进入函数调用(和前一次是一样的):</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun2();</span><br></pre></td></tr></table></figure>

<p>反汇编调用代码:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun2();</span></span><br><span class="line">012E4BA6  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line">012E4BA9  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">012E4BAB  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line">012E4BAD  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line">012E4BB0  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">0Ch</span>]  </span><br><span class="line">012E4BB3  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>这段汇编代码和前面一个完全一样!, 那么问题就来了! Base1 已经没有虚函数表了, 为什么还是把b1的第1个元素当作__vfptr呢?<br>不难猜测: 当前的布局已经发生了变化, 有虚函数表的基类放在对象内存前面!? , 不过事实是否属实? 需要仔细斟酌.</p>
<p>我们可以通过对基类成员变量求偏移来观察:</p>
<p><img src="https://blog.twofei.com/496/9-3.png" alt="img"></p>
<p>可以看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;d1==0x~d4</span><br><span class="line">&amp;d1.Base1::__vfptr==0x~d4</span><br><span class="line">&amp;d1.base2_1==0x~d8</span><br><span class="line">&amp;d1.base2_2==0x~dc</span><br><span class="line">&amp;d1.base1_1==0x~e0</span><br><span class="line">&amp;d1.base1_2==0x~e4</span><br></pre></td></tr></table></figure>

<p>所以不难验证: 我们前面的推断是正确的, 谁有虚函数表, 谁就放在前面!</p>
<p>现在类的布局情况:</p>
<p><img src="https://blog.twofei.com/496/9-4.png" alt="img"></p>
<p>那么, 如果两个基类都没有虚函数表呢?</p>
</li>
<li><h3 id="What-if-两个基类都没有虚函数表"><a href="#What-if-两个基类都没有虚函数表" class="headerlink" title="What if 两个基类都没有虚函数表"></a>What if 两个基类都没有虚函数表</h3><p>代码如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面吃了个亏, 现在先来看看VS的基本布局:</p>
<p><img src="https://blog.twofei.com/496/10-1.png" alt="img"></p>
<p>可以看到, 现在__vfptr已经独立出来了, 不再属于Base1和Base2!</p>
<p>看看求偏移情况:</p>
<p><img src="https://blog.twofei.com/496/10-2.png" alt="img"></p>
<p>Ok, 问题解决! 注意高亮的那两行, <code>&amp;d1==&amp;d1.__vfptr</code>, 说明虚函数始终在最前面!</p>
<p>不用再废话, 相信大家对这种情况已经有底了.</p>
<p>对象布局:</p>
<p><img src="https://blog.twofei.com/496/10-3.png" alt="img"></p>
</li>
<li><h3 id="如果有三个基类-虚函数表分别是有-没有-有"><a href="#如果有三个基类-虚函数表分别是有-没有-有" class="headerlink" title="如果有三个基类: 虚函数表分别是有, 没有, 有!"></a>如果有三个基类: 虚函数表分别是有, 没有, 有!</h3><p>这种情况其实已经无需再讨论了, 作为一个完结篇….</p>
<p>上代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">    <span class="keyword">int</span> base3_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是偏移图：</p>
<p><img src="https://blog.twofei.com/496/11-1.png" alt="img"></p>
<p>以下是对象布局图（多谢 <a href="https://blog.twofei.com/496/#comment-577" target="_blank" rel="noopener">@Oyster</a> 的手绘）：</p>
<p><img src="https://blog.twofei.com/496/11-2.jpg" alt="img"></p>
<p>只需知道: 谁有虚函数表, 谁就往前靠!</p>
</li>
</ol>
<h2 id="C-中父子对象指针间的转换与函数调用"><a href="#C-中父子对象指针间的转换与函数调用" class="headerlink" title="C++中父子对象指针间的转换与函数调用"></a>C++中父子对象指针间的转换与函数调用</h2><p>讲了那么多布局方面的东东, 终于到了尾声, 好累呀!!!</p>
<p>通过前面的讲解内容, 大家至少应该明白了各类情况下类对象的内存布局了. 如果还不会…..呃….. !@#$%^&amp;*</p>
<p>进入正题~</p>
<p>由于继承完全拥有父类的所有, 包括数据成员与虚函数表, 所以:<strong>把一个继承类强制转换为一个基类</strong>是完全可行的.</p>
<p>如果有一个Derive1的指针, 那么:</p>
<ul>
<li>得到Base1的指针: Base1* pb1 = pd1;</li>
<li>得到Base2的指针: Base2* pb2 = pd1;</li>
<li>得到Base3的指针: Base3* pb3 = pd1;</li>
</ul>
<p>非常值得注意的是:</p>
<p>这是在基类与继承类之间的转换, 这种转换会自动计算偏移! 按照前面的布局方式!<br>也就是说: 在这里极有可能: pb1 != pb2 != pb3 ~~, 不要以为她们都等于 pd1!</p>
<p>至于函数调用, 我想, 不用说大家应该知道了:</p>
<ol>
<li>如果不是虚函数, 直接调用指针对应的基本类的那个函数</li>
<li>如果是虚函数, 则查找虚函数表, 并进行后续的调用. 虚函数表在定义一个时, 编译器就为我们创建好了的. 所有的, 同一个类, 共用同一份虚函数表.</li>
</ol>
<h2 id="用C语言完全模拟C-虚函数表的实现与运作方式"><a href="#用C语言完全模拟C-虚函数表的实现与运作方式" class="headerlink" title="用C语言完全模拟C++虚函数表的实现与运作方式"></a>用C语言完全模拟C++虚函数表的实现与运作方式</h2><p>如果对前面两大节的描述仔细了解了的话, 想用C语言来模拟C++的虚函数以及多态, 想必是轻而易举的事情鸟!</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>但是, 话得说在前面, C++的编译器在生成类及对象的时候, 帮助我们完成了很多事件, 比如生成虚函数表!<br>但是, C语言编译器却没有, 因此, 很多事件我们必须手动来完成, 包括但不限于:</p>
<ol>
<li>手动构造父子关系</li>
<li>手动创建虚函数表</li>
<li>手动设置__vfptr并指向虚函数表</li>
<li>手动填充虚函数表</li>
<li>若有虚函数覆盖, 还需手动修改函数指针</li>
<li>若要取得基类指针, 还需手动强制转换</li>
<li>……</li>
</ol>
<p>总之, 要想用C语言来实现, 要写的代码绝对有点复杂.</p>
<h3 id="C-原版调用"><a href="#C-原版调用" class="headerlink" title="C++原版调用"></a>C++原版调用</h3><p>接下来, 我们都将以最后那个, 最繁杂的那个3个基类的实例来讲解, 但作了一些简化与改动:</p>
<ol>
<li>用构造函数初始化成员变量</li>
<li>减少成员变量的个数</li>
<li>减少虚函数的个数</li>
<li>调用函数时产生相关输出</li>
<li>Derive1增加一个基类虚函数覆盖</li>
</ol>
<p>以下是对类的改动, 很少:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base1() : base1_1(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::base1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2() : base2_1(<span class="number">21</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base3() : base3_1(<span class="number">31</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::base3_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derive1() : derive1_1(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::base3_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::derive1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了看到多态的效果, 我们还需要定义一个函数来看效果:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Base1* pb1, Base2* pb2, Base3* pb3, Derive1* pd1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb1-&gt;base1_1 = "</span> &lt;&lt; pb1-&gt;base1_1 &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb1-&gt;base1_fun1(): "</span>;</span><br><span class="line">    pb1-&gt;base1_fun1();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb2-&gt;base2_1 = "</span> &lt;&lt; pb2-&gt;base2_1</span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb3-&gt;base3_1 = "</span> &lt;&lt; pb3-&gt;base3_1 &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt;<span class="string">"    pb3-&gt;base3_fun1(): "</span>;</span><br><span class="line">    pb3-&gt;base3_fun1();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pd1-&gt;derive1_1 = "</span> &lt;&lt; pd1-&gt;derive1_1&lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt;<span class="string">"    pd1-&gt;derive1_fun1(): "</span>;</span><br><span class="line">    pd1-&gt;derive1_fun1();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"    pd1-&gt;base3_fun1(): "</span>;</span><br><span class="line">    pd1-&gt;base3_fun1();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">foo(&amp;d1, &amp;d1, &amp;d1, &amp;d1);</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<p><img src="https://blog.twofei.com/496/c-1.png" alt="img"></p>
<p>可以看到输出结果全部正确(当然了! :-), 哈哈~<br>同时注意到 pb3-&gt;base3_fun1() 的多态效果哦!</p>
<h3 id="用C语言来模拟"><a href="#用C语言来模拟" class="headerlink" title="用C语言来模拟"></a>用C语言来模拟</h3><p>必须要把前面的理解了, 才能看懂下面的代码!</p>
<p>为了有别于已经完成的C++的类, 我们分别在类前面加一个大写的C以示区分(平常大家都是习惯在C++写的类前面加C, 今天恰好反过来, 哈哈).</p>
<h5 id="C语言无法实现的部分"><a href="#C语言无法实现的部分" class="headerlink" title="C语言无法实现的部分"></a>C语言无法实现的部分</h5><p>C/C++是两个语言, 有些语言特性是C++专有的, 我们无法实现! 不过, 这里我是指调用约定, 我们应该把她排除在外.</p>
<p>对于类的成员函数, C++默认使用__thiscall, 也即this指针通过ecx传递, 这在C语言无法实现, 所以我们必须手动声明调用约定为:</p>
<ol>
<li><code>__stdcall</code>, 就像微软的组件对象模型那样</li>
<li><code>__cdecl</code>, 本身就C语言的调用约定, 当然能使用了.</li>
</ol>
<p>上面那种调用约定, 使用哪一种无关紧要, 反正不能使用<code>__thiscall</code>就行了.</p>
<p>因为使用了非__thiscall调用约定, 我们就必须手动传入this指针, 通过成员函数的第1个参数!</p>
<h5 id="从最简单的开始-实现-Base2"><a href="#从最简单的开始-实现-Base2" class="headerlink" title="从最简单的开始: 实现 Base2"></a>从最简单的开始: 实现 Base2</h5><p>由于没有虚函数, 仅有成员变量, 这个当然是最好模拟的咯!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="有了虚函数表的Base1-但没被覆盖"><a href="#有了虚函数表的Base1-但没被覆盖" class="headerlink" title="有了虚函数表的Base1, 但没被覆盖"></a>有了虚函数表的Base1, 但没被覆盖</h5><p>下面是Base1的定义, 要复杂一点了, 多一个__vfptr:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>** __vfptr;</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为有虚函数表, 所以还得单独为虚函数表创建一个结构体的哦!<br>但是, 为了更能清楚起见, 我并未定义前面所说的指针数组, 而是用一个包含一个或多个函数指针的结构体来表示!<br>因为数组能保存的是同一类的函数指针, 不太很友好!<br>但他们的效果是完全一样的, 希望读者能够理解明白!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base1_fun1)(CBase1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> base1_fun1 在这里是一个指针变量!<br><strong>注意:</strong> base1_fun1 有一个CBase1的指针, 因为我们不再使用__thiscall, 我们必须手动传入! Got it?</p>
<p>Base1的成员函数base1_fun1()我们也需要自己定义, 而且是定义成全局的:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">base1_fun1</span><span class="params">(CBase1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有虚函数覆盖的Base3"><a href="#有虚函数覆盖的Base3" class="headerlink" title="有虚函数覆盖的Base3"></a>有虚函数覆盖的Base3</h5><p>虚函数覆盖在这里并不能体现出来, 要在构造对象初始化的时候才会体现, 所以: base3其实和Base1是一样的.</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>** __vfptr;</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base3_fun1)(CBase3* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Base3的成员函数:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">base3_fun1</span><span class="params">(CBase3* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base3_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定义继承类CDerive1"><a href="#定义继承类CDerive1" class="headerlink" title="定义继承类CDerive1"></a>定义继承类CDerive1</h5><p>相对前面几个类来说, 这个类要显得稍微复杂一些了, 因为包含了前面几个类的内容:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CDerive1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CBase1 base1;</span><br><span class="line">    CBase3 base3;</span><br><span class="line">    CBase2 base2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>特别注意: CBase123的顺序不能错!</p>
<p>另外: 由于Derive1本身还有虚函数表, 而且所以项是加到第一个虚函数表(CBase1)的后面的, 所以此时的CBase1::__vfptr不应该单单指向CBase1_VFTable, 而应该指向下面这个包含Derive1类虚函数表的结构体才行:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1_CDerive1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (__stdcall* base1_fun1)(CBase1* that);</span><br><span class="line">    <span class="keyword">void</span>(__stdcall* derive1_fun1)(CDerive1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为CDerive1覆盖了CBase3的base3_fun1()函数, 所以不能直接用Base3的那个表:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3_CDerive1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base3_fun1)(CDerive1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Derive1覆盖Base3::base3_fun1()的函数以及自身定义的derive1_fun1()函数:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">base3_derive1_fun1</span><span class="params">(CDerive1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base3_derive1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">derive1_fun1</span><span class="params">(CDerive1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derive1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造各类的全局虚函数表"><a href="#构造各类的全局虚函数表" class="headerlink" title="构造各类的全局虚函数表"></a>构造各类的全局虚函数表</h5><p>由于没有了编译器的帮忙, 在定义一个类对象时, 所有的初始化工作都只能由我们自己来完成了!</p>
<p>首先构造全局的, 被同一个类共同使用的虚函数表!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CBase1 的虚函数表</span></span><br><span class="line">CBase1_VFTable __vftable_base1;</span><br><span class="line">__vftable_base1.base1_fun1 = base1_fun1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBase3 的虚函数表</span></span><br><span class="line">CBase3_VFTable __vftable_base3;</span><br><span class="line">__vftable_base3.base3_fun1 = base3_fun1;</span><br></pre></td></tr></table></figure>

<p>然后构造CDerive1和CBase1共同使用的虚函数表:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDerive1 和 CBase1 共用的虚函数表</span></span><br><span class="line">CBase1_CDerive1_VFTable __vftable_base1_derive1;</span><br><span class="line">__vftable_base1_derive1.base1_fun1 = base1_fun1;</span><br><span class="line">__vftable_base1_derive1.derive1_fun1 = derive1_fun1;</span><br></pre></td></tr></table></figure>

<p>再构造CDerive1覆盖CBase3后的虚函数表: 注意: 数覆盖会替换原来的函数指针</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBase3_CDerive1_VFTable __vftable_base3_derive1;</span><br><span class="line">__vftable_base3_derive1.base3_fun1 = base3_derive1_fun1;</span><br></pre></td></tr></table></figure>

<h5 id="开始-从CDerive1构造一个完整的Derive1类"><a href="#开始-从CDerive1构造一个完整的Derive1类" class="headerlink" title="开始! 从CDerive1构造一个完整的Derive1类"></a>开始! 从CDerive1构造一个完整的Derive1类</h5><p>先初始化成员变量与__vfptr的指向: 注意不是指错了!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CDerive1 d1;</span><br><span class="line">d1.derive1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">d1.base1.base1_1 = <span class="number">11</span>;</span><br><span class="line">d1.base1.__vfptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;__vftable_base1_derive1);</span><br><span class="line">    </span><br><span class="line">d1.base2.base2_1 = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">d1.base3.base3_1 = <span class="number">31</span>;</span><br><span class="line">d1.base3.__vfptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;__vftable_base3_derive1);</span><br></pre></td></tr></table></figure>

<p>由于目前的CDerive1是我们手动构造的, 不存在真正语法上的继承关系, 如要得到各基类指针, 我们就不能直接来取, 必须手动根据偏移计算:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;d1);</span><br><span class="line">Base1* pb1 = <span class="keyword">reinterpret_cast</span>&lt;Base1*&gt;(p + <span class="number">0</span>);</span><br><span class="line">Base2* pb2 = <span class="keyword">reinterpret_cast</span>&lt;Base2*&gt;(p + <span class="keyword">sizeof</span>(CBase1) + <span class="keyword">sizeof</span>(CBase3));</span><br><span class="line">Base3* pb3 = <span class="keyword">reinterpret_cast</span>&lt;Base3*&gt;(p + <span class="keyword">sizeof</span>(CBase1));</span><br><span class="line">Derive1* pd1 = <span class="keyword">reinterpret_cast</span>&lt;Derive1*&gt;(p);</span><br></pre></td></tr></table></figure>

<p>真正调用:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(pb1, pb2, pb3, pd1);</span><br></pre></td></tr></table></figure>

<p>调用结果:</p>
<p><img src="https://blog.twofei.com/496/last.png" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/08/16/二叉树的遍历方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/08/16/二叉树的遍历方式/" itemprop="url">二叉树的遍历方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T17:27:08+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）"><a href="#二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）" class="headerlink" title="二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）"></a>二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）</h2><p>前言：</p>
<p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。</p>
<p>四种主要的遍历思想为：</p>
<p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>
<p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p>
<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>
<p>层次遍历：只需按层次遍历即可</p>
<p>例如，求下面二叉树的各种遍历</p>
<p><img src="https://img-blog.csdn.net/20150204101904649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTXlfSm9icw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>前序遍历：1  2  4  5  7  8  3  6 </p>
<p>中序遍历：4  2  7  5  8  1  3  6</p>
<p>后序遍历：4  7  8  5  2  6  3  1</p>
<p>层次遍历：1  2  3  4  5  6  7  8</p>
<h4 id="1，前序遍历（先序遍历）"><a href="#1，前序遍历（先序遍历）" class="headerlink" title="1，前序遍历（先序遍历）"></a>1，前序遍历（先序遍历）</h4><p>根据上文提到的遍历思路：根结点 —&gt; 左子树 —&gt; 右子树，很容易写出递归版本</p>
<p>一般的正常遍历的递归代码</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt; 		<span class="keyword">if</span> (root != null) &#123;</span><br><span class="line">&gt; 			System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">&gt; 			preOrderTraverse1(root.left);</span><br><span class="line">&gt; 			preOrderTraverse1(root.right);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; <span class="comment">//下面是迭代的版本</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt; 		LinkedList&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&gt; 		TreeNode pNode = root;</span><br><span class="line">&gt; 		<span class="keyword">while</span> (pNode != null || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">&gt; 			<span class="keyword">if</span> (pNode != null) &#123;</span><br><span class="line">&gt; 				System.out.print(pNode.val+<span class="string">"  "</span>);</span><br><span class="line">&gt; 				<span class="built_in">stack</span>.push(pNode);</span><br><span class="line">&gt; 				pNode = pNode.left;</span><br><span class="line">&gt; 			&#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">&gt; 				TreeNode node = <span class="built_in">stack</span>.pop();</span><br><span class="line">&gt; 				pNode = node.right;</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是Leecode 144题就是先序遍历的题目</p>
<blockquote>
<p>给定一个二叉树，返回它的 前序 遍历。</p>
<p> 示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p>
<p>输出: [1,2,3]</p>
</blockquote>
<ul>
<li><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> &gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - int val;</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - TreeNode *left;</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - TreeNode *right;</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">    &gt; </span></span><br><span class="line"><span class="comment">    &gt; - &#125;;</span></span><br><span class="line"><span class="comment">    &gt;   */</span></span><br><span class="line">    &gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    &gt;   <span class="keyword">public</span>:</span><br><span class="line">    &gt;   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    &gt;      <span class="comment">//递归版本，效率极其低下</span></span><br><span class="line">    &gt;       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    &gt;       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;data;</span><br><span class="line">    &gt;       <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &gt;       &#123;</span><br><span class="line">    &gt;        result.push_back(root-&gt;val);</span><br><span class="line">    &gt;        data=preorderTraversal(root-&gt;left);</span><br><span class="line">    &gt;        result.insert(result.end(),data.begin(),data.end());</span><br><span class="line">    &gt;        data=preorderTraversal(root-&gt;right);</span><br><span class="line">    &gt;        result.insert(result.end(),data.begin(),data.end());</span><br><span class="line">    &gt;       &#125;</span><br><span class="line">    &gt;        <span class="keyword">return</span> result;</span><br><span class="line">    &gt;       <span class="comment">//下面是迭代版本</span></span><br><span class="line">    &gt;        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    &gt;        <span class="built_in">stack</span>&lt;TreeNode*&gt;data;</span><br><span class="line">    &gt;        TreeNode* a1=root;</span><br><span class="line">    &gt;       <span class="keyword">if</span>(a1==<span class="literal">NULL</span>)</span><br><span class="line">    &gt;         <span class="keyword">return</span> result;</span><br><span class="line">    &gt;       <span class="keyword">while</span>(a1!=<span class="literal">NULL</span>||!data.empty())</span><br><span class="line">&gt;       &#123;</span><br><span class="line">    &gt;           <span class="keyword">while</span>(a1!=<span class="literal">NULL</span>)</span><br><span class="line">&gt;           &#123;</span><br><span class="line"> &gt;               result.push_back(a1-&gt;val);   </span><br><span class="line"> &gt;               data.push(a1);</span><br><span class="line"> &gt;               a1=a1-&gt;left;</span><br><span class="line"> &gt;           &#125;</span><br><span class="line"> &gt;           <span class="keyword">if</span>(!data.empty())&#123;</span><br><span class="line"> &gt;           a1=data.top();</span><br><span class="line"> &gt;           data.pop(); </span><br><span class="line"> &gt;           a1=a1-&gt;right;</span><br><span class="line"> &gt;           &#125;</span><br><span class="line"> &gt;       &#125;</span><br><span class="line"> &gt;       <span class="keyword">return</span> result;</span><br><span class="line"> &gt; </span><br><span class="line"> &gt;   &#125;</span><br><span class="line"> &gt;   &#125;;</span><br><span class="line"> &gt; 执行用时 :<span class="number">4</span> ms, 在所有 C++ 提交中击败了<span class="number">84.55</span>%的用户</span><br><span class="line"> &gt; 内存消耗 :<span class="number">9.2</span> MB, 在所有 C++ 提交中击败了<span class="number">43.67</span>%的用户</span><br><span class="line"> &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="2，中序遍历"><a href="#2，中序遍历" class="headerlink" title="2，中序遍历"></a>2，中序遍历</h4><p>根据上文提到的遍历思路：左子树 —&gt; 根结点 —&gt; 右子树，很容易写出递归版本：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt; 		<span class="keyword">if</span> (root != null) &#123;</span><br><span class="line">&gt; 			inOrderTraverse1(root.left);</span><br><span class="line">&gt; 			System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">&gt; 			inOrderTraverse1(root.right);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;                                        </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt; 		LinkedList&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&gt; 		TreeNode pNode = root;</span><br><span class="line">&gt; 		<span class="keyword">while</span> (pNode != null || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">&gt; 			<span class="keyword">if</span> (pNode != null) &#123;</span><br><span class="line">&gt; 				<span class="built_in">stack</span>.push(pNode);</span><br><span class="line">&gt; 				pNode = pNode.left;</span><br><span class="line">&gt; 			&#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">&gt; 				TreeNode node = <span class="built_in">stack</span>.pop();</span><br><span class="line">&gt; 				System.out.print(node.val+<span class="string">"  "</span>);</span><br><span class="line">&gt; 				pNode = node.right;</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Leecode94题就是二叉树的中序遍历</p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">    - struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    - int val;</span></span><br><span class="line"><span class="comment">    - TreeNode *left;</span></span><br><span class="line"><span class="comment">    - TreeNode *right;</span></span><br><span class="line"><span class="comment">    - TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">    - &#125;;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">/* 递归</span></span><br><span class="line"><span class="comment">          vector&lt;int&gt;result;</span></span><br><span class="line"><span class="comment">          vector&lt;int&gt;data;</span></span><br><span class="line"><span class="comment">          if(root!=NULL)</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">           data=inorderTraversal(root-&gt;left);</span></span><br><span class="line"><span class="comment">           result.insert(result.end(),data.begin(),data.end());</span></span><br><span class="line"><span class="comment">           result.push_back(root-&gt;val);</span></span><br><span class="line"><span class="comment">           data=inorderTraversal(root-&gt;right);</span></span><br><span class="line"><span class="comment">           result.insert(result.end(),data.begin(),data.end());</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">           return result;*/</span></span><br><span class="line">          <span class="comment">//迭代 用栈</span></span><br><span class="line">          <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">          <span class="built_in">stack</span>&lt;TreeNode*&gt;data;</span><br><span class="line">          TreeNode* a=root;</span><br><span class="line">          <span class="keyword">while</span>(a||!data.empty())</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">while</span>(a!=<span class="literal">NULL</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                 data.push(a);</span><br><span class="line">              a=a-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           a=data.top();</span><br><span class="line">           data.pop();</span><br><span class="line">           result.push_back(a-&gt;val);</span><br><span class="line">           a=a-&gt;right;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h4 id="3，后序遍历"><a href="#3，后序遍历" class="headerlink" title="3，后序遍历"></a>3，后序遍历</h4><p>根据上文提到的遍历思路：左子树 —&gt; 右子树 —&gt; 根结点，很容易写出递归版本：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt; 		<span class="keyword">if</span> (root != null) &#123;</span><br><span class="line">&gt; 			postOrderTraverse1(root.left);</span><br><span class="line">&gt; 			postOrderTraverse1(root.right);</span><br><span class="line">&gt; 			System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Leecode145后序遍历二叉树</p>
<ul>
<li><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> &gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">    &gt; - struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    &gt; - int val;</span></span><br><span class="line"><span class="comment">    &gt; - TreeNode *left;</span></span><br><span class="line"><span class="comment">    &gt; - TreeNode *right;</span></span><br><span class="line"><span class="comment">    &gt; - TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">    &gt; - &#125;;</span></span><br><span class="line"><span class="comment">    &gt;   */</span></span><br><span class="line">    &gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    &gt;   <span class="keyword">public</span>:</span><br><span class="line">    &gt;   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    &gt;       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">    &gt;       <span class="built_in">stack</span>&lt;TreeNode*&gt;data;<span class="comment">//存放已经遍历的节点</span></span><br><span class="line">    &gt;       TreeNode* a=root; <span class="comment">//这个节点用于遍历整个二叉树</span></span><br><span class="line">    &gt;       TreeNode* last=root; <span class="comment">//设置的最后一次访问的节点      </span></span><br><span class="line">    &gt;       <span class="keyword">while</span>(a!=<span class="literal">NULL</span>||!data.empty())</span><br><span class="line">    &gt;       &#123;</span><br><span class="line">    &gt;           <span class="keyword">while</span>(a!=<span class="literal">NULL</span>)</span><br><span class="line">    &gt;           &#123;</span><br><span class="line">    &gt;               data.push(a);</span><br><span class="line">    &gt;               a=a-&gt;left;</span><br><span class="line">    &gt;           &#125;</span><br><span class="line">    &gt;               a=data.top();<span class="comment">//这一步是关键，因为不断的从占中获取最上面的元素。</span></span><br><span class="line">    &gt;               <span class="keyword">if</span>(a-&gt;right==<span class="literal">NULL</span>||a-&gt;right==last)</span><br><span class="line">    &gt;               &#123;</span><br><span class="line">    &gt;               result.push_back(a-&gt;val);</span><br><span class="line">    &gt;               data.pop();</span><br><span class="line">    &gt;               last=a;</span><br><span class="line">&gt;               a=<span class="literal">NULL</span>;              </span><br><span class="line"> &gt;                &#125;</span><br><span class="line"> &gt;           <span class="keyword">else</span></span><br><span class="line"> &gt;           &#123;</span><br><span class="line"> &gt;           a=a-&gt;right;</span><br><span class="line"> &gt;           &#125;</span><br><span class="line"> &gt;       &#125;</span><br><span class="line"> &gt;       <span class="keyword">return</span> result;</span><br><span class="line"> &gt;   &#125;</span><br><span class="line"> &gt;   &#125;;</span><br><span class="line"> &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="4，层序遍历"><a href="#4，层序遍历" class="headerlink" title="4，层序遍历"></a>4，层序遍历</h4><p>层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt; <span class="keyword">public</span>:</span><br><span class="line">&gt;     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelOrder(TreeNode* root) </span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">&gt;         <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">&gt;         <span class="keyword">if</span>(root)</span><br><span class="line">&gt;             q.push(root);</span><br><span class="line">&gt;         <span class="keyword">while</span>(!q.empty())</span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             TreeNode* temp = q.front();</span><br><span class="line">&gt;             ret.push_back(temp-&gt;val);</span><br><span class="line">&gt;             q.pop();</span><br><span class="line">&gt;             <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">&gt;                 q.push(temp-&gt;left);</span><br><span class="line">&gt;             <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">&gt;                 q.push(temp-&gt;right);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> ret;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Leecode 102题二叉树的层序遍历</p>
<ul>
<li><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">&gt; - struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">&gt; - int val;</span></span><br><span class="line"><span class="comment">&gt; - TreeNode *left;</span></span><br><span class="line"><span class="comment">&gt; - TreeNode *right;</span></span><br><span class="line"><span class="comment">&gt; - TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&gt; - &#125;;</span></span><br><span class="line"><span class="comment">&gt;   */</span></span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt;   <span class="keyword">public</span>:</span><br><span class="line">&gt;    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">&gt;       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">&gt;         pre(root,<span class="number">0</span>,result);</span><br><span class="line">&gt;        <span class="keyword">return</span> result;</span><br><span class="line">&gt;        </span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(TreeNode* root,<span class="keyword">int</span> i,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;result)</span></span></span><br><span class="line">&gt;    &#123;</span><br><span class="line">&gt;        <span class="keyword">if</span>(!root)</span><br><span class="line">&gt;            <span class="keyword">return</span>;</span><br><span class="line">&gt;        <span class="keyword">if</span>(i&gt;=result.size())</span><br><span class="line">&gt;        &#123;</span><br><span class="line">&gt;            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;&#125;);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        result[i].push_back(root-&gt;val);</span><br><span class="line">&gt;        pre(root-&gt;left,i+<span class="number">1</span>,result);</span><br><span class="line">&gt;        pre(root-&gt;right,i+<span class="number">1</span>,result);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>Leecode 107 二叉树的层序遍历II </p>
<ul>
<li><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - int val;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - TreeNode *left;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - TreeNode *right;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt; - &#125;;</span></span><br><span class="line"><span class="comment">&gt;   */</span></span><br><span class="line">&gt;   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt;   <span class="keyword">public</span>:</span><br><span class="line">&gt;    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">&gt;       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   ```</span><br><span class="line">&gt;     pre(root,<span class="number">0</span>,result);</span><br><span class="line">&gt;     <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result1(result.size());</span><br><span class="line">&gt;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.size();i++)</span><br><span class="line">&gt;    &#123;</span><br><span class="line">&gt;      result1[i]=result[result.size()<span class="number">-1</span>-i];  </span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">return</span> result1;</span><br><span class="line">&gt;   ```</span><br><span class="line">&gt; </span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(TreeNode* root,<span class="keyword">int</span> i,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;result)</span></span></span><br><span class="line">&gt;    &#123;</span><br><span class="line">&gt;        <span class="keyword">if</span>(!root)</span><br><span class="line">&gt;            <span class="keyword">return</span>;</span><br><span class="line">&gt;        <span class="keyword">if</span>(i&gt;=result.size())</span><br><span class="line">&gt;        &#123;</span><br><span class="line">&gt;            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;&#125;);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   ```</span><br><span class="line">&gt;    pre(root-&gt;left,i+<span class="number">1</span>,result);</span><br><span class="line">&gt;    pre(root-&gt;right,i+<span class="number">1</span>,result);</span><br><span class="line">&gt;    result[i].push_back(root-&gt;val);</span><br><span class="line">&gt;   ```</span><br><span class="line">&gt; </span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/08/13/递归的详细理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/08/13/递归的详细理解/" itemprop="url">递归的详细理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-13T16:44:58+08:00">
                2019-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、什么是递归"><a href="#一、什么是递归" class="headerlink" title="一、什么是递归"></a>一、什么是递归</h2><p>函数直接或间接调用自身的过程称为递归，相应的函数称为递归函数。使用递归算法，可以很容易地解决某些问题。此类问题的示例包括河内塔TOH，订单/预订/后序树遍历，图表DFS等。</p>
<h5 id="2-1递归时间复杂度"><a href="#2-1递归时间复杂度" class="headerlink" title="2.1递归时间复杂度"></a><strong><em>2.1递归时间复杂度</em></strong></h5><p>给出一个递归算法，其时间复杂度 O(T)通常是<strong>递归调用的数量</strong>（记作 {<em>R</em>） 和计算的时间复杂度的乘积（表示为 O(S)的乘积：<br>$$<br>O(T)=R∗O(s<br>)<br>$$</p>
<h5 id="2-1递归空间复杂度"><a href="#2-1递归空间复杂度" class="headerlink" title="2.1递归空间复杂度"></a><strong><em>2.1递归空间复杂度</em></strong></h5><h2 id="二、正常递归算法"><a href="#二、正常递归算法" class="headerlink" title="二、正常递归算法"></a>二、正常递归算法</h2><p>在递归程序中，提供了对基本情况的解决方案，并且用较小的问题表达了较大问题的解决方案。、</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; = <span class="number">1</span>) <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么在递归中发生堆栈溢出错误？</strong></p>
<p>在递归调用的过程中发生了不可能到达的情况，就可能会发生栈的溢出。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> (n = = <span class="number">100</span>) <span class="comment">// base case</span></span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;     <span class="keyword">else</span>    </span><br><span class="line">&gt;         <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);    </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在上面如果直接用fact(10);</p>
<h2 id="三、尾递归"><a href="#三、尾递归" class="headerlink" title="三、尾递归"></a>三、尾递归</h2><p><strong>尾递归和非尾递归有什么区别？</strong></p>
<p>当递归调用是函数执行的最后一件事时，递归函数是尾递归的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>&lt;&lt; n; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The last executed statement is recursive call </span></span><br><span class="line">    print(n<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑以下函数来计算n的阶乘。它是一种非尾递归函数。虽然看起来像尾巴递归。如果我们仔细看一下，我们可以看到事实（n-1）返回的值在事实（n）中使用，所以对事实（n-1）的调用不是事实（n）所做的最后一件事。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span>` `<span class="keyword">namespace</span>` `<span class="built_in">std</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// A NON-tail-recursive function.  The function is not tail </span></span><br><span class="line"><span class="comment">// recursive because the value returned by fact(n-1) is used in </span></span><br><span class="line"><span class="comment">// fact(n) and call to fact(n-1) is not the last thing done by fact(n) </span></span><br><span class="line"><span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `fact(<span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `n) </span><br><span class="line">&#123; </span><br><span class="line">    ``<span class="keyword">if</span>` `(n == <span class="number">0</span>) ``<span class="keyword">return</span>` `<span class="number">1</span>; </span><br><span class="line"> </span><br><span class="line">    ``<span class="keyword">return</span>` `n*fact(n<span class="number">-1</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// Driver program to test above function </span></span><br><span class="line"><span class="keyword">int</span>` `main() </span><br><span class="line">&#123; </span><br><span class="line">    ``<span class="built_in">cout</span> &lt;&lt; fact(<span class="number">5</span>); </span><br><span class="line">    ``<span class="keyword">return</span>` `<span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把上面的函数写成尾递归的样子，直接在函数最后调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span>` `<span class="keyword">namespace</span>` `<span class="built_in">std</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// A tail recursive function to calculate factorial </span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">factTR</span><span class="params">(<span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `n, <span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `a)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ``<span class="keyword">if</span>` `(n == <span class="number">0</span>)  ``<span class="keyword">return</span>` `a; </span><br><span class="line"> </span><br><span class="line">    ``<span class="keyword">return</span>` `factTR(n<span class="number">-1</span>, n*a); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// A wrapper over factTR </span></span><br><span class="line"><span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `fact(<span class="keyword">unsigned</span> ``<span class="keyword">int</span>` `n) </span><br><span class="line">&#123; </span><br><span class="line">   ``<span class="keyword">return</span>` `factTR(n, <span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// Driver program to test above function </span></span><br><span class="line"><span class="keyword">int</span>` `main() </span><br><span class="line">&#123; </span><br><span class="line">    ``<span class="built_in">cout</span> &lt;&lt; fact(<span class="number">5</span>); </span><br><span class="line">    ``<span class="keyword">return</span>` `<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-Fibonacci尾部调用优化"><a href="#3-1-Fibonacci尾部调用优化" class="headerlink" title="3.1 Fibonacci尾部调用优化"></a><strong><em>3.1 Fibonacci尾部调用优化</em></strong></h5><p>关于如何使用外部空间直接保存数据，但是可以优化程序的堆栈的数量。</p>
<p>正常的调用递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciRecursive</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">if</span>( n &lt; <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span>         <span class="keyword">return</span> n;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">return</span> (FibonacciRecursive(n<span class="number">-1</span>)+FibonacciRecursive(n<span class="number">-2</span>));</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>

<p>下面是当n=5的递归的情况</p>
<p><img src="https://images0.cnblogs.com/blog/305504/201303/04214621-bde3e339931444a1a56ce66dd73d1f9b.png" alt="img"></p>
<p>尾递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciTailRecursive</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> ret1,<span class="keyword">int</span> ret2)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span>    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line"><span class="number">4</span>       <span class="keyword">return</span> ret1;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">return</span> FibonacciTailRecursive(n<span class="number">-1</span>,ret2,ret1+ret2);</span><br><span class="line"><span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images0.cnblogs.com/blog/305504/201303/04221026-166e3bca62d14ea7bb37eee0e6390d2d.png" alt="img"></p>
<h5 id="3-2Quicksort尾部调用优化（将最坏情况空间减少到Log-n）"><a href="#3-2Quicksort尾部调用优化（将最坏情况空间减少到Log-n）" class="headerlink" title="3.2Quicksort尾部调用优化（将最坏情况空间减少到Log n）"></a>3.2<strong><em>Quicksort尾部调用优化（将最坏情况空间减少到Log n）</em></strong></h5><p>在一般的快排中，调用的不是尾递归。Quicksort的一个简单实现会对自身进行两次调用，最坏的情况是在函数调用堆栈上需要O（n）空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>` `quickSort(``<span class="keyword">int</span>` `arr[], ``<span class="keyword">int</span>` `low, ``<span class="keyword">int</span>` `high) </span><br><span class="line">&#123; </span><br><span class="line">    ``<span class="keyword">if</span>` `(low &lt; high) </span><br><span class="line">    ``&#123; </span><br><span class="line">        ``<span class="comment">/* pi is partitioning index, arr[p] is now </span></span><br><span class="line"><span class="comment">           ``at right place */</span></span><br><span class="line">        ``<span class="keyword">int</span>` `pi = partition(arr, low, high); </span><br><span class="line">  </span><br><span class="line">        ``<span class="comment">// Separately sort elements before </span></span><br><span class="line">        ``<span class="comment">// partition and after partition </span></span><br><span class="line">        ``quickSort(arr, low, pi - <span class="number">1</span>); </span><br><span class="line">        ``quickSort(arr, pi + <span class="number">1</span>, high); </span><br><span class="line">    ``&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是用尾递归优化的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>` `quickSort(``<span class="keyword">int</span>` `arr[], ``<span class="keyword">int</span>` `low, ``<span class="keyword">int</span>` `high) </span><br><span class="line">&#123; </span><br><span class="line">    ``<span class="keyword">while</span>` `(low &lt; high) </span><br><span class="line">    ``&#123; </span><br><span class="line">        ``<span class="keyword">int</span>` `pi = partition(arr, low, high); </span><br><span class="line">        ``<span class="keyword">if</span>` `(pi - low &lt; high - pi) </span><br><span class="line">        ``&#123; </span><br><span class="line">            ``quickSort(arr, low, pi - <span class="number">1</span>); </span><br><span class="line">            ``low = pi + <span class="number">1</span>; </span><br><span class="line">        ``&#125; </span><br><span class="line">        ``<span class="keyword">else</span></span><br><span class="line">        ``&#123; </span><br><span class="line">            ``quickSort(arr, pi + <span class="number">1</span>, high); </span><br><span class="line">            ``high = pi - <span class="number">1</span>; </span><br><span class="line">        ``&#125; </span><br><span class="line">    ``&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：Partition函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剑指offer书上的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> throws Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data==null||data.length&lt;=<span class="number">0</span>||start&lt;<span class="number">0</span>||end&gt;=data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Invalid Parameters"</span>);</span><br><span class="line">        <span class="keyword">int</span> index=RandomInRange(start,end);  <span class="comment">// 随机取一个标准元素</span></span><br><span class="line">        Swap(data,index,end);  <span class="comment">// 交换元素</span></span><br><span class="line">        <span class="keyword">int</span> small=start<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&lt;data[end]) &#123;</span><br><span class="line">                ++small;</span><br><span class="line">                <span class="keyword">if</span>(small!=i)</span><br><span class="line">                    Swap(data,i,small);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++small;</span><br><span class="line">        Swap(data,small,end);</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般数据结构书上的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> throws Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data==null||data.length&lt;=<span class="number">0</span>||start&lt;<span class="number">0</span>||end&gt;=data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Invalid Parameters"</span>);</span><br><span class="line">        <span class="keyword">int</span> index=RandomInRange(start,end);  <span class="comment">// 随机取一个标准元素</span></span><br><span class="line">        Swap(data,index,start);  <span class="comment">// 交换元素</span></span><br><span class="line">        <span class="keyword">int</span> temp=data[start];  <span class="comment">// 保存标准元素</span></span><br><span class="line">        <span class="keyword">int</span> i=start,j=end;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;data[i]&lt;=temp) j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                data[j]=data[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;temp&lt;=data[j]) i++;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                data[i]=data[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[i]=temp;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2019/08/05/动态规划相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2019/08/05/动态规划相关/" itemprop="url">动态规划问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T21:24:29+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>​         动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划(DP)</p>
<p>在什么时候需要使用动态规划？</p>
<p> 如果要求一个问题的<strong>最优解</strong>（通常是最大值或者最小值），而且该问题能够<strong>分解成若干个子问题，并且小问题之间也存在重叠的子问题</strong>，则考虑采用动态规划。</p>
<h2 id="2、基本思想和策略"><a href="#2、基本思想和策略" class="headerlink" title="2、基本思想和策略"></a>2、基本思想和策略</h2><p>​         基本思想与<strong>分治法</strong>类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<h2 id="3、相关的问题思路和过程"><a href="#3、相关的问题思路和过程" class="headerlink" title="3、相关的问题思路和过程"></a>3、相关的问题思路和过程</h2><p>一、最短路径的问题</p>
<p>给定一个矩阵m，从左上角开始每次只能向右走或者向下走，最后达到右下角的位置，路径中所有数字累加起来就是路径和，返回所有路径的最小路径和，如果给定的m如下，那么路径1,3,1,0,6,1,0就是最小路径和，返回12.</p>
<p>1 3 5 9<br>8 1 3 4<br>5 0 6 1<br>8 8 4 0</p>
<p>分析可知；由分析可知：走到第(i ,j)个数时，只可能是从(i-1 ,j)或是(i ,j-1)走来的，路径(i ,j)的阶段依赖的是(i-1 ,j)和(i ,j-1)的子阶段，所以状态转移方程为<br>$$<br>dp[i][j] =a[i][j] + min(dp[i-1][j]+ dp[i][j-1])，<br>$$</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">&gt; <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">int</span> dp[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#125;;     <span class="comment">//全局数组，存放决策表</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; 	<span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>&#125;;  <span class="comment">//矩阵存储a[i][j]</span></span><br><span class="line">&gt; 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)</span><br><span class="line">&gt; 	&#123;</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;++j)</span><br><span class="line">&gt; 		&#123;</span><br><span class="line">&gt; 			<span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)                         <span class="comment">//边界条件问题需要考虑到</span></span><br><span class="line">&gt; 			&#123;</span><br><span class="line">&gt; 				dp[i][j] = a[i][j];</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 			<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; j!=<span class="number">0</span>)</span><br><span class="line">&gt; 			&#123;</span><br><span class="line">&gt; 				dp[i][j] = a[i][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 			<span class="keyword">else</span> <span class="keyword">if</span> (i!=<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)</span><br><span class="line">&gt; 			&#123;</span><br><span class="line">&gt; 				dp[i][j] = a[i][j] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 			<span class="keyword">else</span></span><br><span class="line">&gt; 			&#123;</span><br><span class="line">&gt; 				dp[i][j] = a[i][j] + min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; ```</span><br><span class="line">&gt; <span class="built_in">cout</span>&lt;&lt;<span class="string">"走到位置"</span>&lt;&lt;<span class="string">"(4,4)"</span>&lt;&lt;<span class="string">"最短路径为："</span>;</span><br><span class="line">&gt; <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">3</span>][<span class="number">3</span>]&lt;&lt;<span class="built_in">endl</span>;           <span class="comment">//好像到这里又脑残了一次，真输出dp[4][4]了~</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt; system(<span class="string">"pause"</span>);</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt; ```</span><br><span class="line">&gt; </span><br><span class="line">&gt; ## &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>二、剪绳子问题<br>给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n&gt;1并且m&gt;1)每段绳子的长度记为k[0],k[1],…,k[m].请问k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？</p>
<p>分析：此时绳子的长度是m，但是每一次都可以分为<br>$$<br>k[1]k[m-1]k[2]k[m-2]…….k[m/2][m/2+1]<br>$$<br>然后比如k[1]k[m-1] 其中的k[m-1]又同样可以分为一直向下分，一直到找出最优解<br>$$<br>k[1]k[m-2]k[2]k[m-3]…….k[m/2][m/2]<br>$$</p>
<blockquote>
<ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cutting</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">&gt;   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;value;<span class="comment">//长度小于等等于1没办法剪</span></span><br><span class="line">&gt;     <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) </span><br><span class="line">&gt;      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="comment">//对于f(2)，长度为2的绳子，只有一种剪法，剪成两段长度为1的绳子，剪后的乘积为1</span></span><br><span class="line">&gt;     <span class="keyword">if</span>(n == <span class="number">2</span>)    </span><br><span class="line">&gt;      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;     <span class="comment">//对于f(3)，长度为3的绳子，只有一种剪法，剪成两段长度为1和2的绳子，但剪后的乘积为2</span></span><br><span class="line">&gt;     <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">&gt;      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&gt;     <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="comment">//数组用于存储绳子乘积最大值</span></span><br><span class="line">&gt;     <span class="keyword">int</span> value[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">&gt;   value[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&gt;   value[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&gt;   value[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">&gt;   value[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">&gt;   <span class="comment">// value[i]=k;</span></span><br><span class="line">&gt;     <span class="comment">//从f(4)开始迭代</span></span><br><span class="line">&gt;     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>;i &lt;= n; i++) &#123;</span><br><span class="line">&gt;    max = <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> val = value[j] * value[i - j];</span><br><span class="line">&gt;     <span class="comment">//不同于递推，这里对每一个的值做了一次舍弃。</span></span><br><span class="line">&gt;    max = val &gt; max ? val : max;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      value[i] = max;</span><br><span class="line">&gt;      <span class="comment">//当下一次又有这样子的分类的时候，这里的value[i]的值可以直接带进去，不用计算。</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     max = value[n];</span><br><span class="line">&gt;     <span class="keyword">return</span> max;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>三、背包问题的动态规划</p>
<p>给定一组多个n物品，每种物品都有自己的重量w[i]和价值（v[i]），在限定的总重量/总容量（maxw）内，选择其中若干个（也即每种物品可以选0个或1个），设计选择方案使得物品的总价值最高。</p>
<p>代码如下，并没有理解的很好。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line">&gt; <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">int</span> n, MaxValue;</span><br><span class="line">&gt; <span class="keyword">int</span> w[MAXN + <span class="number">1</span>], v[MAXN + <span class="number">1</span>];</span><br><span class="line">&gt; <span class="keyword">int</span> dp[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; 	<span class="keyword">int</span> w[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">&gt; 	<span class="keyword">int</span> v[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">&gt; 	<span class="keyword">int</span> maxW = <span class="number">8</span>;</span><br><span class="line">&gt; 	<span class="keyword">int</span> dp[<span class="number">5</span>][<span class="number">9</span>] = &#123; &#123;<span class="number">0</span>&#125; &#125;;</span><br><span class="line">&gt; 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= maxW; j++)</span><br><span class="line">&gt; 		&#123;</span><br><span class="line">&gt; 			<span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">&gt; 				dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">&gt; 			<span class="keyword">else</span> &#123;</span><br><span class="line">&gt; 				dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;     <span class="comment">//return dp[4][maxW];</span></span><br><span class="line">&gt; 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&gt; 	&#123;</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">&gt; 		&#123;</span><br><span class="line">&gt; 			<span class="built_in">cout</span> &lt;&lt; <span class="string">"dp["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; j &lt;&lt; <span class="string">"]===="</span> &lt;&lt; dp[i][j] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是输出的内容</p>
<blockquote>
<ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   dp[<span class="number">0</span>][<span class="number">0</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">1</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">2</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">3</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">4</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">5</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">6</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">7</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">8</span>]====<span class="number">0</span></span><br><span class="line">&gt;   dp[<span class="number">1</span>][<span class="number">0</span>]====<span class="number">0</span>  dp[<span class="number">1</span>][<span class="number">1</span>]====<span class="number">0</span>  dp[<span class="number">1</span>][<span class="number">2</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">3</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">4</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">5</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">6</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">7</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">8</span>]====<span class="number">3</span></span><br><span class="line">&gt;   dp[<span class="number">2</span>][<span class="number">0</span>]====<span class="number">0</span>  dp[<span class="number">2</span>][<span class="number">1</span>]====<span class="number">0</span>  dp[<span class="number">2</span>][<span class="number">2</span>]====<span class="number">3</span>  dp[<span class="number">2</span>][<span class="number">3</span>]====<span class="number">4</span>  dp[<span class="number">2</span>][<span class="number">4</span>]====<span class="number">4</span>  dp[<span class="number">2</span>][<span class="number">5</span>]====<span class="number">7</span>  dp[<span class="number">2</span>][<span class="number">6</span>]====<span class="number">7</span>  dp[<span class="number">2</span>][<span class="number">7</span>]====<span class="number">7</span>  dp[<span class="number">2</span>][<span class="number">8</span>]====<span class="number">7</span> </span><br><span class="line">&gt;   dp[<span class="number">3</span>][<span class="number">0</span>]====<span class="number">0</span>  dp[<span class="number">3</span>][<span class="number">1</span>]====<span class="number">0</span>  dp[<span class="number">3</span>][<span class="number">2</span>]====<span class="number">3</span>  dp[<span class="number">3</span>][<span class="number">3</span>]====<span class="number">4</span>  dp[<span class="number">3</span>][<span class="number">4</span>]====<span class="number">5</span>  dp[<span class="number">3</span>][<span class="number">5</span>]====<span class="number">7</span>  dp[<span class="number">3</span>][<span class="number">6</span>]====<span class="number">8</span>  dp[<span class="number">3</span>][<span class="number">7</span>]====<span class="number">9</span>  dp[<span class="number">3</span>][<span class="number">8</span>]====<span class="number">9</span></span><br><span class="line">&gt;   dp[<span class="number">4</span>][<span class="number">0</span>]====<span class="number">0</span>  dp[<span class="number">4</span>][<span class="number">1</span>]====<span class="number">0</span>  dp[<span class="number">4</span>][<span class="number">2</span>]====<span class="number">3</span>  dp[<span class="number">4</span>][<span class="number">3</span>]====<span class="number">4</span>  dp[<span class="number">4</span>][<span class="number">4</span>]====<span class="number">5</span>  dp[<span class="number">4</span>][<span class="number">5</span>]====<span class="number">7</span>  dp[<span class="number">4</span>][<span class="number">6</span>]====<span class="number">8</span>  dp[<span class="number">4</span>][<span class="number">7</span>]====<span class="number">9</span>  dp[<span class="number">4</span>][<span class="number">8</span>]====<span class="number">10</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>四、零钱问题</p>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<ol>
<li><blockquote>
<p>输入: amount = 5, coins = [1, 2, 5]<br>输出: 4<br>解释: 有四种方式可以凑成总金额:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p>
</blockquote>
</li>
</ol>
<p>如果一直用递归做，中间会有重复计算的过程，时间大大增加，用动态规划做。</p>
<p><strong>方法一</strong>      </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(amount&lt;<span class="number">0</span>||(coins.size()==<span class="number">0</span>&amp;&amp;amount!=<span class="number">0</span>))</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(coins.size()==<span class="number">0</span>&amp;&amp;amount==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(coins.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;coins.size();i++)</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;amount+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%coins[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">0</span>;         </span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;coins.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;coins[i])</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j-coins[i]];</span><br><span class="line">        &#125;                           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[coins.size()<span class="number">-1</span>][amount];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这个方法直接构造的是dp[零钱的种类的多少][指定金额的大小]做的动态规划，但是问题就是很大一部分其实没有用，虽然比递归时间短，但是还是很大。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">if</span>(amount&lt;<span class="number">0</span>||(coins.size()==<span class="number">0</span>&amp;&amp;amount!=<span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(coins.size()==<span class="number">0</span>&amp;&amp;amount==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(amount+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=coins[k];k&lt;coins.size();k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(j&gt;=coins[k])</span><br><span class="line">               dp[j]=dp[j]+dp[j-coins[k]];</span><br><span class="line">                                 &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这个应该是个极大的优化了dp[指定金额大小的种类]</span></span><br><span class="line"> <span class="comment">//dp[j]=dp[j]+dp[j-coins[k]];</span></span><br></pre></td></tr></table></figure>

<p>五、字符串问题</p>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<blockquote>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符<br>示例 1:</p>
<p>输入: word1 = “horse”, word2 = “ros”<br>输出: 3<br>解释:<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
</blockquote>
<p>*典型动态规划题：<br>          *状态的定义：将word1前i个字符转化为word2前j个字符最少需要dp[i][j]步；<br>          *状态转移方程：<br>             *若当前两字符相等word1[i] == word2[j]，则易得最小步数不变dp[i][j] = dp[i-1][j-1]；<br>             *否则，最小步数为增删改的步数1 + 增删改后对应的最小步数，即dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])，具体有3种情况：<br>                *dp[i-1][j] + 删除word1[i]操作；（删除word1[i]后就从dp[i][j]转化为了dp[i-1][j]，以下同理）<br>                *dp[i][j-1] + 在word1[i]后添加word2[j]操作；<br>                *dp[i-1][j-1] + 将word1[i]修改为word2[j]操作。<br>        *返回dp[-1][-1]，即为最少步数。<br>*时空间复杂度均为 O(MN)O(MN)</p>
<p>代码如下；</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt; <span class="keyword">public</span>:</span><br><span class="line">&gt;     <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;     </span><br><span class="line">&gt;         <span class="comment">/*int leng1=word1.length();</span></span><br><span class="line"><span class="comment">&gt;         int leng2=word2.length();</span></span><br><span class="line"><span class="comment">&gt;     </span></span><br><span class="line"><span class="comment">&gt;         vector&lt;vector&lt;int&gt;&gt;dp(leng1+1,vector&lt;int&gt;(leng2+1));</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt;         for(int i=0;i&lt;=leng1;i++)</span></span><br><span class="line"><span class="comment">&gt;         &#123;</span></span><br><span class="line"><span class="comment">&gt;             dp[i][0]=i;</span></span><br><span class="line"><span class="comment">&gt;         &#125;</span></span><br><span class="line"><span class="comment">&gt;         for(int j=0;j&lt;=leng2;j++)</span></span><br><span class="line"><span class="comment">&gt;         &#123;</span></span><br><span class="line"><span class="comment">&gt;             dp[0][j]=j;</span></span><br><span class="line"><span class="comment">&gt;             </span></span><br><span class="line"><span class="comment">&gt;         &#125;</span></span><br><span class="line"><span class="comment">&gt;         for(int i=1;i&lt;=leng1;i++)</span></span><br><span class="line"><span class="comment">&gt;         &#123;</span></span><br><span class="line"><span class="comment">&gt;             for(int j=1;j&lt;=leng2;j++)</span></span><br><span class="line"><span class="comment">&gt;             &#123;</span></span><br><span class="line"><span class="comment">&gt;                 if(word1[i-1]==word2[j-1])</span></span><br><span class="line"><span class="comment">&gt;                     dp[i][j]=dp[i-1][j-1];</span></span><br><span class="line"><span class="comment">&gt;                 else</span></span><br><span class="line"><span class="comment">&gt;                 &#123;</span></span><br><span class="line"><span class="comment">&gt;                 dp[i][j]=1+min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));</span></span><br><span class="line"><span class="comment">&gt;                 &#125;</span></span><br><span class="line"><span class="comment">&gt;             &#125;</span></span><br><span class="line"><span class="comment">&gt;         &#125;</span></span><br><span class="line"><span class="comment">&gt;         return dp[leng1][leng2];</span></span><br><span class="line"><span class="comment">&gt;         */</span></span><br><span class="line">&gt;         <span class="keyword">int</span> leng1=word1.length();</span><br><span class="line">&gt;         <span class="keyword">int</span> leng2=word2.length();</span><br><span class="line">&gt;         <span class="keyword">if</span>(leng1==<span class="number">0</span>)</span><br><span class="line">&gt;             <span class="keyword">return</span> leng2;</span><br><span class="line">&gt;         <span class="keyword">if</span>(leng2==<span class="number">0</span>)</span><br><span class="line">&gt;             <span class="keyword">return</span> leng1;</span><br><span class="line">&gt;             </span><br><span class="line">&gt;         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(leng2+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=leng1;i++)</span><br><span class="line">&gt;             dp[i]=i;            </span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=leng2;i++)</span><br><span class="line">&gt;             dp[<span class="number">0</span>]=i;</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=leng1;i++)</span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=leng2;j++)</span><br><span class="line">&gt;             &#123;</span><br><span class="line">&gt;                 <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])</span><br><span class="line">&gt;                     dp[j]=dp[<span class="number">0</span>];</span><br><span class="line">&gt;                 <span class="keyword">else</span>&#123;</span><br><span class="line">&gt;                     dp[j]=<span class="number">1</span>+min(dp[<span class="number">0</span>],min(dp[j],dp[j<span class="number">-1</span>]));</span><br><span class="line">&gt;                      &#125;</span><br><span class="line">&gt;                 dp[<span class="number">0</span>]=dp[j];</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> dp[leng2];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; <span class="comment">//上面有两段dp代码，第二个只用了有个数组，性能应该会有提升。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>还是一个字符串的问题</p>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度</p>
<blockquote>
<ol>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;   输入:</span><br><span class="line">&gt;   A: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">&gt;   B: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">&gt;   输出: <span class="number">3</span></span><br><span class="line">&gt;   解释: </span><br><span class="line">&gt;   长度最长的公共子数组是 [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]。         </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt; <span class="keyword">public</span>:</span><br><span class="line">&gt;     <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;    </span><br><span class="line">&gt;     <span class="keyword">int</span> n=A.size();</span><br><span class="line">&gt;     <span class="keyword">int</span> m=B.size();</span><br><span class="line">&gt;     <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>)</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">&gt;     <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">&gt;     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">&gt;             <span class="keyword">if</span>(A[i<span class="number">-1</span>]==B[j<span class="number">-1</span>])&#123;</span><br><span class="line">&gt;                 dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&gt;                 out=max(out,dp[i][j]); </span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">return</span> out;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; <span class="comment">//可以想一下 是不是有更好的办法 dp[][]--转化为一个dp[];</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>六、通配符的匹配(Leecode44题)</p>
<blockquote>
<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。<br>示例 1:</p>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p>
<p>输入:<br>s = “aa”<br>p = “*”<br>输出: true<br>解释: ‘*’ 可以匹配任意字符串。<br>示例 3:</p>
<p>输入:<br>s = “cb”<br>p = “?a”<br>输出: false<br>解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。<br>示例 4:</p>
<p>输入:<br>s = “adceb”<br>p = “<em>a</em>b”<br>输出: true<br>解释: 第一个 ‘<em>‘ 可以匹配空字符串, 第二个 ‘</em>‘ 可以匹配字符串 “dce”.<br>示例 5:</p>
<p>输入:<br>s = “acdcb”<br>p = “a*c?b”<br>输入: false</p>
</blockquote>
<p>这个题目可以说是标准的动态规划的题目</p>
<p><code>dp[i][j]</code>表示<code>s</code>到<code>i位置</code>,<code>p</code>到<code>j</code>位置是否匹配!</p>
<p>初始化:</p>
<ol>
<li><code>dp[0][0]</code>:什么都没有,所以为<code>true</code></li>
<li>第一行<code>dp[0][j]</code>,换句话说,<code>s</code>为空,与<code>p</code>匹配,所以只要<code>p</code>开始为<code>*</code>才为<code>true</code></li>
<li>第一列<code>dp[i][0]</code>,当然全部为<code>False</code></li>
</ol>
<p>动态方程:</p>
<ol>
<li><p>如果<code>(s[i] == p[j] || p[j] == &quot;?&quot;) &amp;&amp; dp[i-1][j-1]</code> ,有<code>dp[i][j] = true</code></p>
</li>
<li><p>如果<code>p[j] == &quot;*&quot; &amp;&amp; (dp[i-1][j] = true || dp[i][j-1] = true)</code>有<code>dp[i][j] = true</code></p>
<p>​    note:</p>
<p>​    <code>dp[i-1][j]</code>,表示<code>*</code>代表是空字符,例如<code>ab,ab*</code></p>
<p>​    <code>dp[i][j-1]</code>,表示<code>*</code>代表非空任何字符,例如<code>abcd,ab*</code></p>
</li>
</ol>
<p>代码如下</p>
<p>​        </p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt; <span class="keyword">public</span>:</span><br><span class="line">&gt;     <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">if</span>(p.length()==<span class="number">1</span>&amp;&amp;p[<span class="number">0</span>]==<span class="string">'*'</span>)</span><br><span class="line">&gt;            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&gt;        <span class="keyword">int</span> m=s.length();</span><br><span class="line">&gt;        <span class="keyword">int</span> n=p.length();  </span><br><span class="line">&gt; <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">&gt;     dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">&gt;              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;         <span class="keyword">if</span>(p[i<span class="number">-1</span>]==<span class="string">'*'</span>)</span><br><span class="line">&gt;             dp[<span class="number">0</span>][i]=<span class="literal">true</span>;</span><br><span class="line">&gt;         <span class="keyword">else</span></span><br><span class="line">&gt;             <span class="keyword">break</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">&gt;            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">&gt;                 <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">'*'</span>)</span><br><span class="line">&gt;                 &#123;</span><br><span class="line">&gt;                     dp[i][j]=dp[i][j<span class="number">-1</span>]||dp[i<span class="number">-1</span>][j];</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">'?'</span>||s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>])</span><br><span class="line">&gt;                &#123;</span><br><span class="line">&gt;                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;                   <span class="keyword">else</span></span><br><span class="line">&gt;                       dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">&gt;            &#125;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;     <span class="comment">//现在我把二维数组换成一维数组 看看能不能提升时间</span></span><br><span class="line">&gt;   <span class="comment">/* vector&lt;bool&gt;dp(n+1,false);</span></span><br><span class="line"><span class="comment">&gt;     dp[0]=true;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt;     for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">&gt;     &#123;</span></span><br><span class="line"><span class="comment">&gt;         if(p[i-1]=='*')</span></span><br><span class="line"><span class="comment">&gt;             dp[i]=true;</span></span><br><span class="line"><span class="comment">&gt;         else</span></span><br><span class="line"><span class="comment">&gt;             break;</span></span><br><span class="line"><span class="comment">&gt;     &#125;</span></span><br><span class="line"><span class="comment">&gt;   for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">&gt;            for(int j=1;j&lt;=m;j++)&#123;</span></span><br><span class="line"><span class="comment">&gt;              if(p[i-1]=='*')</span></span><br><span class="line"><span class="comment">&gt;              &#123;</span></span><br><span class="line"><span class="comment">&gt;                  dp[i]=dp[i-1];</span></span><br><span class="line"><span class="comment">&gt;                  break;</span></span><br><span class="line"><span class="comment">&gt;              &#125;</span></span><br><span class="line"><span class="comment">&gt;                else if(p[i-1]=='?'||s[j-1]==p[i-1])</span></span><br><span class="line"><span class="comment">&gt;                &#123;</span></span><br><span class="line"><span class="comment">&gt;                    dp[i]=dp[i-1];</span></span><br><span class="line"><span class="comment">&gt;                    break;</span></span><br><span class="line"><span class="comment">&gt;                &#125;</span></span><br><span class="line"><span class="comment">&gt;                   else</span></span><br><span class="line"><span class="comment">&gt;                       dp[i]=false;</span></span><br><span class="line"><span class="comment">&gt;                if(s[m]!=p[n]||p[n]!='*')</span></span><br><span class="line"><span class="comment">&gt;                &#123;</span></span><br><span class="line"><span class="comment">&gt;                    dp[n]=false;</span></span><br><span class="line"><span class="comment">&gt;                &#125;</span></span><br><span class="line"><span class="comment">&gt;               </span></span><br><span class="line"><span class="comment">&gt;            &#125;</span></span><br><span class="line"><span class="comment">&gt;   &#125;</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="keyword">return</span> dp[n];</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​         <strong>上面的题目我想用一个vector数组表示 前i的p字符串与s匹配的真假，但是忽略了这里需要s数组需要完全匹配,如下所示</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string s=aa;</span><br><span class="line">&gt; string p=a;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Leecode 115没有弄递推关系</p>
<p>给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。</p>
<p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<blockquote>
<p>示例 1:</p>
<p>输入: S = “rabbbit”, T = “rabbit”<br>输出: 3<br>解释:</p>
<p>如下图所示, 有 3 种可以从 S 中得到 “rabbit” 的方案。<br>(上箭头符号 ^ 表示选取的字母)</p>
<p>rabbbit<br>^^^^ ^^<br>rabbbit<br>^^ ^^^^<br>rabbbit<br>^^^ ^^^<br>示例 2:</p>
<p>输入: S = “babgbag”, T = “bag”<br>输出: 5<br>解释:</p>
<p>如下图所示, 有 5 种可以从 S 中得到 “bag” 的方案。<br>(上箭头符号 ^ 表示选取的字母)</p>
<p>babgbag<br>^^ ^<br>babgbag<br>^^    ^<br>babgbag<br>^    ^^<br>babgbag<br>  ^  ^^<br>babgbag<br>    ^^^</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划 但是效率并不高 20ms 35.83%</span></span><br><span class="line"><span class="comment">     * 大部分都是二维动态规划 有的代码相同但是是5ms 估计是测试用例有变动</span></span><br><span class="line"><span class="comment">     * 但是看到还是有节省的算法 所以一步一步往下优化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    *  b  a  b  g  b  a  g</span></span><br><span class="line"><span class="comment">     * *  1  1  1  1  1  1  1  1</span></span><br><span class="line"><span class="comment">     * b  0  1  1  2  2  3  3  3</span></span><br><span class="line"><span class="comment">     * a  0  0  1  1  1  1  4  4</span></span><br><span class="line"><span class="comment">     * g  0  0  0  0  1  1  1  5</span></span><br><span class="line"><span class="comment">     * @param s</span></span><br><span class="line"><span class="comment">     * @param t</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i<span class="number">-1</span>) == s.charAt(j<span class="number">-1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i][j<span class="number">-1</span>];<span class="comment">//为什么？？？？</span></span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二维换一维 严格按照二维的流程 参见上面矩阵 这个是15ms</span></span><br><span class="line"><span class="comment">     * @param s</span></span><br><span class="line"><span class="comment">     * @param t</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct2</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//每行算一次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//0-n算n+1次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">                <span class="comment">//先保存dp[j]下次用</span></span><br><span class="line">                <span class="keyword">int</span> temp = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(t.charAt(i) == s.charAt(j<span class="number">-1</span>))&#123;</span><br><span class="line">                        dp[j] = dp[j<span class="number">-1</span>] + pre;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[j] = dp[j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/bolgzxy.github.io/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/bolgzxy.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/bolgzxy.github.io/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/bolgzxy.github.io/images/user.jpg" alt="半世烟尘">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/bolgzxy.github.io/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/bolgzxy.github.io/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/bolgzxy.github.io/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/COTVZHAOYUEXING" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1998lovexs@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/bolgzxy.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
