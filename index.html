<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/bolgzxy.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/bolgzxy.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/bolgzxy.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/bolgzxy.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/bolgzxy.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/bolgzxy.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:type" content="website">
<meta property="og:title" content="し半世烟尘">
<meta property="og:url" content="https://yoursite.com/index.html">
<meta property="og:site_name" content="し半世烟尘">
<meta property="og:description" content="黄沙百战穿金甲，不破楼兰誓不还。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="し半世烟尘">
<meta name="twitter:description" content="黄沙百战穿金甲，不破楼兰誓不还。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/bolgzxy.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/">





  <title>し半世烟尘</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/bolgzxy.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">し半世烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/bolgzxy.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/bolgzxy.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/bolgzxy.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/bolgzxy.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/面试/深信服面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/面试/深信服面试/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="深信服面试总结"><a href="#深信服面试总结" class="headerlink" title="深信服面试总结"></a>深信服面试总结</h3><h6 id="1-、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？"><a href="#1-、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？" class="headerlink" title="1 、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？"></a>1 、为什么有结构体，结构体的优势；结构体内存对齐，对齐的好处；为什么更快？</h6><p><strong><em>答案：因为在实际问题中，一组数据往往有很多种不同的数据类型，例如，登记学生的信息，可能需要用到 char型的姓名，int型或 char型的学号，int型的年龄，char型的性别，float型的成绩。又例如，对于记录一本书，需要 char型的书名，char型的作者名，float型的价格。在这些情况下，使用简单的基本数据类型甚至是数组都是很困难的。而结构体（类似Pascal中的“记录”），则可以有效的解决这个问题。<br>结构体本质上还是一种数据类型，但它可以包括若干个“成员”，每个成员的类型可以相同也可以不同，也可以是基本数据类型或者又是一个构造类型。</em></strong></p>
<h6 id="2、联合体和结构体的区别，变长结构体的实现。"><a href="#2、联合体和结构体的区别，变长结构体的实现。" class="headerlink" title="2、联合体和结构体的区别，变长结构体的实现。"></a>2、联合体和结构体的区别，变长结构体的实现。</h6><p><strong>联合体</strong>：</p>
<ol>
<li><p>在联合体abc中，整型量i和字符m公用同一内存位置。</p>
</li>
<li><p>当一个联合被说明时，编译程序自动地产生一个变量，其长度为联合中最大的变量长度。、</p>
</li>
<li><p>联合体变量所占内存长度是各最长的成员占的内存长度。</p>
</li>
<li><p>联合体变量中起作用的成员是最后一次存放的成员，在存入新的成员后原有的成员失去了作用！</p>
</li>
</ol>
<p>用途：使几个不同类型的变量共占一段内存<em>(</em>相互覆盖<em>)</em></p>
<p><strong>结构体</strong>是一种构造数据类型</p>
<p>结构体变量所占内存长度是各成员占的内存长度的总和。</p>
<p>用途：把不同类型的数据组合成一个整体<em>——-</em>自定义数据类型</p>
<p><em>1. struct<em>和</em>union*都是由多个不同的数据类型成员组成</em>,* 但在任何同一时刻<em>, union*中只存放了一个被选中的成员</em>,* 而<em>struct</em>的所有成员都存在。在<em>struct</em>中，各成员都占有自己的内存空间，它们是同时存在的。一个<em>struct</em>变量的总长度等于所有成员长度之和。在<em>Union</em>中，所有成员不能同时占用它的内存空间，它们不能同时存在。<em>Union</em>变量的长度等于最长的成员的长度。</p>
<p><em>2.</em> 对于<em>union*的不同成员赋值</em>,* 将会对其它成员重写<em>,</em> 原来成员的值就不存在了<em>,</em> 而对于<em>struct</em>的不同成员赋值是互不影响的。</p>
<p><strong>变长结构体的实现</strong></p>
<p>为什么会有变长结构体?</p>
<p> 项目中用到数据包的处理，但包的大小是不固定的，其长度由包头的2字节决定。比如如下的包头：88 0f 0a ob cd ef 23 00 。长度由头2个字节880f决定，考虑字节序，转为0f88，转为10进制3976个字节的包长度。</p>
<p>​    这个时候存储包的时候，一方面可以考虑设定包的大小固定：如4K=4*1024=4096个字节，因为最大包长不可能超过4k，但该方法的有缺陷，存在一种极端就是包最小仅含包头不含数据域，此时包为8个字节，浪费了4096-8 =4088个字节的存储空间。另一方面考虑有没有一种方法能根据长度进行存储，或者说初始不分配长度，计算出了长度后再分配存储呢。而实际项目中正是通过包头计算出了包的整体大小的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Var_Len_Struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> nsize;</span><br><span class="line">     <span class="keyword">char</span> buffer[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面是为什么要用数组，而不是指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">0</span>];</span><br><span class="line">&#125;Empty;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> *y;</span><br><span class="line">&#125;Ptr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//变长结构体申请内存</span></span><br><span class="line">    Empty *p_array = (Empty *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Empty) + <span class="number">100</span>);  <span class="comment">//可以看到这里直接申请了变长结     构体大小的空间再加100字节,这100字节就相当于是给char b[0]用的了</span></span><br><span class="line">    <span class="comment">//常规方式申请内存,先申请结构体的,再申请指针的</span></span><br><span class="line">    Ptr *p_ptr = (Ptr *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Ptr));</span><br><span class="line">    p_ptr-&gt;y = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//初始化malloc申请的内存</span></span><br><span class="line">    <span class="built_in">memset</span>(p_array, <span class="number">0</span>, <span class="keyword">sizeof</span>(p_array));</span><br><span class="line">    <span class="built_in">memset</span>(p_ptr, <span class="number">0</span>, <span class="keyword">sizeof</span>(p_ptr));</span><br><span class="line">    <span class="built_in">memset</span>(p_ptr-&gt;y, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝字符串并输出</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p_array-&gt;b, <span class="string">"test"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p_ptr-&gt;y, <span class="string">"test"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p_array-&gt;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p_ptr-&gt;y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(p_array != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1.释放变长结构体的空间"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">free</span>(p_array);</span><br><span class="line">        p_array = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(p_ptr-&gt;y != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1.释放指针申请的空间"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">free</span>(p_ptr-&gt;y);</span><br><span class="line">        p_ptr-&gt;y = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(p_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"2.释放结构体的空间"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">free</span>(p_ptr);</span><br><span class="line">            p_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是结构体的最后一个成员<code>char b[0]</code>,是个<strong>空数组</strong>。在我们不知道结构体内的某个成员大小是多少的时候,我们在最后一个成员放置了一个空数组,这样做的好处就是,我们直接用结构体指针申请空间(<code>sizeof(struct) + 给空数组申请的空间</code>),就完成了动态分配</p>
<p>变长结构体的内存是连续的(严谨的说是虚拟内存),而常规方法的不是,所以变长结构体只需释放一次空间,而常规方法需要释放两次。</p>
<p>并且我们使用sizeof查看两个结构体的大小会发现,Empty结构体的大小为4字节,而Ptr的大小为8字节,可以得出char b[0]是不占内存空间的。</p>
<p>最后还有需要注意的一点就是,有些编译器可能不支持char b[0]这样的写法,可以换成char b[1],用法还是一样的,只是这时的结构体大小变成了4 + 1 + 3 = 8字节,最后那个3字节是由于内存对齐填补上的。</p>
<h6 id="3-fprintf函数的使用和返回值（fprintf-、sprintf-、printf-、fwrite-函数的用法与区别）"><a href="#3-fprintf函数的使用和返回值（fprintf-、sprintf-、printf-、fwrite-函数的用法与区别）" class="headerlink" title="3 fprintf函数的使用和返回值（fprintf()、sprintf()、printf()、fwrite()函数的用法与区别）"></a>3 fprintf函数的使用和返回值（fprintf()、sprintf()、printf()、fwrite()函数的用法与区别）</h6><p> <strong>fprintf</strong>()函数主要用于格式化信息输出到指定的文件流中  </p>
<p> fprintf(fp, “%d”, buffer); </p>
<p> fprintf(文件指针,格式字符串,输出表列);</p>
<p>返回值：成功则返回输出的字节数，失败返回eof；</p>
<p><strong>sprintf</strong>是格式化输出到一个字符串，fprintf是格式化输出到一个stream，通常是到文件。</p>
<p><strong>printf</strong> 是和标准输出文件(stdout)关联的,fprintf 则没有这个限制.</p>
<p><strong>fwrite</strong>(&amp;buffer, sizeof(int), 1, fp);是以二进位位方式写入文件<br>fwrite(数据，数据类型大小（字节数），写入数据的最大数量，文件指针);</p>
<p>由于fprintf写入时，对于整数来说，一位占一个字节，比如1，占1个字节；10，占2个字节；100，占3个字节，10000，占5个字节<br>所以文件的大小会随数据的大小而改变，对大数据空间占用很大。<br>而fwrite是按二进制写入，所以写入数据所占空间是根据数据类型来确定，比如int的大小为4个字节（一般32位下），那么整数10所占空间为4个字节，100、10000所占空间也是4个字节。所以二进制写入比格式化写入更省空间。</p>
<h6 id="4-智能指针-share-ptr-的实现"><a href="#4-智能指针-share-ptr-的实现" class="headerlink" title="4 智能指针 share_ptr 的实现"></a>4 智能指针 share_ptr 的实现</h6><p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>成员函数：</p>
<p>use_count 返回引用计数的个数</p>
<p>unique 返回是否是独占所有权( use_count 为 1)</p>
<p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
<p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
<h6 id="6-引用计数的时候怎么保证安全"><a href="#6-引用计数的时候怎么保证安全" class="headerlink" title="6 引用计数的时候怎么保证安全"></a>6 引用计数的时候怎么保证安全</h6><p>这个也是今天想重点介绍的方案，这个方案没有方案一那么直观，但是确实能够解决上面的问题，也比较安全。</p>
<p>综上，其实问题并不出现在Release里面，问题出现在Addref里面，这个addref 做的自增操作，有些随意了。他没有判断当前的状态，是不是应该加一。而是灰常武断的上来就加，这就是问题的根源。</p>
<p>下面直接上硬菜，addref 的算法应该修改如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_ref_lock</span><span class="params">()</span> <span class="comment">// true on success</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>( ;; )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">long</span> tmp = <span class="keyword">static_cast</span>&lt; <span class="keyword">long</span> <span class="keyword">const</span> <span class="keyword">volatile</span>&amp; &gt;(m_ulRef);</span><br><span class="line">         <span class="keyword">if</span>( tmp == <span class="number">0</span> )</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">if</span>( InterlockedCompareExchange( &amp;m_ulRef, tmp + <span class="number">1</span>, tmp ) == tmp )</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细分析一下，</p>
<p>l  首先，会将应用计数放入一个临时变量，然后用InterlockedCompareExchange 方式来比较修改。如果任何其他线程，修改了m_ulRef 这个变量</p>
<p>l  那么肯定InterlockedCompareExchange的返回值不等于 tmp 变量，那么就修改不成功。</p>
<p>l  这个时候重新获取，再次修改，肯定有成功的时候</p>
<p>l  如果上来就是0，那么就不addref了。这个情况下，说明肯定是对象要释放了。</p>
<h6 id="7-防御性编程"><a href="#7-防御性编程" class="headerlink" title="7 防御性编程"></a>7 防御性编程</h6><p>1、保护你的代码远离来自“外部”的无效数据，无论这个“外部”的概念被定位为什么。它可以是来自于外部系统、用户、文件的数据，也可以是模块/组件以外的数据，由你决定。树立“路障”、“安全区”或“信任边界”——在边界之外的一切都是危险的，界限之内的所有都是安全的。关于“路障”代码，需要验证所有的输入数据：检查所有输入参数的类型、长度和值域是否正确。还要加倍检查限制和界限。</p>
<p>2.当我们检查出错误数据后，还需要决定如何处理它。防御性编程不会掩盖错误，也不会隐藏bug。这需要在健壮性（如果问题可以处理那就继续运行）和正确性（不返回不准确的结果）之间做权衡。选择好策略来应对错误数据：返回错误就马上停止，返回中性值就替换数据值……确保策略明确且一贯。</p>
<p>3.不要将代码外部的函数调用或方法调用想得太过美好。请确保你调用外部的API和库之前理解并测试了错误。</p>
<p>4.至少在开发和测试阶段，要使用断言记录假设，并高亮“不可能”的条件。这在大型系统中显得尤为重要，因为随着时间的推移，将会有不同的程序员用高度可靠的代码来维护这些大型系统。</p>
<p>5.添加诊断代码，智能地记录和跟踪以帮助解释在运行时发生的事情，尤其是当你遇到问题的时候。</p>
<p>6.标准化的错误处理。想好如何处理“正常错误”、“预期错误”以及警告，并对此习以为常。</p>
<p>7.只有当你真的需要的时候，才使用异常处理，并确保你得彻底理解该编程语言的异常处理程序。</p>
<h6 id="8-对C-中三大特性的各自的理解https-blog-csdn-net-skySongkran-article-details-82012698"><a href="#8-对C-中三大特性的各自的理解https-blog-csdn-net-skySongkran-article-details-82012698" class="headerlink" title="8 对C++中三大特性的各自的理解https://blog.csdn.net/skySongkran/article/details/82012698"></a>8 对C++中三大特性的各自的理解<a href="https://blog.csdn.net/skySongkran/article/details/82012698" target="_blank" rel="noopener">https://blog.csdn.net/skySongkran/article/details/82012698</a></h6><p><img src="https://img-blog.csdn.net/201808241009396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NreVNvbmdrcmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>封装性是基础，继承性是关键，多态性是补充，并且多态性存在于继承的环境中。</p>
<p> <span style="color:red">封装性</span></p>
<p>​    C++语言中支持数据封装，类是支持数据封装的工具，对象是数据封装的实现。在封装中，还提供一种对数据访问的控制机制，使得一些数据被隐藏在封装体内，因此具有隐藏性。封装体与外界进行信息交换是通过操作接口进行的。这种访问控制机制体现在类的成员可以有公有成员(public)，私有成员(private)，保护成员(protected)。</p>
<p>​    私有成员是在封装体内被隐藏的部分，只有类体内说明的函数(类的成员函数)才可以访问私有成员，而在类体外的函数时不能访问的，公有成员是封装体与外界的一个接口，类体外的函数可以访问公有成员，保护成员是只有该类的成员函数和该类的派生类才可以访问的。</p>
<p>​    类是一种复杂的数据类型它是将不同类型的数据和与这些数据相关的操作封装在一起的集合体。因此，类具有对数据的抽象性，隐藏性和封装性。</p>
<p><span style="color:red"> 继承性</span></p>
<p>​    C++语言允许单继承和多继承。继承是面向对象语言的重要特性。一个类可以根据需要生成它的派生类，派生类还可以再生成派生类。派生类继承基类的成员，另外，还可以定义自己的成员。继承是实现抽象和共享的一种机制。</p>
<p>​    C++语言中的继承机制可以克服传统的面向过程程序设计的缺点，因为传统编程方式不能重复使用程序而造成资源的浪费，而c++语言提供了无限重复利用程序资源的一种新途径。</p>
<p><span style="color:red"> 多态性</span></p>
<p>   多态性是指对不同类的对象发出相同的消息将会有不同的实现。多态性也可以理解为，在一般类中定义的属性或服务被特殊类继承后，可以具有不同的数据类型或不同的实现。可见，多态性与继承性相关联。简单的说，多态性是指发出同样的消息被不同的数据类型的对象接收后导致不同的行为。</p>
<p> C++语言支持多态性表现在：</p>
<p>​       1，C++语言允许函数重载和运算符重载。</p>
<p>​       2，C++语言通过<strong>定义虚函数</strong>来支持动态联编，动态联编是多态性的一个重要的特征。</p>
<p>多态特性的工作依赖虚函数的定义，在需要解决多态问题的重载成员函数前，加上virtual关键字，那么该成员函数就变成了虚函数，从上例代码运行的结果看，系统成功的分辨出了对象的真实类型，成功的调用了各自的重载成员函数。</p>
<p>　　<strong>多态特性让程序员省去了细节的考虑，提高了开发效率，使代码大大的简化，当然虚函数的定义也是有缺陷的，因为多态特性增加了一些数据存储和执行指令的开销，所以能不用多态最好不用</strong>。</p>
<h6 id="9-对数据结构中堆的理解，小顶堆的建立顺序。"><a href="#9-对数据结构中堆的理解，小顶堆的建立顺序。" class="headerlink" title="9 对数据结构中堆的理解，小顶堆的建立顺序。"></a>9 对数据结构中堆的理解，小顶堆的建立顺序。</h6><p>堆（heap）也被称为优先队列（priority queue）。队列中允许的操作是先进先出（FIFO），在队尾插入元素，在队头取出元素。而堆也是一样，在堆底插入元素，在堆顶取出元素，但是堆中元素的排列不是按照到来的先后顺序，而是按照一定的优先顺序排列的。这个优先顺序可以是元素的大小或者其他规则。如图一所示就是一个堆，堆优先顺序就是大的元素排在前面，小的元素排在后面，这样得到的堆称为最大堆。最大堆中堆顶的元素是整个堆中最大的，并且每一个分支也可以看成一个最大堆。同样的，我们可以定义最小堆。</p>
<p>最小堆是一棵完全二叉树，非叶子结点的值不大于左孩子和右孩子的值。本文以图解的方式，说明</p>
<p>最小堆的构建、插入、删除的过程。搞懂最小堆的相应知识后，最大堆与此类似。</p>
<h6 id="10-哈希表的优势，哈希表的使用场景。hash函数的理解；"><a href="#10-哈希表的优势，哈希表的使用场景。hash函数的理解；" class="headerlink" title="10 哈希表的优势，哈希表的使用场景。hash函数的理解；"></a>10 哈希表的优势，哈希表的使用场景。hash函数的理解；</h6><p><strong>优点:(查找速度快)</strong></p>
<p>​       哈希表是种数据结构，它可以提供快速的插入操作和查找操作。第一次接触哈希表时，它的优点多得让人难以置信。不论哈希表中有多少数据，插入和删除（有时包括侧除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。</p>
<p>　　对哈希表的使用者一一人来说，这是一瞬间的事。哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。</p>
<p>​      <strong>使用场景：</strong></p>
<p>​       <strong>而且，也没有一种简便的方法可以以任何一种顺序〔例如从小到大〕遍历表中数据项。如果需要这种能力，就只能选择其他数据结构。</strong></p>
<p><strong>然而如果不需要有序遍历数据，井且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。</strong></p>
<p>若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数（哈希函数），按这个思想建立的表为散列表（哈希表）。</p>
<p>对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为碰撞(英语:Collision)。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理碰撞的方法将一组关键字映射到一个有限的连续的地址集(区间)上，并以关键字在地址集中的”像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。（就是发生冲突，有两个或者多个关键词对应同一个物理地址，就无法分清哪一个对应哪个了。）</p>
<p>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数(Uniform Hash function)，这就是使关键字经过散列函数得到一个”随机的地址”，从而减少碰撞（注意冲突无法避免的）。</p>
<p><strong>什么是哈希函数</strong></p>
<p><strong>哈希函数（散列函数）能够将任意长度的输入值转变成固定长度的值输出，该值称为散列值，输出值通常为字母与数字组合</strong>。</p>
<h6 id="11-给定一百万个IP和端口，如何设计一个hash函数，和哈希表去存储，做什么样子的哈希运算。"><a href="#11-给定一百万个IP和端口，如何设计一个hash函数，和哈希表去存储，做什么样子的哈希运算。" class="headerlink" title="11 给定一百万个IP和端口，如何设计一个hash函数，和哈希表去存储，做什么样子的哈希运算。"></a>11 给定一百万个IP和端口，如何设计一个hash函数，和哈希表去存储，做什么样子的哈希运算。</h6><h6 id="12、解决哈希冲突的办法"><a href="#12、解决哈希冲突的办法" class="headerlink" title="12、解决哈希冲突的办法"></a>12、<strong>解决哈希冲突的办法</strong></h6><p><strong>1、开放定址法</strong></p>
<p>这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p>
<p>Hi=（H（key）+di）% m   i=1，2，…，n</p>
<p>其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：</p>
<p><strong>线性探测再散列</strong></p>
<p>dii=1，2，3，…，m-1</p>
<p>这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>
<p>① 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。<br>② 按上述算法建立起来的哈希表，删除工作非常困难。如果将此元素删除，查找的时会发现空槽，则会认为要找的元素不存在。只能标上已被删除的标记，否则，将会影响以后的查找。<br>③ 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</p>
<p><strong>二次探测再散列</strong></p>
<p>di=12，-12，22，-22，…，k2，-k2    ( k&lt;=m/2 )</p>
<p>这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p>
<p><strong>伪随机探测再散列</strong></p>
<p>di=伪随机数序列。</p>
<p>具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。</p>
<p>例如，已知哈希表长度m=11，哈希函数为：H（key）= key  %  11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。</p>
<p>如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。</p>
<p>如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。</p>
<p>如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。</p>
<p><strong>2、再哈希法</strong></p>
<p>这种方法是同时构造多个不同的哈希函数：</p>
<p>Hi=RH1（key）  i=1，2，…，k</p>
<p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
<p><strong>3、链地址法</strong></p>
<p>​         这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
<p><strong>开放散列（open hashing）/ 拉链法（针对桶链结构）</strong></p>
<p>1）优点： ①对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销） ②由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了 ③删除记录时，比较方便，直接通过指针操作即可</p>
<p>2）缺点： ①存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 ②如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列 ③由于使用指针，记录不容易进行序列化（serialize）操作</p>
<p><strong>封闭散列（closed hashing）/ 开放定址法</strong></p>
<p>1）优点： ①记录更容易进行序列化（serialize）操作 ②如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的</p>
<p>2）缺点： ①存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷 ②使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低 ③由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费 ④删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。</p>
<h6 id="13、未定义的bool值为什么"><a href="#13、未定义的bool值为什么" class="headerlink" title="13、未定义的bool值为什么"></a>13、未定义的bool值为什么</h6><p>不确定 </p>
<p>综上可以看出，在Debug环境下，变量的内存地址空间被编译器默认用0xcc填充了。而在Release环境下，变量的内存地址空间被编译器用随机值填充了。</p>
<p>研究了这么多，其实还是要给出一条建议：在定义变量的同时，给出一个初始值，而不要让编译器默认填充。这样既方便调试，也不会因为Debug或者Release环境的不同而不同。默认填充会有许多的不确定性，不同的编译器也会不同，会引入许多隐含的Bug。</p>
<h6 id="14、Char-c-abc；-strlen（指针）多大4，strlen（c）为3"><a href="#14、Char-c-abc；-strlen（指针）多大4，strlen（c）为3" class="headerlink" title="14、Char* c= abc； strlen（指针）多大4，strlen（c）为3"></a>14、Char* c= abc； strlen（指针）多大4，strlen（c）为3</h6><h6 id="15、套接字编程，一台是小段，一台大端怎么通信"><a href="#15、套接字编程，一台是小段，一台大端怎么通信" class="headerlink" title="15、套接字编程，一台是小段，一台大端怎么通信?"></a>15、套接字编程，一台是小段，一台大端怎么通信?</h6><p>首先理解什么是大端什么是小端</p>
<ul>
<li><strong>大端模式，</strong>是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中</li>
<li><strong>小端模式，</strong>是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180425152114637?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NDk4MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="å¤§å°ç«¯æ¨¡å¼"></p>
<p><strong>大端模式优点：</strong>符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小</p>
<p><strong>小端模式优点：</strong></p>
<ol>
<li>内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（注解：比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）；</li>
<li>CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效</li>
</ol>
<p>由于不同的处理器可以配置成大端或者小端，使得不同主机之间的通信变得复杂。<br>为此，网络协议指定了字节序。TCP/IP协议栈采用<strong>大端字节序</strong>，所以应用程序有时需要再处理器的字节序与网络的字节序之间进行转换。<br>对于TCP/IP应用程序，提供了以下四个通用函数进行转换：</p>
<p><strong>怎么判断本机现在是大端还是小端</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">char</span> * p = (<span class="keyword">char</span>*)&amp;a;  </span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little-endian"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big-endian"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​       如果小端方式中（a占至少两个字节的长度）则a所分配的内存最小地址那个字节中就存着1，其他字节是0；大端的话则1在i的最高地址字节处存放。char是一个字节，所以强制将char型量p指向i则p指向的一定是i的最低地址，那么就可以判断p中的值是不是1来确定是不是小端。</p>
<p><strong>在网络上传输的数据普遍采用的都是大端</strong></p>
<h6 id="16、并发模型有哪些？（留）"><a href="#16、并发模型有哪些？（留）" class="headerlink" title="16、并发模型有哪些？（留）"></a>16、并发模型有哪些？（留）</h6><h6 id="17、程序有哪些段"><a href="#17、程序有哪些段" class="headerlink" title="17、程序有哪些段"></a>17、程序有哪些段</h6><p>站在汇编语言的角度，一个程序分为：<br>数据段 – DS<br>堆栈段 – SS<br>代码段 – CS<br>扩展段 – ES</p>
<p>站在高级语言的角度，根据APUE，一个程序分为如下段：<br>text<br>data (initialized)<br>bss<br>stack<br>heap</p>
<p> 1.一般情况下，一个可执行二进制程序(更确切的说，在Linux操作系统下为一个进程单元，在UC/OSII中被称为任务)在存储(没有调入到内存运行)时拥有3个部分，分别是代码段(text)、数据段(data)和BSS段。这3个部分一起组成了该可执行程序的文件。</p>
<p><strong>★★可执行二进制程序 = 代码段(text)＋数据段(data)+BSS段★★</strong></p>
<p> 2.而当程序被加载到内存单元时，则需要另外两个域：堆域和栈域。图1-1所示为可执行代码存储态和运行态的结构对照图。一个正在运行的C程序占用的内存区域分为代码段、初始化数据段、未初始化数据段(BSS)、堆、栈5个部分。</p>
<p><strong>★★正在运行的C程序 = 代码段+初始化数据段(data)+未初始化数据段(BSS)+堆+栈★★</strong></p>
<p>3.在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显示地申请和释放空间。</p>
<p> 4.动态分配与静态分配，二者最大的区别在于:1. 直到Run-Time的时候，执行动态分配，而在compile-time的时候，就已经决定好了分配多少Text+Data+BSS+Stack。2.通过malloc()动态分配的内存，需要程序员手工调用free()释放内存，否则容易导致内存泄露，而静态分配的内存则在进程执行结束后系统释放(Text, Data), 但Stack段中的数据很短暂，函数退出立即被销毁</p>
<p><img src="https://img-blog.csdn.net/20141120150231808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZV9nYW9oeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><span style="color:green">从可执行文件a.out的角度来讲，如果一个数据未被初始化那就不需要为其分配空间，所以.data和.bss一个重要的区别就是.bss并不占用可执行文件的大小，它只是记载需要多少空间来存储这些未初始化数据，而不分配实际的空间</span></p>
<p><strong>代码段 –text（code segment/text segment）</strong><br>text段在内存中被映射为只读，但.data和.bss是可写的。<br>text段是程序代码段，在AT91库中是表示程序段的大小，它是由编译器在编译连接时自动计算的，当你在链接定位文件中将该符号放置在代码段后，那么该符号表示的值就是代码段大小，编译连接时，该符号所代表的值会自动代入到源程序中。</p>
<p><strong>数据段 – data</strong><br>data包含静态初始化的数据，所以有初值的全局变量和static变量在data区。段的起始位置也是由连接定位文件所确定，大小在编译连接时自动分配，它和你的程序大小没有关系，但和程序使用到的全局变量，常量数量相关。数据段属于静态内存分配。 </p>
<p><strong>bss段–bss</strong><br>bss是英文Block Started by Symbol的简称，通常是指用来存放程序中未初始化的全局变量的一块内存区域，在程序载入时由内核清0。BSS段属于静态内存分配。它的初始值也是由用户自己定义的连接定位文件所确定，用户应该将它定义在可读写的RAM区内，源程序中使用malloc分配的内存就是这一块，它不是根据data大小确定，主要由程序中同时分配内存最大值所确定，不过如果超出了范围，也就是分配失败，可以等空间释放之后再分配。BSS段属于静态内存分配。<br><strong>stack：</strong><br>栈(stack)保存函数的局部变量（但不包括static声明的变量， static 意味着 在数据段中 存放变量），参数以及返回值。是一种“后进先出”（Last In First Out，LIFO）的数据结构，这意味着最后放到栈上的数据，将会是第一个从栈上移走的数据。对于哪些暂时存贮的信息，和不需要长时间保存的信息来说，LIFO这种数据结构非常理想。在调用函数或过程后，系统通常会清除栈上保存的局部变量、函数调用信息及其它的信息。栈另外一个重要的特征是，它的地址空间“向下减少”，即当栈上保存的数据越多，栈的地址就越低。栈（stack）的顶部在可读写的RAM区的最后。</p>
<p><strong>heap:</strong><br>堆(heap)保存函数内部动态分配内存，是另外一种用来保存程序信息的数据结构，更准确的说是保存程序的动态变量。堆是“先进先出”（First In first Out，FIFO）数据结构。它只允许在堆的一端插入数据，在另一端移走数据。堆的地址空间“向上增加”，即当堆上保存的数据越多，堆的地址就越高。<br><img src="https://img-blog.csdn.net/20141120144640019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZV9nYW9oeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>下图是APUE中的一个典型C内存空间分布图：</strong></p>
<p><img src="https://img-blog.csdn.net/20141120145439174?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG92ZV9nYW9oeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>所以可以知道传入的参数,局部变量,都是在栈顶分布,随着子函数的增多而向下增长.函数的调用地址(函数运行代码),全局变量,静态变量都是在分配内存的低部存在,而malloc分配的堆则存在于这些内存之上,并向上生长.</strong></p>
<h6 id="18、MMU内存管理单元"><a href="#18、MMU内存管理单元" class="headerlink" title="18、MMU内存管理单元"></a>18、MMU内存管理单元</h6><p><strong>什么是MMU</strong></p>
<p>MMU(Memory Management Unit)主要用来管理虚拟存储器、物理存储器的控制线路，同时也负责<strong>虚拟地址映射为物理地址</strong>，以及提供硬件机制的内存访问授权、多任务多进程操作系统。（来自百度百科，<strong>对其几个点不熟悉，因此可以只考虑加粗部分</strong>）</p>
<p><strong>发展历史</strong></p>
<p><em>注意：学习一个知识点，很重要的一步是了解其<strong>为什么而存在？它的存在是为了解决什么问题？</strong>然后，在学习的过程中带着这些问题去理解、去思考。</em></p>
<p>在许多年以前，还是使用DOS或一些古老的操作系统时，内存很小，同时，应用程序也很小，将程序存储在内存中基本能够满足需要。随着科技的发展，图形界面及一些其他更复杂的应用出现，内存已经无法存储这些应用程序了，通常的解决办法是将程序分割成很多个<strong>覆盖块</strong>，覆盖块0最先运行，运行结束之后，就调用另一个覆盖块，虽然这些操作由OS来完成，但是，需要程序员对程序进行分割，这非常不高效；因此，人们想出了一个<strong>虚拟存储器（virtual memory）</strong>的方法。虚拟存储器的基本思想是：程序、数据、堆栈的总大小可以超过内存空间的大小，操作系统将当前运行的部分保存在内存中，未使用的部分保存在磁盘中。比如一个16MB的程序和一个内存只有4MB的机器，操作系统通过选择可以决定哪部分4MB的程序内容保存在内存中，并在需要时，在内存与磁盘中交换程序代码，这样16MB的代码就可以运行在4MB的机器中了。<strong>注意：这里面包含了虚拟地址和物理地址的概念</strong></p>
<p><strong>相关概念</strong></p>
<p><strong>地址范围、虚拟地址映射成物理地址</strong>以及<strong>分页机制</strong></p>
<ul>
<li><p><strong>地址范围</strong>： 指处理器能够产生的地址集合，如一个32bit的处理器ARM9，其能产生的地址集合是<strong>0x0000 0000 ~ 0xffff ffff</strong>(4G)，这个地址范围也称为<strong>虚拟地址空间</strong>，其中对应的地址为<strong>虚拟地址</strong>。</p>
</li>
<li><p><strong>虚拟地址与物理地址</strong>： 与虚拟地址空间和虚拟地址相对应的是物理地址空间和物理地址；物理地址空间只是虚拟地址空间的一个<strong>子集</strong>。如一台内存为256MB的32bit X86主机，其虚拟地址空间是0 ~ 0xffffffff(4GB)，物理地址空间范围是0 ~ 0x0fff ffff(256M)</p>
</li>
<li><p>分页机制</p>
<p> 如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为物理地址（<strong>Physical Address</strong>，以下简称<strong>PA</strong>），如下图3-1-1所示；</p>
</li>
</ul>
<p>  <img src="https://upload-images.jianshu.io/upload_images/2310756-67a4ff2b53385008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/455/format/webp" alt="img"></p>
<p>  如果处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将VA映射成PA，，如下图3-1-2。</p>
<p>  <img src="https://upload-images.jianshu.io/upload_images/2310756-3b1e7fc263f0642a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/446/format/webp" alt="img"></p>
<ul>
<li>大多数使用MMU的机器都采用<strong>分页机制</strong>。虚拟地址空间以<strong>页</strong>为单位进行划分，而相应的物理地址空间也被划分，其使用的单位称为<strong>页帧</strong>，页帧和页必须保持相同，因为<strong>内存与外部存储器之间的传输是以页为单位进行传输的</strong>。例如，MMU可以通过一个映射项将VA的一页0xb70010000xb7001fff映射到PA的一页0x20000x2fff，如果CPU执行单元要访问虚拟地址0xb7001008，则实际访问到的物理地址是0x2008。</li>
</ul>
<p>虚拟内存的哪个页面映射到物理内存的哪个页帧是通过<strong>页表（Page Table）</strong>来描述的，页表保存在<strong>物理内存中</strong>，<strong>MMU会查找页表来确定一个VA应该映射到什么PA。</strong></p>
<p><strong>功能</strong></p>
<p><strong>执行过程</strong></p>
<p>操作系统和MMU是这样配合的：</p>
<ol>
<li>操作系统在初始化或分配、释放内存时会执行一些指令在物理内存中填写页表，然后用指令设置MMU，告诉MMU页表在物理内存中的什么位置。</li>
<li>设置好之后，CPU每次执行访问内存的指令都会自动引发MMU做查表和地址转换操作，地址转换操作由硬件自动完成，不需要用指令控制MMU去做。</li>
</ol>
<p><span style="color:green"><strong>重要：</strong>我们在程序中使用的变量和函数都有各自的地址，在程序被编译后，这些地址就成了指令中的地址，指令中的地址就成了CPU执行单元发出的内存地址，所以在启用MMU的情况下， 程序中使用的地址均是<strong>虚拟内存地址</strong>，都会引发MMU进行查表和地址转换操作。（注意理解这句话）</span></p>
<p><strong>内存保护机制</strong></p>
<p>处理器一般有<strong>用户模式（User Mode）</strong>和<strong>特权模式（privileged Mode）</strong>之分。操作系统可以在页表中设置每个页表访问权限，有些页表不可以访问，有些页表只能在特权模式下访问，有些页表在用户模式和特权模式下都可以访问，同时，访问权限又分为<strong>可读</strong>、<strong>可写</strong>和<strong>可执行</strong>三种。这样设定之后，当CPU要访问一个VA（Virtual Address）时，<strong>MMU</strong>会检查CPU当前处于用户模式还是特权模式，访问内存的目的是读数据、写数据还是取指令执行，<strong>如果与操作系统设定的权限相符，则允许访问，把VA转换成PA，否则不允许执行，产生异常（Exception）</strong>。</p>
<p><strong>异常与中断</strong>：异常与中断的处理机制类似，不同的是中断由外部设备产生，而 异常由CPU内部产生的；中断产生与CPU当前执行的指令无关，而异常是由于当前执行的指令出现问题导致的</p>
<p>通常操作系统会将<strong>虚拟地址空间</strong>划分为<strong>用户空间</strong>和<strong>内核空间</strong>。例如x86平台的linux系统的虚拟地址空间范围是0x0000 0000 ~ 0xffff ffff，前3G的空间为用户空间，后1G的空间为内核空间。用户程序加载到用户空间，内核程序加载到内核空间，<strong>用户程序不能访问内核中的数据，也不能跳转到内核空间执行</strong>。这样可以保护内核，如果一个进程访问了非法地址，顶多就是这个进程崩溃，而不会影响到内核和系统的稳定性。在系统发生中断或异常时，不仅会跳转到中断或异常服务函数中执行，而且还会从用户模式切换到特权模式，从中断或异常服务程序跳转到内核代码中执行。<strong>总结一下：在正常情况下处理器在用户模式执行用户程序，在中断或异常情况下处理器切换到特权模式执行内核程序，处理完中断或异常之后再返回用户模式继续执行用户程序。</strong></p>
<p><strong>段错误</strong>我们已经遇到过很多次了，它是这样产生的：</p>
<ol>
<li>用户程序要访问的一个VA，经MMU检查无权访问。</li>
<li>MMU产生一个异常，CPU从用户模式切换到特权模式，跳转到内核代码中执行异常服务程序。</li>
<li>内核把这个异常解释为段错误，把引发异常的进程终止掉。</li>
</ol>
<p><strong>S3C2440/S3C2410 中的MMU</strong></p>
<p><strong>S3C2440/S3C2410 MMU概述</strong></p>
<ol>
<li>S3C2440的MMU使用<strong>页表</strong>来实现虚拟地址到物理地址的转换；页表存储在内存中，页表中的每一行对应于虚拟存储空间的一个页，该行包含了该虚拟内存页对应的物理内存页的地址、该页的方位权限和该页的缓冲特性等。这里页表中的每一行称为一个<strong>地址变换条目（entry）也称为“描述符”</strong>。描述符有：段描述符、大页描述符、小页描述符、极小页描述符——他们保存段、大页、小页或极小页的<strong>起始物理地址</strong>；粗页表描述符、细页表描述符——它们保存<strong>二级页表的物理地址</strong>。</li>
<li><strong>页表的存储</strong>：页表存放在内存中，系统通常有<strong>一个寄存器来保存页表的基地址</strong>。在ARM中<strong>系统控制协处理器CP15的寄存器C2用来保存页表的基地址</strong>。</li>
<li><strong>TLB</strong>：因为从虚拟地址到物理地址的变换过程是通过查询页表完成的，而页表又存储在内存中，如果每次程序执行时去读取内存中的数据获取物理地址，代价很大。而程序在执行过程中可能只对页表中的少数几个单元进行访问，根据这一特点，采用一个容量更小（通常为8~16个字）、访问速度和CPU中通用寄存器相当的存储器件来存放当前访问需要的地址变换条目。这个小容量的页表称为TLB（Translation Lookaside buffer）。</li>
<li><strong>S3C2440/S3C2410中的页表</strong><br>在S32440/S3C2410中最多会使用两级页表：以段（Section 1MB）的方式进行转换时只用到一级页表，以页（Page）的方式进行转换时用到二级页表。</li>
<li><strong>CPU访问内存的过程</strong>：<br>a . 当CPU需要访问内存时，先在TLB中查询需要的地址变换条目。如果该条目不存在，CPU从位于内存中的页表中查询，并把相应的结果添加到TLB中。这样，当CPU下一次又需要该地址变换条目时，可以从TLB中直接得到，从而使地址变换的速度大大加快。<br>b. 当内存中的页表内容改变，或者通过修改系统控制协处理器CP15的寄存器C2使用新的页表时，TLB中的内容需要全部清除。系统控制协处理器<strong>CP15的寄存器C8</strong>用来控制清除TLB内容的相关操作。<br>c. MMU可以将某些地址变换条目锁定在TLB中，从而使得获取该地址变换条目的速度保持很快。在CP15中的C10用于控制TLB内容的锁定。<br>d. MMU 可以将整个存储空间分为最多16个域，每个域对应一定的内存区域，该区域具有相同的访问控制属性。<strong>MMU中寄存器C3用于控制与域相关的属性的配置</strong>。<br>e. 当存储访问失效时，MMU提供了相应的机制用于处理这种情况。在<strong>MMU中寄存器C5和寄存器C6用于支持这些机制</strong>。</li>
</ol>
<p><strong>禁止/使能MMU时应注意的问题（重要）</strong></p>
<p>应注意如下几点：</p>
<ul>
<li><span style="color:red">在使能MMU之前，要在内存中<strong>建立页表</strong>，同时，<strong>CP15中的各相关寄存器必须完成初始化</strong>。</span></li>
<li><span style="color:red">如果使用的不是平板存储模式（物理地址和虚拟地址相等），在禁止/使能MMU时，虚拟地址和物理地址的对应关系会发生改变，这时应该<strong>清除cache中的当前地址变换条目</strong>。</span></li>
</ul>
<p><strong>S3C2440/S3C2410中的MMU地址变换</strong></p>
<p>ARM CPU上的地址转换过程涉及3个概念：虚拟地址（VA）、<strong>变换后的虚拟地址（MVA, modified virtrual address）</strong>、物理地址（PA）。</p>
<p>没启动MMU时，CPU核、cache、MMU、外设等所有部件使用的都是物理地址。</p>
<p><strong>启动MMU后，CPU核对外发出虚拟地址VA；VA被转换为MVA供cache、MMU使用，在这里MVA被转换为PA，最后使用PA读写实际设备。</strong></p>
<p>ARM支持的存储块大小有以下几种：</p>
<ul>
<li>段（section）：是大小为1M的存储块。</li>
<li>大页（Large Pages）：是大小为64KB的存储块。</li>
<li>小页（Small Pages）：是大小为4KB的存储块。</li>
<li>极小页（Tiny Pages）：是大小为1KB的存储块。<br>通过配置访问控制机制，还可以将大页分成大小为16KB的子页；将小页分成大小为1KB的子页；极小页不能再细分，只能以1KB大小的整页为单位。</li>
</ul>
<p><strong>MMU中的域</strong></p>
<p>MMU中的域指的是一些段、大页或者小页的集合。ARM支持最多16个域，每个域的访问控制特性由CP15中的寄存器C3中的两位来控制，CP15中的寄存器C3的格式如下所示:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2310756-3e2d70fcfe123989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/876/format/webp" alt="img"></p>
<p>其中每两位控制一个域的访问控制特性，其编码及对应的含义如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2310756-a20552080cd50a24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/900/format/webp" alt="img"></p>
<h6 id="19、函数调用过程"><a href="#19、函数调用过程" class="headerlink" title="19、函数调用过程"></a>19、函数调用过程</h6><p>​       在x86的计算机系统中，内存空间中的栈主要用于保存函数的参数，返回值，返回地址，本地变量等。一切的函数调用都要将不同的数据、地址压入或者弹出栈。因此，为了更好地理解函数的调用，我们需要先来看看栈是怎么工作的。</p>
<p>栈帧，也就是stack frame，其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的。在x86-32bit中，我们用 <code>%ebp</code> 指向栈底，也就是基址指针；用 <code>%esp</code> 指向栈顶，也就是栈指针。下面是一个栈帧的示意图：</p>
<p>​                                              <img src="https://segmentfault.com/img/remote/1460000007977465" alt="å¾ä¸ï¼æ å¸§ç¤ºæå¾"></p>
<p>一般来说，我们将 <code>%ebp</code> 到 <code>%esp</code> 之间区域当做栈帧（也有人认为该从函数参数开始，不过这不影响分析）。并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧。在函数调用过程中，我们将调用函数的函数称为“调用者(caller)”，将被调用的函数称为“被调用者(callee)”。在这个过程中，1）“调用者”需要知道在哪里获取“被调用者”返回的值；2）“被调用者”需要知道传入的参数在哪里，3）返回的地址在哪里。同时，我们需要保证在“被调用者”返回后，<code>%ebp</code>, <code>%esp</code> 等寄存器的值应该和调用前一致。因此，我们需要使用栈来保存这些数据。</p>
<p><strong>函数的调用</strong></p>
<p>我们直接通过实例来看函数是如何调用的。这是一个有参数但没有调用任何函数的简单函数，我们假设它被其他函数调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyFunction</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">5</span>;</span><br><span class="line">    c = <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>;</span><br><span class="line">    MyFunction1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个函数，当调用时，<code>MyFunction()</code> 的汇编代码大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_MyFunction:</span><br><span class="line">    push %ebp            ; //保存%ebp的值</span><br><span class="line">    movl %esp, $ebp      ; //将%esp的值赋给%ebp，使新的%ebp指向栈顶</span><br><span class="line">    movl -12(%esp), %esp ; //分配额外空间给本地变量</span><br><span class="line">    movl $10, -4(%ebp)   ; </span><br><span class="line">    movl $5,  -8(%ebp)   ; </span><br><span class="line">    movl $2,  -12(%ebp)  ;</span><br></pre></td></tr></table></figure>

<p>光看代码可能还是不太明白，我们先来看看此时的栈是什么样的：</p>
<p><img src="https://segmentfault.com/img/remote/1460000007977466" alt="图四：被调用者栈帧的生成"></p>
<p>此时调用者做了两件事情：<strong>第一，将被调用函数的参数按照从右到左的顺序压入栈中。第二，将返回地址压入栈中。</strong>这两件事都是调用者负责的，g。我们再来看看被调用者，它也做了两件事情：第一，将老的（调用者的） <code>%ebp</code> 压入栈，此时 <code>%esp</code> 指向它。第二，将 <code>%esp</code> 的值赋给 <code>%ebp</code>, <code>%ebp</code> 就有了新的值，它也指向存放老 <code>%ebp</code> 的栈空间。这时，它成了是函数 <code>MyFunction()</code> 栈帧的栈底。<strong>这样，我们就保存了“调用者”函数的 `%ebp</strong>`，并且建立了一个新的栈帧。</p>
<p>只要这步弄明白了，下面的操作就好理解了。在 <code>%ebp</code> 更新后，我们先分配一块0x12字节的空间用于存放本地变量，这步一般都是用 <code>sub</code> 或者 <code>mov</code> 指令实现。在这里使用的是 <code>movl</code>。通过使用 <code>mov</code> 配合 <code>-4(%ebp)</code>, <code>-8(%ebp)</code> 和 <code>-12(%ebp)</code> 我们便可以给 <code>a</code>, <code>b</code> 和 <code>c</code> 赋值了。</p>
<p><img src="https://segmentfault.com/img/remote/1460000007977467" alt="图五：本地变量赋值后的栈帧"></p>
<p>上面讲的都是函数的调用过程，我们现在来看看函数是如何返回的。从下面这个例子我们可以看出，和调用函数时正好相反。当函数完成自己的任务后，它会将 <code>%esp</code> 移到 <code>%ebp</code> 处，然后再弹出旧的 <code>%ebp</code> 的值到 <code>%ebp</code>。这样，<code>%ebp</code> 就恢复到了函数调用前的状态了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyFunction</span><span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其汇编大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_MyFunction:</span><br><span class="line">    push %ebp</span><br><span class="line">    movl %esp, %ebp</span><br><span class="line">    movl -12(%esp), %esp</span><br><span class="line">    ...</span><br><span class="line">    mov %ebp, %esp</span><br><span class="line">    pop %ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>我们注意到最后有一个 <code>ret</code> 指令，这个指令相当于 <code>pop + jum</code>。它首先将数据（返回地址）弹出栈并保存到 <code>%esp</code> 中，然后处理器根据这个地址无条件地跳到相应位置获取新的指令。</p>
<p><img src="https://segmentfault.com/img/remote/1460000007977468" alt="图六：被调用者返回后的栈帧"></p>
<p>到这里，C函数的调用过程就基本讲完了。函数的调用其实不难，只要搞懂了如何保存以及还原 <code>%ebp</code> 和 <code>%esp</code>，就能明白函数是如何通过栈帧进行调用和返回的了。</p>
<h6 id="20、时钟中断如何触发进程切换"><a href="#20、时钟中断如何触发进程切换" class="headerlink" title="20、时钟中断如何触发进程切换"></a>20、时钟中断如何触发进程切换</h6><p>一、Linux时钟系统</p>
<p>1.时钟硬件</p>
<p>  绝大多数的PC都有两个时钟源，RTC（实时时钟）和OS（系统时钟）。RTC也叫做CMOS时钟，它是PC主机板上的一块芯片。OS时钟产生于PC主板上的定时/计数芯片，由操作系统控制这个芯片的工作，OS 时钟的基本单位就是该芯片的计数周期。在系统上电启动的时候，会用RTC来初始化OS。OS 时钟只在开机时才有效，而且完全由操作系统控制，所以也被称为软时钟或系统时钟。OS 时钟所用的定时/计数芯片最典型的是 8253/8254 可编程定时/计数芯片。所以当然是以脉冲计数了，输出脉冲的周期叫做一个“时钟滴答”，计算机中的时间是以时钟滴答为单位的，每一次时钟滴答，系统时间就会加 1。操作系统根据当前时钟滴答的数目就可以得到以秒或毫秒等为单位的其他时间格式。</p>
<p><a href="https://s4.51cto.com/wyfs02/M02/08/26/wKiom1nc7JDyv9AjAAAskULi-o0043.png" target="_blank" rel="noopener"><img src="https://s4.51cto.com/wyfs02/M02/08/26/wKiom1nc7JDyv9AjAAAskULi-o0043.png" alt="wKiom1nc7JDyv9AjAAAskULi-o0043.png"></a></p>
<p>2.时钟运行机制</p>
<p><a href="https://s1.51cto.com/wyfs02/M02/08/26/wKiom1nc7M-AgBFmAAEDKBEgcRo105.png" target="_blank" rel="noopener"><img src="https://s1.51cto.com/wyfs02/M02/08/26/wKiom1nc7M-AgBFmAAEDKBEgcRo105.png" alt="wKiom1nc7M-AgBFmAAEDKBEgcRo105.png"></a></p>
<p>二、时钟中断</p>
<p>  Linux的OS时钟的物理产生原因是可编程定时/计数器产生的输出脉冲，这个脉冲送入CPU，就可以引发一个中断请求信号，我们就把它叫做时钟中断。</p>
<p>  每个时钟滴答，时钟中断得到执行。时钟中断执行的频率很高：100次/秒，时钟中断的主要工作是处理和时间有关的所有信息、决定是否执行调度程序。和时间有关的所有信息包括系统时间、进程的时间片、延时、使用 CPU 的时间、各种定时器，进程更新后的时间片为进程调度提供依据，然后在时钟中断返回时决定是否要执行调度程序。</p>
<p>三、Linux的调度程序—Schedule</p>
<p>1.调度原理</p>
<p>  进程运行需要各种各样的系统资源，如内存、文件、打印机和最宝贵的 CPU 等， 所以说，调度的实质就是资源的分配。 </p>
<p>  一个好的调度算法（时间片轮转调度算法、优先权调度算法、多级反馈队列调度、实时调度）应当考虑以下几个方面。<br>（1）公平：保证每个进程得到合理的 CPU 时间。<br>（2）高效：使 CPU 保持忙碌状态，即总是有进程在 CPU 上运行。<br>（3）响应时间：使交互用户的响应时间尽可能短。<br>（4）周转时间：使批处理用户等待输出的时间尽可能短。<br>（5）吞吐量：使单位时间内处理的进程数量尽可能多。</p>
<p>很明显，五个不可能同时满足，所以每种调度算法都是满足其中的一种或多种。</p>
<p>2.Linux进程调度时机</p>
<p>（1）进程状态转换的时刻：进程终止、进程睡眠；<br>（2）当前进程的时间片用完时（current-&gt;counter=0）；<br>（3）设备驱动程序；<br>（4）进程从中断、异常及系统调用返回到用户态时。</p>
<p>3.进程调度的依据</p>
<p>  调度程序运行时，要在所有处于可运行状态的进程之中选择最值得运行的进程投入运行。选择进程的依据是什么呢？在每个进程的 task_struct 结构中有如下 5 项：need_resched、nice、counter、policy 及rt_priority这五项在前面进程概念中介绍过,对于普通进程，选择进程的主要依据为counter 和nice 。对于实时进程，Linux采用了两种调度策略，即FIFO（先来先服务调度）和RR（时间片轮转调度）。因为实时进程具有一定程度的紧迫性，所以衡量一个实时进程是否应该运行，Linux 采用了一个比较固定的标准。实时进程的counter只是用来表示该进程的剩余滴答数，并不作为衡量它是否值得运行的标准，这和普通进程是有区别的。</p>
<p> 与其他操作系统一样，Linux 的时间单位也是“时钟滴答”，只是不同的操作系统对一个时钟滴答的定义不同而已 （Linux 设计者将一个 “时钟滴答” 定义为 10ms）。在这里，我们把 counter 叫做进程的时间片，但实际上它仅仅是时钟滴答的个数。</p>
<h6 id="21、用数组表示二叉树"><a href="#21、用数组表示二叉树" class="headerlink" title="21、用数组表示二叉树"></a>21、用数组表示二叉树</h6><p>传统的二叉树是使用链表的形式,其优点是便于插入和删除,但是查找速度很慢,占用空间也很大.所以现在用数组的形式来构建二叉树,节点存在数组中,而不是由引用相连,节点在数组中的位置对应它在树中的位置,下标为0 的节点为根节点,下标为1是根的左节点,2为根节点的右节点,依次类推,从左到右的顺序存储树的每一层,包括空节点.如下图:</p>
<p><img src="https://img-blog.csdn.net/20160708110724036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>找节点的子节点和父节点可以利用简单的算术计算它们在数组中的索引值</p>
<p>设某个节点索引值为index,则节点的左子节点索引为:</p>
<p><code>2*index+1</code></p>
<p>右子节点索引为:</p>
<p><code>2*index+2</code></p>
<p>父节点索引为:</p>
<p><code>(index-1)/2</code></p>
<p>大多数情况下用数组表示数不是很有效率,除非是完全二叉树.但是普通的二叉树,特别是有很多空节点的.会有很多空洞,浪费存储空间.用数组表示树,删除节点是很费时费力的.</p>
<p>所以用数组表示树适合用于 完全二叉树查找,和插入.下面是我自己写的代码,比较简单:</p>
<p>首先是用数组建立一个二叉树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Binary_tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Binary_tree* left;</span><br><span class="line">    Binary_tree*right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_tree</span><span class="params">(Binary_tree*tree,<span class="keyword">int</span> a[],<span class="keyword">int</span> len,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&gt;len)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    tree=<span class="keyword">new</span> Binary_tree;</span><br><span class="line">    tree-&gt;data=a[index];</span><br><span class="line">    tree-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    create_tree(tree-&gt;left, a, len, <span class="number">2</span> * index + <span class="number">1</span>)</span><br><span class="line">    create_tree(tree-&gt;right, a, len, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用数组的形式表示二叉树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAYTREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYTREE_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ArrayTree(<span class="keyword">int</span> size,<span class="keyword">int</span> *pRoot);</span><br><span class="line">    ~ArrayTree();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">searchNode</span><span class="params">(<span class="keyword">int</span> nodeIndex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> nodeIndex,<span class="keyword">int</span> direction,<span class="keyword">int</span> *node)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> nodeIndex,<span class="keyword">int</span> *node)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">treeTraverse</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>*m_pTree;</span><br><span class="line">    <span class="keyword">int</span> m_isize;</span><br><span class="line">&#125;</span><br><span class="line">ArrayTree::ArrayTree(<span class="keyword">int</span> size,<span class="keyword">int</span> *pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    m_isize=size;</span><br><span class="line">    m_pTree = <span class="keyword">new</span> <span class="keyword">int</span>[m_iSize];</span><br><span class="line">    r(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; m_iSize;i++)</span><br><span class="line">        m_pTree[i] = <span class="number">0</span>;</span><br><span class="line">    m_pTree[<span class="number">0</span>]=*pRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayTree::~ArrayTree()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_pTree;</span><br><span class="line">    m_pTree = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">searchNode</span><span class="params">(<span class="keyword">int</span> nodeIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nodeIndex&lt;<span class="number">0</span>||nodeIndex&gt;=m_isize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(m_pTree[nodeIndex]==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;m_pTree[nodeIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ArrayTree::addNode(<span class="keyword">int</span> nodeIndex,<span class="keyword">int</span> direction,<span class="keyword">int</span> *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(nodeIndex&lt;<span class="number">0</span>||nodeIndex&gt;=m_isize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>:</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">2</span>*nodeIndex+direction;</span><br><span class="line">    <span class="keyword">if</span>(index&gt;=m_isize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    m_pTree[index]=*node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ArrayTree::delNode(<span class="keyword">int</span> nodeIndex)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nodeIndex &lt; <span class="number">0</span> || nodeIndex &gt;= m_iSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(m_pTree[nodeIndex] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    m_pTree[nodeIndex] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index=nodeIndex*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index1=nodeIndex*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(m_pTree[index]!=<span class="literal">NULL</span>)</span><br><span class="line">        delNode(index);</span><br><span class="line">    <span class="keyword">if</span>(m_pTree[index1]!=<span class="literal">NULL</span>)</span><br><span class="line">        delNode(index1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ArrayTree::treeTraverse()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m_iSize;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m_pTree[i]&lt;&lt;<span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="22、TOPK问题"><a href="#22、TOPK问题" class="headerlink" title="22、TOPK问题"></a>22、TOPK问题</h6><p>面试中，TopK，是问得比较多的几个问题之一，到底有几种方法，这些方案里蕴含的优化思路究竟是怎么样的，今天和大家聊一聊。</p>
<p><em>画外音：</em> <em>除非校招，我在面试过程中从不问TopK这个问题，默认大家都知道。</em></p>
<p><strong>问题描述</strong>：</p>
<p>从<code>arr[1, n]</code>这n个数中，找出最大的k个数，这就是经典的TopK问题。 </p>
<p><strong>栗子</strong>：</p>
<p>从<code>arr[1, 12]={5,3,7,1,8,2,9,4,7,2,6,6}</code> 这<code>n=12个</code>数中，找出最大的<code>k=5</code>个。</p>
<p><strong>一、排序</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f63b5392d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>排序是最容易想到的方法，将n个数排序之后，取出最大的k个，即为所得</p>
<p><strong>伪代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort(arr, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">1</span>, k];</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：<code>O(n*lg(n))</code></p>
<p><strong>分析</strong>：明明只需要TopK，却将全局都排序了，这也是这个方法复杂度非常高的原因。那能不能不全局排序，而只局部排序呢？ 这就引出了第二个优化方法。</p>
<p><strong>二、局部排序</strong></p>
<p>不再全局排序，只对最大的k个排序。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f6398efd6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>冒泡是一个很常见的排序方法，每冒一个泡，找出最大值，冒k个泡，就得到TopK。</p>
<p><strong>伪代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span> to k)&#123;</span><br><span class="line">       bubble_find_max(arr,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">1</span>, k];</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：<code>O(n*k)</code></p>
<p><strong>分析</strong>：冒泡，将全局排序优化为了局部排序，非TopK的元素是不需要排序的，节省了计算资源。不少朋友会想到，需求是TopK，是不是这最大的k个元素也不需要排序呢？ 这就引出了第三个优化方法。</p>
<p><strong>三、堆</strong></p>
<p><strong>思路</strong>：只找到TopK，不排序TopK。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f63ab4ba7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f63a8839a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f7b5e35f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>直到，扫描完所有n-k个元素，最终堆中的k个元素，就是猥琐求的TopK。</p>
<p><strong>伪代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = make_heap(arr[<span class="number">1</span>, k]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=k+<span class="number">1</span> to n)&#123;</span><br><span class="line">        adjust_heap(heep[k],arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> heap[k];</span><br></pre></td></tr></table></figure>



<p><strong>时间复杂度</strong>：<code>O(n*lg(k))</code></p>
<p><em>画外音：n个元素扫一遍，假设运气很差，每次都入堆调整，调整时间复杂度为堆的高度，即lg(k)，故整体时间复杂度是n\</em>lg(k)。 </p>
<p><strong>分析</strong>：堆，将冒泡的TopK排序优化为了TopK不排序，节省了计算资源。堆，是求TopK的经典算法，那还有没有更快的方案呢？</p>
<p><strong>四、随机选择</strong></p>
<p>随机选择算在是《算法导论》中一个经典的算法，其时间复杂度为O(n)，是一个线性复杂度的方法。</p>
<p>这个方法并不是所有同学都知道，为了将算法讲透，先聊一些前序知识，一个所有程序员都应该烂熟于胸的经典算法：快速排序。</p>
<p><em>画外音：</em></p>
<p><em>（1）如果有朋友说，“不知道快速排序，也不妨碍我写业务代码呀”…额…</em></p>
<p><em>（2）除非校招，我在面试过程中从不问快速排序，默认所有工程师都知道；</em></p>
<p><strong>其伪代码是</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, inthigh)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low== high) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> i = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">         quick_sort(arr, low, i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">         quick_sort(arr, i+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心算法思想是，分治法</p>
<p><strong>分治法</strong>（Divide&amp;Conquer），把一个大的问题，转化为若干个子问题 （Divide），每个子问题“<strong>都</strong>”解决，大的问题便随之解决（Conquer）。这里的关键词是<strong>“都”</strong>。从伪代码里可以看到，快速排序递归时，先通过partition把数组分隔为两个部分，两个部分“都”要再次递归。</p>
<p>分治法有一个特例，叫减治法。</p>
<p><strong>减治法</strong>（Reduce&amp;Conquer），把一个大的问题，转化为若干个子问题 （Reduce），这些子问题中“<strong>只</strong>”解决一个，大的问题便随之解决（Conquer）。这里的关键词是<strong>“只”</strong>。</p>
<p><strong>二分查找binary_search</strong>，BS，是一个典型的运用 减治法思想的算法，其伪代码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BS</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, inthigh, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(low&gt; high) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">         mid= (low+high)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[mid]== target) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(arr[mid]&gt; target)</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">return</span> BS (arr, low, mid<span class="number">-1</span>, target);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">return</span> BS (arr, mid+<span class="number">1</span>, high, target);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从伪代码可以看到，二分查找，一个大的问题，可以用一个mid元素，分成左半区，右半区两个子问题。而左右两个子问题，只需要解决其中一个，递归一次，就能够解决二分查找全局的问题。</p>
<p>通过分治法与减治法的描述，可以发现，分治法的复杂度一般来说是大于减治法的：</p>
<p>快速排序：<code>O(n*lg(n))</code></p>
<p>二分查找：<code>O(lg(n))</code></p>
<p>话题收回来，<strong>快速排序</strong>的核心是：</p>
<p><code>i = partition(arr, low, high);</code></p>
<p><strong>这个partition是干嘛的呢？</strong></p>
<p>顾名思义，partition会把整体分为两个部分。</p>
<p>更具体的，会用数组arr中的一个元素（默认是第一个元素t=arr[low]）为划分依据，将数据arr[low, high]划分成左右两个子数组：</p>
<ul>
<li>左半部分，都比t大</li>
<li>右半部分，都比t小</li>
<li>中间位置i是划分元素</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f7c00aa05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>以上述TopK的数组为例，先用第一个元素t=arr[low]为划分依据，扫描一遍数组，把数组分成了两个半区：</p>
<ul>
<li>左半区比t大</li>
<li>右半区比t小</li>
<li>中间是t</li>
</ul>
<p>partition返回的是t最终的位置i。 </p>
<p>很容易知道，partition的时间复杂度是<code>O(n)</code>。</p>
<p><em>画外音：把整个数组扫一遍，比t大的放左边，比t小的放右边，最后t放在中间N[i]。</em></p>
<p><strong>partition和TopK问题有什么关系呢？</strong></p>
<p>TopK是希望求出arr[1,n]中最大的k个数，那如果找到了<strong>第k大</strong> 的数，做一次partition，不就一次性找到最大的k个数了么？</p>
<p><em>画外音：即partition后左半区的k个数。</em></p>
<p>问题变成了arr[1, n]中找到第k大的数。</p>
<p>再回过头来看看<strong>第一次</strong>partition，划分之后：</p>
<p>i = partition(arr, 1, n);</p>
<ul>
<li>如果i大于k，则说明arr[i]左边的元素都大于k，于是只递归arr[1, i-1]里第k大的元素即可；</li>
<li>如果i小于k，则说明说明第k大的元素在arr[i]的右边，于是只递归arr[i+1, n]里第k-i大的元素即可；</li>
</ul>
<p><em>画外音：这一段非常重要，多读几遍。</em></p>
<p>这就是<strong>随机选择</strong>算法randomized_select，RS，其伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RS</span><span class="params">(arr, low, high, k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(low== high) <span class="keyword">return</span> arr[low];</span><br><span class="line"></span><br><span class="line">  i= partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">  temp= i-low; <span class="comment">//数组前半部分元素个数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(temp&gt;=k)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> RS(arr, low, i<span class="number">-1</span>, k); <span class="comment">//求前半部分第k大</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> RS(arr, i+<span class="number">1</span>, high, k-i); <span class="comment">//求后半部分第k-i大</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6c2f7d503df1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>这是一个典型的减治算法，递归内的两个分支，最终只会执行一个，它的时间复杂度是O(n)。</p>
<p>再次强调一下：</p>
<ul>
<li><strong>分治法</strong>，大问题分解为小问题，小问题都要递归各个分支，例如：快速排序</li>
<li><strong>减治法</strong>，大问题分解为小问题，小问题只要递归一个分支，例如：二分查找，随机选择</li>
</ul>
<p>通过随机选择（randomized_select），找到arr[1, n]中第k大的数，再进行一次partition，就能得到TopK的结果。</p>
<p><strong>五、总结</strong></p>
<p>TopK，不难；其思路优化过程，不简单：</p>
<ul>
<li><strong>全局排序</strong>，O(n*lg(n))</li>
<li><strong>局部排序</strong>，只排序TopK个数，O(n*k)</li>
<li><strong>堆</strong>，TopK个数也不排序了，O(n*lg(k))</li>
<li>分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n))</li>
<li>减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n)</li>
<li>TopK的另一个解法：<strong>随机选择</strong>+partition</li>
</ul>
<h6 id="23、UDP-和TCP的区别"><a href="#23、UDP-和TCP的区别" class="headerlink" title="23、UDP 和TCP的区别"></a>23、UDP 和TCP的区别</h6><p>TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。</p>
<p>　　<strong>对于可靠性，TCP通过以下方式进行保证：</strong></p>
<p><strong>数据包校验：</strong></p>
<p>目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p>
<p><strong>对失序数据包重排序：</strong></p>
<p>既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p>
<p><strong>丢弃重复数据：</strong></p>
<p>对于重复数据，能够丢弃重复数据；</p>
<p><strong>应答机制</strong>：</p>
<p>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>
<p><strong>超时重发</strong>：</p>
<p>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>
<p><strong>流量控制</strong>：</p>
<p>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的<strong>滑动窗口协议。</strong></p>
<p><strong>一、UDP与TCP</strong></p>
<p>UDP（User Datagram Protocol用户数据报协议）是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP采用了流量控制、拥塞控制、连续ARQ（Automatic Repeat Request自动重传请求）等技术来保证它的可靠性。</p>
<p>Redis客户端与Redis服务器之间使用TCP协议进行连接，极光推送内部原理也是基于TCP的长连接。</p>
<p><strong>二：UDP应用场景</strong></p>
<p>1、面向数据报方式；2、网络数据大多为短消息；3、拥有大量Client；4、对数据安全性无特殊要求；5、网络负担非常重，但对响应速度要求高。</p>
<p><strong>三：TCP连接与套接字</strong></p>
<p>TCP连接是一种抽象的概念，表示一条可以通信的链路。每条TCP连接有且仅有两个端点，表示通信的双方。且双方在任意时刻都可以作为发送者和接收者。</p>
<p>一条TCP连接的两端就是两个套接字。套接字=IP地址:端口号。因此，TCP连接=（套接字1，套接字2）=（IP1:端口号1，IP2:端口号2）</p>
<p><strong>四：TCP与UDP的基本区别</strong></p>
<p>1、TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付<br>3、<strong>TCP面向字节流，TCP把数据看成一连串无结构的字节流；UDP是面向报文的</strong><br>4、UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等），但网络拥塞时有些报文可能会丢失（所以不可靠）<br>5、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信<br>6<strong>、TCP首部开销20字节；UDP的首部开销小，只有8个字节</strong><br>7、要求比较高的服务一般使用TCP协议，如FTP、Telnet、HTTP、SMTP（Simple Mail Transfer Protocol简单邮件传输协议）、POP3等，而UDP是面向无连接的，使用这个协议的常见服务有DNS（Domain Name System，域名系统）、SNMP(Simple Network Management Protocol，简单网络管理协议)</p>
<p><strong>TCP对应的协议：</strong></p>
<p>（1） FTP：定义了文件传输协议，使用21端口<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口<br>（5） HTTP：是从Web服务器传输超文本到本地浏览器的传送协议</p>
<p><strong>UDP对应的协议：</strong></p>
<p>（1） DNS：用于域名（主机名）解析服务，将域名地址转换为IP地址。DNS用的是53号端口<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势</p>
<p><strong>五：编程区别</strong></p>
<p>通常我们在说到网络编程时默认是指TCP编程，即用前面提到的socket函数创建一个socket用于TCP通讯，函数参数我们通常填为SOCK_STREAM。即socket(PF_INET, SOCK_STREAM, 0)，这表示建立一个socket用于流式网络通讯。<br>SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，也是双向的，即任何一方都可以收发数据，协议本身提供了一些保障机制保证它是可靠的、有序的，即每个包按照发送的顺序到达接收方。<br>而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的，因为通讯双方发送数据后不知道对方是否已经收到数据，是否正常收到数据。任何一方建立一个socket以后就可以用sendto发送数据，也可以用recvfrom接收数据。根本不关心对方是否存在，是否发送了数据。它的特点是通讯速度比较快。大家都知道TCP是要经过三次握手的，而UDP没有。</p>
<p><strong>socket编程：</strong></p>
<p>Socket用在哪呢，主要用在进程间，网络间通信。所谓socket 通常也称作”套接字“，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。一条TCP连接的两端就是两个套接字（套接字=IP地址：端口号）<br>Socket和ServerSocket类库位于java.net包中。ServerSocket用于服务器端，Socket是建立网络连接时使用的。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别。不管是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的。<br>Accept方法用于产生”阻塞”，直到接受到一个连接，并且返回一个客户端的Socket对象实例。”阻塞”是一个术语，它使程序运行暂时”停留”在这个地方，直到一个会话产生，然后程序继续；通常”阻塞”是由循环产生的。<br>getInputStream方法获得网络连接输入，同时返回一个InputStream对象实例。<br>getOutputStream方法连接的另一端将得到输入，同时返回一个OutputStream对象实例。</p>
<p>注意：其中getInputStream和getOutputStream方法均会产生一个IOException，它必须被捕获，因为它们返回的流对象，通常都会被另一个流对象使用。</p>
<p><strong>TCP：</strong></p>
<p>TCP编程的服务器端一般步骤是：</p>
<p>1、创建一个socket，用函数socket()；<br>2、设置socket属性，用函数setsockopt(); * 可选<br>3、绑定IP地址、端口等信息到socket上，用函数bind();<br>4、开启监听，用函数listen()；<br>5、接收客户端上来的连接，用函数accept()；<br>6、收发数据，用函数send()和recv()，或者read()和write();<br>7、关闭网络连接；<br>8、关闭监听；</p>
<p>TCP编程的客户端一般步骤是：</p>
<p>1、创建一个socket，用函数socket()；<br>2、设置socket属性，用函数setsockopt();* 可选<br>3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>4、设置要连接的服务器的IP地址和端口等属性；<br>5、连接服务器，用函数connect()；<br>6、收发数据，用函数send()和recv()，或者read()和write();<br>7、关闭网络连接；</p>
<p><strong>UDP：</strong></p>
<p>UDP编程的服务器端一般步骤是：</p>
<p>　　1、创建一个socket，用函数socket()；</p>
<p>　　2、设置socket属性，用函数setsockopt();* 可选</p>
<p>　　3、绑定IP地址、端口等信息到socket上，用函数bind();</p>
<p>　　4、循环接收数据，用函数recvfrom();</p>
<p>　　5、关闭网络连接；</p>
<p>UDP编程的客户端一般步骤是：</p>
<p>　　1、创建一个socket，用函数socket()；</p>
<p>　　2、设置socket属性，用函数setsockopt();* 可选</p>
<p>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选</p>
<p>　　4、设置对方的IP地址和端口等属性;</p>
<p>　　5、发送数据，用函数sendto();</p>
<p>　　6、关闭网络连接；</p>
<p><span style="color:red">大多数TCP服务器是并发的，大多数UDP服务器是迭代的。</span></p>
<p>如果服务一个客户请求的时间不长，使用迭代服务器没有太大问题，一旦客户请求的时间需要花费很长，不希望整个服务器被单个客户长期占用，而希望同事服务多个客户，就需要选择并发服务器了。</p>
<h6 id="24、面向字节流和面向报文的区别"><a href="#24、面向字节流和面向报文的区别" class="headerlink" title="24、面向字节流和面向报文的区别"></a>24、面向字节流和面向报文的区别</h6><p>面向报文（UDP）和面向字节流（TCP）的区别</p>
<p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。<br>面向字节流的话，<strong>虽然应用程序和TCP的交互是一次一个数据块（</strong>大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p>
<h6 id="25、sizeof数组的值"><a href="#25、sizeof数组的值" class="headerlink" title="25、sizeof数组的值"></a>25、sizeof数组的值</h6><p><img src="/bolgzxy.github.io/.com//C:%5CUsers%5CCCTVZYX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568838258773.png" alt="1568838258773"></p>
<h6 id="26、int-、long在32和64位下的长度"><a href="#26、int-、long在32和64位下的长度" class="headerlink" title="26、int 、long在32和64位下的长度"></a>26、int 、long在32和64位下的长度</h6><p><img src="/bolgzxy.github.io/.com//C:%5CUsers%5CCCTVZYX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568838315710.png" alt="1568838315710"></p>
<h6 id="27、malloc一次性最大能申请多大内存空间？"><a href="#27、malloc一次性最大能申请多大内存空间？" class="headerlink" title="27、malloc一次性最大能申请多大内存空间？"></a>27、malloc一次性最大能申请多大内存空间？</h6><p>malloc是一个库函数，不同的操作系统上具体实现细节是不同的，以下就以linux条件下进行分析：linux采用的是glibc中堆内存管理ptmalloc实现，虚拟内存的布局规定了malloc申请位置以及大小，malloc一次性能申请小内存（小于128KB），分配的是在堆区（heap），用sbrk()进行对齐生长，而malloc一次性申请大内存（大于128KB时）分配到的是在映射区，而不是在堆区，<strong>采用的mmap()系统调用进行映射。当然虚拟地址只是规定了一种最理想的状态，实际分配还是要考虑到物理内存加交换内存总量的限制，因为每次分配，特别是大内存分配采用mmap（）映射内存需要记录物理内存加交换内存地址，所有物理内存加交换内存限制了malloc实际分配</strong>。比如32位情况下，最新版本的linux的映射区在用户空间区的3G位置，而映射区向下生长，所以理想情况下大概能有2.9GB（除去开始地址128M）,如果你的物理内存加交换区只有2G，malloc一次申请最多1.8G左右，如果你的物理内存加交换区大于4G，那么最多能有2.9G或者2.8G左右。网上能找到测试代码的。</p>
<h6 id="28、全局变量和静态变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"><a href="#28、全局变量和静态变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？" class="headerlink" title="28、全局变量和静态变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？ 　　"></a>28、全局变量和静态变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？ 　　</h6><p>1) 全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>
<p>2) 从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。</p>
<p>3) static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件</p>
<h6 id="29、进程和线程区别，线程共享哪些资源，独占哪些资源"><a href="#29、进程和线程区别，线程共享哪些资源，独占哪些资源" class="headerlink" title="29、进程和线程区别，线程共享哪些资源，独占哪些资源"></a>29、进程和线程区别，线程共享哪些资源，独占哪些资源</h6><h6 id="30、讲讲IO复用，epoll为什么比select效率高"><a href="#30、讲讲IO复用，epoll为什么比select效率高" class="headerlink" title="30、讲讲IO复用，epoll为什么比select效率高"></a>30、讲讲IO复用，epoll为什么比select效率高</h6><p>epoll_data是一个union结构体,它就是epoll版大妈用于保存同学信息的结构体,它可以保存很多类型的信息:fd,指针,等等.有了这个结构体,epoll大妈可以不用吹灰之力就可以定位到同学甲.</p>
<p>别小看了这些效率的提高,在一个大规模并发的服务器中,轮询IO是最耗时间的操作之一.再回到那个例子中,如果每到来一个朋友楼管大妈都要全楼的查询同学,那么处理的效率必然就低下了,过不久楼底就有不少的人了.</p>
<p>对比最早给出的阻塞IO的处理模型, 可以看到采用了多路复用IO之后, 程序可以自由的进行自己除了IO操作之外的工作, 只有到IO状态发生变化的时候由多路复用IO进行通知, 然后再采取相应的操作, 而不用一直阻塞等待IO状态发生变化了.</p>
<p>从上面的分析也可以看出,epoll比select的提高实际上是一个用空间换时间思想的具体应用.</p>
<p>epoll在高并发的情况下，比poll和select的效率要高出很多。比如说淘宝的服务器用的就是epoll。淘宝的访问量就非常大，要如何支持高并发呢？用的就是linux的epoll实现的。要了解epoll，还得从select慢慢看起，而且select也有它的适用情况，比如就使用于局域网下，客户端最多就1000台，那么使用select就比较好，又容易，开销又小</p>
<p>select：主要就是起一个监听的作用。也就是监听多个文件描述符。</p>
<p>在多线程多进程情况时，我们是这样处理连接进来的socket的：</p>
<p><img src="https://pic3.zhimg.com/80/v2-49e0d29ba45efa4d359681c647063e5a_hd.jpg" alt="img"></p>
<p>中间的数组是文件描述符集合，里面都是socket的文件描述符。然后一个线程或进程调用accept进行阻塞监听，然后来了一个连接后，就创建新的进程或者线程去对应该连接，然后就有了新的文件描述符。新的文件描述符就是负责和连接通信的，比如读写什么的，就不是accept新的进程线程了。这种情况下，当客户端没有发数据来服务端，那么对应的线程和进程会一直处于阻塞状态，它要读取该文件描述符，可是却数据，所以一直不返回。而很多情况下，客户端和服务端的数据量传输都是比较少的，所以就有大量的进程或线程处于阻塞状态，这样就会非常耗费系统的资源。</p>
<p>上面就是没有select，poll，epoll的时候的处理方式。</p>
<p>而select是这样的，如下图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4f5057199f22b90350bd748e89453b1b_hd.jpg" alt="img"></p>
<p>select只在一个线程内运行，但它可以监视多个文件描述符，这样就不需要另外的进程和线程资源了。然后我们来叙述一下select的一个比较完整的运行流程：如下图：</p>
<p><img src="https://pic3.zhimg.com/80/v2-0b8e3969800ba34c819104ea153543e6_hd.jpg" alt="img"></p>
<p>我来慢慢解释：socket文件描述符在这里分两种，一种是用于接收外面的socket的，另一种是和外面的socket进行通信的。比如上图中，文件描述符7就是用于接收请求连接的客户端，4，5，6，8都是直接和外面的socket通信的。我们先把4，5，6，7都挂载到select上，也就是说当文件描述符4，5，6，7任一个处于就绪状态的时候，就会反应到select上，什么时候文件描述符处于就绪状态呢？就是当外面发送数据进来，然后文件描述符这里有数据要读，或者文件描述符这边有请求连接的链接，那么select就会去遍历自己对应的文件描述符集合，看看到底是哪个文件描述符有反应了，<strong>select返回的是就绪的文件描述符的个数</strong>，如果是7有反应了，那么就调用accept函数去接收新的连接，然后分配新的文件描述符8给对应的连接，然后再把文件描述符8挂载到这个select上。如果是4，5，6上有反应了，那么就调用read函数，去读取文件描述符上的数据。当select返回后一般还会继续运行select，也就是说放在死循环里，然后继续处于阻塞状态，等待响应。 这里有个瓶颈：就是比如select在处理文件描述符4的时候，文件描述符5又来了数据，那么select就不能处理。这个看视频没有注意到答案？？？</p>
<p>这就是<strong>多路IO转接</strong>了，相信大家应该有理解了吧？如果大家对java的nio框架netty有所熟悉的话，应该就很容易理解了。虽然netty在linux上底层使用的是epoll，但是模型是一样的，有兴趣的可以了解一下：<a href="https://zhuanlan.zhihu.com/c_1040914558763941888" target="_blank" rel="noopener">netty学习</a> 。</p>
<p>这里要注意select的一个缺陷：</p>
<p>1.select能监听的文件描述符个数受限于FD_ SETSIZE,一 般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数。（一个进程能打开的文件描述符的个数就是1024）</p>
<p>2.解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力</p>
<p>然后我们再来看看select函数的声明：</p>
<p>int select(int nfds, fd_ set *readfds, fd_ set *wr itefds,fd_ set *exceptfds, struct timeval *t imeout);</p>
<p>nfds:监控的文件描述符集里最大文件描述符加1,因为此参数会告诉内核检测前多少个文件描述符的状态</p>
<p>（比如刚才那副图中，文件描述符最大是8，所以这个值就是9）</p>
<p>readfds :监控有读数据到达文件描述符集合，传入传出参数</p>
<p>writefds :监控写数据到达文件描述符集合，传入传出参数</p>
<p>exceptfds :监控异常发生到达文件描述符集合,如带外数据到达异常，传入传出参数</p>
<p>（上面三个参数的意思就是：文件描述符有三种方式可以触发select的响应，需要读数据的时候，需要写数据的时候，发送异常的时候，比如说文件描述符4只存在于读数据的集合中，那么select只在4需要读数据的就绪情况下产生反应，其它情况都不产生反应，这样就显得更加灵活）</p>
<p>timeout :定时阻塞监控时间，3种情况</p>
<p>1.NULL，永远等下去</p>
<p>2.设置timeval,等待固定时间</p>
<p>3.设置timeval里时间均为0，检查描述字后立即返回，轮询</p>
<p>（跟java中的wait一个机制，语义理解就好）</p>
<p>所以，这个select就讲到这里了，学习这个能看懂别人的代码就好，或者用于局域网的几台机器即可，不需要要求太高。</p>
<p>（大家可以去看视频看看代码的演示效果，也就是使用select之后就可以一个进程线程对应多个进程线程的连接了）</p>
<p>poll:</p>
<p>就我的大致了解看来，和select没什么大的区别，就是这里没发现说没有最大连接数的限制了。</p>
<p>如下图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-e3e36c9b14933b7b6825afc260170bb3_hd.jpg" alt="img"></p>
<p>第一感觉就是构造形式不同，它传入的是pollfd的结构体数组，一个结构体里，fd是文件描述符号，events是此文件描述符监控的事件，比如前面提到的读数据，写数据，异常。revents是返回的事件，比如此文件符监控读数据和写数据，那么读数据发生时，就会从这里返回。</p>
<p>感觉可能是自己现在的基础比较少，后面有了足够的基础后再来好好看看。</p>
<p>epoll:</p>
<p>epoll是Linux下多路复用IO接口se1ect/poll的增强版本，它能<strong>显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率</strong>，因为它会<strong>复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合</strong>，另一点原因就是获取事件的时候，它<strong>无须遍历整个被侦听的描述符集，只要遍历那些被内核I0事件异步唤醒而加入Ready队列的描述符集合就行</strong>了。</p>
<p>​    epoll:</p>
<p>epoll是Linux下多路复用IO接口se1ect/poll的增强版本，它能<strong>显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率</strong>，因为它会<strong>复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合</strong>，另一点原因就是获取事件的时候，它<strong>无须遍历整个被侦听的描述符集，只要遍历那些被内核I0事件异步唤醒而加入Ready队列的描述符集合就行</strong>了。</p>
<p>解释一下上面这段话：”复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合“ 也就是说，比如select函数响应返回之后，传入的参数，即监听的文件描述符集合需要重新准备，然后再传入。而epoll就不需要再重新准备传入的参数。</p>
<p>“无须遍历整个被侦听的描述符集，只要遍历那些被内核I0事件异步唤醒而加入Ready队列的描述符集合就行” 这句话的意思是：</p>
<p>如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-2cd162d5f176bb06233ec3159aa0f448_hd.jpg" alt="img"></p>
<p>比如左边的就是传入的要监控的文件描述符集合。select和epoll返回了就绪的文件描述符的个数，但是不知道是哪个文件描述符，所以它需要遍历一遍去一一确认。而epoll就是用一个队列存储了这些就绪的文件描述符，直接遍历这个队列即可。这表示了什么？比如说有10万个要监控的文件描述符集合，然后只有三个文件描述符就绪了（或者说三个文件描述符是活跃的），如果是select或epoll,那么他们就需要遍历这10万个文件描述符（应该是满3个了就结束了吧，但是哪个就绪也不确定，如果是最后的那不就凉凉），这就消耗了很大的系统资源。而epoll只需要遍历这个只存储了三个元素的队列即可，这就跟开了挂一样。所以，这就显示出了它能<strong>显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</strong>如果是10万的文件描述符，有8万的活跃文件描述符，那么epoll就显示不出比较大的优越性了。所以，并没有绝对的要使用哪个函数，取决于并发量和数据量。</p>
<p><strong>select的几大缺点：</strong></p>
<p><strong>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大（因为在内核才能监听那些数据，也就是操作文件描述符的读写）</strong></p>
<p><strong>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p>
<p><strong>（3）select支持的文件描述符数量太小了，默认是1024</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-4a0e2948e47c619bc10c4ceb5119db88_hd.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-c804d66ee794fdd113a7cdd003db6f8a_hd.jpg" alt="img"></p>
<p>二 工作模式</p>
<p>　epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<ol>
<li>LT模式</li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ol start="2">
<li>ET模式</li>
</ol>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h6 id="31、浏览器输入一个URL会发生什么"><a href="#31、浏览器输入一个URL会发生什么" class="headerlink" title="31、浏览器输入一个URL会发生什么"></a>31、浏览器输入一个URL会发生什么</h6><p><strong>1、</strong>查询DNS，获取域名对应的IP。</p>
<p>（1）检查本地hosts文件是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。 </p>
<p>（2）如果没有，则查找本地DNS解析器缓存是否有这个网址的映射，如果有，返回映射，解析完成。 </p>
<p>（3）如果没有，则查找填写或分配的首选DNS服务器，称为本地DNS服务器。服务器接收到查询时：</p>
<ul>
<li>如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。 </li>
<li>如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。</li>
</ul>
<p>（4）如果本地DNS服务器也失效：  </p>
<ul>
<li>如果未采用转发模式（迭代），本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如<a href="https://link.zhihu.com/?target=http%3A//baidu.com" target="_blank" rel="noopener">http://baidu.com</a>）的IP给本地DNS服务器，循环往复直至查询到映射，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。</li>
<li>如果采用转发模式（递归），则此DNS服务器就会把请求转发至上一级DNS服务器，如果上一级DNS服务器不能解析，则继续向上请求。最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。</li>
</ul>
<p><strong>2、</strong>客户机发送HTTP请求报文：</p>
<p>（1）应用层：客户端发送HTTP请求报文</p>
<p>（2）传输层：切分长数据，并确保可靠性。</p>
<p>（3）网络层：进行路由</p>
<p>（4）数据链路层：传输数据</p>
<p>（5）物理层：物理传输bit</p>
<p><strong>3、</strong>服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。</p>
<p><strong>4、</strong>客户端解析HTTP响应报文</p>
<p><strong>5、</strong>浏览器开始显示HTML</p>
<p><strong>6、</strong>浏览器重新发送请求获取图片、CSS、JS的数据。</p>
<p><strong>7、</strong>如果有AJAX，浏览器发送AJAX请求，及时更新页面</p>
<p><img src="https://img-blog.csdn.net/20180421153546225" alt="img"></p>
<h6 id="32、类的什么函数不能为虚函数"><a href="#32、类的什么函数不能为虚函数" class="headerlink" title="32、类的什么函数不能为虚函数"></a>32、类的什么函数不能为虚函数</h6><p>1：只有类的成员函数才能说明为虚函数；<br><strong>2：静态成员函数不能是虚函数；</strong><br><strong>3：内联函数不能为虚函数；</strong> </p>
<p><strong>4：构造函数不能是虚函数；</strong><br>5：析构函数可以是虚函数，而且通常声明为虚函数。</p>
<h6 id="33、什么时候需要自己定义拷贝构造函数"><a href="#33、什么时候需要自己定义拷贝构造函数" class="headerlink" title="33、什么时候需要自己定义拷贝构造函数"></a>33、什么时候需要自己定义拷贝构造函数</h6><p>如果你需要定义一个非空的析构函数，那么，通常情况下你也需要定义一个拷贝构造函数。</p>
<h6 id="34、纯虚函数有什么用"><a href="#34、纯虚函数有什么用" class="headerlink" title="34、纯虚函数有什么用"></a>34、纯虚函数有什么用</h6><p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。而针对每种动物的方法又有所不同，此时需要使用多态特性，也就需要在基类中定义虚函数。</p>
<p>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。</p>
<p>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
<p>含有纯虚函数的类称之为抽象类，它不能生成对象（创建实例），只能创建它的派生类的实例。抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。</p>
<p>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<h6 id="35、有哪几种情况只能用intialization-list-而不能用assignment"><a href="#35、有哪几种情况只能用intialization-list-而不能用assignment" class="headerlink" title="35、有哪几种情况只能用intialization list 而不能用assignment?"></a>35、<strong>有哪几种情况只能用intialization list 而不能用assignment?</strong></h6><p>   当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。</p>
<h6 id="36、main-函数执行以前，还会执行什么代码？"><a href="#36、main-函数执行以前，还会执行什么代码？" class="headerlink" title="36、main 函数执行以前，还会执行什么代码？"></a>36、<strong>main 函数执行以前，还会执行什么代码？</strong></h6><p>   全局对象的构造函数会在main 函数之前执行。</p>
<h6 id="37、请说出const与-define-相比，有何优点？"><a href="#37、请说出const与-define-相比，有何优点？" class="headerlink" title="37、请说出const与#define 相比，有何优点？"></a>37、<strong>请说出const与#define 相比，有何优点？</strong></h6><p>const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</p>
<p>1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</p>
<p>2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p>
<h6 id="38、简述数组与指针的区别？"><a href="#38、简述数组与指针的区别？" class="headerlink" title="38、简述数组与指针的区别？"></a>38、<strong>简述数组与指针的区别？</strong></h6><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</p>
<p>(1)修改内容上的差别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = “hello”;</span><br><span class="line">a[<span class="number">0</span>] = ‘X’;</span><br><span class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意p 指向常量字符串</span></span><br><span class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误，运行时错误</span></span><br></pre></td></tr></table></figure>

<p>(2) 用运算符sizeof 可以计算出数组的容量（字节数）。</p>
<p>sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</p>
<p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br><span class="line">计算数组和指针的内存容量</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是100 字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="39、int-s-10-int-表示的是什么？"><a href="#39、int-s-10-int-表示的是什么？" class="headerlink" title="39、int (*s[10])(int) 表示的是什么？"></a>39、<strong>int (*s[10])(int) 表示的是什么？</strong></h6><p>int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。</p>
<h6 id="40、栈和文字常量区"><a href="#40、栈和文字常量区" class="headerlink" title="40、栈和文字常量区"></a>40、栈和文字常量区</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">char</span> str2[] = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">const</span> <span class="keyword">char</span> str3[] = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">const</span> <span class="keyword">char</span> str4[] = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">const</span> <span class="keyword">char</span> *str5 = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">const</span> <span class="keyword">char</span> *str6 = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">char</span> *str7 = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="keyword">char</span> *str8 = <span class="string">"abc"</span>;</span><br><span class="line">　　<span class="built_in">cout</span> &lt;&lt; ( str1 == str2 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0  分别指向各自的栈内存</span></span><br><span class="line">　　<span class="built_in">cout</span> &lt;&lt; ( str3 == str4 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0  分别指向各自的栈内存</span></span><br><span class="line">　　<span class="built_in">cout</span> &lt;&lt; ( str5 == str6 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1指向文字常量区地址相同</span></span><br><span class="line">　　<span class="built_in">cout</span> &lt;&lt; ( str7 == str8 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1指向文字常量区地址相同</span></span><br></pre></td></tr></table></figure>

<h6 id="41、将程序跳转到指定内存地址"><a href="#41、将程序跳转到指定内存地址" class="headerlink" title="41、将程序跳转到指定内存地址"></a>41、<strong>将程序跳转到指定内存地址</strong></h6><p>要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*((<span class="keyword">void</span> (*)( ))<span class="number">0x100000</span> ) ( );</span><br><span class="line">　　首先要将<span class="number">0x100000</span>强制转换成函数指针,即:</span><br><span class="line">　　(<span class="keyword">void</span> (*)())<span class="number">0x100000</span>　　然后再调用它:</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*((<span class="keyword">void</span> (*)())<span class="number">0x100000</span>)();</span><br><span class="line">　　用<span class="keyword">typedef</span>可以看得更直观些:</span><br><span class="line">　　<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*)</span><span class="params">()</span> voidFuncPtr</span>;</span><br><span class="line">　　*((voidFuncPtr)<span class="number">0x100000</span>)();</span><br></pre></td></tr></table></figure>

<h6 id="42、复杂声明"><a href="#42、复杂声明" class="headerlink" title="42、复杂声明"></a>42、<strong>复杂声明</strong></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * ( * (*fp1)(<span class="keyword">int</span>))[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">float</span> (*(* fp2)(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>))(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (* ( * fp3)())[<span class="number">10</span>]();</span><br></pre></td></tr></table></figure>

<p>分别表示什么意思？  </p>
<p>1、<code>void * ( * (*fp1)(int))[10]</code>; <code>fp1</code>是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个<code>void*</code>型指针。</p>
<p>2、<code>float (*(* fp2)(int,int,int))(int)</code>; <code>fp2</code>是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是<code>float</code>型。</p>
<p>3、<code>int (* ( * fp3)())[10]()</code>; <code>fp3</code>是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是<code>int</code>型。</p>
<h6 id="43、头文件中的ifndef-define-endif有什么作用？"><a href="#43、头文件中的ifndef-define-endif有什么作用？" class="headerlink" title="43、头文件中的ifndef/define/endif有什么作用？"></a>43、<strong>头文件中的ifndef/define/endif有什么作用？</strong></h6><p>这是C++预编译头文件保护符，保证即使文件被多次包含，头文件也只定义一次。</p>
<h6 id="44、关于sizeof小结的。"><a href="#44、关于sizeof小结的。" class="headerlink" title="44、关于sizeof小结的。"></a>44、<strong>关于sizeof小结的。</strong></h6><p>答：sizeof计算的是在栈中分配的内存大小。</p>
<p>（1） sizeof不计算static变量占得内存；</p>
<p>（2） 32位系统的指针的大小是4个字节，64位系统的指针是8字节，而不用管指针类型；</p>
<p>（3） char型占1个字节，int占4个字节，short int占2个字节</p>
<p>long int占4个字节，float占4字节，double占8字节，string占4字节</p>
<p>一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节</p>
<p>（4） 数组的长度：</p>
<p>若指定了数组长度，则不看元素个数，总字节数=数组长度*sizeof（元素类型）</p>
<p>若没有指定长度，则按实际元素个数类确定</p>
<p>Ps：若是字符数组，则应考虑末尾的空字符。</p>
<p>（5） 结构体对象的长度</p>
<p>在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。</p>
<p>（6） unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）=4</p>
<p>（7） 自定义类型的sizeof取值等于它的类型原型取sizeof</p>
<p>（8） 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替</p>
<p>（9） sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符</p>
<p>（10） 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸</p>
<h6 id="45、公有继承、受保护继承、私有继承"><a href="#45、公有继承、受保护继承、私有继承" class="headerlink" title="45、公有继承、受保护继承、私有继承"></a>45、<strong>公有继承、受保护继承、私有继承</strong></h6><p>（1）公有继承时，派生类对象可以访问基类中的公有成员，派生类的成员函数可以访问基类中的公有和受保护成员；</p>
<p>（2）私有继承时，基类的成员只能被直接派生类的成员访问，无法再往下继承；</p>
<p>（3）受保护继承时，基类的成员也只被直接派生类的成员访问，无法再往下继承。</p>
<h6 id="46、-main函数执行之前会执行什么？执行之后还能执行代码吗？"><a href="#46、-main函数执行之前会执行什么？执行之后还能执行代码吗？" class="headerlink" title="46、.main函数执行之前会执行什么？执行之后还能执行代码吗？"></a>46、<strong>.main函数执行之前会执行什么？执行之后还能执行代码吗？</strong></h6><p>（1）全局对象的构造函数会在main函数之前执行；</p>
<p>（2）可以，可以用_onexit 注册一个函数，它会在main 之后执行;</p>
<p>如果你需要加入一段在main退出后执行的代码，可以使用atexit()函数，注册一个函数。</p>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function<span class="string">")(void));</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">void fn1( void ), fn2( void ), fn3( void );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">int main( void )</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">atexit(fn1);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">atexit( fn2 );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">printf( "</span>This is executed first.\n<span class="string">" );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">void fn1()</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">printf( "</span> This is\n<span class="string">" );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">void fn2()</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">printf( "</span> executed next.<span class="string">" );</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">结果：</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">This is executed first.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">This is executed next.</span></span></span></span><br></pre></td></tr></table></figure>

<h6 id="46、-类使用static成员的优点，如何访问？"><a href="#46、-类使用static成员的优点，如何访问？" class="headerlink" title="46、.类使用static成员的优点，如何访问？"></a>46、<strong>.类使用static成员的优点，如何访问？</strong></h6><p>（1）static 成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突；</p>
<p>（2）可以实施封装。static 成员可以是私有成员，而全局对象不可以；</p>
<p>（3） static 成员是与特定类关联的，可清晰地显示程序员的意图。</p>
<p>static 数据成员必须在类定义体的外部定义(正好一次)，static 关键字只能用于类定义体内部的声明中，定义不能标示为static.<br>不像普通数据成员，static成员不是通过类构造函数进行初始化，也不能在类的声明中初始化，而是应该在定义时进行初始化.保证对象正好定义一次的最好办法，就是将static<br>数据成员的定义放在包含类非内联成员函数定义的文件中。</p>
<p>静态数据成员初始化的格式为：<br>$$<br>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞<br>$$<br>类的静态数据成员有两种访问形式：<br>$$<br>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞<br>$$</p>
<h6 id="47、多态类中的虚函数表是-Compile-Time，还是-Run-Time时建立的"><a href="#47、多态类中的虚函数表是-Compile-Time，还是-Run-Time时建立的" class="headerlink" title="47、多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?"></a>47、<strong>多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?</strong></h6><p>虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组。而对象的隐藏成员–虚拟函数表指针是在运行期–也就是构造函数被调用时进行初始化的，这是实现多态的关键。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/重载、继承、多态/C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/重载、继承、多态/C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>就是一种传承，可以把父类型中的数据传承到子类中，子类除了传承了父类的数据之外，还可以对父类型进行扩展；</strong></p>
<ol>
<li><strong>公开继承  public</strong></li>
<li><strong>保护继承  protected</strong></li>
<li><strong>私有继承  private</strong></li>
<li><strong>保护成员：在子类和本类中可以访问，其他不行；</strong></li>
</ol>
<p>1、公开继承：在公开继承下，父类型中的数据是公开的到子类型中权限是公开的；父类型中保护权限的数据到子类中是保护的；父类中私有的数据到子类中会隐藏掉（就是说看不见权限，但是实际上式在子类中的）；</p>
<p>2、私有继承：在私有继承下，父类中的公开数据到子类中变成私有的，父类中的保护数据到子类中称为私有的，父类中的私有数据到子类中隐藏；</p>
<p>3、保护继承：保护继承下，父类中的公开数据和保护数据到了子类中都成为保护权限，父类中私有的数据到了子类中就变成了隐藏的；<br>4、注意：不管何种类型的继承关系，父类私有成员到子类中都成为了隐藏掉。</p>
<h5 id="1-公开继承下的public成员和protected成员的权限变化："><a href="#1-公开继承下的public成员和protected成员的权限变化：" class="headerlink" title="1.公开继承下的public成员和protected成员的权限变化："></a><strong>1.公开继承下的public成员和protected成员的权限变化：</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">geta</span><span class="params">()</span></span>&#123;</span><br><span class="line">		a = <span class="number">300</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*保护类型成员在本类和子类中可以访问*/</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="comment">//int x;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getb</span><span class="params">()</span></span>&#123;</span><br><span class="line">		b = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showa</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt; a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/*关键在于如何设置接口，成功合理的访问到各种类型的数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B pex;</span><br><span class="line">	<span class="comment">/*公开继承public成员依旧是public，所以可以类外访问*/</span></span><br><span class="line">	pex.a = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">/*b是保护类型成员，可以通过设置public接口来访问*/</span></span><br><span class="line">	pex.getb();</span><br><span class="line">	pex.show();</span><br><span class="line">	<span class="comment">/*隐藏成员的问题，怎么访问到隐藏的成员*/</span></span><br><span class="line">	pex.geta();</span><br><span class="line">	pex.showa();</span><br><span class="line">	<span class="comment">//A a = pex;//子类类型赋给了父类类型</span></span><br><span class="line">	<span class="comment">//a.geta();</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a.a &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-私有继承下的成员的权限变化关系，"><a href="#2-私有继承下的成员的权限变化关系，" class="headerlink" title="2.私有继承下的成员的权限变化关系，"></a>2.私有继承下的成员的权限变化关系，</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*私有继承下的权限变化，关键是设置合理的接口访问</span></span><br><span class="line"><span class="comment">父类中的各种类型的数据成员*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showa</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is showa()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showb</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is showb"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is showc"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">geta</span><span class="params">()</span></span>&#123;<span class="comment">//设置合理的接口访问A中的私有数据</span></span><br><span class="line">		showa();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">private</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		showc();</span><br><span class="line">		showb();</span><br><span class="line">		geta();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="comment">//A a = b;对比公开继承，对比一下</span></span><br><span class="line">	b.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。"><a href="#3-突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。" class="headerlink" title="3.突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。"></a>3.突破成员访问权限，可以设置合理的访问接口，也可以使用友元类。</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*友元类*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():x(<span class="number">10</span>),y(<span class="number">123</span>)&#123;&#125;</span><br><span class="line">	<span class="comment">/*B,C声明为A的友元类之后，可以访问到父类的所有类型成员*/</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"---"</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		A a;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;a.x&lt;&lt; <span class="string">"---"</span> &lt;&lt; a.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.show();</span><br><span class="line">	C c;</span><br><span class="line">	c.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数"><a href="#4-继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数" class="headerlink" title="4.继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数"></a>4.继承中构造函数、析构函数、赋值运算符函数和拷贝构造函数</h5><p><span style="color:red"><strong>构造函数和析构函数是不能被继承的，但是可以被调用。并且子类一定会调用父类的构造函数；</strong></span></p>
<p><strong>子类默认调用父类的无参构造，也可以制定调用构造函数；</strong></p>
<p><strong>析构函数的调用和构造函数的调用顺序相反；</strong></p>
<p><strong>拷贝构造函数和赋值运算符函数也不能被继承：在子类不提供拷贝构造和赋值运算符时，子类默认调用父类的赋值运算符和拷贝构造函数。但子类一旦提供拷贝构造和赋值运算符函数则不再调用父类拷贝构造和赋值运算符函数。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*继承中构造函数和析构函数的调用：构造函数和析构函数不可以</span></span><br><span class="line"><span class="comment">被继承，但是可以被调用，而且子类肯定会调用父类的构造函数</span></span><br><span class="line"><span class="comment">和析构函数。这种机制可以很自然的用于访问父类的私有成员*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//A()&#123;cout &lt;&lt; "A()" &lt;&lt; endl;&#125;</span></span><br><span class="line">	A(<span class="keyword">int</span> x = <span class="number">0</span>):x(x)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"A()构造"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="keyword">int</span> _get()&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*在初始化参数列表中可以指定调用父类的构造函数,指定调用构造函数并且给</span></span><br><span class="line"><span class="comment">	父类中的私有成员赋值*/</span></span><br><span class="line">	<span class="comment">/*注意：子类默认调用父类的无参构造，如果下面的代码没有：A(100),则会调用无参构造，但是父类无参构造</span></span><br><span class="line"><span class="comment">	被注释掉，所以会出错*/</span></span><br><span class="line">	B():A(<span class="number">100</span>)&#123;</span><br><span class="line">		<span class="comment">//x = 200;</span></span><br><span class="line">		<span class="comment">//A(100);</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//访问有参构造的方式,理解这种方式的作用</span></span><br><span class="line">	<span class="comment">/*注意，这种机制下的构造函数所赋的值是赋到了子类中的数据x中，</span></span><br><span class="line"><span class="comment">	而父类中的x仍然为0*/</span></span><br><span class="line">	~B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getbx</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _get();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;<span class="comment">//构建A对象，此时A类构造被调用，并打印出了值</span></span><br><span class="line"> </span><br><span class="line">	B b;<span class="comment">//B类为无参构造，首先调用了A的构造，在调用B的构造</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//打印a对象中的x成员</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;a._get()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a对象中的x为0</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//打印b对象中的x</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.getbx()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//是100</span></span><br><span class="line">	<span class="comment">/*一层一层的退，先调用b的析构，在调用a的析构*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-拷贝构造和赋值运算符的问题"><a href="#5-拷贝构造和赋值运算符的问题" class="headerlink" title="5.拷贝构造和赋值运算符的问题"></a>5.拷贝构造和赋值运算符的问题</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*系统一旦提供构造函数，系统默认的构造函数将被回收</span></span><br><span class="line"><span class="comment">记住，拷贝构造也是构造函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A()&#123;&#125;</span><br><span class="line">	<span class="comment">//A(int x = 0):arr(x)&#123;&#125;</span></span><br><span class="line">	A(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"父类拷贝构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"父类赋值运算符函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*有指针类型的成员时，采用默认机制就麻烦了*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="comment">//int * pi;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B()&#123;&#125;</span><br><span class="line">	B(<span class="keyword">const</span> B&amp; b):A(b)&#123;                      </span><br><span class="line">		<span class="comment">//子类中提供了拷贝构造函数将不再调用父类的拷贝构造</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"子类拷贝构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> B&amp; b)&#123;</span><br><span class="line">		A::<span class="keyword">operator</span>=(b);         <span class="comment">//调用父类的拷贝构造函数的机制</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"子类赋值运算符函数"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B a;</span><br><span class="line">	B b = a;</span><br><span class="line">	B c;</span><br><span class="line">	c = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-名字隐藏"><a href="#6-名字隐藏" class="headerlink" title="6.名字隐藏"></a>6.名字隐藏</h5><p><strong>名字隐藏机制：子类中如果定义了和父类中同名的数据，这些数据包括成员变量和成员函数。则会把父类中的数据隐藏掉。</strong></p>
<p>注意：只要名字相同，计算返回值或者形参列表不同，也会被隐藏。隐藏不代表就没有了，可以通过类名作用域::访问到被隐藏的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"show A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A()&#123;x=<span class="number">20</span>;&#125;</span><br><span class="line">	A(<span class="keyword">int</span> x):x(x)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"show A(int x)"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shouu</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"shouu()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"show B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		A::show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.shouu();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.A::x &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//突破名字隐藏机制</span></span><br><span class="line">	<span class="keyword">int</span> c = b.show();被隐藏，无法访问</span><br><span class="line">	b.A::show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-多继承和函数重写"><a href="#7-多继承和函数重写" class="headerlink" title="7.多继承和函数重写"></a>7.多继承和函数重写</h5><p><strong>多继承是c++特有的语法机制，表现为一个子类有多个直接的父类。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//phone();</span></span><br><span class="line">	phone(<span class="keyword">double</span> price = <span class="number">15</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~phone()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use calling"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MP3(<span class="keyword">double</span> price = <span class="number">20</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~MP3()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use to listening music"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vedio</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vedio(<span class="keyword">double</span> price = <span class="number">0</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~vedio()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">vcd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"watch vedio"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*多继承*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iphone</span>:</span><span class="keyword">public</span> phone,<span class="keyword">public</span> MP3,<span class="keyword">public</span> vedio&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> phone::getprice() + MP3::getprice() + vedio::getprice();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	iphone iphone6;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(iphone) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.MP3::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.phone::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.getprice() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//用名字隐藏机制解决多分数据同名冲突的问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:green">多继承遇到的问题：上面的代码用sizeof就可以看到，子类在多继承的时候会多次复制顶层数据，而我们期望的是price这个成员只需要复制一份就可以了，因为多余的复制是无意义的。首先采用顶层抽象的方式，将三个父类抽象到更高的层面上。</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*抽象到更高层的类中*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">product</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	product(<span class="keyword">double</span> price = <span class="number">0</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt;<span class="string">"product"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span>:</span><span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//phone();</span></span><br><span class="line">	phone(<span class="keyword">double</span> price = <span class="number">15</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~phone()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use calling"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3</span>:</span><span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MP3(<span class="keyword">double</span> price = <span class="number">20</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~MP3()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use to listening music"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vedio</span>:</span><span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vedio(<span class="keyword">double</span> price = <span class="number">0</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~vedio()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">vcd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"watch vedio"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iphone</span>:</span><span class="keyword">public</span> phone,<span class="keyword">public</span> MP3,<span class="keyword">public</span> vedio&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> phone::getprice() + MP3::getprice() + vedio::getprice();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	iphone iphone6;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;同样会产生冲突的问题</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; sizeof(iphone) &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.MP3::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.phone::getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;//直接调用产生冲突问题，编译器不知道该调用哪一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，product的构造函数 被调用了三次，因为这种继承是一级一级的来的，构造子类的时候找父类，发现父类还有父类，就去调用爷爷类的构造函数，三次继承，三次调用。</p>
<p>这种继承方式构成了一种菱形或者钻石型的继承，叫做菱形继承或者钻石继承，但钻石继承并没有实际解决数据多次复制的问题，为了解决菱形继承，c++提出了虚继承。虚继承就是在继承的时候加上virtual关键字修饰即可。</p>
<p><span style="color:green">虚继承对于共同的成员父亲类从爷爷类那里继承来的，这里为double price，子类直接越级访问，直接从爷爷类那里继承price。</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*类中也会有对齐和补齐*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*抽象到更高层的类中*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">product</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span>  <span class="title">getprice</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	product(<span class="keyword">double</span> price = <span class="number">0</span>):price(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"product"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//phone();</span></span><br><span class="line">	phone(<span class="keyword">double</span> price = <span class="number">15</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~phone()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~phone"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use calling"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MP3(<span class="keyword">double</span> price = <span class="number">20</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~MP3()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~MP3"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"use to listening music"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vedio</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> product&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vedio(<span class="keyword">double</span> price = <span class="number">0</span>):product(price)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	~vedio()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~vedio"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">vcd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"watch vedio"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iphone</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> phone,<span class="keyword">virtual</span> <span class="keyword">public</span> MP3,<span class="keyword">virtual</span> <span class="keyword">public</span> vedio&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	iphone(<span class="keyword">int</span> m = <span class="number">0</span>,<span class="keyword">int</span> v = <span class="number">0</span>,<span class="keyword">int</span> p = <span class="number">0</span>):product(m + p + v)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*虚函数之后，product的构造函数只被调用了一次，孙子类直接越级访问</span></span><br><span class="line"><span class="comment">了product类*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">iphone <span class="title">iphone6</span><span class="params">(<span class="number">1000</span>,<span class="number">2041</span>,<span class="number">3201</span>)</span></span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;同样会产生冲突的问题</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; sizeof(iphone) &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.MP3::getprice() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.phone::getprice() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; iphone6.getprice() &lt;&lt; endl;直接调用产生冲突问题，编译器不知道该调用哪一个</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(iphone) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iphone6.getprice() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码中product的构造函数只调用了一次，说明子类直接越级访问了爷爷类的数据。而对于父类特有的子类照常继承，只是没有通过父类去继承爷爷类的数据成员，所以product的构造函数只被调用了一次。</p>
<p>虚函数：在函数前面加上virtual关键字修饰过的就是虚函数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showa</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚函数的主要表现为会占用四个字节的空间，只要成员中出现虚函数，不管有多少个虚函数，都只用四个字节来维护这个虚关系。虚函数会影响对象的大小。维护虚关系使用一个指针来维护的，所以是四个字节。</p>
<p><strong>函数重写：</strong></p>
<p><strong>在父类中出现一个虚函数，如果在子类中提供和父类同名的函数（注意区分名字隐藏），这就加函数重写。</strong></p>
<p><strong>函数重写要求必须有相同函数名，相同的参数列表，相同的返回值。</strong></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li>
<li>多态是以封装和继承为基础的。</li>
<li>C++ 多态分类及实现：<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ul>
<p>当人们谈论C ++中的多态时，他们通常意味着通过基类指针或引用使用派生类，这称为<strong>子类型多态</strong>。但是他们经常忘记C ++中存在各种其他多态性，例如<strong>参数多态性</strong>，<strong>ad-hoc多态性</strong>和<strong>强制多态性</strong>。</p>
<ul>
<li>子类型多态性也称为<strong>运行时多态性</strong>。</li>
<li>参数多态也称为<strong>编译时多态</strong>。</li>
<li>Ad-hoc多态性也称为<strong>重载</strong>。</li>
<li>强制也称为（隐式或显式）<strong>铸造</strong>。</li>
</ul>
<p>在本文中，我将通过C ++语言中的示例来说明所有多态性，并且还可以深入了解它们具有各种其他名称的原因。</p>
<h4 id="1-子类型多态性（运行时多态性）"><a href="#1-子类型多态性（运行时多态性）" class="headerlink" title="1.子类型多态性（运行时多态性）"></a>1.子类型多态性（运行时多态性）</h4><p>子类型多态性是每个人在C ++中说“多态”时都能理解的。它是通过基类指针和引用使用派生类的能力</p>
<p>这是一个例子。假设你有像这些猫科动物的各种猫，</p>
<p><img src="https://catonmat.net/images/polymorphic-cats.gif" alt="å¤æç«"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cats.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> meow（）= <span class="number">0</span>; </span><br><span class="line">&#125;;<span class="comment">//纯虚函数 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>：<span class="title">public</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">void</span> meow（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt;“Meowing like a regular cat！meow！\ n”; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span>：<span class="title">public</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">void</span> meow（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt;“Meowing like a tiger！MREOWWW！\ n”; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ocelot</span>：<span class="title">public</span> <span class="title">Felid</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> <span class="keyword">void</span> meow（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt;“Meowing like a ocelot！mews！\ n”; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_meowing</span><span class="params">(Felid *cat)</span> </span>&#123;</span><br><span class="line"> cat-&gt;meow();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Cat cat;</span><br><span class="line"> Tiger tiger;</span><br><span class="line"> Ocelot ocelot;</span><br><span class="line"></span><br><span class="line"> do_meowing(&amp;cat);</span><br><span class="line"> do_meowing(&amp;tiger);</span><br><span class="line"> do_meowing(&amp;ocelot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的主要程序传递指针<code>cat</code>，<code>tiger</code>并<code>ocelot</code>以<code>do_meowing</code>一个期望的指针功能<code>Felid</code>。由于它们都是<code>Felid</code>s，程序<code>meow</code>为每个felid 调用正确的函数，输出为：</p>
<p>子类型多态性也称为运行时多态，这是有充分理由的。多态函数调用的解析在运行时通过虚拟表的间接发生。解释这一点的另一种方法是编译器没有在编译时定位要调用的函数的地址，而是在程序运行时，通过解除引用虚拟表中的右指针来调用该函数。在类型理论中，它也被称为包含多态性</p>
<h4 id="2-参数多态性（编译时多态性）"><a href="#2-参数多态性（编译时多态性）" class="headerlink" title="2.参数多态性（编译时多态性）"></a>2.参数多态性（编译时多态性）</h4><p>参数多态提供了为任何类型执行相同代码的方法。在C ++中，参数多态通过模板实现。</p>
<p>最简单的例子之一是泛型<code>max</code>函数，它最多找到两个参数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">max</span>（<span class="title">T</span> <span class="title">a</span>，<span class="title">T</span> <span class="title">b</span>）&#123;</span> </span><br><span class="line"> <span class="keyword">return</span> a&gt; b？a：b; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main（）&#123; </span><br><span class="line"> <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; :: max（<span class="number">9</span>,<span class="number">5</span>）&lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>; <span class="comment">// 9 </span></span><br><span class="line"> <span class="built_in">std</span> :: <span class="built_in">string</span> foo（“foo”），bar（“bar”）; </span><br><span class="line"> <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; :: max（foo，bar）&lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>; <span class="comment">//“foo” </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>max</code>函数是类型的多态<code>T</code>。但请注意，它不适用于指针类型，因为比较指针会比较内存位置而不是内容。为了使它适用于指针，你必须专门化指针类型的模板，这将不再是参数多态，而是ad-hoc多态。</p>
<p>由于参数多态在编译时发生，因此它也称为<strong>编译时多态</strong>。</p>
<h4 id="3-Ad-hoc多态（重载）"><a href="#3-Ad-hoc多态（重载）" class="headerlink" title="3.Ad-hoc多态（重载）"></a>3.Ad-hoc多态（重载）</h4><p>Ad-hoc多态性允许具有相同名称的函数对每种类型采取不同的行为。例如，给定两个<code>int</code>s和<code>+</code>运算符，它将它们加在一起。给定两个，<code>std::string</code>它将它们连接在一起。这称为<strong>重载</strong>。</p>
<p>这是实现功能的具体例子<code>add</code>为<code>int</code> 和<code>string</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">result</span><span class="params">(a)</span></span>;</span><br><span class="line"> result += b;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">5</span>, <span class="number">9</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//14</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="string">"hello "</span>, <span class="string">"world"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您专门化模板，Ad-hoc多态也会出现在C ++中。回到上一个关于<code>max</code>函数的例子，这里是你如何写一个最大值为2 <code>char *</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * max（<span class="keyword">const</span> <span class="keyword">char</span> * a，<span class="keyword">const</span> <span class="keyword">char</span> * b）&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">strcmp</span>（a，b）&gt; <span class="number">0</span>？a：b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-强制多态（铸造）"><a href="#4-强制多态（铸造）" class="headerlink" title="4.强制多态（铸造）"></a>4.强制多态（铸造）</h4><p>当对象或基元被转换为另一种对象类型或基本类型时，就会发生强制。例如，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> b = <span class="number">6</span>; <span class="comment">// int被提升（强制转换）为隐式浮动</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">9.99</span> <span class="comment">// float隐式降级为int</span></span><br></pre></td></tr></table></figure>

<p>当你用C的类型转换的表达式，如明确铸造发生<code>(unsigned int *)</code>或<code>(int)</code>或C ++的<code>static_cast</code>，<code>const_cast</code>，<code>reinterpret_cast</code>，或<code>dynamic_cast</code>。</p>
<p><code>explicit</code>例如，如果类的构造函数不是，则也会发生强制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"> <span class="keyword">int</span> foo; </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> A（<span class="keyword">int</span> foo）：foo（foo）&#123;&#125; </span><br><span class="line"> <span class="keyword">void</span> giggidy（）&#123;<span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; foo &lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> moo（A a）&#123; </span><br><span class="line"> a.giggidy（）; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main（）&#123; </span><br><span class="line"> moo（<span class="number">55</span>）; <span class="comment">//打印55 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你创建了A的构造函数<code>explicit</code>，那就不可能了。让构造函数明确以避免意外转换始终是个好主意。</p>
<p>此外，如果类为类型定义转换运算符<code>T</code>，则可以在<code>T</code>期望类型的任何位置使用它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrazyInt</span> &#123;</span> </span><br><span class="line"> <span class="keyword">int</span> v; </span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"> CrazyInt（<span class="keyword">int</span> i）：v（i）&#123;&#125; </span><br><span class="line"> <span class="keyword">operator</span> <span class="keyword">int</span>（）<span class="keyword">const</span> &#123;<span class="keyword">return</span> v; &#125; <span class="comment">//从CrazyInt转换为int </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="C-中的虚函数-表-实现机制以及用C语言对其进行的模拟实现"><a href="#C-中的虚函数-表-实现机制以及用C语言对其进行的模拟实现" class="headerlink" title="C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现"></a>C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都应该知道C++的精髓是虚函数吧? 虚函数带来的好处就是: 可以定义一个基类的指针, 其指向一个继承类, 当通过基类的指针去调用函数时, 可以在运行时决定该调用基类的函数还是继承类的函数. 虚函数是实现多态(动态绑定)/接口函数的基础. 可以说: 没有虚函数, C++将变得一无是处!</p>
<p>既然是C++的精髓, 那么我们有必要了解一下她的实现方式吗? 有必要! 既然C++是从C语言的基础上发展而来的, 那么我们可以尝试用C语言来模拟实现吗? 有可能! 接下来, 就是我一步一步地来解析C++的虚函数的实现方式, 以及用C语言对其进行的模拟.</p>
<h2 id="C-对象的内存布局"><a href="#C-对象的内存布局" class="headerlink" title="C++对象的内存布局"></a>C++对象的内存布局</h2><p>要想知道C++对象的内存布局, 可以有多种方式, 比如:</p>
<ol>
<li><p>输出成员变量的偏移, 通过offsetof宏来得到</p>
</li>
<li><p>通过调试器查看, 比如常用的VS</p>
</li>
<li><h3 id="只有数据成员的对象"><a href="#只有数据成员的对象" class="headerlink" title="只有数据成员的对象"></a>只有数据成员的对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象大小及偏移:</p>
<table>
<thead>
<tr>
<th align="center">sizeof(Base1)</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">offsetof(Base1, base1_1)</td>
<td>0</td>
</tr>
<tr>
<td align="center">offsetof(Base1, base1_2)</td>
<td>4</td>
</tr>
</tbody></table>
<p>可知对象布局:</p>
<p><img src="/bolgzxy.github.io/.com//C:%5CUsers%5CCCTVZYX%5CDesktop%5C1-1.png" alt="1-1"></p>
<p>可以看到, 成员变量是按照定义的顺序来保存的, 最先声明的在最上边, 然后依次保存!<br>类对象的大小就是所有成员变量大小之和.</p>
</li>
<li><h3 id="没有虚函数的对象"><a href="#没有虚函数的对象" class="headerlink" title="没有虚函数的对象"></a>没有虚函数的对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>4</td>
</tr>
</tbody></table>
<p>和前面的结果是一样的? 不需要有什么疑问对吧?<br>因为如果一个函数不是虚函数,那么他就不可能会发生动态绑定,也就不会对对象的布局造成任何影响.<br>当调用一个非虚函数时, 那么调用的一定就是当前指针类型拥有的那个成员函数. 这种调用机制在编译时期就确定下来了.</p>
</li>
<li><h3 id="拥有仅一个虚函数的类对象"><a href="#拥有仅一个虚函数的类对象" class="headerlink" title="拥有仅一个虚函数的类对象"></a>拥有仅一个虚函数的类对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>4</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>8</td>
</tr>
</tbody></table>
<p>咦? 多了4个字节? 且 base1_1 和 base1_2 的偏移都各自向后多了4个字节!<br>说明类对象的最前面被多加了4个字节的”东东”, what’s it?<br>现在, 我们通过VS2013来瞧瞧类Base1的变量b1的内存布局情况:<br>(由于我没有写构造函数, 所以变量的数据没有根据, 但虚函数是编译器为我们构造的, 数据正确!)<br>(Debug模式下, 未初始化的变量值为<code>0xCCCCCCCC</code>, 即:<code>-858983460</code>)</p>
<p><img src="/bolgzxy.github.io/.com//C:%5CUsers%5CCCTVZYX%5CDesktop%5C3-1.png" alt="3-1"></p>
<p>看到没? base1_1前面多了一个变量 __vfptr(常说的虚函数表vtable指针), 其类型为void<strong>, 这说明它是一个void*指针(</strong>注意:**不是数组).</p>
<p>再看看[0]元素, 其类型为void*, 其值为 ConsoleApplication2.exe!Base1::base1_fun1(void), 这是什么意思呢? 如果对WinDbg比较熟悉, 那么应该知道这是一种惯用表示手法, 她就是指 Base1::base1_fun1() 函数的地址.</p>
<p>可得, __vfptr的定义伪代码大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>*   __fun[<span class="number">1</span>] = &#123; &amp;Base1::base1_fun1 &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>**  __vfptr = &amp;__fun[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>值得注意的是:</p>
<ol>
<li><p>上面只是一种伪代码方式, 语法不一定能通过</p>
</li>
<li><p>该类的对象大小为12个字节, 大小及偏移信息如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(__vfptr)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(base1_1)</td>
<td>4</td>
</tr>
<tr>
<td>offsetof(base1_2)</td>
<td>8</td>
</tr>
</tbody></table>
</li>
<li><p>大家有没有留意这个__vfptr? 为什么它被定义成一个指向指针数组的指针, 而不是直接定义成一个指针数组呢?</p>
<p>我为什么要提这样一个问题? 因为如果仅是一个指针的情况, 您就无法轻易地修改那个数组里面的内容, 因为她并不属于类对象的一部分.<br>属于类对象的, 仅是一个指向<strong>虚函数表的一个指针__vfptr</strong>而已, 下一节我们将继续讨论这个问题.</p>
</li>
<li><p>注意到<strong>vfptr前面的const修饰. 她修饰的是那个虚函数表, 而不是</strong>vfptr.</p>
</li>
</ol>
<p>现在的对象布局如下:</p>
<p><img src="https://blog.twofei.com/496/3-2.png" alt="img"></p>
<p>虚函数指针__vfptr位于所有的成员变量之前定义.</p>
<p>注意到: 我并未在此说明__vfptr的具体指向, 只是说明了现在类对象的布局情况.<br>接下来看一个稍微复杂一点的情况, 我将清楚地描述虚函数表的构成.</p>
</li>
<li><h3 id="拥有多个虚函数的类对象"><a href="#拥有多个虚函数的类对象" class="headerlink" title="拥有多个虚函数的类对象"></a>拥有多个虚函数的类对象</h3><p>和前面一个例子差不多, 只是再加了一个虚函数. 定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大小以及偏移信息如下:</p>
<p><img src="https://blog.twofei.com/496/4-1.png" alt="img"></p>
<p>有情况!? 多了一个虚函数, 类对象大小却依然是12个字节!</p>
<p>再来看看VS形象的表现:</p>
<p><img src="https://blog.twofei.com/496/4-2.png" alt="img"></p>
<p>呀, __vfptr所指向的函数指针数组中出现了第2个元素, 其值为Base1类的第2个虚函数base1_fun2()的函数地址.</p>
<p>现在, 虚函数指针以及虚函数表的伪定义大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* __fun[] = &#123; &amp;Base1::base1_fun1, &amp;Base1::base1_fun2 &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>** __vfptr = &amp;__fun[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>通过上面两张图表, 我们可以得到如下结论:</p>
<ol>
<li>更加肯定前面我们所描述的: __vfptr只是一个指针, 她指向一个函数指针数组(即: 虚函数表)</li>
<li>增加一个虚函数, 只是简单地向该类对应的虚函数表中增加一项而已, 并不会影响到类对象的大小以及布局情况</li>
</ol>
<p>前面已经提到过: <strong>vfptr只是一个指针, 她指向一个数组, 并且: 这个数组没有包含到类定义内部, 那么她们之间是怎样一个关系呢?<br>不妨, 我们再定义一个类的变量b2, 现在再来看看</strong>vfptr的指向:</p>
<p><img src="https://blog.twofei.com/496/4-3.png" alt="img"></p>
<p>通过Watch 1窗口我们看到:</p>
<ol>
<li>b1和b2是类的两个变量, 理所当然, 她们的地址是不同的(见 &amp;b1 和 &amp;b2)</li>
<li>虽然b1和b2是类的两个变量, 但是: 她们的__vfptr的指向却是同一个虚函数表</li>
</ol>
<p>由此我们可以总结出:</p>
<p>同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void**类型)指向该虚函数表.</p>
<p>是时候该展示一下类对象的内存布局情况了:</p>
<p><img src="https://blog.twofei.com/496/4-4.png" alt="img"></p>
<p>不出意外, 很清晰明了地展示出来了吧? :-) hoho~~</p>
<p>那么问题就来了! 这个虚函数表保存在哪里呢? 其实, 我们无需过分追究她位于哪里, 重点是:</p>
<ol>
<li>她是编译器在<strong>编译时期</strong>为我们创建好的, 只存在一份</li>
<li>定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表</li>
</ol>
</li>
<li><h3 id="单继承且本身不存在虚函数的继承类的内存布局"><a href="#单继承且本身不存在虚函数的继承类的内存布局" class="headerlink" title="单继承且本身不存在虚函数的继承类的内存布局"></a>单继承且本身不存在虚函数的继承类的内存布局</h3><p>前面研究了那么多啦, 终于该到研究继承类了! 先研究单继承!</p>
<p>依然, 简单地定义一个继承类, 如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们再来看看现在的内存布局(定义为Derive1 d1):</p>
<p><img src="https://blog.twofei.com/496/5-1.png" alt="img"></p>
<p>没错! 基类在上边, 继承类的成员在下边依次定义! 展开来看看:</p>
<p><img src="https://blog.twofei.com/496/5-2.png" alt="img"></p>
<p>经展开后来看, 前面部分完全就是Base1的东西: 虚函数表指针+成员变量定义.<br>并且, Base1的虚函数表的[0][1]两项还是其本身就拥有的函数: base1_fun1() 和 base1_fun2().</p>
<p>现在类的布局情况应该是下面这样:</p>
<p><img src="https://blog.twofei.com/496/5-3.png" alt="img"></p>
</li>
<li><h3 id="本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局"><a href="#本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局" class="headerlink" title="本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局"></a>本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局</h3><p>标题<code>本身不存在虚函数</code>的说法有些不严谨, 我的意思是说: 除经过继承而得来的基类虚函数以外, 自身没有再定义其它的虚函数.</p>
<p>Ok, 既然存在基类虚函数覆盖, 那么来看看接下来的代码会产生何种影响:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖基类函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到, Derive1类 重写了Base1类的base1_fun1()函数, 也就是常说的虚函数覆盖. 现在是怎样布局的呢?</p>
<p><img src="https://blog.twofei.com/496/6-1.png" alt="img"></p>
<p>特别注意我高亮的那一行: 原本是Base1::base1_fun1(), 但由于<strong>继承类重写</strong>了基类Base1的此方法, 所以现在变成了Derive1::base1_fun1()!</p>
<p>那么, 无论是通过Derive1的指针还是Base1的指针来调用此方法, 调用的都将是被继承类重写后的那个方法(函数), 多态发生鸟!!!</p>
<p>那么新的布局图:</p>
<p><img src="https://blog.twofei.com/496/6-2.png" alt="img"></p>
</li>
<li><h3 id="定义了基类没有的虚函数的单继承的类对象布局"><a href="#定义了基类没有的虚函数的单继承的类对象布局" class="headerlink" title="定义了基类没有的虚函数的单继承的类对象布局"></a>定义了基类没有的虚函数的单继承的类对象布局</h3><p>说明一下: 由于前面一种情况只会造成覆盖基类虚函数表的指针, 所以接下来我不再同时讨论虚函数覆盖的情况.</p>
<p>继续贴代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和第5类不同的是多了一个自身定义的虚函数. 和第6类不同的是没有基类虚函数的覆盖.</p>
<p><img src="https://blog.twofei.com/496/7-1.png" alt="img"></p>
<p>咦, 有没有发现问题? 表面上看来几乎和第5种情况完全一样? 为嘛呢?<br>现在继承类明明定义了自身的虚函数, 但不见了??<br>那么, 来看看类对象的大小, 以及成员偏移情况吧:</p>
<p><img src="https://blog.twofei.com/496/7-2.png" alt="img"></p>
<p>居然没有变化!!! 前面12个字节是Base1的, 有没有觉得很奇怪?</p>
<p>好吧, 既然表面上没办法了, 我们就只能从汇编入手了, 来看看调用derive1_fun1()时的代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun1();</span><br></pre></td></tr></table></figure>

<p>要注意: 我为什么使用指针的方式调用? 说明一下: 因为如果不使用指针调用, 虚函数调用是不会发生动态绑定的哦! 你若直接 <code>d1.derive1_fun1();</code> , 是不可能会发生动态绑定的, 但如果使用指针: <code>pd1-&gt;derive1_fun1();</code> , 那么 pd1就无从知道她所指向的对象到底是Derive1 还是继承于Derive1的对象, 虽然这里我们并没有对象继承于Derive1, 但是她不得不这样做, 毕竟继承类不管你如何继承, 都不会影响到基类, 对吧?</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun1();</span></span><br><span class="line"><span class="number">00825466</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00825469</span>  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">0082546B  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line"><span class="number">0082546D</span>  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00825470</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">8</span>]  </span><br><span class="line"><span class="number">00825473</span>  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>汇编代码解释:</p>
<p>第2行: 由于pd1是指向d1的指针, 所以执行此句后 eax 就是<strong>d1的地址</strong><br>第3行: 又因为Base1::<strong>vfptr是Base1的第1个成员, 同时也是Derive1的第1个成员, 那么: &amp;</strong>vfptr == &amp;d1, clear? 所以当执行完 <code>mov edx, dword ptr[eax]</code> 后, edx就得到了<strong>vfptr的值, 也就是<strong>虚函数表的地址</strong>.<br>第5行: 由于是</strong>thiscall调用, 所以把this保存到ecx中.<br>第6行: 一定要注意到那个 edx+8, 由于edx是虚函数表的地址, 那么 edx+8将是虚函数表的第3个元素, 也就是__vftable[2]!!!<br>第7行: 调用虚函数.</p>
<p>结果:</p>
<ol>
<li>现在我们应该知道内幕了! 继承类Derive1的虚函数表被加在基类的后面! 事实的确就是这样!</li>
<li>由于Base1只知道自己的两个虚函数索引[0][1], 所以就算在后面加上了[2], Base1根本不知情, 不会对她造成任何影响.</li>
<li>如果<strong>基类没有虚函数</strong>呢? 这个问题我们留到第9小节再来讨论!</li>
</ol>
<p>最新的类对象布局表示:</p>
<p><img src="https://blog.twofei.com/496/7-3.png" alt="img"></p>
</li>
<li><h3 id="多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"><a href="#多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局" class="headerlink" title="多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"></a>多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局</h3><p>真快, 该看看多继承了, 多继承很常见, 特别是接口类中!</p>
<p>依然写点小类玩玩:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类虚函数覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码变得越来越长啦! 为了代码结构清晰, 我尽量简化定义.</p>
<p>初步了解一下对象大小及偏移信息:</p>
<p><img src="https://blog.twofei.com/496/8-1.png" alt="img"></p>
<p>貌似, 若有所思? 不管, 来看看VS再想:</p>
<p><img src="https://blog.twofei.com/496/8-2.png" alt="img"></p>
<p>哇, 不摆了! 一丝不挂啊! :-)</p>
<p>结论:</p>
<ol>
<li>按照基类的声明顺序, 基类的成员依次分布在继承中.</li>
<li>注意被我高亮的那两行, 已经发生了虚函数覆盖!</li>
<li>我们自己定义的虚函数呢? 怎么还是看不见?!</li>
</ol>
<p>好吧, 继承反汇编, 这次的调用代码如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun2();</span><br></pre></td></tr></table></figure>

<p>反汇编代码如下:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun2();</span></span><br><span class="line"><span class="number">00995306</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00995309</span>  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">0099530B  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line"><span class="number">0099530D</span>  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00995310</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">0Ch</span>]  </span><br><span class="line"><span class="number">00995313</span>  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>解释下, 其实差不多:</p>
<p>第2行: 取d1的地址<br>第3行: 取Base1::__vfptr的值!!<br>第6行: 0x0C, 也就是第4个元素(下标为[3])</p>
<p>结论:</p>
<p>Derive1的虚函数表依然是保存到第1个拥有虚函数表的那个基类的后面的.</p>
<p>看看现在的类对象布局图:</p>
<p>（注：图中有点错误，右上角应该是 <code>void* __vftable[4]</code>，多谢 shadow3002 的提醒）</p>
<p>（注：图中有点错误，Derive1是存在虚函数覆盖的。源图丢失，请读者注意不要被误导。<a href="https://blog.twofei.com/496/#comment-577" target="_blank" rel="noopener">多谢 Oyster 的提醒</a>）</p>
<p><img src="https://blog.twofei.com/496/8-3.png" alt="img"></p>
<p>如果第1个基类没有虚函数表呢? 进入第9节!</p>
</li>
<li><h3 id="如果第1个直接基类没有虚函数-表"><a href="#如果第1个直接基类没有虚函数-表" class="headerlink" title="如果第1个直接基类没有虚函数(表)"></a>如果第1个直接基类没有虚函数(表)</h3><p>这次的代码应该比上一个要稍微简单一些, 因为把第1个类的虚函数给去掉鸟!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来看看VS的布局:</p>
<p><img src="https://blog.twofei.com/496/9-1.png" alt="img"></p>
<p>这次相对前面一次的图来说还要简单啦! Base1已经没有虚函数表了! (真实情况并非完全这样, 请继续往下看!)</p>
<p>现在的大小及偏移情况: 注意: <code>sizeof(Base1) == 8;</code></p>
<p><img src="https://blog.twofei.com/496/9-2.png" alt="img"></p>
<p>重点是看虚函数的位置, 进入函数调用(和前一次是一样的):</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun2();</span><br></pre></td></tr></table></figure>

<p>反汇编调用代码:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun2();</span></span><br><span class="line">012E4BA6  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line">012E4BA9  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">012E4BAB  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line">012E4BAD  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line">012E4BB0  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">0Ch</span>]  </span><br><span class="line">012E4BB3  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>这段汇编代码和前面一个完全一样!, 那么问题就来了! Base1 已经没有虚函数表了, 为什么还是把b1的第1个元素当作__vfptr呢?<br>不难猜测: 当前的布局已经发生了变化, 有虚函数表的基类放在对象内存前面!? , 不过事实是否属实? 需要仔细斟酌.</p>
<p>我们可以通过对基类成员变量求偏移来观察:</p>
<p><img src="https://blog.twofei.com/496/9-3.png" alt="img"></p>
<p>可以看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;d1==0x~d4</span><br><span class="line">&amp;d1.Base1::__vfptr==0x~d4</span><br><span class="line">&amp;d1.base2_1==0x~d8</span><br><span class="line">&amp;d1.base2_2==0x~dc</span><br><span class="line">&amp;d1.base1_1==0x~e0</span><br><span class="line">&amp;d1.base1_2==0x~e4</span><br></pre></td></tr></table></figure>

<p>所以不难验证: 我们前面的推断是正确的, 谁有虚函数表, 谁就放在前面!</p>
<p>现在类的布局情况:</p>
<p><img src="https://blog.twofei.com/496/9-4.png" alt="img"></p>
<p>那么, 如果两个基类都没有虚函数表呢?</p>
</li>
<li><h3 id="What-if-两个基类都没有虚函数表"><a href="#What-if-两个基类都没有虚函数表" class="headerlink" title="What if 两个基类都没有虚函数表"></a>What if 两个基类都没有虚函数表</h3><p>代码如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面吃了个亏, 现在先来看看VS的基本布局:</p>
<p><img src="https://blog.twofei.com/496/10-1.png" alt="img"></p>
<p>可以看到, 现在__vfptr已经独立出来了, 不再属于Base1和Base2!</p>
<p>看看求偏移情况:</p>
<p><img src="https://blog.twofei.com/496/10-2.png" alt="img"></p>
<p>Ok, 问题解决! 注意高亮的那两行, <code>&amp;d1==&amp;d1.__vfptr</code>, 说明虚函数始终在最前面!</p>
<p>不用再废话, 相信大家对这种情况已经有底了.</p>
<p>对象布局:</p>
<p><img src="https://blog.twofei.com/496/10-3.png" alt="img"></p>
</li>
<li><h3 id="如果有三个基类-虚函数表分别是有-没有-有"><a href="#如果有三个基类-虚函数表分别是有-没有-有" class="headerlink" title="如果有三个基类: 虚函数表分别是有, 没有, 有!"></a>如果有三个基类: 虚函数表分别是有, 没有, 有!</h3><p>这种情况其实已经无需再讨论了, 作为一个完结篇….</p>
<p>上代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">    <span class="keyword">int</span> base3_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是偏移图：</p>
<p><img src="https://blog.twofei.com/496/11-1.png" alt="img"></p>
<p>以下是对象布局图（多谢 <a href="https://blog.twofei.com/496/#comment-577" target="_blank" rel="noopener">@Oyster</a> 的手绘）：</p>
<p><img src="https://blog.twofei.com/496/11-2.jpg" alt="img"></p>
<p>只需知道: 谁有虚函数表, 谁就往前靠!</p>
</li>
</ol>
<h2 id="C-中父子对象指针间的转换与函数调用"><a href="#C-中父子对象指针间的转换与函数调用" class="headerlink" title="C++中父子对象指针间的转换与函数调用"></a>C++中父子对象指针间的转换与函数调用</h2><p>讲了那么多布局方面的东东, 终于到了尾声, 好累呀!!!</p>
<p>通过前面的讲解内容, 大家至少应该明白了各类情况下类对象的内存布局了. 如果还不会…..呃….. !@#$%^&amp;*</p>
<p>进入正题~</p>
<p>由于继承完全拥有父类的所有, 包括数据成员与虚函数表, 所以:<strong>把一个继承类强制转换为一个基类</strong>是完全可行的.</p>
<p>如果有一个Derive1的指针, 那么:</p>
<ul>
<li>得到Base1的指针: Base1* pb1 = pd1;</li>
<li>得到Base2的指针: Base2* pb2 = pd1;</li>
<li>得到Base3的指针: Base3* pb3 = pd1;</li>
</ul>
<p>非常值得注意的是:</p>
<p>这是在基类与继承类之间的转换, 这种转换会自动计算偏移! 按照前面的布局方式!<br>也就是说: 在这里极有可能: pb1 != pb2 != pb3 ~~, 不要以为她们都等于 pd1!</p>
<p>至于函数调用, 我想, 不用说大家应该知道了:</p>
<ol>
<li>如果不是虚函数, 直接调用指针对应的基本类的那个函数</li>
<li>如果是虚函数, 则查找虚函数表, 并进行后续的调用. 虚函数表在定义一个时, 编译器就为我们创建好了的. 所有的, 同一个类, 共用同一份虚函数表.</li>
</ol>
<h2 id="用C语言完全模拟C-虚函数表的实现与运作方式"><a href="#用C语言完全模拟C-虚函数表的实现与运作方式" class="headerlink" title="用C语言完全模拟C++虚函数表的实现与运作方式"></a>用C语言完全模拟C++虚函数表的实现与运作方式</h2><p>如果对前面两大节的描述仔细了解了的话, 想用C语言来模拟C++的虚函数以及多态, 想必是轻而易举的事情鸟!</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>但是, 话得说在前面, C++的编译器在生成类及对象的时候, 帮助我们完成了很多事件, 比如生成虚函数表!<br>但是, C语言编译器却没有, 因此, 很多事件我们必须手动来完成, 包括但不限于:</p>
<ol>
<li>手动构造父子关系</li>
<li>手动创建虚函数表</li>
<li>手动设置__vfptr并指向虚函数表</li>
<li>手动填充虚函数表</li>
<li>若有虚函数覆盖, 还需手动修改函数指针</li>
<li>若要取得基类指针, 还需手动强制转换</li>
<li>……</li>
</ol>
<p>总之, 要想用C语言来实现, 要写的代码绝对有点复杂.</p>
<h3 id="C-原版调用"><a href="#C-原版调用" class="headerlink" title="C++原版调用"></a>C++原版调用</h3><p>接下来, 我们都将以最后那个, 最繁杂的那个3个基类的实例来讲解, 但作了一些简化与改动:</p>
<ol>
<li>用构造函数初始化成员变量</li>
<li>减少成员变量的个数</li>
<li>减少虚函数的个数</li>
<li>调用函数时产生相关输出</li>
<li>Derive1增加一个基类虚函数覆盖</li>
</ol>
<p>以下是对类的改动, 很少:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base1() : base1_1(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::base1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2() : base2_1(<span class="number">21</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base3() : base3_1(<span class="number">31</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::base3_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derive1() : derive1_1(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::base3_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::derive1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了看到多态的效果, 我们还需要定义一个函数来看效果:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Base1* pb1, Base2* pb2, Base3* pb3, Derive1* pd1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb1-&gt;base1_1 = "</span> &lt;&lt; pb1-&gt;base1_1 &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb1-&gt;base1_fun1(): "</span>;</span><br><span class="line">    pb1-&gt;base1_fun1();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb2-&gt;base2_1 = "</span> &lt;&lt; pb2-&gt;base2_1</span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pb3-&gt;base3_1 = "</span> &lt;&lt; pb3-&gt;base3_1 &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt;<span class="string">"    pb3-&gt;base3_fun1(): "</span>;</span><br><span class="line">    pb3-&gt;base3_fun1();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive1::\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"    pd1-&gt;derive1_1 = "</span> &lt;&lt; pd1-&gt;derive1_1&lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt;<span class="string">"    pd1-&gt;derive1_fun1(): "</span>;</span><br><span class="line">    pd1-&gt;derive1_fun1();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"    pd1-&gt;base3_fun1(): "</span>;</span><br><span class="line">    pd1-&gt;base3_fun1();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">foo(&amp;d1, &amp;d1, &amp;d1, &amp;d1);</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<p><img src="https://blog.twofei.com/496/c-1.png" alt="img"></p>
<p>可以看到输出结果全部正确(当然了! :-), 哈哈~<br>同时注意到 pb3-&gt;base3_fun1() 的多态效果哦!</p>
<h3 id="用C语言来模拟"><a href="#用C语言来模拟" class="headerlink" title="用C语言来模拟"></a>用C语言来模拟</h3><p>必须要把前面的理解了, 才能看懂下面的代码!</p>
<p>为了有别于已经完成的C++的类, 我们分别在类前面加一个大写的C以示区分(平常大家都是习惯在C++写的类前面加C, 今天恰好反过来, 哈哈).</p>
<h5 id="C语言无法实现的部分"><a href="#C语言无法实现的部分" class="headerlink" title="C语言无法实现的部分"></a>C语言无法实现的部分</h5><p>C/C++是两个语言, 有些语言特性是C++专有的, 我们无法实现! 不过, 这里我是指调用约定, 我们应该把她排除在外.</p>
<p>对于类的成员函数, C++默认使用__thiscall, 也即this指针通过ecx传递, 这在C语言无法实现, 所以我们必须手动声明调用约定为:</p>
<ol>
<li><code>__stdcall</code>, 就像微软的组件对象模型那样</li>
<li><code>__cdecl</code>, 本身就C语言的调用约定, 当然能使用了.</li>
</ol>
<p>上面那种调用约定, 使用哪一种无关紧要, 反正不能使用<code>__thiscall</code>就行了.</p>
<p>因为使用了非__thiscall调用约定, 我们就必须手动传入this指针, 通过成员函数的第1个参数!</p>
<h5 id="从最简单的开始-实现-Base2"><a href="#从最简单的开始-实现-Base2" class="headerlink" title="从最简单的开始: 实现 Base2"></a>从最简单的开始: 实现 Base2</h5><p>由于没有虚函数, 仅有成员变量, 这个当然是最好模拟的咯!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="有了虚函数表的Base1-但没被覆盖"><a href="#有了虚函数表的Base1-但没被覆盖" class="headerlink" title="有了虚函数表的Base1, 但没被覆盖"></a>有了虚函数表的Base1, 但没被覆盖</h5><p>下面是Base1的定义, 要复杂一点了, 多一个__vfptr:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>** __vfptr;</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为有虚函数表, 所以还得单独为虚函数表创建一个结构体的哦!<br>但是, 为了更能清楚起见, 我并未定义前面所说的指针数组, 而是用一个包含一个或多个函数指针的结构体来表示!<br>因为数组能保存的是同一类的函数指针, 不太很友好!<br>但他们的效果是完全一样的, 希望读者能够理解明白!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base1_fun1)(CBase1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> base1_fun1 在这里是一个指针变量!<br><strong>注意:</strong> base1_fun1 有一个CBase1的指针, 因为我们不再使用__thiscall, 我们必须手动传入! Got it?</p>
<p>Base1的成员函数base1_fun1()我们也需要自己定义, 而且是定义成全局的:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">base1_fun1</span><span class="params">(CBase1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有虚函数覆盖的Base3"><a href="#有虚函数覆盖的Base3" class="headerlink" title="有虚函数覆盖的Base3"></a>有虚函数覆盖的Base3</h5><p>虚函数覆盖在这里并不能体现出来, 要在构造对象初始化的时候才会体现, 所以: base3其实和Base1是一样的.</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>** __vfptr;</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base3_fun1)(CBase3* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Base3的成员函数:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">base3_fun1</span><span class="params">(CBase3* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base3_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定义继承类CDerive1"><a href="#定义继承类CDerive1" class="headerlink" title="定义继承类CDerive1"></a>定义继承类CDerive1</h5><p>相对前面几个类来说, 这个类要显得稍微复杂一些了, 因为包含了前面几个类的内容:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CDerive1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CBase1 base1;</span><br><span class="line">    CBase3 base3;</span><br><span class="line">    CBase2 base2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>特别注意: CBase123的顺序不能错!</p>
<p>另外: 由于Derive1本身还有虚函数表, 而且所以项是加到第一个虚函数表(CBase1)的后面的, 所以此时的CBase1::__vfptr不应该单单指向CBase1_VFTable, 而应该指向下面这个包含Derive1类虚函数表的结构体才行:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1_CDerive1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (__stdcall* base1_fun1)(CBase1* that);</span><br><span class="line">    <span class="keyword">void</span>(__stdcall* derive1_fun1)(CDerive1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为CDerive1覆盖了CBase3的base3_fun1()函数, 所以不能直接用Base3的那个表:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3_CDerive1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base3_fun1)(CDerive1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Derive1覆盖Base3::base3_fun1()的函数以及自身定义的derive1_fun1()函数:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">base3_derive1_fun1</span><span class="params">(CDerive1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base3_derive1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">derive1_fun1</span><span class="params">(CDerive1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derive1_fun1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造各类的全局虚函数表"><a href="#构造各类的全局虚函数表" class="headerlink" title="构造各类的全局虚函数表"></a>构造各类的全局虚函数表</h5><p>由于没有了编译器的帮忙, 在定义一个类对象时, 所有的初始化工作都只能由我们自己来完成了!</p>
<p>首先构造全局的, 被同一个类共同使用的虚函数表!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CBase1 的虚函数表</span></span><br><span class="line">CBase1_VFTable __vftable_base1;</span><br><span class="line">__vftable_base1.base1_fun1 = base1_fun1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBase3 的虚函数表</span></span><br><span class="line">CBase3_VFTable __vftable_base3;</span><br><span class="line">__vftable_base3.base3_fun1 = base3_fun1;</span><br></pre></td></tr></table></figure>

<p>然后构造CDerive1和CBase1共同使用的虚函数表:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDerive1 和 CBase1 共用的虚函数表</span></span><br><span class="line">CBase1_CDerive1_VFTable __vftable_base1_derive1;</span><br><span class="line">__vftable_base1_derive1.base1_fun1 = base1_fun1;</span><br><span class="line">__vftable_base1_derive1.derive1_fun1 = derive1_fun1;</span><br></pre></td></tr></table></figure>

<p>再构造CDerive1覆盖CBase3后的虚函数表: 注意: 数覆盖会替换原来的函数指针</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBase3_CDerive1_VFTable __vftable_base3_derive1;</span><br><span class="line">__vftable_base3_derive1.base3_fun1 = base3_derive1_fun1;</span><br></pre></td></tr></table></figure>

<h5 id="开始-从CDerive1构造一个完整的Derive1类"><a href="#开始-从CDerive1构造一个完整的Derive1类" class="headerlink" title="开始! 从CDerive1构造一个完整的Derive1类"></a>开始! 从CDerive1构造一个完整的Derive1类</h5><p>先初始化成员变量与__vfptr的指向: 注意不是指错了!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CDerive1 d1;</span><br><span class="line">d1.derive1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">d1.base1.base1_1 = <span class="number">11</span>;</span><br><span class="line">d1.base1.__vfptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;__vftable_base1_derive1);</span><br><span class="line">    </span><br><span class="line">d1.base2.base2_1 = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">d1.base3.base3_1 = <span class="number">31</span>;</span><br><span class="line">d1.base3.__vfptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;__vftable_base3_derive1);</span><br></pre></td></tr></table></figure>

<p>由于目前的CDerive1是我们手动构造的, 不存在真正语法上的继承关系, 如要得到各基类指针, 我们就不能直接来取, 必须手动根据偏移计算:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;d1);</span><br><span class="line">Base1* pb1 = <span class="keyword">reinterpret_cast</span>&lt;Base1*&gt;(p + <span class="number">0</span>);</span><br><span class="line">Base2* pb2 = <span class="keyword">reinterpret_cast</span>&lt;Base2*&gt;(p + <span class="keyword">sizeof</span>(CBase1) + <span class="keyword">sizeof</span>(CBase3));</span><br><span class="line">Base3* pb3 = <span class="keyword">reinterpret_cast</span>&lt;Base3*&gt;(p + <span class="keyword">sizeof</span>(CBase1));</span><br><span class="line">Derive1* pd1 = <span class="keyword">reinterpret_cast</span>&lt;Derive1*&gt;(p);</span><br></pre></td></tr></table></figure>

<p>真正调用:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(pb1, pb2, pb3, pd1);</span><br></pre></td></tr></table></figure>

<p>调用结果:</p>
<p><img src="https://blog.twofei.com/496/last.png" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/设计模式/设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/设计模式/设计模式/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题"><a href="#请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题" class="headerlink" title="请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题"></a>请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>常见的设计模式如下：</p>
<p>单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<p>工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</p>
<p>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>单例模式的多线程安全问题：</p>
<p>在单例模式的实现中，如果不采取任何措施，在多线程下是不安全的，可能会同时创建多个实例。因此，为了保证单例模式在多线程下的线程安全，一般采用下面几种方式实现单例模式：</p>
<p>1)饿汉式：基于class loader机制避免多线程的同步问题，不过，instance在类装载时就实例化，可能会产生垃圾对象。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552475722008_A2BE64A5AC63C768998DF8A4AB546BE6" alt="img"></p>
<p>2)懒汉式：通过双重锁机制实现线程安全。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552475744068_794C59674E8895ACAE32F19FCD4DF359" alt="img"></p>
<h2 id="●-请问你了解哪些设计模式？"><a href="#●-请问你了解哪些设计模式？" class="headerlink" title="● 请问你了解哪些设计模式？"></a>● 请问你了解哪些设计模式？</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>常见的设计模式如下：</p>
<p>单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<p>工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</p>
<p>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>装饰器模式：对已经存在的某些类进行装饰，以此来扩展一些功能，从而动态的为一个对象增加新的功能。装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<h2 id="●-请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？"><a href="#●-请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？" class="headerlink" title="● 请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？"></a>● 请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>单例的实现主要是通过以下两个步骤：</p>
<p>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</p>
<p>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</p>
<p>单例模式的实现主要有两种一种是饿汉式，一种是懒汉式。饿汉式线程安全的单例模式如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552475817756_0ABB4D7B05F0CEEF9D60F6FD5B1F4040" alt="img"></p>
<p>懒汉式线程安全的单例模式如下</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552475838096_082BA455073278EBC75F86A1E72C3EBD" alt="img"></p>
<h2 id="●-请你说一说OOP的设计模式的五项原则"><a href="#●-请你说一说OOP的设计模式的五项原则" class="headerlink" title="● 请你说一说OOP的设计模式的五项原则"></a>● 请你说一说OOP的设计模式的五项原则</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、单一职责原则</p>
<p>单一职责有2个含义，一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。减少类的耦合，提高类的复用性。</p>
<p>2、接口隔离原则</p>
<p>表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中额方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是使用多个专门的接口比使用单个接口好很多。</p>
<p>该原则观点如下：<br>1）一个类对另外一个类的依赖性应当是建立在最小的接口上</p>
<p>2）客户端程序不应该依赖它不需要的接口方法。</p>
<p>3、开放-封闭原则</p>
<p>open模块的行为必须是开放的、支持扩展的，而不是僵化的。</p>
<p>closed在对模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。一句话概括：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。</p>
<p>核心思想就是对抽象编程，而不对具体编程。</p>
<p>4、替换原则</p>
<p>子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。</p>
<p>主要针对继承的设计原则</p>
<p>1）父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中生命的方法，而不应当给出多余的,方法定义或实现。</p>
<p>2）在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期间绑定。</p>
<p>5、依赖倒置原则</p>
<p>上层模块不应该依赖于下层模块，他们共同依赖于一个抽象，即：父类不能依赖子类，他们都要依赖抽象类。</p>
<p>抽象不能依赖于具体，具体应该要依赖于抽象。</p>
<h2 id="●-请你说说工厂模式的优点？"><a href="#●-请你说说工厂模式的优点？" class="headerlink" title="● 请你说说工厂模式的优点？"></a>● 请你说说工厂模式的优点？</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>解耦，代码复用，更改功能容易。</p>
<h2 id="●-请你说一下观察者模式"><a href="#●-请你说一下观察者模式" class="headerlink" title="● 请你说一下观察者模式"></a>● 请你说一下观察者模式</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>观察者模式中分为观察者和被观察者，当被观察者发生装填改变时，观察者会受到通知。主要为了解决对象状态改变给其他对象通知的问题，其实现类似于观察者在被观察者那注册了一个回调函数。</p>
<h2 id="●-请你介绍一下单例模式"><a href="#●-请你介绍一下单例模式" class="headerlink" title="● 请你介绍一下单例模式"></a>● 请你介绍一下单例模式</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>C++的实现有两种，一种通过局部静态变量，利用其只初始化一次的特点，返回对象。另外一种，则是定义全局的指针，getInstance判断该指针是否为空，为空时才实例化对象</p>
<h2 id="●-单例模式中的懒汉加载，如果并发访问该怎么做？"><a href="#●-单例模式中的懒汉加载，如果并发访问该怎么做？" class="headerlink" title="● 单例模式中的懒汉加载，如果并发访问该怎么做？"></a>● 单例模式中的懒汉加载，如果并发访问该怎么做？</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>使用锁机制，防止多次访问,可以这样，第一次判断为空不加锁，若为空，再进行加锁判断是否为空，若为空则生成对象。</p>
<h2 id="●-装饰器模式和单例模式，使用单例模式应该注意什么"><a href="#●-装饰器模式和单例模式，使用单例模式应该注意什么" class="headerlink" title="● 装饰器模式和单例模式，使用单例模式应该注意什么"></a>● 装饰器模式和单例模式，使用单例模式应该注意什么</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>考察点：设计模式</p>
<p>公司：百度</p>
<p>1、装饰器模式</p>
<p>装饰器模式主要是为了动态的为一个对象增加新的功能，装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p>缺点：多层装饰比较复杂。</p>
<p>使用场景：1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<p>2、单例模式</p>
<p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>优点：1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</p>
<p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景：1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
<p>实现：</p>
<p>单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。</p>
<p>单例的实现主要是通过以下两个步骤：</p>
<p>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</p>
<p>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</p>
<p>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<p>3）单例模式举例（常手撕）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SingleTon</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">SingleTon() &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>SingleTon(const SingleTon&amp;) {}; // 禁止拷贝</p>
<p>SingleTon&amp; operator=(const SingleTon&amp;) {}; // 禁止赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`static` `T* uniqueInstance;``static` `pthread_mutex_t mutex;``public``:``static` `T* GetInstance()``&#123;``pthread_mutex_lock(&amp;mutex);``if` `(uniqueInstance == nullptr)``&#123;``uniqueInstance = ``new` `T();``&#125;``pthread_mutex_unlock(&amp;mutex);``return` `uniqueInstance;``&#125;``&#125;;``template` `&lt;``class` `T&gt;``pthread_mutex_t SingleTon&lt;T&gt;::mutex = PTHREAD_MUTEX_INITIALIZER;``template` `&lt;``class` `T&gt;``T* SingleTon&lt;T&gt;::uniqueInstance = nullptr;`</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/网络编程/计算机网路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/网络编程/计算机网路/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、-请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程"><a href="#1、-请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程" class="headerlink" title="1、 请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程"></a>1、 请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程</h2><p>TCP保证可靠性：</p>
<p>（1）序列号、确认应答、超时重传</p>
<p>数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p>
<p>（2）窗口控制与高速重发控制/快速重传（重复确认应答）</p>
<p>TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</p>
<p>使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……</p>
<p>（3）拥塞控制</p>
<p>如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p>
<p>慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p>
<p>拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p>
<p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p>
<p>快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p>
<p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p>
<p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p>
<p>TCP建立连接和断开连接的过程：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471554293_3A87D0457A6EE404083BBF3CB192C358" alt="img"></p>
<p>三次握手：</p>
<ol>
<li><p>Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
<p>四次挥手：</p>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p>1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</p>
<p>2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</p>
<p>3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</p>
<p>4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</p>
<h2 id="2、-请你说一说TCP的模型，状态转移"><a href="#2、-请你说一说TCP的模型，状态转移" class="headerlink" title="2、 请你说一说TCP的模型，状态转移"></a>2、 请你说一说TCP的模型，状态转移</h2><p>四层TCP/IP模型如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471617097_2C832BB517B9ED772DCA7DCAD9AFBC75" alt="img"></p>
<p>其状态转移图如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471666772_F4FEF3EED170579049D40CE58E343EE4" alt="img"></p>
<h2 id="3、-请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"><a href="#3、-请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？" class="headerlink" title="3、 请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？"></a>3、 请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？</h2><p>HTTP协议和HTTPS协议区别如下：</p>
<p>1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p>
<p>2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
<p>3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p>
<p>4）HTTP协议端口是80，HTTPS协议端口是443</p>
<p>HTTPS优点：</p>
<p>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</p>
<p>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</p>
<p>HTTPS缺点：</p>
<p>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p>
<p>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p>
<h2 id="4、-请你说一说HTTP和HTTPS的不同"><a href="#4、-请你说一说HTTP和HTTPS的不同" class="headerlink" title="4、 请你说一说HTTP和HTTPS的不同"></a>4、 请你说一说HTTP和HTTPS的不同</h2><p>HTTP协议和HTTPS协议区别如下：</p>
<p>1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p>
<p>2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
<p>3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p>
<p>4）HTTP协议端口是80，HTTPS协议端口是443</p>
<h2 id="5、请你说一说HTTP返回码"><a href="#5、请你说一说HTTP返回码" class="headerlink" title="5、请你说一说HTTP返回码"></a>5、请你说一说HTTP返回码</h2><p>HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：</p>
<p>1xx：指示信息–表示请求已接收，继续处理。</p>
<p>2xx：成功–表示请求已被成功接收、理解、接受。</p>
<p>3xx：重定向–要完成请求必须进行更进一步的操作。</p>
<p>4xx：客户端错误–请求有语法错误或请求无法实现。</p>
<p>5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p>常见状态代码、状态描述的详细说明如下。</p>
<p>200 OK：客户端请求成功。</p>
<p>206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围</p>
<p>300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。</p>
<p>301  moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</p>
<p>302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，</p>
<p>304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。</p>
<p>403 Forbidden：服务器收到请求，但是拒绝提供服务。</p>
<p>t Found：请求资源不存在，举个例子：输入了错误的URL。</p>
<h2 id="6、-请你说一说IP地址作用，以及MAC地址作用"><a href="#6、-请你说一说IP地址作用，以及MAC地址作用" class="headerlink" title="6、 请你说一说IP地址作用，以及MAC地址作用"></a>6、 请你说一说IP地址作用，以及MAC地址作用</h2><p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
<h2 id="7、请介绍一下操作系统中的中断"><a href="#7、请介绍一下操作系统中的中断" class="headerlink" title="7、请介绍一下操作系统中的中断"></a>7、请介绍一下操作系统中的中断</h2><p>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。中断一般三类，一种是由CPU外部引起的，如I/O中断、时钟中断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出），最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。</p>
<h2 id="8、-请回答OSI七层模型和TCP-IP四层模型，每层列举2个协议"><a href="#8、-请回答OSI七层模型和TCP-IP四层模型，每层列举2个协议" class="headerlink" title="8、 请回答OSI七层模型和TCP/IP四层模型，每层列举2个协议"></a>8、 请回答OSI七层模型和TCP/IP四层模型，每层列举2个协议</h2><p>OSI七层模型及其包含的协议如下:</p>
<p>物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45</p>
<p>数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP</p>
<p>网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP</p>
<p>传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP</p>
<p>会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS</p>
<p>表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII</p>
<p>应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</p>
<p>TCP/IP 4层模型包括：</p>
<p>网络接口层：MAC VLAN</p>
<p>网络层:IP ARP ICMP</p>
<p>传输层:TCP UDP</p>
<p>应用层:HTTP DNS SMTP</p>
<h2 id="9、-请你说一说TCP的三次握手和四次挥手的过程及原因"><a href="#9、-请你说一说TCP的三次握手和四次挥手的过程及原因" class="headerlink" title="9、 请你说一说TCP的三次握手和四次挥手的过程及原因"></a>9、 请你说一说TCP的三次握手和四次挥手的过程及原因</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>TCP的三次握手过程如下：</p>
<p>C-&gt; SYN -&gt; S</p>
<p>S-&gt;SYN/ACK-&gt;C</p>
<p>C-&gt;ACK-&gt;S</p>
<p>三次握手的原因：三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。</p>
<p>TCP的四次挥手过程如下：</p>
<p>C-&gt;FIN-&gt;S</p>
<p>S-&gt;ACK-&gt;C</p>
<p>S-&gt;FIN-&gt;C</p>
<p>C-&gt;ACK-&gt;S</p>
<p>四次挥手的原因：由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。</p>
<h2 id="10、-搜索baidu，会用到计算机网络中的什么层？每层是干什么的"><a href="#10、-搜索baidu，会用到计算机网络中的什么层？每层是干什么的" class="headerlink" title="10、 搜索baidu，会用到计算机网络中的什么层？每层是干什么的"></a>10、 搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h2><p>浏览器中输入URL</p>
<p>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p>
<p>其中：</p>
<p>1、DNS协议，http协议，https协议属于应用层</p>
<p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p>
<p>2、TCP/UDP属于传输层</p>
<p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>，和无连接的用户数据报协议<a href="https://www.baidu.com/s?wd=UDP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">UDP</a>。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p>
<p>3、IP协议，ARP协议属于网络层</p>
<p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在<a href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">TCP</a>/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。<br>4、数据链路层</p>
<p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及<a href="https://www.baidu.com/s?wd=流量控制&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">流量控制</a>信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。<br>5、物理层</p>
<p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如<a href="https://www.baidu.com/s?wd=双绞线&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">双绞线</a>、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p>
<h2 id="11、-请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？"><a href="#11、-请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？" class="headerlink" title="11、 请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？"></a>11、 请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？</h2><p>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。</p>
<p>1、慢开始</p>
<p>最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。</p>
<p>2、拥塞避免</p>
<p>每经过一个往返时间RTT，cwnd就增长1。</p>
<p>在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）</p>
<p>3、快重传</p>
<p>接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。</p>
<p>4、快恢复</p>
<p>当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。</p>
<p>采用快恢复算法时，慢开始只在建立连接和网络超时才使用。</p>
<p>达到什么情况的时候开始减慢增长的速度？</p>
<p>采用慢开始和拥塞避免算法的时候</p>
<ol>
<li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p>
</li>
<li><p>一旦出现丢包的情况，就重新进行慢开始，减慢增长速度</p>
</li>
</ol>
<p>采用快恢复和快重传算法的时候</p>
<ol>
<li><p>一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</p>
</li>
<li><p>一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度</p>
</li>
</ol>
<h3 id="12、请你说说TCP-IP数据链路层的交互过程"><a href="#12、请你说说TCP-IP数据链路层的交互过程" class="headerlink" title="12、请你说说TCP/IP数据链路层的交互过程"></a>12、请你说说TCP/IP数据链路层的交互过程</h3><p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器</p>
<h3 id="13、-请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"><a href="#13、-请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文" class="headerlink" title="13、 请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"></a>13、 请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文</h3><p>根据端口区分；</p>
<p>看ip头中的协议标识字段，17是udp，6是tcp</p>
<h2 id="14-请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）"><a href="#14-请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）" class="headerlink" title="14 请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）"></a>14 请问你有没有基于做过socket的开发？具体网络层的操作该怎么做？（其实也是问网络编程的基本步骤）</h2><p>服务端：socket-bind-listen-accept</p>
<p>客户端：socket-connect</p>
<h2 id="●-请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"><a href="#●-请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？" class="headerlink" title="● 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"></a>● 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态</p>
<h2 id="●-请问TCP三次握手是怎样的？"><a href="#●-请问TCP三次握手是怎样的？" class="headerlink" title="● 请问TCP三次握手是怎样的？"></a>● 请问TCP三次握手是怎样的？</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.客户端发送syn0给服务器</p>
<p>2.服务器收到syn0，回复syn1,ack(syn0+1)</p>
<h2 id="●-请问tcp握手为什么两次不可以？为什么不用四次？"><a href="#●-请问tcp握手为什么两次不可以？为什么不用四次？" class="headerlink" title="● 请问tcp握手为什么两次不可以？为什么不用四次？"></a>● 请问tcp握手为什么两次不可以？为什么不用四次？</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常</p>
<p>不用四次：</p>
<h2 id="●-请你来说一下TCP拥塞控制？"><a href="#●-请你来说一下TCP拥塞控制？" class="headerlink" title="● 请你来说一下TCP拥塞控制？"></a>● 请你来说一下TCP拥塞控制？</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p>过程cwnd的大小呈指数增长，直到超过慢启动门限，然后进入拥塞避免阶段，cwnd的大小线性增长，当出现网络拥塞(三个重复的ack或者超时)时候，将慢启动门限设置为出现拥塞时候大小的一半，cwnd的大小重新从0开始进入慢启动阶段。</p>
<h2 id="●-TCP和UDP的区别和各自适用的场景"><a href="#●-TCP和UDP的区别和各自适用的场景" class="headerlink" title="● TCP和UDP的区别和各自适用的场景"></a>● TCP和UDP的区别和各自适用的场景</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）TCP和UDP区别</p>
<p>1） 连接</p>
<p>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</p>
<p>UDP无连接。</p>
<p>2） 服务对象</p>
<p>TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</p>
<p>UDP支持一对一，一对多，多对一，多对多的交互通信。</p>
<p>3） 可靠性</p>
<p>TCP是可靠交付：无差错，不丢失，不重复，按序到达。</p>
<p>UDP是尽最大努力交付，不保证可靠交付。</p>
<p>4）拥塞控制，流量控制</p>
<p>TCP有拥塞控制和流量控制保证数据传输的安全性。</p>
<p>UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</p>
<p>5） 报文长度</p>
<p>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</p>
<p>UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</p>
<p>6)   首部开销</p>
<p>TCP首部开销大，首部20个字节。</p>
<p>UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</p>
<p>2）TCP和UDP适用场景</p>
<p>从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p>
<p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p>
<h2 id="●-请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次-time-wait状态"><a href="#●-请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次-time-wait状态" class="headerlink" title="● 请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次, time_wait状态"></a>● 请你来说一下TCP三次握手四次挥手的过程，为什么tcp连接握手需要三次, time_wait状态</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）TCP连接（三次握手）过程：</p>
<p>客户端A：发送SYN连接报文，序列号为x，进入SYNC-SENT状态。</p>
<p>服务端B：发送SYN连接确认报文（SYN=1，ACK = 1），序列号为y（seq = y），确认报文x（ack = x + 1），进入SYNC-RCVD状态。</p>
<p>客户端A：发送ACK确认报文（ACK = 1），序列号为x+1（seq = x + 1），确认报文y+1（ack = y + 1），进入ESTABLISHED状态。</p>
<p>服务器B：收到后进入ESTABLISHED状态。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654514757_B2186A0EB2E4E9A381061A1CC4706248" alt="img"></p>
<p>2）三次握手原因：</p>
<p>三次握手是为了防止，客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。</p>
<p>服务器对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务器的回应呢？此时，客户端仍认为连接未建立，服务器会对已建立的连接保存必要的资源，如果大量的这种情况，服务器会崩溃。</p>
<p>3） TCP释放（四次分手）过程：</p>
<p>服务端A：发送FIN报文（FIN = 1），序列号为u（seq = u），进入FIN-WAIT 1状态。</p>
<p>客户端B：发送ACK确认报文（ACK = 1），序列号为v（seq = v），确认报文u（ack = u + 1），进入CLOSE-WAIT状态，继续传送数据。</p>
<p>服务端A：收到上述报文进入FIN-WAIT2状态，继续接受B传输的数据。</p>
<p>客户端B：数据传输完毕后，发送FIN报文（FIN = 1，ACK = 1），序列号为w（seq = w），确认报文u（ack = u + 1），进入LAST-ACK状态。</p>
<p>服务端A：发送ACK确认报文（ACK = 1），序列号为u+1（seq = u + 1），确认报文w（ack = w + 1），进入TIME-WAIT状态，等待2MSL（最长报文段寿命），进入CLOSED状态。</p>
<p>客户端B：收到后上述报文后进入CLOSED状态。</p>
<p>4）为什么TCP协议终止链接要四次？</p>
<p>1、当客户端确认发送完数据且知道服务器已经接收完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给服务器。</p>
<p>2、服务器收到客户端发送的FIN，表示收到了，就会发送ACK回复。</p>
<p>3、但这时候服务器可能还在发送数据，没有想要关闭数据口的意思，所以服务器的FIN与ACK不是同时发送的，而是等到服务器数据发送完了，才会发送FIN给客户端。</p>
<p>4、客户端收到服务器发来的FIN，知道服务器的数据也发送完了，回复ACK， 客户端等待2MSL以后，没有收到服务器传来的任何消息，知道服务器已经收到自己的ACK了，客户端就关闭链接，服务器也关闭链接了。</p>
<p>5）2MSL意义：</p>
<p>1、保证最后一次握手报文能到B，能进行超时重传。</p>
<p>2、2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。</p>
<h2 id="●-请你来说一说http协议"><a href="#●-请你来说一说http协议" class="headerlink" title="● 请你来说一说http协议"></a>● 请你来说一说http协议</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）HTTP协议：</p>
<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG（Next Generation of HTTP）的建议已经提出。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>2）HTTP协议特点</p>
<p>1、简单快速：</p>
<p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>2、灵活：</p>
<p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>3、无连接：</p>
<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>4、无状态：</p>
<p>HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>5、支持B/S及C/S模式。</p>
<p>6、默认端口80</p>
<p>7、基于TCP协议</p>
<p>3）HTTP过程概述：</p>
<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>HTTP 请求/响应的步骤如下：</p>
<p>1、客户端连接到Web服务器</p>
<p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com</a>。</p>
<p>2、发送HTTP请求</p>
<p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<p>3、服务器接受请求并返回HTTP响应</p>
<p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<p>4、释放连接TCP连接</p>
<p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<p>5、客户端浏览器解析HTML内容</p>
<p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
<p>4、举例：</p>
<p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；</p>
<p>3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；</p>
<p>5、释放 TCP连接；</p>
<p>6、浏览器将该 html 文本并显示内容；</p>
<h2 id="●-请你来说一下GET和POST的区别"><a href="#●-请你来说一下GET和POST的区别" class="headerlink" title="● 请你来说一下GET和POST的区别"></a>● 请你来说一下GET和POST的区别</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、概括</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p>
<p>2、区别：</p>
<p>1、get参数通过url传递，post放在request body中。</p>
<p>2、get请求在url中传递的参数是有长度限制的，而post没有。</p>
<p>3、get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p>
<p>4、get请求只能进行url编码，而post支持多种编码方式。</p>
<p>5、get请求会浏览器主动cache，而post支持多种编码方式。</p>
<p>6、get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p>
<p>7、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
<p>8、GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<h2 id="●-请你来说一下socket编程中服务器端和客户端主要用到哪些函数"><a href="#●-请你来说一下socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="● 请你来说一下socket编程中服务器端和客户端主要用到哪些函数"></a>● 请你来说一下socket编程中服务器端和客户端主要用到哪些函数</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）基于TCP的socket：</p>
<p>1、服务器端程序：</p>
<p>1创建一个socket，用函数socket()</p>
<p>2绑定IP地址、端口等信息到socket上，用函数bind()</p>
<p>3设置允许的最大连接数，用函数listen()</p>
<p>4接收客户端上来的连接，用函数accept()</p>
<p>5收发数据，用函数send()和recv()，或者read()和write()</p>
<p>6关闭网络连接</p>
<p>2、客户端程序：</p>
<p>1创建一个socket，用函数socket()</p>
<p>2设置要连接的对方的IP地址和端口等属性</p>
<p>3连接服务器，用函数connect()</p>
<p>4收发数据，用函数send()和recv()，或read()和write()</p>
<p>5关闭网络连接</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654678444_69CF8398BCC9F204991E623723D022E7" alt="img"></p>
<p>2）基于UDP的socket：</p>
<p>1、服务器端流程</p>
<p>1建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</p>
<p>2设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</p>
<p>3绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</p>
<p>4接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</p>
<p>5向客户端发送数据，使用sendto()函数向服务器主机发送数据。</p>
<p>6关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</p>
<p>2、客户端流程</p>
<p>1建立套接字文件描述符，socket()。</p>
<p>2设置服务器地址和端口，struct sockaddr。</p>
<p>3向服务器发送数据，sendto()。</p>
<p>4接收服务器的数据，recvfrom()。</p>
<p>5关闭套接字，close()。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552654687053_263E6AFD1A48F8511D04B67EB12AA24C" alt="img"></p>
<h2 id="●-请你来说一下数字证书是什么，里面都包含那些内容"><a href="#●-请你来说一下数字证书是什么，里面都包含那些内容" class="headerlink" title="● 请你来说一下数字证书是什么，里面都包含那些内容"></a>● 请你来说一下数字证书是什么，里面都包含那些内容</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）概念：</p>
<p>数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。</p>
<p>认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。</p>
<p>2）数字证书颁发过程：</p>
<p>数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。</p>
<p>3）内容：</p>
<p>数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：</p>
<p>1、证书的版本信息；</p>
<p>2、证书的序列号，每个证书都有一个唯一的证书序列号；</p>
<p>3、证书所使用的签名算法；</p>
<p>4、证书的发行机构名称，命名规则一般采用X.500格式；</p>
<p>5、证书的有效期，通用的证书一般采用UTC时间格式；</p>
<p>6、证书所有人的名称，命名规则一般采用X.500格式；</p>
<p>7、证书所有人的公开密钥；</p>
<p>8、证书发行者对证书的签名。</p>
<h2 id="●-请你来介绍一下udp的connect函数"><a href="#●-请你来介绍一下udp的connect函数" class="headerlink" title="● 请你来介绍一下udp的connect函数"></a>● 请你来介绍一下udp的connect函数</h2><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>除非套接字已连接，否则异步错误是不会反悔到UDP套接字的。我们确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接不同的是没有三路握手过程。内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回调用进程。</p>
<p>对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。</p>
<p>其实一旦UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。</p>
<p>1、我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0.</p>
<p>2、不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。</p>
<p>3、由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。</p>
<p>来自任何其他IP地址或断开的数据报不投递给这个已连接套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。</p>
<p>UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。</p>
<h2 id="●-请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？"><a href="#●-请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？" class="headerlink" title="● 请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？"></a>● 请你讲述一下TCP三次握手，四次挥手，以及为什么用三次握手？</h2><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>三次握手</p>
<p>1.客户端发送syn0给服务器<br>2.服务器收到syn0，回复syn1,ack(syn0+1)<br>3.客户端收到syn1，回复ack(syn1+1)<br>四次挥手(这里以客户端主动断开为例)<br>1.客户端发送fin<br>2.服务端收到fin,回复ack,然后服务器去处理其他事<br>3.服务器事情处理完，回复fin<br>4.客户端回复ack<br>为什么用三次握手<br>本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：<br>1.客户端发送syn0给服务器<br>2.服务器收到syn0，回复ack(syn0+1)<br>3.服务器发送syn1<br>3.客户端收到syn1，回复ack(syn1+1)<br>因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。</p>
<h2 id="●-请你说一下阻塞，非阻塞，同步，异步"><a href="#●-请你说一下阻塞，非阻塞，同步，异步" class="headerlink" title="● 请你说一下阻塞，非阻塞，同步，异步"></a>● 请你说一下阻塞，非阻塞，同步，异步</h2><h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。</p>
<p>同步和异步：调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步</p>
<h2 id="●-请你讲述一下Socket编程的send-recv-accept-socket-函数？"><a href="#●-请你讲述一下Socket编程的send-recv-accept-socket-函数？" class="headerlink" title="● 请你讲述一下Socket编程的send() recv() accept() socket()函数？"></a>● 请你讲述一下Socket编程的send() recv() accept() socket()函数？</h2><h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。</p>
<p>recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。</p>
<h2 id="●-请你说一下http协议会话结束标志怎么截出来？"><a href="#●-请你说一下http协议会话结束标志怎么截出来？" class="headerlink" title="● 请你说一下http协议会话结束标志怎么截出来？"></a>● 请你说一下http协议会话结束标志怎么截出来？</h2><h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>看tcp连接是否有断开的四部挥手阶段。</p>
<h2 id="●-请你说一说三次握手"><a href="#●-请你说一说三次握手" class="headerlink" title="● 请你说一说三次握手"></a>● 请你说一说三次握手</h2><h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.客户端发送syn0给服务器</p>
<p>2.服务器收到syn0，回复syn1,ack(syn0+1)</p>
<h2 id="●-请你说一说四次挥手"><a href="#●-请你说一说四次挥手" class="headerlink" title="● 请你说一说四次挥手"></a>● 请你说一说四次挥手</h2><h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.客户端发送syn0给服务器</p>
<p>2.服务器收到syn0，回复ack(syn0+1)</p>
<h2 id="●-请你说一说TCP-IP数据链路层的交互过程"><a href="#●-请你说一说TCP-IP数据链路层的交互过程" class="headerlink" title="● 请你说一说TCP/IP数据链路层的交互过程"></a>● 请你说一说TCP/IP数据链路层的交互过程</h2><h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/网络编程/OSI7层协议详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/网络编程/OSI7层协议详解/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、OSI7层模型"><a href="#一、OSI7层模型" class="headerlink" title="一、OSI7层模型"></a>一、OSI7层模型</h2><p><img src="http://hi.csdn.net/attachment/201201/5/0_1325744597WM32.gif" alt="img"></p>
<p>OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，<span style="color:red">因此其最主要的功能就是帮助不同类型的主机实现数据传输 。</span></p>
<p>完成中继功能的节点通常称为中继系统。在OSI七层模型中，处于不同层的中继系统具有不同的名称。   </p>
<p>一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。<br>具体说:<br>物理层：网卡，网线，集线器，中继器，调制解调器</p>
<p>数据链路层：网桥，交换机</p>
<p>网络层：路由器</p>
<p>网关工作在第四层传输层及其以上</p>
<p>集线器是物理层设备,采用广播的形式来传输信息。</p>
<p>交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文.。</p>
<p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。 </p>
<p><strong>交换机和路由器的区别</strong></p>
<p>交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在则广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部MAC地址表中。<br>使用交换机也可以把网络“分段”，通过对照MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。<br>交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。假使这里使用的是10Mbps的以太网交换机，那么该交换机这时的总流通量就等于2×10Mbps＝20Mbps，而使用10Mbps的共享式HUB时，一个HUB的总流通量也不会超出10Mbps。<br>总之，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。</p>
<p>从过滤网络流量的角度来看，路由器的作用与交换机和网桥非常相似。但是与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。因此，使用路由器转发和过滤数据的速度往往要比只查看数据包物理地址的交换机慢。但是，对于那些结构复杂的网络，使用路由器可以提高网络的整体效率。路由器的另外一个明显优势就是可以自动过滤网络广播。</p>
<p>集线器与路由器在功能上有什么不同? </p>
<p>首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。这样在机器很多或数据量很大时，两者将会有比较明显的。而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，不是完全独立的两种设备。路由器主要克服了交换机不能路由转发数据包的不足。 </p>
<p>总的来说，路由器与交换机的主要区别体现在以下几个方面： </p>
<p>（1）工作层次不同<br>最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 </p>
<p>（2）数据转发所依据的对象不同<br>交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。 </p>
<p>（3）传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域<br>由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 </p>
<p>（4）路由器提供了防火墙的服务<br>路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</p>
<h4 id="1、物理层"><a href="#1、物理层" class="headerlink" title="1、物理层"></a><strong>1、物理层</strong></h4><p>在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。<br>物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-343093645638ea0839b71db5eba1f7c0_hd.jpg" alt="img"></p>
<p>看着高大上，其实是将数据的0、1转换成电信号或者光信号。通过光纤、双绞线甚至是无限电波等介质传输到指定的地址。而传输过程中的集线器、中继器、调制解调器等，也属于物理层的传输介质。物理层是 <code>OSI</code> 七层模型的物理基础，没有它就谈不上数据传输了。</p>
<h4 id="2、数据链路层"><a href="#2、数据链路层" class="headerlink" title="2、数据链路层"></a><strong>2、数据链路层</strong></h4><p>数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。</p>
<p><strong><em>该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</em></strong></p>
<p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。<br>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p>
<p><strong>MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；</strong></p>
<p><strong>LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。</strong></p>
<p>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；<strong>并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</strong></p>
<p><strong><img src="https://pic1.zhimg.com/80/v2-fb8534d86e40986e43449de6c35ebd14_hd.jpg" alt="img"></strong></p>
<p><strong>数据链路层会将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）</strong>。举个例子可能会更好理解，暂且把需要传输的数据看作为不同来源的水，如果直接倒入池子中时，是无法重新分辨出不同来源的水的。但如果将不同来源的灌入瓶子中并打上记号，那就能区分出不同来源的水。这也就是为什么要划分为具有意义的数据帧传送给对端。同时要注意的是，数据链路层只负责将数据运送给物理相连的两端，并不负责直接发送到最终地址。</p>
<p>数据链路层可以看作是快递公司的司机，他们驾驶着汽车，将打包好的货物（数据帧）从一个城市（物理节点）运输到另一个城市</p>
<h4 id="3、网络层"><a href="#3、网络层" class="headerlink" title="3、网络层"></a><strong>3、网络层</strong></h4><p>网络层（Network Layer）是OSI模型的第三层，<strong>它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。</strong>它在下两层的基础上向资源子网提供服务。<strong>其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接</strong>。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。<br>一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 </p>
<p>在实现网络层功能时，需要解决的主要问题如下：<br> <strong>寻址</strong>：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是<strong>逻辑地址（如IP地址）</strong>。<br> <strong>交换</strong>：规定不同的信息交换方式。常见的交换技术有：<strong>线路交换技术和存储转发技术</strong>，后者又包括<strong>报文交换技术和分组交换技术</strong>。<br> <strong>路由算法</strong>：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。<br> <strong>连接服务</strong>：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。</p>
<p><img src="https://pic4.zhimg.com/80/v2-991572825990575d273f653a78bcc5e7_hd.jpg" alt="img"></p>
<p>​        网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。主要由 <code>IP</code>、<code>ICMP</code> 两个协议组成</p>
<p>​        网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是IP地址。IP地址和我们的住址有点相似，我们的住址可以从省到市再到街逐步缩小范围，直至我们住址。IP地址也有这样的能力，通过不断转发到更近的IP地址，最终可以到达目标地址。如何选择这条路，就看网络层了。</p>
<h4 id="4、传输层"><a href="#4、传输层" class="headerlink" title="4、传输层"></a><strong>4、传输层</strong></h4><p>OSI下3层的主要任务是<strong>数据通信</strong>，上3层的任务是<strong>数据处理</strong>。而传输层（Transport Layer）是OSI模型的第4层。因此该层<strong>是通信子网和资源子网的接口和桥梁，起到承上启下的作用</strong>。<br>该层的主要任务是：<strong>向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。</strong><br>传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：<br><strong>传输连接管理</strong>：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提<strong>供“面向连接”和“面向无接连”</strong>的两种服务。<br><strong>处理传输差错</strong>：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。<br><strong>监控服务质量。</strong></p>
<p><strong><img src="https://pic2.zhimg.com/80/v2-31bff54e0720487afe37e5f3f282d231_hd.jpg" alt="img"></strong></p>
<p><strong>传输层起着可靠传输的作用。只在通信双方节点进行处理，而不需在路由器上处理。此层有两个具有代表性的协议： <code>TCP</code> 与 <code>UDP</code>。</strong></p>
<p><code>TCP</code> 协议提供可靠的通信传输，简单说就是确认目标能通信的情况下才会传输数据（因此需要三次握手），传输过程如果丢了数据，也会重发。而 <code>UDP</code> 协议则不然，不会确认目标能否通信，只会根据协议发到对方地址的端口。至于对方收不收到，丢不丢包，一概不管。</p>
<p>传输层有一个重要作用，就是指定通信端口。以请求服务器数据为例，服务器有处理多种协议的能力，如之前应用层所说的<code>HTTP</code>，<code>FTP</code>，<code>TELNET</code> 等，但到底你是用什么协议呢？服务器并不知道。但如果你指定了端口，如 <code>80</code>，服务器就会知道你是想用 <code>HTTP</code> 协议的，自然会转给对应协议的处理程序进行处理。</p>
<p>作比喻的话，可以将传输层看作是快递公司的跟单员。负责任的跟单员（使用 <code>TCP</code> 协议）会保证快递送到客户手上，如果送不到就让公司再发一次。不负责任的跟单员（使用 <code>UDP</code> 协议）层只管将快递送到客户指定的地方，不管快递是否送到客户手上。</p>
<h4 id="5、会话层"><a href="#5、会话层" class="headerlink" title="5、会话层"></a><strong>5、会话层</strong></h4><p>会话层（Session Layer）是OSI模型的第5层，<strong>是用户应用程序和网络之间的接口</strong>，主要任务是：<strong>向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。</strong><br>用户可以按照<strong>半双工、单工和全双工</strong>的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。<strong>域名（DN）</strong>就是一种网络上使用的远程地址例如：<a href="http://www.3721.com就是一个域名。会话层的具体功能如下：" target="_blank" rel="noopener">www.3721.com就是一个域名。会话层的具体功能如下：</a><br><strong>会话管理</strong>：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。<br> <strong>会话流量控制</strong>：提供会话流量控制和交叉会话功能。<br><strong>寻址</strong>：使用远程地址建立会话连接。l<br><strong>出错控制</strong>：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。</p>
<p>会话层作用是负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。常见的协议有 <code>ADSP</code>、<code>RPC</code> 等。</p>
<h4 id="6、表示层"><a href="#6、表示层" class="headerlink" title="6、表示层"></a><strong>6、表示层</strong></h4><p>表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。表示层的具体功能如下：<br><strong>数据格式处理</strong>：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。<br><strong>数据的编码</strong>：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。<br><strong>压缩和解压缩</strong>：为了减少数据的传输量，这一层还负责数据的压缩与恢复。<br><strong>数据的加密和解密</strong>：可以提高网络的安全性。</p>
<p>表示层的作用是将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有 <code>ASCII</code>、<code>SSL/TLS</code> 等。</p>
<p>作用看起来可能比较绕，但其实是挺好理解的。我只会说中文，而日本友人只会说日文，那么我们两个是无法交流的。但如果我们都会说英文，交流时我先在心里想好要说的话是什么，再用英语说出来，日本友人听到英文，在心里转换为日语，他就能弄懂我的意思，此时表示层就是各自在心里转化语言。而浏览器请求回一堆数据，是解析成文本还是图片，就由表示层决定。数据的压缩、加密、打包等功能也都在这层完成。</p>
<p>这一层相当于快递公司的打包员。如果快递（数据）太臃肿，他会在不破坏快递的情况下压扁（压缩）它。如果客户注重安全线，全能的快递公司还能用密码箱（ <code>SSL/TLS</code>）打包快递再快送。当然，打包员会确定，目的地快递站的拆包员，能无损地拆开包裹，将快递交给用户。</p>
<h4 id="7、应用层"><a href="#7、应用层" class="headerlink" title="7、应用层"></a><strong>7、应用层</strong></h4><p>应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，<strong>其功能是直接向用户提供服务</strong>，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。<br>应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。应用层的主要功能如下：<br>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。<br>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</p>
<p><img src="https://pic2.zhimg.com/80/v2-741e4cd7f95897d6a61bd219e208f1c1_hd.jpg" alt="img"></p>
<p>作为前端，应用层肯定是最熟悉的。它的作用是为应用程序提供服务并规定应用程序中通讯相关的细节，也就是为应用提供服务。常见的协议有 <code>HTTP</code>，<code>FTP</code>，<code>TELNET</code>、<code>SMTP</code> 等。</p>
<p>我们日常开发中，接触的协议主要以 <code>HTTP</code> 为主，那么把浏览器看作一个应用，当用户发起请求时，通过 <code>HTTP协议</code>获得数据以供浏览器使用，这就是应用层的用途。而请求时发生错误，对错误进行处理，也是应用层需要负责的</p>
<p> <strong>OSI7层模型的小结</strong><br>由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。<br>在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。<strong>简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。</strong></p>
<h2 id="二-、TCP-IP分层模型"><a href="#二-、TCP-IP分层模型" class="headerlink" title="二 、TCP/IP分层模型"></a><strong>二 、TCP/IP分层模型</strong></h2><p>​        ┌────——────┐┌─┬─┬─-┬─┬─-┬─┬─-┬─┬─-┬─┬─-┐<br>　　│　　　　　　　　││Ｄ│Ｆ│Ｗ│Ｆ│Ｈ│Ｇ│Ｔ│Ｉ│Ｓ│Ｕ│　│<br>　　│　　　　　　　　││Ｎ│Ｉ│Ｈ│Ｔ│Ｔ│Ｏ│Ｅ│Ｒ│Ｍ│Ｓ│其│<br>　　│第四层，应用层　││Ｓ│Ｎ│Ｏ│Ｐ│Ｔ│Ｐ│Ｌ│Ｃ│Ｔ│Ｅ│　│<br>　　│　　　　　　　　││　│Ｇ│Ｉ│　│Ｐ│Ｈ│Ｎ│　│Ｐ│Ｎ│　│<br>　　│　　　　　　　　││　│Ｅ│Ｓ│　│　│Ｅ│Ｅ│　│　│Ｅ│它│<br>　　│　　　　　　　　││　│Ｒ│　│　│　│Ｒ│Ｔ│　│　│Ｔ│　│<br>　　└───────——─┘└─┴─┴─-┴─┴─-┴─┴─-┴─┴─-┴─┴-─┘<br>　　┌───────—–─┐┌─────────——-┬──——–─────────┐<br>　　│第三层，传输层　││　　　ＴＣＰ　　　│　　　　ＵＤＰ　　　　│<br>　　└───────—–─┘└────────——-─┴──────────——–─┘<br>　　┌───────—–─┐┌───—-──┬───—─┬────────——-──┐<br>　　│　　　　　　　　││　　　　　│ＩＣＭＰ│　　　　　　　　　　│<br>　　│第二层，网间层　││　　　　　└──—──┘　　　　　　　　　　│<br>　　│　　　　　　　　││　　　　　　　ＩＰ　　　　　　　　　　　 │<br>　　└────────—–┘└────────────────────————-─-┘<br>　　┌────────—–┐┌─────────——-┬──────——–─────┐<br>　　│第一层，网络接口││ＡＲＰ／ＲＡＲＰ　│　　　　其它　　　　　│<br>　　└────────——┘└─────────——┴─────——–──────┘<br>　　　　　　 TCP/IP四层参考模型</p>
<p>　　包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。<strong>TCP/IP协议簇</strong>是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。</p>
<p>​          TCP/IP协议被组织成四个概念层<strong>，其中有三层对应于ISO参考模型中的相应层</strong>。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。<br>　　TCP/IP分层模型的四个协议层分别完成以下的功能：</p>
<h4 id="第一层-网络接口层"><a href="#第一层-网络接口层" class="headerlink" title="第一层:网络接口层"></a>第一层:网络接口层</h4><p>　　包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。</p>
<p>​       网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，</p>
<p>　　然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。<br>　　实际上TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。</p>
<h4 id="第二层-网间层"><a href="#第二层-网间层" class="headerlink" title="第二层:网间层"></a>第二层:网间层</h4><p>　　对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。</p>
<p>网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。　　<br>　　网络互连层定义了分组格式和协议，即IP协议（Internet Protocol）。　　<br>　　网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。</p>
<h4 id="第三层-传输层"><a href="#第三层-传输层" class="headerlink" title="第三层:传输层"></a>第三层:传输层</h4><p>　　对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。</p>
<p>​        在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。　　<br>　　TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。</p>
<p>　　在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。　　<br>　　UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。</p>
<h4 id="第四层-应用层"><a href="#第四层-应用层" class="headerlink" title="第四层:应用层"></a>第四层:应用层</h4><p>TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。　　<br>　　应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于TCP协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本链接协议（Hyper Text Transfer Protocol，HTTP），也有基于UDP协议的。</p>
<p><img src="https://img-my.csdn.net/uploads/201302/25/1361801670_1367.png" alt="è¿éåå¾çæè¿°"></p>
<h2 id="三、-数据的封装与分用"><a href="#三、-数据的封装与分用" class="headerlink" title="三、 数据的封装与分用"></a>三、 数据的封装与分用</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><img src="https://img-my.csdn.net/uploads/201302/25/1361802159_1221.png" alt="è¿éåå¾çæè¿°"></p>
<p><strong>当应用程序用TCP传送数据时</strong>，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。</p>
<p>TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP segment）；UDP数据与TCP数据基本一致。唯一的不同是UDP传给IP的信息单元称作U D P数据报（UDP datagram），而且UDP的首部长为8字节。IP传给网络接口层的数据单元称作IP数据报(IP datagram)。<strong>通过以太网传输的比特流称作帧(Frame )</strong>。</p>
<h4 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h4><p><img src="https://img-my.csdn.net/uploads/201302/25/1361802639_2204.png" alt="è¿éåå¾çæè¿°"></p>
<p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。<strong>协议是通过目的端口号、源I P地址和源端口号进行解包的。</strong></p>
<h2 id="四、TCP-IP协议简述"><a href="#四、TCP-IP协议简述" class="headerlink" title="四、TCP/IP协议简述"></a>四、TCP/IP协议简述</h2><h4 id="1、什么是TCP-IP"><a href="#1、什么是TCP-IP" class="headerlink" title="1、什么是TCP/IP"></a><strong>1、什么是TCP/IP</strong></h4><p>如果要了解一个人，可以从他归属的集体聊起来。我们的HTTP协议就属于TCP/IP协议家族中的一员，了解HTTP协议再整个网络流程中的地位，也能更加充分的理解HTTP协议。</p>
<p>​      要想了解什么是TCP/IP协议，就要知道为什么有这个协议。中国人和中国人说话，要遵循汉语的的语法结构，使用汉语的发音。当我们和外国人交流时，就要适用外国的语言了，遵循外国的语法机构和发音。其实这就是一种协议，只不过我们称之为语言。计算机再这方面体现的更为直观，两台机器之间该如何通信呢，就需要制定各种各样的协议了。例如：文件传输适用TCP协议。域名系统适用DNS协议。有了些协议的存在，各种数据流按照规则传输，计算机之间得意通信。</p>
<p>​       TCP/IP协议是一个协议集合。大家叫的时候方便说，所以统称为TCP/IP。TCP/IP协议族中有一个重要的概念是分层，TCP/IP协议按照层次分为以下四层。<strong>应用层、传输层、网络层、数据链路层</strong>。为什么要分层？这就如同邓小平1978年的大包干，责任到人。一个层只负责一个层次的问题，如果出问题了，和其他的层次无关，只要维护这个层次也就好了。其实编程语言里也能体现这个分层理论，即封转性、隔离。这里不再延伸细谈。下面我是制作的一个简图。</p>
<p>下面是从网络上找到的TCP/IP通信数据流</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201223112616-1937529463.jpg" alt="img"></p>
<h4 id="2、HTTP-关系密切的协议-IP、TCP-和-DNS"><a href="#2、HTTP-关系密切的协议-IP、TCP-和-DNS" class="headerlink" title="2、HTTP 关系密切的协议 : IP、TCP 和 DNS"></a><strong>2、HTTP 关系密切的协议 : IP、TCP 和 DNS</strong></h4><p>  <strong>IP协议：</strong>IP(Internet protocol),这里的IP不是值得我们通常所说的192.168.1.1.这个IP指的是一种协议，而后面的数字值得是IP地址。IP协议的作用在于把各种数据包准确无误的传递给对方，其中两个重要的条件是IP地址，和MAC地址（Media Access Control Address）。由于IP地址是稀有资源，不可能每个人都拥有一个IP地址，所以我们通常的IP地址是路由器给我们生成的IP地址，路由器里面会记录我们的MAC地址。而MAC地址是全球唯一的，除去人为因素外不可能重复。举一个现实生活中的例子，IP地址就如同是我们居住小区的地址，而MAC地址就是我们住的那栋楼那个房间那个人</p>
<p>==IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址==</p>
<p>你向另外一台电脑发送一条信息，怎么再茫茫人海中瞬间找到对方，以下是图示</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201231521929-1635094019.png" alt="img"></p>
<p><strong>TCP协议：</strong>如果说IP协议是找到对方的详细地址。那么TCP协议就是把安全的把东西带给对方。各有分工，互不冲突。</p>
<p>​         按层次分，TCP属于传输层，提供可靠的字节流服务。什么叫字节流服务呢？这个名字听起来让人不知所以然，下面听下我通俗的解释。所谓的<strong>字节流</strong>，其实就类似于信息切割。比如你是一个卖自行车的，你要去送货。安装好的自行车，太过庞大，又不稳定，容易损伤。不如直接把自行车拆开来，每个零件上都贴上收货人的姓名。最后送到后按照把属于同一个人的自行车再组装起来，这个拆解、运输、拼装的过程其实就是TCP字节流的过程。</p>
<p> <u>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</u></p>
<p> 为了确保信息能够确保准确无误的到达，TCP采用了著名的三次握手策略</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201234441944-1271451860.png" alt="img"></p>
<p><strong>DNS：</strong>DNS(Domain names System) 和HTTP协议一样是处于应用层的服务，提供域名到IP地址之间的解析服务。</p>
<p>互联网之间是通过IP地址通信的，但是IP地址并不符合认得记忆习惯，人喜欢记忆有意义的字词。所以DNS服务就为了解决这个问题而生了。其实很好理解，形如我们电脑中host文件。</p>
<p>192.168.1.11       roverliang.com  </p>
<p>当我们访问roverliang.com 的时候，电脑便不会去外网服务器上查询了，直接去访问192.168.1.111。这是一个简单的域名劫持，足以说明DNS的涵义了。</p>
<p>下面是我们访问一个网页，各种协议在里面起的作用。</p>
<p><img src="http://images2015.cnblogs.com/blog/785686/201602/785686-20160201235309225-1640442692.jpg" alt="img"></p>
<h4 id="3、正常的TCP的三次握手和四次挥手过程"><a href="#3、正常的TCP的三次握手和四次挥手过程" class="headerlink" title="3、正常的TCP的三次握手和四次挥手过程"></a>3、正常的TCP的三次握手和四次挥手过程</h4><p>通过上一篇中网络模型中的IP层的介绍，我们知道网络层，可以实现两个主机之间的通信。但是这并不具体，因为，真正进行通信的实体是在主机中的进程，<strong>是一个主机中的一个进程与另外一个主机中的一个进程在交换数据</strong>。IP协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程<strong>。而端到端的通信才应该是应用进程之间的通信。</strong></p>
<p>UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p>
<p>TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p>
<p><strong>常用的熟知端口号</strong></p>
<p><img src="/bolgzxy.github.io/.com//C:%5CUsers%5CCCTVZYX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1567738933945.png" alt="1567738933945"></p>
<p><strong>TCP的概述</strong></p>
<p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。</p>
<p><strong>TCP报文首部</strong></p>
<p><strong>1 源端口和目的端口</strong>，各占2个字节，分别写入源端口和目的端口；<br><strong>2 序号</strong>，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；<br><strong>3 确认号</strong>，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；<br><strong>4 数据偏移</strong>，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；<br><strong>5 保留</strong>，占6位，保留今后使用，但目前应都位0；<br><strong>6 紧急URG</strong>，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；<br><strong>7 确认ACK</strong>，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；<br><strong>8 推送PSH</strong>，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；<br><strong>9 复位RST</strong>，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；<br><strong>10 同步SYN</strong>，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；<br><strong>11 终止FIN</strong>，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；<br><strong>12 窗口</strong>，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；<br><strong>13 检验和</strong>，占2字节，校验首部和数据这两部分；<br><strong>14 紧急指针</strong>，占2字节，指出本报文段中的紧急数据的字节数；<br><strong>15 选项</strong>，长度可变，定义一些其他的可选的参数。</p>
<h5 id="TCP连接的建立（三次握手）"><a href="#TCP连接的建立（三次握手）" class="headerlink" title="TCP连接的建立（三次握手）"></a><strong>TCP连接的建立（三次握手）</strong></h5><p><img src="https://img-blog.csdn.net/20170607205709367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
<p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p>
<p>1 <strong>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</strong></p>
<p>2 <strong>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong></p>
<p>3 <strong>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</strong></p>
<p>4 <strong>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong></p>
<p>5 <strong>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</strong></p>
<p><img src="https://img-blog.csdn.net/20170605110405666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ä¸æ¬¡æ¡æ"></p>
<h5 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h5><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h5 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h5><p>1  <strong>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong></p>
<p>2  <strong>服务器收到连接释放报文，发出确认报文，<span style="color:red">ACK=1，ack=u+1，并且带上自己的序列号seq=v，</span>此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，<span style="color:red">即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。</span>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</strong></p>
<p>3  <strong>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</strong></p>
<p>4  <strong>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<span style="color:red">FIN=1，ack=u+1，</span>由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的<span style="color:red">序列号为seq=w，</span>此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</strong></p>
<p>5  <strong>客户端收到服务器的连接释放报文后，必须发出确认，<span style="color:red">ACK=1，ack=w+1，而自己的序列号是seq=u+1，</span>此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</strong></p>
<p>6  <strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</strong></p>
<p><img src="https://img-blog.csdn.net/20170606084851272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="åæ¬¡æ¥æ"></p>
<h5 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h5><p> MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h5 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h5><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<h5 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h5><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/算法/排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/算法/排序/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="●-请你来手写一下快排的代码"><a href="#●-请你来手写一下快排的代码" class="headerlink" title="● 请你来手写一下快排的代码"></a>● 请你来手写一下快排的代码</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`int` `once_quick_sort(vector&lt;``int``&gt; &amp;data, ``int` `left, ``int` `right)``&#123;``int` `key = data[left];``while` `(left &lt; right)``&#123;``while` `(left &lt; right &amp;&amp; key &lt;= data[right])``&#123;``right--;``&#125;``if` `(left &lt; right)``&#123;``data[left++] = data[right];``&#125;``while` `(left &lt; right &amp;&amp; key &gt; data[left])``&#123;``left++;``&#125;``if` `(left &lt; right)``&#123;``data[right--] = data[left];``&#125;``&#125;``data[left] = key;``return` `left;``&#125;``int` `quick_sort(vector&lt;``int``&gt; &amp; data, ``int` `left, ``int` `right)``&#123;``if` `(left &gt;= right )``&#123;``return` `1;``&#125;``int` `middle = 0;``middle = once_quick_sort(data, left, right);``quick_sort(data, left, middle-1);``quick_sort(data, middle + 1, right);``&#125;；`</span><br></pre></td></tr></table></figure>

<h2 id="●-请你手写一下快排的代码"><a href="#●-请你手写一下快排的代码" class="headerlink" title="● 请你手写一下快排的代码"></a>● 请你手写一下快排的代码</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`nt once_quick_sort(vector&lt;``int``&gt; &amp;data, ``int` `left, ``int` `right)``&#123;``int` `key = data[left];``while` `(left &lt; right)``&#123;``while` `(left &lt; right &amp;&amp; key &lt;= data[right])``&#123;``right--;``&#125;``if` `(left &lt; right)``&#123;``data[left++] = data[right];``&#125;``while` `(left &lt; right &amp;&amp; key &gt; data[left])``&#123;``left++;``&#125;``if` `(left &lt; right)``&#123;``data[right--] = data[left];``&#125;``&#125;``data[left] = key;``return` `left;``&#125;``int` `quick_sort(vector&lt;``int``&gt; &amp; data, ``int` `left, ``int` `right)``&#123;``if` `(left &gt;= right )``&#123;``return` `1;``&#125;``int` `middle = 0;``middle = once_quick_sort(data, left, right);``quick_sort(data, left, middle-1);``quick_sort(data, middle + 1, right);``&#125;`</span><br></pre></td></tr></table></figure>

<h2 id="●-请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素"><a href="#●-请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素" class="headerlink" title="● 请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素"></a>● 请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>首先使用快速排序算法将数组按照从大到小排序，然后取第k个，其时间复杂度最快为O(nlogn)</p>
<p>使用堆排序，建立最大堆，然后调整堆，知道获得第k个元素，其时间复杂度为O(n+klogn)</p>
<p>首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数</p>
<p>利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl的元素都小于i,Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素；如果Dr元素个数大于k,那么继续求Dr中第k大的元素。</p>
<p>当有相同元素的时候，</p>
<p>首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)</p>
<h2 id="●-请你来介绍一下各种排序算法及时间复杂度"><a href="#●-请你来介绍一下各种排序算法及时间复杂度" class="headerlink" title="● 请你来介绍一下各种排序算法及时间复杂度"></a>● 请你来介绍一下各种排序算法及时间复杂度</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>插入排序：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。</p>
<p>希尔排序：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1.</p>
<p>归并排序：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。</p>
<p>冒泡排序：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。</p>
<p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>选择排序：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。</p>
<p>堆排序：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆。</p>
<p>各个排序的时间复杂度、空间复杂度及稳定性如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552474444160_93CF294B0FB45C83DC616C5700184F2E" alt="img"></p>
<h2 id="●-请你说一说你知道的排序算法及其复杂度"><a href="#●-请你说一说你知道的排序算法及其复杂度" class="headerlink" title="● 请你说一说你知道的排序算法及其复杂度"></a>● 请你说一说你知道的排序算法及其复杂度</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、冒泡排序：</p>
<p>从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并“冒泡”至数列的顶端。</p>
<p>稳定性：稳定</p>
<p>平均时间复杂度：O(n ^ 2)</p>
<p>2、插入排序：</p>
<p>从待排序的n个记录中的第二个记录开始，依次与前面的记录比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。</p>
<p>稳定性：稳定</p>
<p>平均时间复杂度：O(n ^ 2)</p>
<p>3、希尔排序（缩小增量排序）：</p>
<p>希尔排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。</p>
<p>希尔排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量di逐渐缩小，分组数减少，各组的记录数增多，但由于已经按di−1分组排序，文件叫接近于有序状态，所以新的一趟排序过程较快。因此希尔 排序在效率上比直接插入排序有较大的改进。</p>
<p>在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为希尔排序最后一轮的增量d就为1。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：希尔排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。时间复杂度在O(n ^ 1.3)到O(n ^ 2)之间。</p>
<p>4、选择排序：</p>
<p>从所有记录中选出最小的一个数据元素与第一个位置的记录交换；然后在剩下的记录当中再找最小的与第二个位置的记录交换，循环到只剩下最后一个数据元素为止。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(n ^ 2)</p>
<p>5、快速排序</p>
<p>1）从待排序的n个记录中任意选取一个记录（通常选取第一个记录）为分区标准;</p>
<p>2）把所有小于该排序列的记录移动到左边，把所有大于该排序码的记录移动到右边，中间放所选记录，称之为第一趟排序；</p>
<p>3）然后对前后两个子序列分别重复上述过程，直到所有记录都排好序。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>6、堆排序：</p>
<p>堆：</p>
<p>1、完全二叉树或者是近似完全二叉树。</p>
<p>2、大顶堆：父节点不小于子节点键值，小顶堆：父节点不大于子节点键值。左右孩子没有大小的顺序。</p>
<p>堆排序在选择排序的基础上提出的，步骤：</p>
<p>1、建立堆</p>
<p>2、删除堆顶元素，同时交换堆顶元素和最后一个元素，再重新调整堆结构，直至全部删除堆中元素。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>7、归并排序：</p>
<p>采用分治思想，现将序列分为一个个子序列，对子序列进行排序合并，直至整个序列有序。</p>
<p>稳定性：稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>8、计数排序：</p>
<p>思想：如果比元素x小的元素个数有n个，则元素x排序后位置为n+1。</p>
<p>步骤：</p>
<p>1）找出待排序的数组中最大的元素；</p>
<p>2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</p>
<p>3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</p>
<p>4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>
<p>稳定性：稳定</p>
<p>时间复杂度：O(n+k)，k是待排序数的范围。</p>
<p>9、桶排序：</p>
<p>步骤：</p>
<p>1）设置一个定量的数组当作空桶子； 常见的排序算法及其复杂度：</p>
<p>2）寻访序列，并且把记录一个一个放到对应的桶子去；</p>
<p>3）对每个不是空的桶子进行排序。</p>
<p>4）从不是空的桶子里把项目再放回原来的序列中。</p>
<p>时间复杂度：O(n+C) ，C为桶内排序时间。</p>
<h2 id="●-请问海量数据如何去取最大的k个"><a href="#●-请问海量数据如何去取最大的k个" class="headerlink" title="● 请问海量数据如何去取最大的k个"></a>● 请问海量数据如何去取最大的k个</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.直接全部排序（只适用于内存够的情况）</p>
<p>当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。</p>
<p>这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。</p>
<p>2.快速排序的变形 （只使用于内存够的情况）</p>
<p>这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。</p>
<p>这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  &gt; K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p>
<p>3.最小堆法</p>
<p>这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p>
<p>4.分治法</p>
<p>将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p>
<p>5.Hash法</p>
<p>如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p>
<h2 id="●-请问快排的时间复杂度最差是多少？什么时候时间最差"><a href="#●-请问快排的时间复杂度最差是多少？什么时候时间最差" class="headerlink" title="● 请问快排的时间复杂度最差是多少？什么时候时间最差"></a>● 请问快排的时间复杂度最差是多少？什么时候时间最差</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>O（N2),元素本来倒序排列用时最多</p>
<h2 id="●-请问稳定排序哪几种？"><a href="#●-请问稳定排序哪几种？" class="headerlink" title="● 请问稳定排序哪几种？"></a>● 请问稳定排序哪几种？</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序</p>
<h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、快排算法</p>
<p>根据哨兵元素，用两个指针指向待排序数组的首尾，首指针从前往后移动找到比哨兵元素大的，尾指针从后往前移动找到比哨兵元素小的，交换两个元素，直到两个指针相遇，这是一趟排序，经常这趟排序后，比哨兵元素大的在右边，小的在左边。经过多趟排序后，整个数组有序。</p>
<p>稳定性：不稳定</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>2、稳定排序</p>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>快排算法是不稳定的排序算法。例如：</p>
<p>待排序数组:int a[] ={1, 2, 2, 3, 4, 5, 6};</p>
<p>若选择a[2]（即数组中的第二个2）为枢轴，而把大于等于比较子的数均放置在大数数组中，则a[1]（即数组中的第一个2）会到pivot的右边， 那么数组中的两个2非原序。</p>
<p>若选择a[1]为比较子，而把小于等于比较子的数均放置在小数数组中，则数组中的两个2顺序也非原序。</p>
<p>3、快排最差情况推倒</p>
<p>在快速排序的早期版本中呢，最左面或者是最右面的那个元素被选为枢轴，那最坏的情况就会在下面的情况下发生啦：</p>
<p>1）数组已经是正序排过序的。 （每次最右边的那个元素被选为枢轴）</p>
<p>2）数组已经是倒序排过序的。 （每次最左边的那个元素被选为枢轴）</p>
<p>3）所有的元素都相同（1、2的特殊情况）</p>
<p>因为这些案例在用例中十分常见，所以这个问题可以通过要么选择一个随机的枢轴，或者选择一个分区中间的下标作为枢轴，或者（特别是对于相比更长的分区）选择分区的第一个、中间、最后一个元素的中值作为枢轴。有了这些修改，那快排的最差的情况就不那么容易出现了，但是如果输入的数组最大（或者最小元素）被选为枢轴，那最坏的情况就又来了。</p>
<p>快速排序，在最坏情况退化为冒泡排序，需要比较O(n2)次（n(n - 1)/2次）。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/算法/各种排序的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/算法/各种排序的方法/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="各种排序方法总结"><a href="#各种排序方法总结" class="headerlink" title="各种排序方法总结"></a>各种排序方法总结</h2><h2 id="1、冒泡排序（bubble-Sort）"><a href="#1、冒泡排序（bubble-Sort）" class="headerlink" title="1、冒泡排序（bubble Sort）"></a>1、冒泡排序（bubble Sort）</h2><p>冒泡排序是最简单粗暴的排序方法之一。它的原理很简单，每次从左到右两两比较，把大的交换到后面，每次可以确保将前M个元素的最大值移动到最右边。</p>
<p><strong>步骤</strong></p>
<ol>
<li>从左开始比较相邻的两个元素x和y，如果 x &gt; y 就交换两者</li>
<li>执行比较和交换，直到到达数组的最后一个元素</li>
<li>重复执行1和2，直到执行n次，也就是n个最大元素都排到了最后</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123; <span class="comment">// times</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size() - i - <span class="number">1</span>; j++) &#123; <span class="comment">// position</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换的哪里可以写一个函数进行交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=nums[j];</span><br><span class="line">    nums[j]=nums[j+<span class="number">1</span>];</span><br><span class="line">    nums[j+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当然这里的一不也可以不借助临时变量</span></span><br><span class="line">nums[j]+=nums[j+<span class="number">1</span>];</span><br><span class="line">nums[j+<span class="number">1</span>]=nums[j]-nums[j+<span class="number">1</span>];</span><br><span class="line">nums[j]=nums[j]-nums[j+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//swap函数写成模板的形式是</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span>((<span class="title">vector</span>&lt;T&gt; &amp;<span class="title">nums</span>,<span class="title">T</span> *<span class="title">a</span>,<span class="title">T</span> *<span class="title">b</span>)//&lt;typename T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>由于我们要重复执行n次冒泡，每次冒泡要执行n次比较（实际是1到n的等差数列，也就是<code>(a1 + an) * n / 2</code>），也就是 <code>O(n^2)</code>。 空间复杂度是<code>O(n)</code>。</p>
<p>冒泡排序是稳定的排序算法，元素较少时效率比较高。</p>
<h2 id="2、插入排序（Insertion-Sort）"><a href="#2、插入排序（Insertion-Sort）" class="headerlink" title="2、插入排序（Insertion Sort）"></a>2、插入排序（Insertion Sort）</h2><p>插入排序的原理是从左到右，把选出的一个数和前面的数进行比较，找到最适合它的位置放入，使前面部分有序。</p>
<p> <strong>步骤</strong></p>
<ol>
<li>从左开始，选出当前位置的数x，和它之前的数y比较，如果x &lt; y则交换两者</li>
<li>对x之前的数都执行1步骤，直到前面的数字都有序</li>
<li>选择有序部分后一个数字，插入到前面有序部分，直到没有数字可选择</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size(),i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i,j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j]+=nums[j<span class="number">-1</span>];</span><br><span class="line">                nums[j<span class="number">-1</span>]=nums[j]-nums[j<span class="number">-1</span>];</span><br><span class="line">                nums[j]-=nums[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>因为要选择n次，而且插入时最坏要比较n次，所以时间复杂度同样是<code>O(n^2)</code>。空间复杂度是<code>O(n)</code>。</p>
<p>插入排序是一种稳定的排序方法，排序元素比较少的时候很好，大量元素便会效率低下。</p>
<h2 id="3、选择排序（Selection-Sort）"><a href="#3、选择排序（Selection-Sort）" class="headerlink" title="3、选择排序（Selection Sort）"></a>3、选择排序（Selection Sort）</h2><p>选择排序的原理是，每次都从乱序数组中找到最大（最小）值，放到当前乱序数组头部，最终使数组有序。</p>
<p><strong>步骤</strong></p>
<ol>
<li>从左开始，选择后面元素中最小值，和最左元素交换</li>
<li>从当前已交换位置往后执行，直到最后一个元素</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selection_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;nums.size(),j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[min]&gt;nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">            min=j;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[min];</span><br><span class="line">        muns[min]=nums[i];</span><br><span class="line">        nums[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是<code>O(n^2)</code>。空间复杂度是<code>O(n)</code>。</p>
<p><span style="color:red">冒泡法和选择排序</span>很像，两者区别在于：冒泡排序是每一次都可能要交换，而选择排序是在比较时记下最小数的位置最后来交换，所以他们的交换过程是不一样的，但查找的过程是一样的。因此选择排序的效率比冒泡法只高不低。</p>
<h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><p>希尔排序从名字上看不出来特点，因为它是以发明者命名的。它的另一个名字是“递减增量排序算法“。这个算法可以看作是插入排序的优化版，因为插入排序需要一位一位比较，然后放置到正确位置。为了提升比较的跨度，希尔排序将数组按照一定步长分成几个子数组进行排序，通过逐渐减短步长来完成最终排序</p>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png" alt="img"></p>
<p><strong>步骤</strong></p>
<ol>
<li>计算当前步长，按步长划分子数组</li>
<li>子数组内插入排序</li>
<li>步长除以2后继续12两步，直到步长最后变成1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap=nums.size()&gt;&gt;<span class="number">1</span>;gap&gt;<span class="number">0</span>;gap&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">            <span class="keyword">int</span> j=i-gap;</span><br><span class="line">            <span class="keyword">for</span>(; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp;j-=gap)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j+gap]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j+gap]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h2><p>归并排序是采用分治法（Divide and Conquer）的一个典型例子。这个排序的特点是把一个数组打散成小数组，然后再把小数组拼凑再排序，直到最终数组有序。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png" alt="img"></p>
<p>　     可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。<strong>分</strong>阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p>
<p>​       再来看看<strong>治</strong>阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。    </p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194508761-468169540.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194621308-588010220.png" alt="img"></p>
<p><strong>步骤</strong></p>
<ol>
<li>把当前数组分化成n个单位为1的子数组，然后两两比较合并成单位为2的n/2个子数组</li>
<li>继续进行这个过程，按照2的倍数进行子数组的比较合并，直到最终数组有序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> end=nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp(nums.size);</span><br><span class="line">    Merge_Sort(nums,begin,end,temp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> middle=(begin+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(middle!=begin)</span><br><span class="line">    &#123;</span><br><span class="line">        Merge_Sort(nums,begin,middle,temp);<span class="comment">//左边</span></span><br><span class="line">        Merge_Sort(nums,middle,end,temp)<span class="comment">//右边</span></span><br><span class="line">        Merge_array(nums.begin,middle,end.temp);  <span class="comment">//排序合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_array</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> middle,<span class="keyword">int</span> end,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=begin; <span class="comment">//左边数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> b=middle;<span class="comment">//右边数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> c=begin; <span class="comment">//临时数组的指针</span></span><br><span class="line">    <span class="keyword">while</span>(a!=middle&amp;&amp;b!=end)<span class="comment">//左右两个数据进行比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[a]&lt;nums[b])</span><br><span class="line">            temp[c++]=nums[a];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[c++]=nums[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;middle)<span class="comment">//一边的数组已近没有了，全部放进到temp数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[c++]=nums[a++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;end)<span class="comment">//一边的数组已近没有了，全部放进到temp数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[c++]=nums[b++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>在<code>merge_array</code>过程中，实际的操作是当前两个子数组的长度，即2m。又因为打散数组是二分的，最终循环执行数是<code>logn</code>。所以这个算法最终时间复杂度是<code>O(nlogn)</code>，空间复杂度是<code>O(n)</code>。</p>
<h2 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h2><p>快速排序也是利用分治法实现的一个排序算法。快速排序和归并排序不同，它不是一半一半的分子数组，而是选择一个基准数，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断对左右两部分也执行相同步骤，直到整个数组有序。</p>
<p><strong>步骤</strong></p>
<ol>
<li>用一个基准数将数组分成两个子数组</li>
<li>将大于基准数的移到右边，小于的移到左边</li>
<li>递归的对子数组重复执行1，2，直到整个数组有序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//占用辅助空间的解法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> end=nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp(nums.size);</span><br><span class="line">    Quick_Sort(nums,begin,end,temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> middle,<span class="keyword">int</span> end,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> middle=(begin+end)/<span class="number">2</span>;<span class="comment">//选取中间的一个点</span></span><br><span class="line">    <span class="keyword">if</span>(midlle!=begin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=begin,b=end<span class="number">-1</span>;<span class="comment">//辅助空间的两个指针 一前一后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i=middle)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[midlle])<span class="comment">//和这个值做一个比较 </span></span><br><span class="line">                temp[a++]=nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[b--]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        temp[a]=nums[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=temp[i];<span class="comment">//放回nums数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        Quick_Sort(nums,begin,a,temp);</span><br><span class="line">        Quick_Sort(nums,a+<span class="number">1</span>,end,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不占用辅助空间的解法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> end=nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">    Quick_Sort(nums,begin,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里进行比较的数字还可以是随机的、</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int index=RandomInRange(begin,end); </span></span><br><span class="line">    <span class="keyword">if</span>(begin&lt;end<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=begin;</span><br><span class="line">        <span class="keyword">int</span> b=end<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a&lt;b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[b]&gt;=nums[begin]&amp;&amp;a&lt;b)</span><br><span class="line">                b--;</span><br><span class="line">            <span class="keyword">while</span>(nums[a]&lt;=nums[begin]&amp;&amp;a&lt;b)</span><br><span class="line">                a++;</span><br><span class="line">            swap(nums[a],nums[b]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[begin],nums[b]);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另外一张快排的写法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Patition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> length,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>||begin&lt;<span class="number">0</span>||end&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index=RandomInRange(begin,end); </span><br><span class="line">    swap(nums[index],nums[end]);</span><br><span class="line">    <span class="keyword">int</span> small=begin<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=samll;i&lt;end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;nums[end])</span><br><span class="line">        &#123;   </span><br><span class="line">            ++small;</span><br><span class="line">            <span class="keyword">if</span>(small!=i)</span><br><span class="line">                swap(nums[i],nums[small]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++small;</span><br><span class="line">    swap(nums[small],nums[end]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> length,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin==end)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index=Patition(nums,length,begin,end);</span><br><span class="line">    <span class="keyword">if</span>(index&gt;begin)</span><br><span class="line">        index=Patition(nums,length,begin,index<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        index=Patition(nums,length,index+<span class="number">1</span>,end); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h2><p>堆排序经常用于求一个数组中最大k个元素时。因为堆实际上是一个完全二叉树，所以用它可以用一维数组来表示。因为最大堆的第一位总为当前堆中最大值，所以每次将最大值移除后，调整堆即可获得下一个最大值，通过一遍一遍执行这个过程就可以得到前k大元素，或者使堆有序。</p>
<p>在了解算法之前，首先了解在一维数组中节点的下标：</p>
<ul>
<li>i节点的父节点 parent(i) = floor((i-1)/2)</li>
<li>i节点的左子节点 left(i) = 2i + 1</li>
<li>i节点的右子节点 right(i) = 2i</li>
</ul>
<p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p>
<p><strong>堆</strong></p>
<p>　　<strong>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182750011-675658660.png" alt="img"></p>
<p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182857323-2092264199.png" alt="img"></p>
<p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p>
<p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p>
<p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p>
<p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p>
<p><strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p>
<p>　　a.假设给定无序序列结构如下</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192038651-934327647.png" alt="img"></p>
<p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192209433-270379236.png" alt="img"></p>
<p>4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192854636-1823585260.png" alt="img"></p>
<p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217193347886-1142194411.png" alt="img"></p>
<p>此时，我们就将一个无需序列构造成了一个大顶堆。</p>
<p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p>
<p>a.将堆顶元素9和末尾元素4进行交换</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217194207620-1455153342.png" alt="img"></p>
<p>b.重新调整结构，使其继续满足堆定义</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218153110495-1280388728.png" alt="img"></p>
<p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>
<p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152348229-935654830.png" alt="img"></p>
<p>再简单总结下堆排序的基本思路：</p>
<p>　　<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p>
<p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p>
<p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p>
<p>步骤</p>
<ol>
<li>构造最大堆（Build Max Heap）：首先将当前元素放入最大堆下一个位置，然后将此元素依次和它的父节点比较，如果大于父节点就和父节点交换，直到比较到根节点。重复执行到最后一个元素。</li>
<li>最大堆调整（Max Heapify）：调整最大堆即将根节点移除后重新整理堆。整理方法为将根节点和最后一个节点交换，然后把堆看做n-1长度，将当前根节点逐步移动到其应该在的位置。</li>
<li>堆排序（HeapSort）：重复执行2，直到所有根节点都已移除。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();<span class="comment">//整个的大小是 n </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//先是确定最下面的那个非叶节点，然后依次过构造一个最大堆 </span></span><br><span class="line">    &#123; </span><br><span class="line">        max_heapify(nums, i, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)<span class="comment">// heap sort</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        num[i] = nums[<span class="number">0</span>];</span><br><span class="line">        num[<span class="number">0</span>] = temp;</span><br><span class="line">        max_heapify(nums, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curr = beg;</span><br><span class="line">    <span class="keyword">int</span> child = curr * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//子节点</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; end &amp;&amp; nums[child] &lt; nums[child + <span class="number">1</span>])<span class="comment">//先把左节点和右节点比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[curr] &lt; nums[child]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//交换子节点和父节点的值</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[curr];</span><br><span class="line">            nums[curr] = nums[child];</span><br><span class="line">            num[child] = temp;</span><br><span class="line">            <span class="comment">//这里是一直往下 后面的操作可能会改变之前排列好的序列</span></span><br><span class="line">            curr = child;</span><br><span class="line">            child = <span class="number">2</span> * curr + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Max_headpify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current=begin;</span><br><span class="line">    <span class="keyword">int</span> child=current*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(child+<span class="number">1</span>&lt;end&amp;&amp;nums[child]&lt;nums[child+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[current]&lt;nums[child])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[current],current[child]);</span><br><span class="line">            current=child;</span><br><span class="line">            child=current*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;in&gt;Max_Sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result(nums.size());</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)<span class="comment">//先构造一个最大堆</span></span><br><span class="line">    &#123;</span><br><span class="line">       Max_headpify(nums,i,nums.size()<span class="number">-1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        num[i] = nums[<span class="number">0</span>];</span><br><span class="line">        num[<span class="number">0</span>] = temp;</span><br><span class="line">        result.push_back(num[i]);</span><br><span class="line">        max_heapify(nums, <span class="number">0</span>, i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>堆执行一次调整需要<code>O(logn)</code>的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度是<code>O(nlogn)</code>。空间复杂度是<code>O(n)</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/算法/动态规划相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/算法/动态规划相关/" itemprop="url">动态规划问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>​         动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划(DP)</p>
<p>在什么时候需要使用动态规划？</p>
<p> 如果要求一个问题的<strong>最优解</strong>（通常是最大值或者最小值），而且该问题能够<strong>分解成若干个子问题，并且小问题之间也存在重叠的子问题</strong>，则考虑采用动态规划。</p>
<h2 id="2、基本思想和策略"><a href="#2、基本思想和策略" class="headerlink" title="2、基本思想和策略"></a>2、基本思想和策略</h2><p>​         基本思想与<strong>分治法</strong>类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<h2 id="3、相关的问题思路和过程"><a href="#3、相关的问题思路和过程" class="headerlink" title="3、相关的问题思路和过程"></a>3、相关的问题思路和过程</h2><p>一、最短路径的问题</p>
<p>给定一个矩阵m，从左上角开始每次只能向右走或者向下走，最后达到右下角的位置，路径中所有数字累加起来就是路径和，返回所有路径的最小路径和，如果给定的m如下，那么路径1,3,1,0,6,1,0就是最小路径和，返回12.</p>
<p>1 3 5 9<br>8 1 3 4<br>5 0 6 1<br>8 8 4 0</p>
<p>分析可知；由分析可知：走到第(i ,j)个数时，只可能是从(i-1 ,j)或是(i ,j-1)走来的，路径(i ,j)的阶段依赖的是(i-1 ,j)和(i ,j-1)的子阶段，所以状态转移方程为<br>$$<br>dp[i][j] =a[i][j] + min(dp[i-1][j]+ dp[i][j-1])，<br>$$</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">&gt; <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">int</span> dp[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#125;;     <span class="comment">//全局数组，存放决策表</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; 	<span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>&#125;;  <span class="comment">//矩阵存储a[i][j]</span></span><br><span class="line">&gt; 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)</span><br><span class="line">&gt; 	&#123;</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;++j)</span><br><span class="line">&gt; 		&#123;</span><br><span class="line">&gt; 			<span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)                         <span class="comment">//边界条件问题需要考虑到</span></span><br><span class="line">&gt; 			&#123;</span><br><span class="line">&gt; 				dp[i][j] = a[i][j];</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 			<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; j!=<span class="number">0</span>)</span><br><span class="line">&gt; 			&#123;</span><br><span class="line">&gt; 				dp[i][j] = a[i][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 			<span class="keyword">else</span> <span class="keyword">if</span> (i!=<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)</span><br><span class="line">&gt; 			&#123;</span><br><span class="line">&gt; 				dp[i][j] = a[i][j] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 			<span class="keyword">else</span></span><br><span class="line">&gt; 			&#123;</span><br><span class="line">&gt; 				dp[i][j] = a[i][j] + min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; ```</span><br><span class="line">&gt; <span class="built_in">cout</span>&lt;&lt;<span class="string">"走到位置"</span>&lt;&lt;<span class="string">"(4,4)"</span>&lt;&lt;<span class="string">"最短路径为："</span>;</span><br><span class="line">&gt; <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">3</span>][<span class="number">3</span>]&lt;&lt;<span class="built_in">endl</span>;           <span class="comment">//好像到这里又脑残了一次，真输出dp[4][4]了~</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt; system(<span class="string">"pause"</span>);</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt; ```</span><br><span class="line">&gt; </span><br><span class="line">&gt; ## &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>二、剪绳子问题<br>给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n&gt;1并且m&gt;1)每段绳子的长度记为k[0],k[1],…,k[m].请问k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？</p>
<p>分析：此时绳子的长度是m，但是每一次都可以分为<br>$$<br>k[1]k[m-1]k[2]k[m-2]…….k[m/2][m/2+1]<br>$$<br>然后比如k[1]k[m-1] 其中的k[m-1]又同样可以分为一直向下分，一直到找出最优解<br>$$<br>k[1]k[m-2]k[2]k[m-3]…….k[m/2][m/2]<br>$$</p>
<blockquote>
<ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cutting</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">&gt;   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;value;<span class="comment">//长度小于等等于1没办法剪</span></span><br><span class="line">&gt;     <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) </span><br><span class="line">&gt;      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="comment">//对于f(2)，长度为2的绳子，只有一种剪法，剪成两段长度为1的绳子，剪后的乘积为1</span></span><br><span class="line">&gt;     <span class="keyword">if</span>(n == <span class="number">2</span>)    </span><br><span class="line">&gt;      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;     <span class="comment">//对于f(3)，长度为3的绳子，只有一种剪法，剪成两段长度为1和2的绳子，但剪后的乘积为2</span></span><br><span class="line">&gt;     <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">&gt;      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&gt;     <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="comment">//数组用于存储绳子乘积最大值</span></span><br><span class="line">&gt;     <span class="keyword">int</span> value[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">&gt;   value[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&gt;   value[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&gt;   value[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">&gt;   value[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">&gt;   <span class="comment">// value[i]=k;</span></span><br><span class="line">&gt;     <span class="comment">//从f(4)开始迭代</span></span><br><span class="line">&gt;     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>;i &lt;= n; i++) &#123;</span><br><span class="line">&gt;    max = <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> val = value[j] * value[i - j];</span><br><span class="line">&gt;     <span class="comment">//不同于递推，这里对每一个的值做了一次舍弃。</span></span><br><span class="line">&gt;    max = val &gt; max ? val : max;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      value[i] = max;</span><br><span class="line">&gt;      <span class="comment">//当下一次又有这样子的分类的时候，这里的value[i]的值可以直接带进去，不用计算。</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     max = value[n];</span><br><span class="line">&gt;     <span class="keyword">return</span> max;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>三、背包问题的动态规划</p>
<p>给定一组多个n物品，每种物品都有自己的重量w[i]和价值（v[i]），在限定的总重量/总容量（maxw）内，选择其中若干个（也即每种物品可以选0个或1个），设计选择方案使得物品的总价值最高。</p>
<p>代码如下，并没有理解的很好。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line">&gt; <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">int</span> n, MaxValue;</span><br><span class="line">&gt; <span class="keyword">int</span> w[MAXN + <span class="number">1</span>], v[MAXN + <span class="number">1</span>];</span><br><span class="line">&gt; <span class="keyword">int</span> dp[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; 	<span class="keyword">int</span> w[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">&gt; 	<span class="keyword">int</span> v[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">&gt; 	<span class="keyword">int</span> maxW = <span class="number">8</span>;</span><br><span class="line">&gt; 	<span class="keyword">int</span> dp[<span class="number">5</span>][<span class="number">9</span>] = &#123; &#123;<span class="number">0</span>&#125; &#125;;</span><br><span class="line">&gt; 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= maxW; j++)</span><br><span class="line">&gt; 		&#123;</span><br><span class="line">&gt; 			<span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">&gt; 				dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">&gt; 			<span class="keyword">else</span> &#123;</span><br><span class="line">&gt; 				dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;     <span class="comment">//return dp[4][maxW];</span></span><br><span class="line">&gt; 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&gt; 	&#123;</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">&gt; 		&#123;</span><br><span class="line">&gt; 			<span class="built_in">cout</span> &lt;&lt; <span class="string">"dp["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; j &lt;&lt; <span class="string">"]===="</span> &lt;&lt; dp[i][j] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是输出的内容</p>
<blockquote>
<ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   dp[<span class="number">0</span>][<span class="number">0</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">1</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">2</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">3</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">4</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">5</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">6</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">7</span>]====<span class="number">0</span>  dp[<span class="number">0</span>][<span class="number">8</span>]====<span class="number">0</span></span><br><span class="line">&gt;   dp[<span class="number">1</span>][<span class="number">0</span>]====<span class="number">0</span>  dp[<span class="number">1</span>][<span class="number">1</span>]====<span class="number">0</span>  dp[<span class="number">1</span>][<span class="number">2</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">3</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">4</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">5</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">6</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">7</span>]====<span class="number">3</span>  dp[<span class="number">1</span>][<span class="number">8</span>]====<span class="number">3</span></span><br><span class="line">&gt;   dp[<span class="number">2</span>][<span class="number">0</span>]====<span class="number">0</span>  dp[<span class="number">2</span>][<span class="number">1</span>]====<span class="number">0</span>  dp[<span class="number">2</span>][<span class="number">2</span>]====<span class="number">3</span>  dp[<span class="number">2</span>][<span class="number">3</span>]====<span class="number">4</span>  dp[<span class="number">2</span>][<span class="number">4</span>]====<span class="number">4</span>  dp[<span class="number">2</span>][<span class="number">5</span>]====<span class="number">7</span>  dp[<span class="number">2</span>][<span class="number">6</span>]====<span class="number">7</span>  dp[<span class="number">2</span>][<span class="number">7</span>]====<span class="number">7</span>  dp[<span class="number">2</span>][<span class="number">8</span>]====<span class="number">7</span> </span><br><span class="line">&gt;   dp[<span class="number">3</span>][<span class="number">0</span>]====<span class="number">0</span>  dp[<span class="number">3</span>][<span class="number">1</span>]====<span class="number">0</span>  dp[<span class="number">3</span>][<span class="number">2</span>]====<span class="number">3</span>  dp[<span class="number">3</span>][<span class="number">3</span>]====<span class="number">4</span>  dp[<span class="number">3</span>][<span class="number">4</span>]====<span class="number">5</span>  dp[<span class="number">3</span>][<span class="number">5</span>]====<span class="number">7</span>  dp[<span class="number">3</span>][<span class="number">6</span>]====<span class="number">8</span>  dp[<span class="number">3</span>][<span class="number">7</span>]====<span class="number">9</span>  dp[<span class="number">3</span>][<span class="number">8</span>]====<span class="number">9</span></span><br><span class="line">&gt;   dp[<span class="number">4</span>][<span class="number">0</span>]====<span class="number">0</span>  dp[<span class="number">4</span>][<span class="number">1</span>]====<span class="number">0</span>  dp[<span class="number">4</span>][<span class="number">2</span>]====<span class="number">3</span>  dp[<span class="number">4</span>][<span class="number">3</span>]====<span class="number">4</span>  dp[<span class="number">4</span>][<span class="number">4</span>]====<span class="number">5</span>  dp[<span class="number">4</span>][<span class="number">5</span>]====<span class="number">7</span>  dp[<span class="number">4</span>][<span class="number">6</span>]====<span class="number">8</span>  dp[<span class="number">4</span>][<span class="number">7</span>]====<span class="number">9</span>  dp[<span class="number">4</span>][<span class="number">8</span>]====<span class="number">10</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>四、零钱问题</p>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<ol>
<li><blockquote>
<p>输入: amount = 5, coins = [1, 2, 5]<br>输出: 4<br>解释: 有四种方式可以凑成总金额:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p>
</blockquote>
</li>
</ol>
<p>如果一直用递归做，中间会有重复计算的过程，时间大大增加，用动态规划做。</p>
<p><strong>方法一</strong>      </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(amount&lt;<span class="number">0</span>||(coins.size()==<span class="number">0</span>&amp;&amp;amount!=<span class="number">0</span>))</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(coins.size()==<span class="number">0</span>&amp;&amp;amount==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(coins.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;coins.size();i++)</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;amount+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%coins[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">0</span>;         </span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;coins.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;coins[i])</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j-coins[i]];</span><br><span class="line">        &#125;                           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[coins.size()<span class="number">-1</span>][amount];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这个方法直接构造的是dp[零钱的种类的多少][指定金额的大小]做的动态规划，但是问题就是很大一部分其实没有用，虽然比递归时间短，但是还是很大。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">if</span>(amount&lt;<span class="number">0</span>||(coins.size()==<span class="number">0</span>&amp;&amp;amount!=<span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(coins.size()==<span class="number">0</span>&amp;&amp;amount==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(amount+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=coins[k];k&lt;coins.size();k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(j&gt;=coins[k])</span><br><span class="line">               dp[j]=dp[j]+dp[j-coins[k]];</span><br><span class="line">                                 &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这个应该是个极大的优化了dp[指定金额大小的种类]</span></span><br><span class="line"> <span class="comment">//dp[j]=dp[j]+dp[j-coins[k]];</span></span><br></pre></td></tr></table></figure>

<p>五、字符串问题</p>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<blockquote>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符<br>示例 1:</p>
<p>输入: word1 = “horse”, word2 = “ros”<br>输出: 3<br>解释:<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
</blockquote>
<p>*典型动态规划题：<br>          *状态的定义：将word1前i个字符转化为word2前j个字符最少需要dp[i][j]步；<br>          *状态转移方程：<br>             *若当前两字符相等word1[i] == word2[j]，则易得最小步数不变dp[i][j] = dp[i-1][j-1]；<br>             *否则，最小步数为增删改的步数1 + 增删改后对应的最小步数，即dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])，具体有3种情况：<br>                *dp[i-1][j] + 删除word1[i]操作；（删除word1[i]后就从dp[i][j]转化为了dp[i-1][j]，以下同理）<br>                *dp[i][j-1] + 在word1[i]后添加word2[j]操作；<br>                *dp[i-1][j-1] + 将word1[i]修改为word2[j]操作。<br>        *返回dp[-1][-1]，即为最少步数。<br>*时空间复杂度均为 O(MN)O(MN)</p>
<p>代码如下；</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt; <span class="keyword">public</span>:</span><br><span class="line">&gt;     <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;     </span><br><span class="line">&gt;         <span class="comment">/*int leng1=word1.length();</span></span><br><span class="line"><span class="comment">&gt;         int leng2=word2.length();</span></span><br><span class="line"><span class="comment">&gt;     </span></span><br><span class="line"><span class="comment">&gt;         vector&lt;vector&lt;int&gt;&gt;dp(leng1+1,vector&lt;int&gt;(leng2+1));</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt;         for(int i=0;i&lt;=leng1;i++)</span></span><br><span class="line"><span class="comment">&gt;         &#123;</span></span><br><span class="line"><span class="comment">&gt;             dp[i][0]=i;</span></span><br><span class="line"><span class="comment">&gt;         &#125;</span></span><br><span class="line"><span class="comment">&gt;         for(int j=0;j&lt;=leng2;j++)</span></span><br><span class="line"><span class="comment">&gt;         &#123;</span></span><br><span class="line"><span class="comment">&gt;             dp[0][j]=j;</span></span><br><span class="line"><span class="comment">&gt;             </span></span><br><span class="line"><span class="comment">&gt;         &#125;</span></span><br><span class="line"><span class="comment">&gt;         for(int i=1;i&lt;=leng1;i++)</span></span><br><span class="line"><span class="comment">&gt;         &#123;</span></span><br><span class="line"><span class="comment">&gt;             for(int j=1;j&lt;=leng2;j++)</span></span><br><span class="line"><span class="comment">&gt;             &#123;</span></span><br><span class="line"><span class="comment">&gt;                 if(word1[i-1]==word2[j-1])</span></span><br><span class="line"><span class="comment">&gt;                     dp[i][j]=dp[i-1][j-1];</span></span><br><span class="line"><span class="comment">&gt;                 else</span></span><br><span class="line"><span class="comment">&gt;                 &#123;</span></span><br><span class="line"><span class="comment">&gt;                 dp[i][j]=1+min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));</span></span><br><span class="line"><span class="comment">&gt;                 &#125;</span></span><br><span class="line"><span class="comment">&gt;             &#125;</span></span><br><span class="line"><span class="comment">&gt;         &#125;</span></span><br><span class="line"><span class="comment">&gt;         return dp[leng1][leng2];</span></span><br><span class="line"><span class="comment">&gt;         */</span></span><br><span class="line">&gt;         <span class="keyword">int</span> leng1=word1.length();</span><br><span class="line">&gt;         <span class="keyword">int</span> leng2=word2.length();</span><br><span class="line">&gt;         <span class="keyword">if</span>(leng1==<span class="number">0</span>)</span><br><span class="line">&gt;             <span class="keyword">return</span> leng2;</span><br><span class="line">&gt;         <span class="keyword">if</span>(leng2==<span class="number">0</span>)</span><br><span class="line">&gt;             <span class="keyword">return</span> leng1;</span><br><span class="line">&gt;             </span><br><span class="line">&gt;         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(leng2+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=leng1;i++)</span><br><span class="line">&gt;             dp[i]=i;            </span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=leng2;i++)</span><br><span class="line">&gt;             dp[<span class="number">0</span>]=i;</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=leng1;i++)</span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=leng2;j++)</span><br><span class="line">&gt;             &#123;</span><br><span class="line">&gt;                 <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])</span><br><span class="line">&gt;                     dp[j]=dp[<span class="number">0</span>];</span><br><span class="line">&gt;                 <span class="keyword">else</span>&#123;</span><br><span class="line">&gt;                     dp[j]=<span class="number">1</span>+min(dp[<span class="number">0</span>],min(dp[j],dp[j<span class="number">-1</span>]));</span><br><span class="line">&gt;                      &#125;</span><br><span class="line">&gt;                 dp[<span class="number">0</span>]=dp[j];</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> dp[leng2];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; <span class="comment">//上面有两段dp代码，第二个只用了有个数组，性能应该会有提升。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>还是一个字符串的问题</p>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度</p>
<blockquote>
<ol>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;   输入:</span><br><span class="line">&gt;   A: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">&gt;   B: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">&gt;   输出: <span class="number">3</span></span><br><span class="line">&gt;   解释: </span><br><span class="line">&gt;   长度最长的公共子数组是 [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]。         </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt; <span class="keyword">public</span>:</span><br><span class="line">&gt;     <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;    </span><br><span class="line">&gt;     <span class="keyword">int</span> n=A.size();</span><br><span class="line">&gt;     <span class="keyword">int</span> m=B.size();</span><br><span class="line">&gt;     <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>)</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">&gt;     <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">&gt;     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">&gt;             <span class="keyword">if</span>(A[i<span class="number">-1</span>]==B[j<span class="number">-1</span>])&#123;</span><br><span class="line">&gt;                 dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&gt;                 out=max(out,dp[i][j]); </span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">return</span> out;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; <span class="comment">//可以想一下 是不是有更好的办法 dp[][]--转化为一个dp[];</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>六、通配符的匹配(Leecode44题)</p>
<blockquote>
<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。<br>示例 1:</p>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p>
<p>输入:<br>s = “aa”<br>p = “*”<br>输出: true<br>解释: ‘*’ 可以匹配任意字符串。<br>示例 3:</p>
<p>输入:<br>s = “cb”<br>p = “?a”<br>输出: false<br>解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。<br>示例 4:</p>
<p>输入:<br>s = “adceb”<br>p = “<em>a</em>b”<br>输出: true<br>解释: 第一个 ‘<em>‘ 可以匹配空字符串, 第二个 ‘</em>‘ 可以匹配字符串 “dce”.<br>示例 5:</p>
<p>输入:<br>s = “acdcb”<br>p = “a*c?b”<br>输入: false</p>
</blockquote>
<p>这个题目可以说是标准的动态规划的题目</p>
<p><code>dp[i][j]</code>表示<code>s</code>到<code>i位置</code>,<code>p</code>到<code>j</code>位置是否匹配!</p>
<p>初始化:</p>
<ol>
<li><code>dp[0][0]</code>:什么都没有,所以为<code>true</code></li>
<li>第一行<code>dp[0][j]</code>,换句话说,<code>s</code>为空,与<code>p</code>匹配,所以只要<code>p</code>开始为<code>*</code>才为<code>true</code></li>
<li>第一列<code>dp[i][0]</code>,当然全部为<code>False</code></li>
</ol>
<p>动态方程:</p>
<ol>
<li><p>如果<code>(s[i] == p[j] || p[j] == &quot;?&quot;) &amp;&amp; dp[i-1][j-1]</code> ,有<code>dp[i][j] = true</code></p>
</li>
<li><p>如果<code>p[j] == &quot;*&quot; &amp;&amp; (dp[i-1][j] = true || dp[i][j-1] = true)</code>有<code>dp[i][j] = true</code></p>
<p>​    note:</p>
<p>​    <code>dp[i-1][j]</code>,表示<code>*</code>代表是空字符,例如<code>ab,ab*</code></p>
<p>​    <code>dp[i][j-1]</code>,表示<code>*</code>代表非空任何字符,例如<code>abcd,ab*</code></p>
</li>
</ol>
<p>代码如下</p>
<p>​        </p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">&gt; <span class="keyword">public</span>:</span><br><span class="line">&gt;     <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">if</span>(p.length()==<span class="number">1</span>&amp;&amp;p[<span class="number">0</span>]==<span class="string">'*'</span>)</span><br><span class="line">&gt;            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&gt;        <span class="keyword">int</span> m=s.length();</span><br><span class="line">&gt;        <span class="keyword">int</span> n=p.length();  </span><br><span class="line">&gt; <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">&gt;     dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">&gt;              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;         <span class="keyword">if</span>(p[i<span class="number">-1</span>]==<span class="string">'*'</span>)</span><br><span class="line">&gt;             dp[<span class="number">0</span>][i]=<span class="literal">true</span>;</span><br><span class="line">&gt;         <span class="keyword">else</span></span><br><span class="line">&gt;             <span class="keyword">break</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">&gt;            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">&gt;                 <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">'*'</span>)</span><br><span class="line">&gt;                 &#123;</span><br><span class="line">&gt;                     dp[i][j]=dp[i][j<span class="number">-1</span>]||dp[i<span class="number">-1</span>][j];</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">'?'</span>||s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>])</span><br><span class="line">&gt;                &#123;</span><br><span class="line">&gt;                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;                   <span class="keyword">else</span></span><br><span class="line">&gt;                       dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">&gt;            &#125;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;     <span class="comment">//现在我把二维数组换成一维数组 看看能不能提升时间</span></span><br><span class="line">&gt;   <span class="comment">/* vector&lt;bool&gt;dp(n+1,false);</span></span><br><span class="line"><span class="comment">&gt;     dp[0]=true;</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&gt;     for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">&gt;     &#123;</span></span><br><span class="line"><span class="comment">&gt;         if(p[i-1]=='*')</span></span><br><span class="line"><span class="comment">&gt;             dp[i]=true;</span></span><br><span class="line"><span class="comment">&gt;         else</span></span><br><span class="line"><span class="comment">&gt;             break;</span></span><br><span class="line"><span class="comment">&gt;     &#125;</span></span><br><span class="line"><span class="comment">&gt;   for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">&gt;            for(int j=1;j&lt;=m;j++)&#123;</span></span><br><span class="line"><span class="comment">&gt;              if(p[i-1]=='*')</span></span><br><span class="line"><span class="comment">&gt;              &#123;</span></span><br><span class="line"><span class="comment">&gt;                  dp[i]=dp[i-1];</span></span><br><span class="line"><span class="comment">&gt;                  break;</span></span><br><span class="line"><span class="comment">&gt;              &#125;</span></span><br><span class="line"><span class="comment">&gt;                else if(p[i-1]=='?'||s[j-1]==p[i-1])</span></span><br><span class="line"><span class="comment">&gt;                &#123;</span></span><br><span class="line"><span class="comment">&gt;                    dp[i]=dp[i-1];</span></span><br><span class="line"><span class="comment">&gt;                    break;</span></span><br><span class="line"><span class="comment">&gt;                &#125;</span></span><br><span class="line"><span class="comment">&gt;                   else</span></span><br><span class="line"><span class="comment">&gt;                       dp[i]=false;</span></span><br><span class="line"><span class="comment">&gt;                if(s[m]!=p[n]||p[n]!='*')</span></span><br><span class="line"><span class="comment">&gt;                &#123;</span></span><br><span class="line"><span class="comment">&gt;                    dp[n]=false;</span></span><br><span class="line"><span class="comment">&gt;                &#125;</span></span><br><span class="line"><span class="comment">&gt;               </span></span><br><span class="line"><span class="comment">&gt;            &#125;</span></span><br><span class="line"><span class="comment">&gt;   &#125;</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="keyword">return</span> dp[n];</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​         <strong>上面的题目我想用一个vector数组表示 前i的p字符串与s匹配的真假，但是忽略了这里需要s数组需要完全匹配,如下所示</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string s=aa;</span><br><span class="line">&gt; string p=a;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Leecode 115没有弄递推关系</p>
<p>给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。</p>
<p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<blockquote>
<p>示例 1:</p>
<p>输入: S = “rabbbit”, T = “rabbit”<br>输出: 3<br>解释:</p>
<p>如下图所示, 有 3 种可以从 S 中得到 “rabbit” 的方案。<br>(上箭头符号 ^ 表示选取的字母)</p>
<p>rabbbit<br>^^^^ ^^<br>rabbbit<br>^^ ^^^^<br>rabbbit<br>^^^ ^^^<br>示例 2:</p>
<p>输入: S = “babgbag”, T = “bag”<br>输出: 5<br>解释:</p>
<p>如下图所示, 有 5 种可以从 S 中得到 “bag” 的方案。<br>(上箭头符号 ^ 表示选取的字母)</p>
<p>babgbag<br>^^ ^<br>babgbag<br>^^    ^<br>babgbag<br>^    ^^<br>babgbag<br>  ^  ^^<br>babgbag<br>    ^^^</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划 但是效率并不高 20ms 35.83%</span></span><br><span class="line"><span class="comment">     * 大部分都是二维动态规划 有的代码相同但是是5ms 估计是测试用例有变动</span></span><br><span class="line"><span class="comment">     * 但是看到还是有节省的算法 所以一步一步往下优化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    *  b  a  b  g  b  a  g</span></span><br><span class="line"><span class="comment">     * *  1  1  1  1  1  1  1  1</span></span><br><span class="line"><span class="comment">     * b  0  1  1  2  2  3  3  3</span></span><br><span class="line"><span class="comment">     * a  0  0  1  1  1  1  4  4</span></span><br><span class="line"><span class="comment">     * g  0  0  0  0  1  1  1  5</span></span><br><span class="line"><span class="comment">     * @param s</span></span><br><span class="line"><span class="comment">     * @param t</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i<span class="number">-1</span>) == s.charAt(j<span class="number">-1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i][j<span class="number">-1</span>];<span class="comment">//为什么？？？？</span></span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二维换一维 严格按照二维的流程 参见上面矩阵 这个是15ms</span></span><br><span class="line"><span class="comment">     * @param s</span></span><br><span class="line"><span class="comment">     * @param t</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct2</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//每行算一次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//0-n算n+1次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">                <span class="comment">//先保存dp[j]下次用</span></span><br><span class="line">                <span class="keyword">int</span> temp = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(t.charAt(i) == s.charAt(j<span class="number">-1</span>))&#123;</span><br><span class="line">                        dp[j] = dp[j<span class="number">-1</span>] + pre;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[j] = dp[j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/数据结构/树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/数据结构/树/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="●-请你来说一说红黑树和AVL树的定义，特点，以及二者区别"><a href="#●-请你来说一说红黑树和AVL树的定义，特点，以及二者区别" class="headerlink" title="● 请你来说一说红黑树和AVL树的定义，特点，以及二者区别"></a>● 请你来说一说红黑树和AVL树的定义，特点，以及二者区别</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>平衡二叉树（AVL树）：</p>
<p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。一句话表述为：以树中所有结点为根的树的左右子树高度之差的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p>红黑树：</p>
<p>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p>
<p>性质：</p>
<p>\1. 每个节点非红即黑</p>
<p>\2. 根节点是黑的;</p>
<p>\3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p>
<p>\4. 如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>\5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p>
<p>区别：</p>
<p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<h2 id="●-请你说一下哈夫曼编码"><a href="#●-请你说一下哈夫曼编码" class="headerlink" title="● 请你说一下哈夫曼编码"></a>● 请你说一下哈夫曼编码</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>哈夫曼编码是哈夫曼树的一种应用，广泛用于数据文件压缩。哈夫曼编码算法用字符在文件中出现的频率来建立使用0，1表示个字符的最优表示方式，其具体算法如下：</p>
<p>(1)哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。</p>
<p>(2)算法以|C|个叶结点开始，执行|C|－1次的“合并”运算后产生最终所要求的树T。</p>
<p>(3)假设编码字符集中每一字符c的频率是f(c)。以f为键值的优先队列Q用在贪心选择时有效地确定算法当前要合并的2棵具有最小频率的树。一旦2棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的2棵树的频率之和，并将新树插入优先队列Q。经过n－1次的合并后，优先队列中只剩下一棵树，即所要求的树T。</p>
<h2 id="●-请你回答一下map底层为什么用红黑树实现"><a href="#●-请你回答一下map底层为什么用红黑树实现" class="headerlink" title="● 请你回答一下map底层为什么用红黑树实现"></a>● 请你回答一下map底层为什么用红黑树实现</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、红黑树：</p>
<p>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p>
<p>性质：</p>
<p>\1. 每个节点非红即黑</p>
<p>\2. 根节点是黑的;</p>
<p>\3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p>
<p>\4. 如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>\5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p>
<p>2、平衡二叉树（AVL树）：</p>
<p>红黑树是在AVL树的基础上提出来的。</p>
<p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。</p>
<p>AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1。</p>
<p>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p>3、红黑树较AVL树的优点：</p>
<p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<p>所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<h2 id="●-请你介绍一下B-树"><a href="#●-请你介绍一下B-树" class="headerlink" title="● 请你介绍一下B+树"></a>● 请你介绍一下B+树</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>B+是一种多路搜索树，主要为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，每个节点的可以有多个孩子，并且按照关键字大小有序排列。所有记录节点都是按照键值的大小顺序存放在同一层的叶节点中。相比B树，其具有以下几个特点：</p>
<p>每个节点上的指针上限为2d而不是2d+1（d为节点的出度）</p>
<p>内节点不存储data,只存储key</p>
<p>叶子节点不存储指针</p>
<h2 id="●-请你说一说map和unordered-map的底层实现"><a href="#●-请你说一说map和unordered-map的底层实现" class="headerlink" title="● 请你说一说map和unordered_map的底层实现"></a>● 请你说一说map和unordered_map的底层实现</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>map底层是基于红黑树实现的，因此map内部元素排列是有序的。而unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。</p>
<h2 id="●-请你回答一下map和unordered-map优点和缺点"><a href="#●-请你回答一下map和unordered-map优点和缺点" class="headerlink" title="● 请你回答一下map和unordered_map优点和缺点"></a>● 请你回答一下map和unordered_map优点和缺点</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>对于map，其底层是基于红黑树实现的，优点如下：</p>
<p>1)有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</p>
<p>2)map的查找、删除、增加等一系列操作时间复杂度稳定，都为logn</p>
<p>缺点如下：</p>
<p>1）查找、删除、增加等操作平均时间复杂度较慢，与n相关</p>
<p>对于unordered_map来说，其底层是一个哈希表，优点如下：</p>
<p>查找、删除、添加的速度快，时间复杂度为常数级O(c)</p>
<p>缺点如下：</p>
<p>因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高</p>
<p>Unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n)</p>
<h2 id="●-请你回答一下epoll怎么实现的"><a href="#●-请你回答一下epoll怎么实现的" class="headerlink" title="● 请你回答一下epoll怎么实现的"></a>● 请你回答一下epoll怎么实现的</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Linux epoll机制是通过红黑树和双向链表实现的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。</p>
<h2 id="●-请你说一说Top-K-问题"><a href="#●-请你说一说Top-K-问题" class="headerlink" title="● 请你说一说Top(K)问题"></a>● 请你说一说Top(K)问题</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、直接全部排序（只适用于内存够的情况）</p>
<p>当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。</p>
<p>这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。</p>
<p>2、快速排序的变形 （只使用于内存够的情况）</p>
<p>这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。</p>
<p>这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  &gt; K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p>
<p>3、最小堆法</p>
<p>这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p>
<p>4、分治法</p>
<p>将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p>
<p>5、Hash法</p>
<p>如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p>
<h2 id="●-请你说一说C-两种map"><a href="#●-请你说一说C-两种map" class="headerlink" title="● 请你说一说C++两种map"></a>● 请你说一说C++两种map</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>unordered_map（哈希表)和map（红黑树）</p>
<h2 id="●-请问红黑树了解吗"><a href="#●-请问红黑树了解吗" class="headerlink" title="● 请问红黑树了解吗"></a>● 请问红黑树了解吗</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>参考博客<a href="https://blog.csdn.net/tanrui519521/article/details/80980135" target="_blank" rel="noopener">https://blog.csdn.net/tanrui519521/article/details/80980135</a></p>
<h2 id="●-请你说一说红黑树的性质还有左右旋转"><a href="#●-请你说一说红黑树的性质还有左右旋转" class="headerlink" title="● 请你说一说红黑树的性质还有左右旋转"></a>● 请你说一说红黑树的性质还有左右旋转</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>考察点：算法</p>
<p>公司：京东，阿里巴巴</p>
<p>1）平衡二叉树（AVL树）：</p>
<p>红黑树是在AVL树的基础上提出来的。</p>
<p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。</p>
<p>AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1。</p>
<p>将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p>2）红黑树：</p>
<p>红黑树是在AVL树的基础上发展而来的。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p>
<p>性质：</p>
<p>\1. 每个节点非红即黑</p>
<p>\2. 根节点是黑的;</p>
<p>\3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p>
<p>\4. 如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>\5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p>
<p>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。恢复红黑属性需要少量(O(log n))的颜色变更(这在实践中是非常快速的)并且不超过三次树旋转(对于插入是两次)。这允许插入和删除保持为 O(log n) 次，</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552656203034_7D91838E6EBEB8036D6138A019A0AF1A" alt="img"></p>
<p>3）红黑树较AVL树的优点：</p>
<p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<p>所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<p>4）红黑树旋转：</p>
<p>旋转：红黑树的旋转是一种能保持二叉搜索树性质的搜索树局部操作。有左旋和右旋两种旋转，通过改变树中某些结点的颜色以及指针结构来保持对红黑树进行插入和删除操作后的红黑性质。</p>
<p>左旋：对某个结点x做左旋操作时，假设其右孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的左孩子，y的左孩子成为x的右孩子。<img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552656212115_1587159E7ADB036880D502D2927B9597" alt="img"></p>
<p>右旋：对某个结点x做右旋操作时，假设其左孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的右孩子，y的右孩子成为x的左孩子。<img src="https://uploadfiles.nowcoder.com/images/20190315/308571_1552656223637_991B891FAD560CB072639E0791F9CBB7" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/bolgzxy.github.io/2020/03/15/数据库/数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="半世烟尘">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/bolgzxy.github.io/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="し半世烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bolgzxy.github.io/2020/03/15/数据库/数据库/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:13:16+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="●-请你说一说数据库索引"><a href="#●-请你说一说数据库索引" class="headerlink" title="● 请你说一说数据库索引"></a>● 请你说一说数据库索引</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。</p>
<p>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p>
<h2 id="●-请你说一说数据库事务"><a href="#●-请你说一说数据库事务" class="headerlink" title="● 请你说一说数据库事务"></a>● 请你说一说数据库事务</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p>
<h2 id="●-请你说一说数据库事务隔离"><a href="#●-请你说一说数据库事务隔离" class="headerlink" title="● 请你说一说数据库事务隔离"></a>● 请你说一说数据库事务隔离</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<h2 id="●-请你说一说inner-join和left-join"><a href="#●-请你说一说inner-join和left-join" class="headerlink" title="● 请你说一说inner join和left join"></a>● 请你说一说inner join和left join</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录</p>
<h2 id="●-请你聊一聊数据库事物的一致性"><a href="#●-请你聊一聊数据库事物的一致性" class="headerlink" title="● 请你聊一聊数据库事物的一致性"></a>● 请你聊一聊数据库事物的一致性</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。</p>
<p>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。</p>
<p>1）原子性（Atomicity）</p>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p>2）一致性（Consistency）</p>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>3）隔离性（Isolation）</p>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p>
<p>不同的隔离级别：</p>
<p>Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。</p>
<p>Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。</p>
<p>Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。</p>
<p>Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。</p>
<p>4）持久性（Durability）</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h2 id="●-请你说说索引是什么，多加索引一定会好吗"><a href="#●-请你说说索引是什么，多加索引一定会好吗" class="headerlink" title="● 请你说说索引是什么，多加索引一定会好吗"></a>● 请你说说索引是什么，多加索引一定会好吗</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、索引</p>
<p>数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。</p>
<p>DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p>
<p>优点：</p>
<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p>
<p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
<p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p>
<p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<p>缺点：</p>
<p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<p>2、添加索引原则</p>
<p>在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
<p>只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p>定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
<h2 id="●-请你说一下数据库事务以及四个特性"><a href="#●-请你说一下数据库事务以及四个特性" class="headerlink" title="● 请你说一下数据库事务以及四个特性"></a>● 请你说一下数据库事务以及四个特性</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。</p>
<p>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。</p>
<p>\1. 原子性（Atomicity）</p>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p>\2. 一致性（Consistency）</p>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>\3. 隔离性（Isolation）</p>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p>
<p>这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p>
<p>不同的隔离级别：</p>
<p>Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。</p>
<p>Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。</p>
<p>Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。</p>
<p>Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。</p>
<p>\4. 持久性（Durability）</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h2 id="●-请你说一说数据库的三大范式"><a href="#●-请你说一说数据库的三大范式" class="headerlink" title="● 请你说一说数据库的三大范式"></a>● 请你说一说数据库的三大范式</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分</p>
<p>第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式</p>
<p>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码</p>
<h2 id="●-请你介绍一下数据库的ACID特性"><a href="#●-请你介绍一下数据库的ACID特性" class="headerlink" title="● 请你介绍一下数据库的ACID特性"></a>● 请你介绍一下数据库的ACID特性</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1)原子性：事务被视为不可分割的最小单元，事物的所有操作要不成功，要不失败回滚，而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。</p>
<p>2)一致性：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<p>3)隔离性：一个事务所做的修改在最终提交以前，对其他事务是可不见的。</p>
<p>4)持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。</p>
<h2 id="●-请你说一说mysql的四种隔离状态"><a href="#●-请你说一说mysql的四种隔离状态" class="headerlink" title="● 请你说一说mysql的四种隔离状态"></a>● 请你说一说mysql的四种隔离状态</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>Mysql主要包含四种隔离状态：</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="●-请你介绍一下mysql的MVCC机制"><a href="#●-请你介绍一下mysql的MVCC机制" class="headerlink" title="● 请你介绍一下mysql的MVCC机制"></a>● 请你介绍一下mysql的MVCC机制</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<h2 id="●-请问SQL优化方法有哪些"><a href="#●-请问SQL优化方法有哪些" class="headerlink" title="● 请问SQL优化方法有哪些"></a>● 请问SQL优化方法有哪些</h2><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>通过建立索引对查询进行优化</p>
<p>对查询进行优化，应尽量避免全表扫描</p>
<h2 id="●-请你说一下MySQL引擎和区别"><a href="#●-请你说一下MySQL引擎和区别" class="headerlink" title="● 请你说一下MySQL引擎和区别"></a>● 请你说一下MySQL引擎和区别</h2><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、MySQL引擎</p>
<p>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p>
<p>数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p>
<p>MySQL存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated、Mrg_Myisam。</p>
<p>但是最常用的是InnoDB和Mylsam。</p>
<p>2、InnoDB</p>
<p>InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。</p>
<p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p>
<p>适用场景：</p>
<p>经常更新的表，适合处理多重并发的更新请求。</p>
<p>支持事务。</p>
<p>可以从灾难中恢复（通过bin-log日志等）。</p>
<p>外键约束。只有他支持外键。</p>
<p>支持自动增加列属性auto_increment。</p>
<p>索引结构：</p>
<p>InnoDB也是B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p>
<p>3、Mylsam</p>
<p>MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。</p>
<p>适用场景：</p>
<p>不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。</p>
<p>不支持外键的表设计。</p>
<p>查询速度很快，如果数据库insert和update的操作比较多的话比较适用。</p>
<p>整天对表进行加锁的场景。</p>
<p>MyISAM极度强调快速读取操作。</p>
<p>MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p>
<p>缺点：就是不能在表损坏后主动恢复数据。</p>
<p>索引结构：</p>
<p>MyISAM索引结构：MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。</p>
<p>3、InnoDB和Mylsam的区别：</p>
<p>1）事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。</p>
<p>2）性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。</p>
<p>3）行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。</p>
<p>4）索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。</p>
<p>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p>
<p>InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。</p>
<p>5）服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p>MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p>
<p>InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
<p>6）锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>

          
        
      
    </div>
    
    
    

    

    

    
       <div>
       
      </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/bolgzxy.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/bolgzxy.github.io/page/5/">5</a><a class="extend next" rel="next" href="/bolgzxy.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/bolgzxy.github.io/images/user.jpg" alt="半世烟尘">
            
              <p class="site-author-name" itemprop="name">半世烟尘</p>
              <p class="site-description motion-element" itemprop="description">黄沙百战穿金甲，不破楼兰誓不还。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/bolgzxy.github.io/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/bolgzxy.github.io/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/bolgzxy.github.io/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/COTVZHAOYUEXING" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1998lovexs@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半世烟尘</span>

  
</div>






  <span class="post-meta-divider">一江白练伏地藏，万丈红霞落佛光</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/bolgzxy.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/bolgzxy.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/bolgzxy.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
